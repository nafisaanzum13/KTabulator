{"version":3,"sources":["components/Header.jsx","components/Footer.jsx","components/SettingModal.jsx","components/FilterModal.jsx","components/JoinModal.jsx","components/URLForm.jsx","components/LandingPage.jsx","components/TablePanel.jsx","components/TableSelection.jsx","components/TaskMenu.jsx","components/FirstColSelection.jsx","components/OtherColSelection.jsx","components/PreviewOrigin.jsx","components/ActionPanel.jsx","components/PagePanel.jsx","components/MainBody.jsx","layouts/App.jsx","index.js"],"names":["Header","state","className","href","class","title","onClick","props","copyTable","openModal","undoPreviousStep","Component","Footer","SettingModal","isOpen","this","showSetting","onChange","e","toggleSemantic","type","value","checked","semanticEnabled","unionCutOff","unionCutOffChange","min","max","step","closeModal","FilterModal","optionsEle","i","push","dataAndChecked","toggleChecked","data","length","showFilter","applyFilter","cancelFilter","JoinModal","showJoin","originColOptions","originJoinIndex","selectJoinColumn","placeholder","options","isMulti","joinColOptions","joinJoinIndex","runJoin","cancelJoin","URLForm","handleURLPaste","bind","preventDefault","urlPasted","clipboardData","window","getData","onPaste","LandingPage","TablePanel","createSuperTable","createSelectedTableView","colIndex","tableHeader","label","textLiteral","niceRender","firstColHeaderInfo","curText","j","textToAdd","rowNum","tableData","colNum","table","tempRow","tempHeader","buttonsEle","textEle","firstColFilled","columnHeaderGen","handlePlusClick","contextSetColumn","contextAddColumn","showFilterMethods","keyColIndex","buttonEle","getOtherOptions","contextDeleteColumn","rows","previewColIndex","style","backgroundColor","previewData","readOnly","cellColor","onCellChange","onDoubleClick","originPreviewPage","tableDataExplore","tableHeaderRow","tableRows","tableEle","border","str","replace","TableSelection","createButtonArray","originTableArray","buttonArray","buttonText","headerCells","cells","headerData","removeNewLine","innerText","slice","tableContent","dangerouslySetInnerHTML","__html","outerHTML","selectButton","tableOpenList","listType","buttonFunction","toggleTable","Collapse","originTableArrayEle","TaskMenu","subject","resultStr","bracketIndex","indexOf","handleStartSubject","decodeURIComponent","toggleTableSelection","showTableSelection","CardBody","Card","handleStartTable","FirstColSelection","createFirstColSelection","keyCheckedIndex","firstColSelection","firstColChecked","populateEle","selectedNeighbours","alert","populateText","pDataset","oValue","pValue","populateKeyColumn","confirmAddFirstCol","returnEle","additionEle","toggleFirstNeighbour","selectionEle","OtherColSelection","createOtherColSelection","otherColSelection","otherColChecked","otherCheckedIndex","console","log","populateOtherColumn","toggleOtherNeighbour","PreviewOrigin","createPreviewEle","createOriginEle","previewInfoExpanded","previewInfoArray","previewEle","key","togglePreviewElement","brEle","selectedCell","originEle","origin","ActionPanel","createPropertyArray","createSiblingArray","createTableArray","createRecommendArray","firstIndex","secondIndex","tableArray","propertyNeighbours","siblingArray","tableElement","thirdIndex","tableTitleText","Button","toggleOtherTable","unionTable","colMapping","siblingElement","zeroDividerSet","tooltipText","name","listClassSib","toggleSibling","unionPage","propertyElement","predicate","object","propertyText","listClass","togglePropertyNeighbours","recommendArray","stringRecommend","semanticRecommend","recommendText","relation","actionInfo","neighbourArrayText","createNeighbourText","neighbourArray","sameNeighbourOneRow","sameNeighbourDiffRow","actionEle","wrapperEle","titleEle","usecaseSelected","selectedTableIndex","curActionInfo","task","addToFirstCol","createSameNeighbour","siblingText","plural","siblingNeighbour","range","populateSameRange","sameNeighbourEle","recommendEle","contextSortColumn","openFilter","contextDedupColumn","curIndex","tabIndex","selectedIndex","onSelect","index","handleTabSwitch","toggleUnionJoin","showUnionTables","showJoinTables","handleJoinTable","PagePanel","pageEle","wikiPageClass","iframeURL","buttonhideShow","toggleWikiPage","aria-hidden","pageHidden","id","src","MainBody","optionsMap","tablePasted","lastAction","prevState","keyColNeighbours","firstDegNeighbours","selectedClassAnnotation","curFilterIndex","showJoinModal","joinTableIndex","joinTableData","cellChange","selectColHeader","getKeyOptions","getNeighbourPromise","getOtherColPromise","addAllNeighbour","getTableStates","populateRecommendation","unionProperty","document","body","classList","add","includes","promiseArray","fetchText","allPromiseReady","then","values","htmlText","DOMParser","parseFromString","getElementsByClassName","remove","setState","textArea","createElement","copiedText","undefined","appendChild","select","execCommand","removeChild","taskSelected","_","cloneDeep","fetchJSON","regexReplace","resultsBinding","processedBinding","filter","a","p","dctArray","dbopArray","sort","b","o","count","getPCount","prevNeighbour","curNeighbour","datatype","concat","removePrefix","updateFirstColSelection","results","bindings","neighbourIndex","curColumnArray","curNeighbourData","otherColCheckedIndex","firstColCheckedUpdated","target","allSubject","queryBody","queryURL","myJson","keyColOptions","curValue","somevar","tempObj","neighbour","colEmpty","colFilled","nonEmptyInfo","tempSelection","scrollTo","selectedOptions","keyColLabel","ownLabel","cellValue","curPromise","keyQueryGen","updatedRowCount","Math","rowsToAdd","emptyEntryCount","startingIndex","tempOrigin","uniqBy","x","setFirstColumnData","promiseArrayOne","promiseArrayTwo","valuesOne","valuesTwo","updatedNeighbours","updateNeighbourInfo","numNewRows","hasMultiple","originToAdd","keyOrigin","lastIndex","dataArray","numCols","fillRecommendation","keyColIndexUpdated","tableDataUpdated","k","newTableHeader","tableHeaderUpdated","selectedClassAnnotationUpdated","optionsMapUpdated","curCol","requiredLength","subjectNeighbours","objectNeighbours","curRow","rowToAdd","firstDegNeighboursUpdated","curData","neighbourData","newState","splice","order","numericCol","isNaN","Number","aValue","bValue","rowIndex","otherColPromiseSubject","otherColPromiseObject","subjectInfoArray","updatePreviewInfo","objectInfoArray","tableIndex","originText","Promise","resolve","queryPromise","queryOne","urlReplace","queryTwo","findClassAnnotation","queryResults","propertyNeighboursPO","bindingArray","urlOrigin","curSiblingArray","siblingName","s","setTableFromHTML","stateInfo","siblingNameArray","tableArrayPromise","pageHTML","findTableFromHTML","tableArrayValues","aTableLength","bTableLength","aName","bName","selectedSibling","selectedTable","otherTableHTML","otherTableData","setUnionData","tempMapping","tableConcat","otherTableOrigin","headerRow","sameTable","diffColFound","m","Set","checkIndex","valuesToKeep","originTableHeader","joinTableHeader","joinTableDataUpdated","curJoinEntry","curEntryFound","bodyEle","bottomContentClass","topContentClass","url","fetch","response","ok","Error","json","catch","error","text","all","updateKeyColNeighbours","subPropertyOf","neighbourCount","neighbourToAdd","valuesToAdd","neighbourRange","neighbourSubPropertyOf","objLabel","categoryPreviewInfoArray","categoryBinding","dataToAdd","colInNew","HTMLCleanCell","trim","split","pageName","originCols","wikiTablesFound","tablesFound","tagName","tablePromise","findTableFromTable","unionScore","tableHTML","curHeaderCells","newCols","remainCols","searchCols","headerName","sameStructure","remainClassAnnotation","curSearchIndex","intersection","totalSuccess","numTrial","hyperCDF","tempTable","curCellText","anchorArray","getElementsByTagName","hrefArray","curRowSpan","rowSpan","curColSpan","colSpan","remainEntries","curColIndex","curEntry","classAnnotation","curColumnClass","curCellClass","selecteTableHTML","N","K","n","denom","combinations","processAllNeighbours","allNeighboursArray","allNeighboursArrayCopy","prevEntry","filledCount","filledPercent","round","storeFirstDeg","neighbourArrayCopy","dedupedData","uniq","addRecommendNeighbours","processedNeighboursCopy","processedNeighbours","recommendNeighbours","upperStrOne","toUpperCase","upperStrTwo","differenceBy","myArray","oType","subjectNeighbourArray","temp","processedSubjectNeighbours","objectNeighbourArray","processedObjectNeighbours","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.64b54e71.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport { FaCopy, FaUndo } from \"react-icons/fa\";\r\nimport { FiSettings } from \"react-icons/fi\";\r\n\r\nclass Header extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"row header-body\">\r\n          <div className=\"col-md-8\">\r\n            <a href=\"index.html\" class=\"logo\">\r\n              <b>\r\n                <span>KG</span>Wrangler\r\n              </b>\r\n            </a>\r\n          </div>\r\n          <div className=\"offset-md-2 col-md-2 row\">\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"copy table to csv\"\r\n                onClick={() => this.props.copyTable()}\r\n              >\r\n                <FaCopy className=\"logo-left-color\" />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"Union Table Settings\"\r\n              >\r\n                <FiSettings\r\n                  className=\"logo-left-color\"\r\n                  onClick={() => this.props.openModal()}\r\n                />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"undo previous action\"\r\n                onClick={() => this.props.undoPreviousStep()}\r\n              >\r\n                <FaUndo className=\"color-wrangler\" />\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <hr class=\"header-hr\"></hr>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","import React, { Component } from \"react\";\r\nclass Footer extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        {/* <hr className=\"m-0\"></hr> */}\r\n        <div className=\"text-center text-sm\">\r\n          <small>University of Waterloo, 2020</small>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Footer;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\n// The two following lines are for range sliders\r\nimport RangeSlider from \"react-bootstrap-range-slider\";\r\nimport \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\n\r\nclass SettingModal extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showSetting}\r\n          className=\"setting-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div className=\"row\">\r\n              <div className=\"col-md-6 offset-md-3\">\r\n                <h4>Table Union Search Settings</h4>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Semantic Mapping:</div>\r\n              <div className=\"col-md-6\">\r\n                <div onChange={(e) => this.props.toggleSemantic(e)}>\r\n                  <input\r\n                  type=\"radio\"\r\n                  value=\"enabled\"\r\n                  checked={this.props.semanticEnabled === \"enabled\"}\r\n                  />{\" \"}\r\n                  Enabled\r\n                  <input\r\n                    type=\"radio\"\r\n                    value=\"disabled\"\r\n                    checked={this.props.semanticEnabled === \"disabled\"}\r\n                  />{\" \"}\r\n                  Disabled\r\n                </div>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Percentage of Columns to Union:</div>\r\n              <div className=\"col-md-6\">\r\n                <RangeSlider\r\n                  value={this.props.unionCutOff}\r\n                  onChange={(e) => this.props.unionCutOffChange(e)}\r\n                  min={0}\r\n                  max={1}\r\n                  step={0.05}\r\n                />\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4 offset-md-4\">\r\n                <button onClick={() => this.props.closeModal()}>Confirm Settings</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SettingModal;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\n\r\nclass FilterModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    let optionsEle = [];\r\n    for (let i=0;i<this.props.dataAndChecked.length;++i) {\r\n      optionsEle.push(\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            checked={this.props.dataAndChecked[i].checked}\r\n            onChange={(e) => this.props.toggleChecked(e, i)}\r\n          />\r\n          {this.props.dataAndChecked[i].data}\r\n        </div>\r\n      )\r\n    }\r\n    // console.log(optionsEle);\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showFilter}\r\n          className=\"filter-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div>\r\n              Here is the list of data to filter from selected column.\r\n            </div>\r\n            <br />\r\n            <div className=\"checkbox-list\">\r\n              {optionsEle}\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-1 offset-md-9\">\r\n                <button onClick={(e) => this.props.applyFilter(e)}>OK</button>\r\n              </div>\r\n              <div className=\"col-md-2\">\r\n                <button onClick={(e) => this.props.cancelFilter(e)}>Cancel</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FilterModal;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\nimport Select from \"react-select\";\r\n\r\nclass JoinModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    // let optionsEle = [];\r\n\r\n    // console.log(this.props.originColOptions);\r\n    // console.log(this.props.joinColOptions);\r\n\r\n    // Note, the props originColOptions and joinColOptions are what we are going to pass to react select as options\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showJoin}\r\n          className=\"join-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div className=\"row\"> \r\n              <div className=\"col-md-5\">\r\n                Choose join column from table panel\r\n              </div>\r\n              <div className=\"offset-md-1 col-md-5\">\r\n                Choose join column from selected table\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <Select\r\n                className=\"col-md-5\"\r\n                value={this.props.originColOptions[this.props.originJoinIndex]}\r\n                onChange={(e) => this.props.selectJoinColumn(e, \"originTable\")}\r\n                placeholder={\"Choose Join Column\"}\r\n                options={this.props.originColOptions}\r\n                isMulti={false}\r\n              />\r\n              <Select\r\n                className=\"offset-md-1 col-md-5\"\r\n                value={this.props.joinColOptions[this.props.joinJoinIndex]}\r\n                onChange={(e) => this.props.selectJoinColumn(e, \"joinTable\")}\r\n                placeholder={\"Choose Join Column\"}\r\n                options={this.props.joinColOptions}\r\n                isMulti={false}\r\n              />\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-1 offset-md-9\">\r\n                <button onClick={(e) => this.props.runJoin(e)}>OK</button>\r\n              </div>\r\n              <div className=\"col-md-2\">\r\n                <button onClick={(e) => this.props.cancelJoin(e)}>Cancel</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default JoinModal;\r\n","import React, { Component } from \"react\";\r\n\r\nclass URLForm extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n  }\r\n\r\n  handleURLPaste(e) {\r\n    e.preventDefault();\r\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\r\n    this.props.handleURLPaste(urlPasted);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"row text-center\">\r\n          <div className=\"col-md-6 offset-md-3\">\r\n            <input\r\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\r\n              onPaste={this.handleURLPaste}\r\n              className=\" form-control\"\r\n            ></input>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default URLForm;\r\n","import React, { Component } from \"react\";\r\nimport URLForm from \"../components/URLForm\";\r\n\r\nclass LandingPage extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div class=\"landing-page\">\r\n          <div class=\" row text-center\">\r\n            <div class=\"white-form col-md-5\">\r\n              <h1 class=\"\"> Welcome!</h1>\r\n              <hr className=\"header-hr\"></hr>\r\n              <h4>Enter the URL of a Wikipedia page and start wrangling!</h4>\r\n              <URLForm handleURLPaste={this.props.handleURLPaste} />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default LandingPage;\r\n","import React, { Component } from \"react\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// import Tooltip from '@atlaskit/tooltip';\r\n// import Select from \"react-select\";\r\n// import { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\r\nimport { FaSearch, FaEdit, FaPlus, FaMinus, FaFilter, FaArrowDown } from \"react-icons/fa\";\r\n\r\nclass TablePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createSuperTable = this.createSuperTable.bind(this);\r\n    this.createSelectedTableView = this.createSelectedTableView.bind(this);\r\n  }\r\n\r\n  // This function creates the i-th column header from this.props.tableHeader[i]\r\n  // It is a helper function for createSuperTable\r\n\r\n  columnHeaderGen(colIndex) {\r\n    // console.log(colIndex);\r\n    // console.log(this.props.tableHeader);\r\n\r\n    // In this case we deal with the first column header\r\n    // We want to divide it into two subcases: \"start table\" vs. \"start subject\"\r\n    if (colIndex === 0) {\r\n      // First case is start table\r\n      if (this.props.tableHeader.length > 0 && \r\n          this.props.tableHeader[0].length === 1 && \r\n          this.props.tableHeader[0][0].label === \"OriginURL\") {\r\n        let textLiteral = \"\";\r\n        for (let i = 0; i < this.props.tableHeader[0].length; ++i) {\r\n          let textToAdd = i > 0 ? \"\\nAND \" + niceRender(this.props.tableHeader[0][i].label) : niceRender(this.props.tableHeader[0][i].label);\r\n          textLiteral+=textToAdd;\r\n        }\r\n        let textEle = \r\n          <div>\r\n            {textLiteral}\r\n          </div>\r\n        return textEle;\r\n      }\r\n      // Second case is start subject\r\n      else {\r\n        // Here is the difference: textLiteral for this case is an array instead of a string\r\n        let textLiteral = [];\r\n        let firstColHeaderInfo = this.props.firstColHeaderInfo;\r\n        for (let i = 0; i < firstColHeaderInfo.length; ++i) {\r\n          let curText = \"\";\r\n          for (let j = 0; j < firstColHeaderInfo[i].length; ++j) {\r\n            let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[i][j].label) : niceRender(firstColHeaderInfo[i][j].label);\r\n            curText+=textToAdd;\r\n          }\r\n          textLiteral.push(\r\n            <p>\r\n              {curText}\r\n            </p>\r\n          )\r\n        }\r\n        let textEle = \r\n          <div>\r\n            {textLiteral}\r\n          </div>\r\n        return textEle;\r\n      }\r\n    }\r\n    // In this case we deal with non-first column headers\r\n    else {\r\n      let textLiteral = \"\";\r\n      for (let i = 0; i < this.props.tableHeader[colIndex].length; ++i) {\r\n        let textToAdd = \r\n          this.props.tableHeader[colIndex][i].type === \"object\" ? \"is \" + this.props.tableHeader[colIndex][i].value + \" of\" \r\n          : this.props.tableHeader[colIndex][i].value;\r\n        textToAdd = i > 0 ? \"\\nOR \" + textToAdd : textToAdd;\r\n        textLiteral+=textToAdd;\r\n      }\r\n      let textEle = \r\n        <div>\r\n          {textLiteral}\r\n        </div>\r\n      return textEle;\r\n    }\r\n  }\r\n\r\n  // This function takes the states tableData, keyColIndex, tableHeader, optionsMap\r\n  // And convert them into HTML for the super table\r\n\r\n  createSuperTable() {\r\n\r\n    // console.log(this.props.firstColHeaderInfo);\r\n    // console.log(\"Has first column been filled? \" + this.props.firstColFilled);\r\n    // console.log(this.props.tableData);\r\n    // console.log(\"The current previewColIndex is \"+this.props.previewColIndex);\r\n    \r\n    const rowNum = this.props.tableData.length;\r\n    const colNum = this.props.tableData[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n\r\n    let tempRow = [];\r\n    for (let colIndex = 0; colIndex < colNum; ++colIndex) {\r\n      let tempHeader;\r\n      // This part deals with the column 0 \r\n      if (colIndex === 0) {\r\n        let buttonsEle = null;\r\n        let textEle = <div><br /></div>;\r\n        if (this.props.firstColFilled === true) {\r\n          // If we have filled in the first column already, then we can generate its header text\r\n          textEle = this.columnHeaderGen(colIndex);\r\n          // Moreover, if the first column head is not [\"OriginURL\"], then we can create the button element\r\n          if (this.props.tableHeader[0][0].value !== \"OriginURL\") {\r\n            buttonsEle = \r\n              <div>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add entities\"\r\n                  onClick={() => this.props.handlePlusClick()}\r\n                >\r\n                  <FaArrowDown />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Set as key column\"\r\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\r\n                >\r\n                  <FaSearch />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n                {/* <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Delete this column\"\r\n                  // onClick={(e) => this.props.contextSetColumn(e, colIndex)}\r\n                >\r\n                  <FaMinus />\r\n                </button> */}\r\n              </div>\r\n          }\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            <div\r\n              className=\"super-header-div\"\r\n            >\r\n            </div>\r\n            {buttonsEle}\r\n            {textEle}\r\n          </th>\r\n        )\r\n      }\r\n      // This part deals with key columns that are not column 0\r\n      else if (colIndex === this.props.keyColIndex) {\r\n        let textEle = this.columnHeaderGen(colIndex);\r\n        let buttonEle = <div><br /></div>;\r\n        if (this.props.firstColFilled === true) {\r\n          buttonEle = \r\n            <div>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n            </div>\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            {buttonEle}\r\n            {textEle}\r\n          </th>\r\n        );\r\n      }\r\n      // This part deals with the non-key, non-first column headers\r\n      else {\r\n        let textEle = this.columnHeaderGen(colIndex);\r\n        let buttonEle = <div><br /></div>;;\r\n        if (this.props.firstColFilled === true) {\r\n          buttonEle = \r\n            <div>\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"Add entities\"\r\n                onClick={(e) => this.props.getOtherOptions(e, colIndex)}\r\n              >\r\n                <FaEdit />\r\n              </button>\r\n              <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Set as key column\"\r\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\r\n                >\r\n                  <FaSearch />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Delete this column\"\r\n                  onClick={(e) => this.props.contextDeleteColumn(e, colIndex)}\r\n                >\r\n                  <FaMinus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n            </div>\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            {buttonEle}\r\n            {textEle}\r\n          </th>\r\n        );\r\n      }\r\n      tempRow.push(tempHeader);\r\n    }\r\n    table.push(\r\n      <thead className=\"table-head\">\r\n        <tr>{tempRow}</tr>\r\n      </thead>\r\n    );\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n\r\n    // We are adding an ID for each cell for contextmenu\r\n    let rows = [];\r\n    for (let i = 0; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      // Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // We want to treat preview columns and other columns differently\r\n\r\n        // First we deal with preview column\r\n        if (j === this.props.previewColIndex) {\r\n          let cellColor = {backgroundColor: \"LightGray\"};\r\n          tempRow.push(\r\n            <td style={cellColor}>\r\n              <input\r\n                className=\"twenty-vw column-preview-color\"\r\n                type=\"text\"\r\n                value={niceRender(this.props.tableData[i][j].previewData)}\r\n                readOnly\r\n              />\r\n            </td>\r\n          );\r\n        }\r\n        // Else we are dealing with a regular column\r\n        else {\r\n          let cellColor;\r\n          // We use light blue to represent search column\r\n          if (j === this.props.keyColIndex) {\r\n            cellColor = { backgroundColor: \"LightBlue\" };\r\n          }\r\n          // We use white to represent other columns\r\n          else {\r\n            cellColor = { backgroundColor: \"White\" };\r\n          }\r\n          // console.log(\"Current data is \"+this.props.tableData[i][j]);\r\n          tempRow.push(\r\n            <td style={cellColor}>\r\n              <input\r\n                className=\"twenty-vw\"\r\n                type=\"text\"\r\n                value={niceRender(this.props.tableData[i][j].data)}\r\n                title={niceRender(this.props.tableData[i][j].data)}\r\n                onChange={(e) => this.props.onCellChange(e, i, j)}\r\n                onDoubleClick={(e) => this.props.originPreviewPage(e, i, j)}\r\n              />\r\n            </td>\r\n          );\r\n        }\r\n      }\r\n      //Create the parent and add the children\r\n      rows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{rows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  // This function makes no modification of the data at all.\r\n  // It takes all the data from this.props.tableDataExplore, and convert them into HTML\r\n  createSelectedTableView() {\r\n    // console.log(rowNum);\r\n    // console.log(colNum);\r\n    // console.log(this.props.tableDataExplore[0][0].data);\r\n    // console.log(this.props.tableDataExplore[0][0].origin);\r\n    const rowNum = this.props.tableDataExplore.length;\r\n    const colNum = this.props.tableDataExplore[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n    let tempRow = [];\r\n    for (let j = 0; j < colNum; ++j) {\r\n      let tempHeader = (\r\n        <th className=\"table-head table-col\">\r\n          {this.props.tableDataExplore[0][j].data}\r\n        </th>\r\n      );\r\n      tempRow.push(tempHeader);\r\n    }\r\n    let tableHeaderRow = <tr className=\"table-head table-col\">{tempRow}</tr>;\r\n    table.push(<thead>{tableHeaderRow}</thead>);\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n    let tableRows = [];\r\n    for (let i = 1; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      //Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // Create the each cell\r\n        tempRow.push(\r\n          <td className=\"table-col\">\r\n            {this.props.tableDataExplore[i][j].data}\r\n          </td>\r\n        );\r\n      }\r\n      //Create the parent and add the children\r\n      tableRows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{tableRows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  render() {\r\n    let tableEle = null;\r\n\r\n    // In all cases, once we have pasted the URL. We want to display the super table in the table panel.\r\n    tableEle = (\r\n      // class table-fixed helps with sticky column headers\r\n      <div>\r\n        <table class border=\"1\" className=\"table table-sm table-bordered\">\r\n          {this.createSuperTable()}\r\n        </table>\r\n        {/* {menuArray} */}\r\n      </div>\r\n    );\r\n    return <div>{tableEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TablePanel;\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n\r\n","// This component takes in 5 props:\r\n\r\n// 1) originTableArray: 1D array storing all tables found on pasted URL\r\n// 2) tableOpenList:    1D array storing whether each table in originTableArray has been toggled open or not\r\n// 3) toggleTable:      function that handles the toggling on/off of a table\r\n// 4) listType:         string. Has value \"select\" when we are using TableSelection to select the starting table.\r\n//                              Has value \"join\" when we are using TableSelection in the join tables setting.\r\n// 5) buttonFunction:   function corresponding to the listType.\r\n\r\nimport React, { Component } from \"react\";\r\nimport { Collapse } from \"reactstrap\";\r\nimport { FaTable } from \"react-icons/fa\";\r\n\r\nclass TableSelection extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createButtonArray = this.createButtonArray.bind(this);\r\n  }\r\n\r\n  createButtonArray() {\r\n    const originTableArray = this.props.originTableArray;\r\n    let buttonArray = [];\r\n    for (let i = 0; i < originTableArray.length; ++i) {\r\n      // This first part create the buttons with text: table index plus column names\r\n      // It also removes some newline characters\r\n      let buttonText = \"Table \" + i + \": \";\r\n      let headerCells = originTableArray[i].rows[0].cells;\r\n      for (let j = 0; j < headerCells.length; ++j) {\r\n        let headerData = removeNewLine(headerCells[j].innerText);\r\n        if (headerData[headerData.length - 1] === \"\\n\") {\r\n          headerData = headerData.slice(0, -1);\r\n        }\r\n        buttonText = buttonText + headerData + \"| \";\r\n      }\r\n      // Now let's update the table content\r\n      let tableContent = (\r\n        <div\r\n          dangerouslySetInnerHTML={{\r\n            __html: this.props.originTableArray[i].outerHTML,\r\n          }}\r\n        />\r\n      );\r\n      let selectButton;\r\n      if (this.props.tableOpenList[i] === true) {\r\n        let buttonText = \"\";\r\n        if (this.props.listType === \"select\") {\r\n          buttonText = \"Select\";\r\n        }\r\n        else {\r\n          buttonText = \"Join\"\r\n        }\r\n        selectButton = \r\n          <button\r\n            onClick={(e) => this.props.buttonFunction(e, i)}\r\n          >\r\n            {buttonText}\r\n          </button>\r\n      }\r\n      buttonArray.push(\r\n        <li\r\n          className=\"list-group-item\"\r\n        >\r\n        <span \r\n          onClick={(e) => this.props.toggleTable(e, i)}\r\n        >\r\n          {buttonText} {}\r\n          <FaTable />\r\n        </span>\r\n        {selectButton}\r\n          <Collapse isOpen={this.props.tableOpenList[i]}>\r\n            <div>{tableContent}</div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">{buttonArray}</ul>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const numTables = this.props.originTableArray.length;\r\n    let originTableArrayEle = null;\r\n    if (numTables !== 0) {\r\n      originTableArrayEle = <div>{this.createButtonArray()}</div>;\r\n    }\r\n    return <div>{originTableArrayEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TableSelection;\r\n\r\nfunction removeNewLine(str) {\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1);\r\n  } else {\r\n    return str;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Collapse, CardBody, Card } from \"reactstrap\";\r\nimport { FaList } from \"react-icons/fa\";\r\nimport TableSelection from \"../components/TableSelection\";\r\n\r\nclass TaskMenu extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const subject = niceRender(reverseReplace(this.props.urlPasted.slice(30)));\r\n    return (\r\n      <div>\r\n        <ul class=\"list-group list-css list-group-flush\">\r\n          <hr className=\"m-0\"></hr>\r\n          <li\r\n            className=\"list-group-item\"\r\n            onClick={(e) => this.props.handleStartSubject(e, \"startSubject\")}\r\n          >\r\n            Start creating a table about {decodeURIComponent(subject)}\r\n          </li>\r\n          <li\r\n            className=\"list-group-item\"\r\n          >\r\n            <span \r\n              onClick={() => this.props.toggleTableSelection()}\r\n            >\r\n              Start with an existing table from page <FaList />\r\n            </span>\r\n\r\n            <Collapse isOpen={this.props.showTableSelection}>\r\n              <CardBody>\r\n                <Card>\r\n                  <div>\r\n                    <TableSelection\r\n                      originTableArray={this.props.originTableArray}\r\n                      tableOpenList={this.props.tableOpenList}\r\n                      toggleTable={this.props.toggleTable}\r\n                      buttonFunction={this.props.handleStartTable}\r\n                      listType={\"select\"}\r\n                    />\r\n                  </div>\r\n                </Card>\r\n              </CardBody>\r\n            </Collapse>\r\n          </li>\r\n          <hr className=\"m-0\"></hr>\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TaskMenu;\r\n\r\n// This function changes the copied text \"%E2%80%93\" to \"-\" when we copy a URL from google. \r\n\r\nfunction reverseReplace(str) {\r\n  return str.replace(/%E2%80%93/, \"\");\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\n  function niceRender(str) {\r\n    let resultStr = str;\r\n    let bracketIndex = str.indexOf(\"(\");\r\n    // If ( is present in a string, we want to remove it\r\n    // We include the -1 because usually ( is preceeded by _\r\n    if (bracketIndex !== -1) {\r\n      resultStr = resultStr.slice(0, bracketIndex-1);\r\n    }\r\n    // now we turn all \"_\" into \" \"\r\n    return resultStr.replace(/_/g, \" \");\r\n  }\r\n","import React, { Component } from \"react\";\r\n\r\nclass FirstColSelection extends Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createFirstColSelection = this.createFirstColSelection.bind(this);\r\n  }\r\n\r\n  createFirstColSelection() {\r\n    let keyCheckedIndex = this.props.keyCheckedIndex;\r\n    let firstColSelection = this.props.firstColSelection;\r\n    let firstColChecked = this.props.firstColChecked;\r\n\r\n    let populateEle = null;\r\n\r\n    let selectedNeighbours = [];\r\n    // We will create the selectedNeighbours array from this.props.firstColSelection and this.props.firstColChecked\r\n    if (firstColChecked.length !== firstColSelection.length) {\r\n      alert(\"Some error exists\");\r\n    }\r\n    for (let i = 0; i < firstColChecked.length; ++i) {\r\n      if (firstColChecked[i] === true) {\r\n        selectedNeighbours.push(firstColSelection[i]);\r\n      }\r\n    }\r\n\r\n    // console.log(selectedNeighbours);\r\n\r\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\r\n    if (keyCheckedIndex !== -1 && selectedNeighbours.length > 0) {\r\n      let populateText = \r\n        this.props.firstColFilled === false ? \"Populate first column with entities that\"\r\n        : \"Add to first column with entities that\";\r\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\r\n        let curText = i > 0 ? \", and\" : \"\";\r\n        if (selectedNeighbours[i].pDataset === \"dct\") {\r\n          curText = curText + \" are \" + niceRender(selectedNeighbours[i].oValue);\r\n        }\r\n        else {\r\n          curText = curText + \" have \" + selectedNeighbours[i].pValue + \"=\" + niceRender(selectedNeighbours[i].oValue);\r\n        }\r\n        populateText+=curText;\r\n      }\r\n      populateText+=\"?\";\r\n      // We conditionally create the button element\r\n      // If firstColFilled is false, we want to run populateKeyColumn\r\n      // Otherwise, we want to run addKeyColumn\r\n      let buttonEle = \r\n        this.props.firstColFilled === false ? <button onClick={(e) => this.props.populateKeyColumn(e, 0, selectedNeighbours)}>Okay</button>\r\n        : <button onClick={(e) => this.props.confirmAddFirstCol(e, selectedNeighbours)}>Okay</button>;\r\n      populateEle = \r\n        <div>\r\n          <p>\r\n            <b>\r\n              {populateText}\r\n            </b>\r\n            {buttonEle}\r\n          </p>\r\n        </div>\r\n    }\r\n\r\n    let returnEle = [];\r\n    // We loop over the firstColSelection array, and push on the needed radio checkbox and textual information\r\n    for (let i = 0; i < firstColSelection.length; ++i) {\r\n      // additionEle is basically a copy of populateEle\r\n      let additionEle = i === keyCheckedIndex ? populateEle: null;\r\n      if (firstColSelection[i].pValue === \"category\") {\r\n        returnEle.push(\r\n          <div>\r\n            <div>\r\n              <p>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={firstColChecked[i]}\r\n                  onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\r\n                />\r\n                {'\\u00A0'}{'\\u00A0'}\r\n                {niceRender(firstColSelection[i].oValue)}\r\n              </p>\r\n            </div>\r\n            {additionEle}\r\n          </div>\r\n        )\r\n      }\r\n      else {\r\n        returnEle.push(\r\n          <div>\r\n            <div>\r\n              <p>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={firstColChecked[i]}\r\n                  onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\r\n                />\r\n                {'\\u00A0'}{'\\u00A0'}\r\n                {firstColSelection[i].pValue}\r\n                {\":\"}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}\r\n                {niceRender(firstColSelection[i].oValue)}\r\n              </p>\r\n            </div>\r\n            {additionEle}\r\n          </div>\r\n        )\r\n      }\r\n    }\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n\r\n    let selectionEle = this.createFirstColSelection();\r\n\r\n    return (\r\n      <div>\r\n        <div>\r\n          <p><b>Choose from attributes below</b> to determine the content for the first column</p>\r\n        </div>\r\n        <br />\r\n        <div>\r\n          {selectionEle}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FirstColSelection;\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nclass OtherColSelection extends Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createOtherColSelection = this.createOtherColSelection.bind(this);\r\n  }\r\n\r\n  createOtherColSelection() {\r\n    let otherColSelection = this.props.otherColSelection;\r\n    let otherColChecked = this.props.otherColChecked;\r\n    let otherCheckedIndex = this.props.otherCheckedIndex;\r\n\r\n    // console.log(otherColSelection);\r\n    // console.log(otherColChecked);\r\n    // console.log(otherCheckedIndex);\r\n\r\n    // First do some basic error checking\r\n    if (otherColChecked.length !== otherColSelection.length) {\r\n      console.log(\"Some error exists\");\r\n    }\r\n\r\n    // Now, we will create the selectedNeighbours array from otherColSelection and otherColChecked\r\n    let selectedNeighbours = [];\r\n    for (let i = 0; i < otherColChecked.length; ++i) {\r\n      if (otherColChecked[i] === true) {\r\n        selectedNeighbours.push(otherColSelection[i]);\r\n      }\r\n    }\r\n\r\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\r\n    let populateEle = null;\r\n    if (otherCheckedIndex !== -1 && selectedNeighbours.length > 0) {\r\n      let populateText = \"Populate this column with attributes \";\r\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\r\n        let curText = selectedNeighbours[i].type === \"object\" ? \"is \" + selectedNeighbours[i].value + \" of\" : selectedNeighbours[i].value;\r\n        curText = i > 0 ? \" OR \" + curText : curText;\r\n        populateText+=curText;\r\n      }\r\n      populateText+=\"?\";\r\n      populateEle = \r\n        <div>\r\n          <p><b>{populateText}</b></p>\r\n          <button onClick={(e) => this.props.populateOtherColumn(e, this.props.colIndex, selectedNeighbours)}>OK</button> \r\n        </div>\r\n    }\r\n\r\n    let returnEle = [];\r\n    // We loop through the otherColSelection array, and push on the needed radio checkbox and textual information\r\n    for (let i = 0; i < otherColSelection.length; ++i) {\r\n      let additionEle = i === otherCheckedIndex ? populateEle : null;\r\n      returnEle.push(\r\n        <div>\r\n          <div>\r\n            <p>\r\n              <input  \r\n                type=\"checkbox\"\r\n                checked={otherColChecked[i]}\r\n                onChange={(e) => this.props.toggleOtherNeighbour(e, i, this.props.colIndex)}\r\n              />\r\n              {'\\u00A0'}{'\\u00A0'}\r\n              {otherColSelection[i].label}\r\n            </p>\r\n          </div>\r\n          {additionEle}\r\n        </div>\r\n      )\r\n    }\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n\r\n    let selectionEle = this.createOtherColSelection();\r\n\r\n    return (\r\n      <div>\r\n        <div>\r\n          <p><b>Choose from attributes below</b> to determine the content for this column</p>\r\n        </div>\r\n        <br />\r\n        <div>\r\n          {selectionEle}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default OtherColSelection;\r\n\r\n","import React, { Component } from \"react\";\r\nimport { FaPlus, FaMinus } from \"react-icons/fa\";\r\n\r\nclass PreviewOrigin extends Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createPreviewEle = this.createPreviewEle.bind(this);\r\n    this.createOriginEle = this.createOriginEle.bind(this);\r\n  }\r\n\r\n  createPreviewEle() {\r\n    let previewInfoExpanded = this.props.previewInfoExpanded;\r\n    let previewInfoArray = this.props.previewInfoArray;\r\n    // We do some preliminary error checking\r\n    if (previewInfoExpanded.length !== previewInfoArray.length) {\r\n      alert(\"Some error exists!\");\r\n    }\r\n\r\n    // Move on to actual body of the function\r\n    let previewEle = [];\r\n    for (let i = 0; i < previewInfoArray.length; ++i) {\r\n      // First case: the current previewInfoArray element's value array only has one element. We just want to show some text.\r\n      if (previewInfoArray[i].value.length === 1) {\r\n        previewEle.push(\r\n          <div>\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">\r\n                <b>{previewInfoArray[i].key}:</b>\r\n              </div>\r\n              <div className=\"col-md-7\">\r\n                {niceRender(previewInfoArray[i].value[0])}\r\n              </div>\r\n            </div>\r\n            <br />\r\n          </div>\r\n        )\r\n      } \r\n      // Second case: the current previewInfoArray element's value array has more than one element.\r\n      // In this case we have to check for the previewInfoExpanded's variable.\r\n      else {\r\n        // Subcase one: previewInfoExpanded[i] is false, which means we want to push on one element only, and show a plus button\r\n        if (previewInfoExpanded[i] === false) {\r\n          previewEle.push(\r\n            <div>\r\n              <div className=\"row\">\r\n                <div className=\"col-md-4\">\r\n                  <b>{previewInfoArray[i].key}:</b>\r\n                </div>\r\n                <div className=\"col-md-7\">\r\n                  {niceRender(previewInfoArray[i].value[0])}\r\n                </div>\r\n                <div className=\"col-md-1\">\r\n                  <button\r\n                    className=\"btn btn-default\"\r\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\r\n                  >\r\n                    <FaPlus />\r\n                  </button>\r\n                </div>\r\n              </div>\r\n              <br />\r\n            </div>\r\n          )\r\n        }\r\n        // Subcase one: previewInfoExpanded[i] is true, which means we want to push on value.length number of elements.\r\n        // In this case we want to give a minus, or collapse icon\r\n        else {\r\n          // We first push on the first element(or row), which will include the minus icon\r\n          previewEle.push(\r\n            <div>\r\n              <div className=\"row\">\r\n                <div className=\"col-md-4\">\r\n                  <b>{previewInfoArray[i].key}:</b>\r\n                </div>\r\n                <div className=\"col-md-7\">\r\n                  {niceRender(previewInfoArray[i].value[0])}\r\n                </div>\r\n                <div className=\"col-md-1\">\r\n                  <button\r\n                    className=\"btn btn-default\"\r\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\r\n                  >\r\n                    <FaMinus />\r\n                  </button>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )\r\n          // We then push on the subsequent values\r\n          for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\r\n            let brEle = j === previewInfoArray[i].value.length - 1 ? <br /> : null;\r\n            previewEle.push(\r\n              <div>\r\n                <div className=\"row\">\r\n                  <div className=\"offset-md-4 col-md-7\">\r\n                    {niceRender(previewInfoArray[i].value[j])}\r\n                  </div>\r\n                </div>\r\n                {brEle}\r\n              </div>\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n    let returnEle = (\r\n      <div>\r\n        <p>Preview of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\r\n        {previewEle}\r\n      </div>\r\n    )\r\n    return returnEle;\r\n  }\r\n\r\n  createOriginEle() {\r\n    let originEle = [];\r\n    for (let i = 0; i < this.props.selectedCell.origin.length; ++i) {\r\n      originEle.push(\r\n        <p>\r\n          {niceRender(this.props.selectedCell.origin[i])}\r\n        </p>\r\n      );\r\n    }\r\n    let returnEle = (\r\n      <div>\r\n        <p>Origin of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\r\n        {originEle}\r\n      </div>\r\n    )\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n    // console.log(this.props.previewInfoArray);\r\n    // console.log(this.props.previewInfoExpanded);\r\n    // console.log(this.props.selectedCell);\r\n    let previewEle = this.createPreviewEle();\r\n    let originEle = this.createOriginEle();\r\n    return (\r\n      <div>\r\n        {previewEle}\r\n        <hr className=\"preview-origin-divider\"/>\r\n        {originEle}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PreviewOrigin;\r\n\r\n// This function renders strings in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport TaskMenu from \"../components/TaskMenu\";\r\nimport { Collapse, Button, CardBody, Card } from \"reactstrap\";\r\nimport { FaList, FaTable } from \"react-icons/fa\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// The two following lines are for tabs\r\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\r\nimport \"react-tabs/style/react-tabs.css\";\r\nimport TableSelection from \"./TableSelection\";\r\n// The two following lines are for range sliders\r\n// import RangeSlider from \"react-bootstrap-range-slider\";\r\n// import \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\nimport FirstColSelection from \"./FirstColSelection\";\r\nimport OtherColSelection from \"./OtherColSelection\";\r\nimport PreviewOrigin from \"./PreviewOrigin\";\r\n\r\nclass ActionPanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createPropertyArray = this.createPropertyArray.bind(this);\r\n    this.createSiblingArray = this.createSiblingArray.bind(this);\r\n    this.createTableArray = this.createTableArray.bind(this);\r\n    this.createRecommendArray = this.createRecommendArray.bind(this);\r\n  }\r\n\r\n  createTableArray(firstIndex, secondIndex) {\r\n    const tableArray = this.props.propertyNeighbours[firstIndex].siblingArray[\r\n      secondIndex\r\n    ].tableArray;\r\n    let tableElement = [];\r\n    for (let thirdIndex = 0; thirdIndex < tableArray.length; ++thirdIndex) {\r\n      // console.log(\"Hello\");\r\n      // console.log(tableArray[thirdIndex].title);\r\n      let tableTitleText = \"Table \" + thirdIndex + \": \";\r\n      for (let i = 0; i < tableArray[thirdIndex].title.length; ++i) {\r\n        tableTitleText = tableTitleText + tableArray[thirdIndex].title[i] + \"|\";\r\n      }\r\n      tableElement.push(\r\n        <div>\r\n          <Button\r\n            onClick={(e) =>\r\n              this.props.toggleOtherTable(\r\n                e,\r\n                firstIndex,\r\n                secondIndex,\r\n                thirdIndex\r\n              )\r\n            }\r\n          >\r\n            {tableTitleText}\r\n            <FaTable />\r\n          </Button>\r\n          <Collapse isOpen={tableArray[thirdIndex].isOpen}>\r\n            <Card>\r\n              <CardBody>\r\n                <div>\r\n                  <ul className=\"list-group list-css\">\r\n                    <li\r\n                      className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                      onClick={(e) =>\r\n                        this.props.unionTable(\r\n                          firstIndex,\r\n                          secondIndex,\r\n                          tableArray[thirdIndex].data,\r\n                          tableArray[thirdIndex].colMapping\r\n                        )}\r\n                    >\r\n                      Union table\r\n                    </li>\r\n                  </ul>\r\n                  <div\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: tableArray[thirdIndex].data.outerHTML,\r\n                    }}\r\n                  ></div>\r\n                </div>\r\n              </CardBody>\r\n            </Card>\r\n          </Collapse>\r\n        </div>\r\n      );\r\n    }\r\n    return tableElement;\r\n  }\r\n\r\n  createSiblingArray(firstIndex) {\r\n    const siblingArray = this.props.propertyNeighbours[firstIndex].siblingArray;\r\n    let siblingElement = [];\r\n    let zeroDividerSet = false;\r\n    for (\r\n      let secondIndex = 0;\r\n      secondIndex < siblingArray.length;\r\n      ++secondIndex\r\n    ) {\r\n      let tooltipText =\r\n        \"Examine tables on page \" + siblingArray[secondIndex].name;\r\n      // let divider = null;\r\n      let listClassSib = \"list-group-item\";\r\n      if (siblingArray[secondIndex].isOpen) {\r\n        listClassSib = \"list-group-item list-with-background\";\r\n      }\r\n      if (\r\n        zeroDividerSet === false &&\r\n        siblingArray[secondIndex].tableArray.length === 0\r\n      ) {\r\n        zeroDividerSet = true;\r\n        // divider = (\r\n        //   <li>\r\n        //     <h5>\r\n        //       Below are sibling pages on which no similar tables are found:\r\n        //     </h5>\r\n        //     <hr />\r\n        //   </li>\r\n        // );\r\n        siblingElement.push(\r\n          <li className=\"list-group-item\">\r\n            <hr />\r\n            <h5>\r\n              Below are sibling pages on which no similar tables are found:\r\n            </h5>\r\n            <hr />\r\n          </li>\r\n        );\r\n      }\r\n\r\n      siblingElement.push(\r\n        <li \r\n          className={listClassSib} \r\n          title={tooltipText}\r\n          // onClick={(e) =>\r\n          //   this.props.toggleSibling(e, firstIndex, secondIndex)\r\n          // }\r\n        >\r\n          <span\r\n            onClick={(e) =>\r\n              this.props.toggleSibling(e, firstIndex, secondIndex)\r\n            }\r\n          >\r\n            {siblingArray[secondIndex].name + \" \"}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={siblingArray[secondIndex].isOpen}>\r\n            <div>\r\n              <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button\"\r\n                  onClick={(e) => this.props.unionPage(firstIndex, secondIndex)}\r\n                >\r\n                  Union from page\r\n                </li>\r\n              </ul>\r\n              {this.createTableArray(firstIndex, secondIndex)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {\" \"}\r\n        {siblingElement}{\" \"}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  createPropertyArray() {\r\n    // console.log(\"Getting here meaning we are recreating the property array\");\r\n    const propertyNeighbours = this.props.propertyNeighbours;\r\n    // console.log(propertyNeighbours);\r\n    let propertyElement = [];\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      // We create the text for property buttons: table index plus column names\r\n      const predicate = propertyNeighbours[i].predicate;\r\n      const object = propertyNeighbours[i].object;\r\n      let propertyText = predicate + \": \" + object + \" \";\r\n      let tooltipText = \"Show other pages with \" + predicate + \": \" + object;\r\n\r\n      let listClass = \"list-group-item\";\r\n      if (this.props.propertyNeighbours[i].isOpen) {\r\n        listClass = \"list-group-item list-with-background\";\r\n      }\r\n\r\n      propertyElement.push(\r\n        <li class={listClass} title={tooltipText}>\r\n          <span onClick={(e) => this.props.togglePropertyNeighbours(e, i)}>\r\n            {propertyText}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={this.props.propertyNeighbours[i].isOpen}>\r\n            <div>\r\n              <hr />\r\n              {/* <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                  onClick={(e) => this.props.unionProperty(i)}\r\n                >\r\n                  Union from all pages\r\n                </li>\r\n              </ul> */}\r\n              {this.createSiblingArray(i)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {propertyElement}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  // This function creates the HTML element for recommend array\r\n  createRecommendArray(colIndex, recommendArray) {\r\n    // console.log(recommendArray);\r\n    let stringRecommend = [];\r\n    let semanticRecommend = [];\r\n    // stringRecommend and semanticRecommend are both HTML elements that should be constructed from recommend array\r\n    for (let i = 0; i < recommendArray.length; ++i) {\r\n      // let neighbourArray = [\r\n      //   {\r\n      //     \"value\":recommendArray[i].value,\r\n      //     \"type\":recommendArray[i].type\r\n      //   }\r\n      // ]\r\n      let recommendText = recommendArray[i].type === \"subject\" ? recommendArray[i].value: \"is \" + recommendArray[i].value + \" of\";\r\n      if (recommendArray[i].relation === \"string\") {\r\n        stringRecommend.push(\r\n          <div>\r\n            {/* <Button\r\n              onClick={(e) => this.props.populateRecommendation(e,\r\n                                                                colIndex,\r\n                                                                neighbourArray)}>\r\n              add {recommendText}\r\n            </Button> */}\r\n            <p><b>{recommendText}</b></p>\r\n          </div>\r\n        )\r\n      }\r\n      else {\r\n        semanticRecommend.push(\r\n          <div>\r\n            {/* <Button\r\n              onClick={(e) => this.props.populateRecommendation(e,\r\n                                                                colIndex,\r\n                                                                neighbourArray)}>\r\n              add {recommendText}\r\n            </Button> */}\r\n            <p><b>{recommendText}</b></p>\r\n          </div>\r\n        )\r\n      }\r\n    }\r\n    let returnEle = \r\n      <div className=\"container\">\r\n        <p>Attribute Recommendations:</p>\r\n        {stringRecommend}\r\n        {semanticRecommend}\r\n      </div>\r\n    return returnEle;\r\n  }\r\n\r\n  // This function creates the HTML element for populateSameNeighbour\r\n  createSameNeighbour(actionInfo) {\r\n    let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\r\n    let returnEle = (\r\n      <div className=\"container\">\r\n        <p>Some cells in this column contain multiple values.</p>\r\n        <p>Expand all other values that are also</p>\r\n        <p><b>{neighbourArrayText}</b> ?</p>\r\n        <div className=\"row\">\r\n          <button\r\n            className=\"col-md-4\"\r\n            onClick={(e) =>\r\n              this.props.sameNeighbourOneRow(\r\n                e,\r\n                actionInfo.colIndex,\r\n                actionInfo.neighbourArray,\r\n              )\r\n            }\r\n          >\r\n            In One Row\r\n          </button>\r\n          <button\r\n            className=\"offset-md-1 col-md-4\"\r\n            onClick={(e) =>\r\n              this.props.sameNeighbourDiffRow(\r\n                e,\r\n                actionInfo.colIndex,\r\n                actionInfo.neighbourArray,\r\n              )\r\n            }\r\n          >\r\n            In Separate Rows\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n    let actionEle;  // contains either wrangling actions or unionable tables for the action panel\r\n    let wrapperEle; // wrapper element for actionEle. This is what we will render in the HTML.\r\n    let titleEle;   // contains what we will display as the title for the action panel\r\n\r\n    // We first decide the content for the titleElement\r\n    if (\r\n      this.props.usecaseSelected === \"\" \r\n      // ||\r\n      // (this.props.usecaseSelected === \"startTable\" &&\r\n      //   this.props.selectedTableIndex === -1)\r\n    ) {\r\n      titleEle = (\r\n        <div className=\"row\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              ACTIONS\r\n              <span> </span>\r\n              <span className=\"logo-right-color xsmall\">\r\n                Select your starting action\r\n              </span>\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    } \r\n    else {\r\n      titleEle = (\r\n        <div className=\"row action-header\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              ACTIONS\r\n              <span> </span>\r\n              <span className=\"logo-right-color xsmall\">\r\n                Select your next action\r\n              </span>\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // We now decide the content for the actionElement\r\n    // Case 1: URL has been pasted, but task has not been selected. User needs to select task.\r\n    if (this.props.usecaseSelected === \"\") {\r\n      wrapperEle = \r\n        <TaskMenu \r\n          handleStartSubject={this.props.handleStartSubject} \r\n          urlPasted={this.props.urlPasted}\r\n          showTableSelection={this.props.showTableSelection}\r\n          toggleTableSelection={this.props.toggleTableSelection}\r\n          originTableArray={this.props.originTableArray}\r\n          tableOpenList={this.props.tableOpenList}\r\n          toggleTable={this.props.toggleTable}\r\n          selectedTableIndex={this.props.selectedTableIndex}\r\n          handleStartTable={this.props.handleStartTable}\r\n        />;\r\n    }\r\n    // Case 2: Task has been selected. curActionInfo is not null, meaning we have to display some task in ActionPanel\r\n    else if (this.props.curActionInfo !== null) {\r\n      const actionInfo = this.props.curActionInfo;\r\n      // Case 2.1: Users have selected \"Create Table from subject\".\r\n      // We ask users to select a column header for the first column.\r\n      if (actionInfo.task === \"afterStartSubject\") {\r\n        actionEle = (\r\n          <FirstColSelection\r\n            firstColSelection={this.props.firstColSelection}\r\n            firstColChecked={this.props.firstColChecked}\r\n            firstColFilled={this.props.firstColFilled}\r\n            toggleFirstNeighbour={this.props.toggleFirstNeighbour}\r\n            tableHeader={this.props.tableHeader}\r\n            keyCheckedIndex={this.props.keyCheckedIndex}\r\n            populateKeyColumn={this.props.populateKeyColumn}\r\n            confirmAddFirstCol={this.props.confirmAddFirstCol}\r\n          />\r\n        )\r\n      }\r\n      // Case 2.2: Users have clicked on the down arrow for non-first columns.\r\n      // We ask users to select a column header for this column.\r\n      else if (actionInfo.task === \"showOtherColSelection\") {\r\n        actionEle = (\r\n          <OtherColSelection\r\n            otherColSelection={this.props.otherColSelection}\r\n            otherColChecked={this.props.otherColChecked}\r\n            otherCheckedIndex={this.props.otherCheckedIndex}\r\n            toggleOtherNeighbour={this.props.toggleOtherNeighbour}\r\n            populateOtherColumn={this.props.populateOtherColumn}\r\n            colIndex={actionInfo.colIndex}\r\n          />\r\n        )\r\n      }\r\n      // Case 2.2: Users have click on the PLUS icon on first column's header.\r\n      // We ask users if they want to add more entities to the first column.\r\n      else if (actionInfo.task === \"plusClicked\") {\r\n        // We want to do an error check here: if the first column is not the current search column, we disable adding more entities to it.\r\n        if (this.props.keyColIndex !== 0) {\r\n          actionEle = (\r\n            <div>\r\n              <p>\r\n                <b>\r\n                  Please set the first column as the search column before adding more entities to it.\r\n                </b>\r\n              </p>\r\n            </div>\r\n          )\r\n        }\r\n        else {\r\n          actionEle = (\r\n            <div>\r\n              <p>Add more entities to the first column?</p>\r\n              <button\r\n                onClick={() => this.props.addToFirstCol()}\r\n              >\r\n                OK\r\n              </button>\r\n            </div>\r\n          )\r\n        }\r\n      }\r\n      // In this case, we tell users they can keep wrangling by selecting column header for empty columns\r\n      else if (actionInfo.task === \"afterPopulateColumn\") {\r\n        actionEle = (\r\n          <div>\r\n            Fill an <b>empty column header</b> by clicking on its <b>edit icon</b>\r\n          </div>\r\n        )\r\n      }\r\n      // In this case we give user a button to allow the population of first column\r\n      else if (actionInfo.task === \"populateKeyColumn\") {\r\n        let neighbourArrayText = \"\";\r\n        for (let i = 0; i < actionInfo.neighbourArray.length; ++i) {\r\n          if (i > 0) {\r\n            neighbourArrayText += \" & \";\r\n          }\r\n          neighbourArrayText += actionInfo.neighbourArray[i].label;\r\n        }\r\n        if (neighbourArrayText !== \"\") {\r\n          actionEle = (\r\n            <div>\r\n              <p>Fill this column with:</p>\r\n              <p><b>{neighbourArrayText}</b> ?</p>\r\n              <button\r\n                onClick={(e) =>\r\n                  this.props.populateKeyColumn(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    actionInfo.neighbourArray\r\n                  )\r\n                }\r\n              >\r\n                OK\r\n              </button>\r\n            </div>\r\n          );\r\n        }\r\n        else {\r\n          actionEle = (\r\n            <div>\r\n              <p className=\"suggestion-text\">\r\n                Fill the <b>first column header</b> by choosing from its <b>down arrow</b>\r\n              </p>\r\n            </div>\r\n          );\r\n        }\r\n      } \r\n      // In this case we give user a button to allow the population of a new column\r\n      else if (actionInfo.task === \"populateOtherColumn\") {\r\n        let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\r\n        actionEle = (\r\n          <div>\r\n            <p>Fill this column with:</p>\r\n            <p><b>{neighbourArrayText}</b> ?</p>\r\n            <button\r\n              onClick={(e) =>\r\n                this.props.populateOtherColumn(\r\n                  e,\r\n                  actionInfo.colIndex,\r\n                  actionInfo.neighbourArray,\r\n                )\r\n              }\r\n            >\r\n              OK\r\n            </button>\r\n          </div>\r\n        );\r\n      } \r\n      // In this case we give user a button to allow the population of same neighbour\r\n      else if (actionInfo.task === \"populateSameNeighbour\") {\r\n        actionEle = this.createSameNeighbour(actionInfo);\r\n      } \r\n      // In this case we give user a button to allow the population of all neighbours from the same range\r\n      else if (actionInfo.task === \"populateSameRange\") {\r\n        let siblingText = \"\";\r\n        let plural = \"\";\r\n        for (let i = 0; i < actionInfo.siblingNeighbour.length; ++i) {\r\n          if (i > 0) {\r\n            siblingText += \", \";\r\n            plural = \"s\";\r\n          }\r\n          siblingText += actionInfo.siblingNeighbour[i].value;\r\n        }\r\n        actionEle = (\r\n          <div>\r\n            <p>Add column{plural}: <b>{siblingText}</b></p>\r\n            <p>that also has type: {actionInfo.range} ?</p>\r\n            <button\r\n              onClick={(e) =>\r\n                this.props.populateSameRange(\r\n                  e,\r\n                  actionInfo.colIndex,\r\n                  actionInfo.range,\r\n                  actionInfo.siblingNeighbour\r\n                )\r\n              }\r\n            >\r\n              OK\r\n            </button>\r\n          </div>\r\n        );\r\n      } \r\n      // In this case we give users an array of recommended neighbours to add to the table\r\n      else if (actionInfo.task === \"populateRecommendation\") {\r\n        let recommendArray = this.createRecommendArray(actionInfo.colIndex, actionInfo.recommendArray);\r\n        actionEle = (\r\n          <div>\r\n            {recommendArray}\r\n          </div>\r\n        )\r\n      }\r\n      // In this case we have to include both populateSameNeighbour and populateRecommendation\r\n      else if (actionInfo.task === \"sameNeighbourAndRecommendation\") {\r\n        let sameNeighbourEle = this.createSameNeighbour(actionInfo);\r\n        let recommendEle = this.createRecommendArray(actionInfo.colIndex, actionInfo.recommendArray);\r\n        actionEle = (\r\n          <div>\r\n            <Card className=\"action-panel-card\">\r\n              {sameNeighbourEle}\r\n            </Card>\r\n            <br />\r\n            <Card className=\"action-panel-card\">\r\n              {recommendEle}\r\n            </Card>\r\n          </div>\r\n        )\r\n      }\r\n      // In this case we give user four column filter methods: sort asc, sort des, filter, and dedup\r\n      else if (actionInfo.task === \"showFilterMethods\") {\r\n        let textEle = null;\r\n        if (actionInfo.colIndex === 0) {\r\n          textEle = \r\n            <p><b>How would you like to process the first column?</b></p>\r\n        }\r\n        else {\r\n          textEle = \r\n            <p><b>How would you like to process column {createNeighbourText(this.props.tableHeader[actionInfo.colIndex])} ?</b></p>\r\n        }\r\n        // console.log(textEle);\r\n        actionEle = (\r\n          <div>\r\n            <div>\r\n              {textEle}\r\n            </div>\r\n            <div>\r\n              <Button\r\n                onClick={(e) => this.props.contextSortColumn(e, actionInfo.colIndex, \"ascending\")}\r\n              >\r\n                Sort ascending\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) => this.props.contextSortColumn(e, actionInfo.colIndex, \"descending\")}\r\n              >\r\n                Sort descending\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) => this.props.openFilter(e, actionInfo.colIndex)}\r\n              >\r\n                Filter this column\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) => this.props.contextDedupColumn(e, actionInfo.colIndex)}\r\n              >\r\n                Dedup this column\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        )\r\n      }\r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"contextCellOrigin\") {\r\n        actionEle = (\r\n          <div>\r\n            <p>Origin of selected cell is:</p>\r\n            <div>{actionInfo.origin}</div>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"originPreviewPage\") {\r\n      actionEle = (\r\n        // <div>\r\n        //   <div>\r\n        //     <p>Preview of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\r\n        //     <div>\r\n        //       {renderPreview(actionInfo.preview)}\r\n        //     </div>\r\n        //   </div>\r\n        //   <hr className=\"preview-origin-divider\"/>\r\n        //   <div>\r\n        //     <p>Origin of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\r\n        //     <div>{actionInfo.origin}</div>\r\n        //   </div>\r\n        // </div>\r\n          <PreviewOrigin\r\n            previewInfoArray={this.props.previewInfoArray}\r\n            previewInfoExpanded={this.props.previewInfoExpanded}\r\n            selectedCell={this.props.selectedCell}\r\n            togglePreviewElement={this.props.togglePreviewElement}\r\n          />\r\n        );\r\n      }  \r\n    } \r\n    // This is an empty else clause\r\n    else {\r\n    }\r\n\r\n    // Now we have to determine whether we are rendering one tab or two tabs.\r\n    // One tab for startSubject. Two tabs for startTable.\r\n    // console.log(this.props.usecaseSelected);\r\n\r\n    // Modified after JOIN has been added in:\r\n    // In the startSubject case, we will have two tab: wrangling actions, and table actions.\r\n    // Wrangling Actions: same as before.\r\n    // Table Actions: Union will be empty, JOIN will use the pasted URL from the beginning.\r\n\r\n    if (this.props.usecaseSelected === \"startSubject\") {\r\n      let curIndex = this.props.tabIndex;\r\n      wrapperEle = (\r\n        <div>\r\n          <Tabs\r\n            selectedIndex={curIndex}\r\n            onSelect={(index) => this.props.handleTabSwitch(index)}\r\n          >\r\n            <TabList>\r\n              <Tab>Wrangling Actions</Tab>\r\n              <Tab>Table Actions</Tab>\r\n            </TabList>\r\n              <TabPanel>\r\n                {actionEle}\r\n              </TabPanel>\r\n              <TabPanel>\r\n                <div>\r\n                  <ul class=\"list-group list-css list-group-flush\">\r\n                    <hr className=\"m-0\"></hr>\r\n                    <li\r\n                      className=\"list-group-item\"\r\n                    >\r\n                      <span \r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"union\")}\r\n                      >\r\n                        Union Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showUnionTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                            Currently, finding unionable tables for customized table is not supported.\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <li\r\n                      className=\"list-group-item\"\r\n                    >\r\n                      <span \r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\r\n                      >\r\n                        Join Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showJoinTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                            <p>\r\n                              The following tables are from page: <b>{decodeURIComponent(this.props.urlPasted.slice(30))}</b>\r\n                            </p>\r\n                            <TableSelection \r\n                              originTableArray={this.props.originTableArray}\r\n                              tableOpenList={this.props.tableOpenList}\r\n                              toggleTable={this.props.toggleTable}\r\n                              buttonFunction={this.props.handleJoinTable}\r\n                              listType={\"join\"}\r\n                            />\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <hr className=\"m-0\"></hr>\r\n                  </ul>\r\n                </div>\r\n              </TabPanel>\r\n          </Tabs>\r\n        </div>\r\n      );\r\n    }\r\n    else if (this.props.usecaseSelected === \"startTable\") {\r\n      // If we have not selected a table, we show both tabs, as we are fully ready.\r\n      if (this.props.selectedTableIndex !== -1) {\r\n        let curIndex = this.props.tabIndex;\r\n        wrapperEle = (\r\n          <div>\r\n            <Tabs \r\n              selectedIndex={curIndex}\r\n              onSelect={(index) => this.props.handleTabSwitch(index)}\r\n            >\r\n              <TabList>\r\n                <Tab>Wrangling Actions</Tab>\r\n                <Tab>Table Actions</Tab>\r\n              </TabList>\r\n              <TabPanel>\r\n                {actionEle}\r\n              </TabPanel>\r\n              <TabPanel>\r\n                <div>\r\n                  <ul class=\"list-group list-css list-group-flush\">\r\n                    <hr className=\"m-0\"></hr>\r\n                    <li\r\n                      className=\"list-group-item\"\r\n                    >\r\n                      <span \r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"union\")}\r\n                      >\r\n                        Union Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showUnionTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                              Expand relations below to look at other pages with similar\r\n                              tables:\r\n                            <br /><br />\r\n                            {this.createPropertyArray()}\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <li\r\n                      className=\"list-group-item\"\r\n                    >\r\n                      <span \r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\r\n                      >\r\n                        Join Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showJoinTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                            <p>\r\n                              The following tables are from page: <b>{decodeURIComponent(this.props.urlPasted.slice(30))}</b>\r\n                            </p>\r\n                            <TableSelection \r\n                              originTableArray={this.props.originTableArray}\r\n                              tableOpenList={this.props.tableOpenList}\r\n                              toggleTable={this.props.toggleTable}\r\n                              buttonFunction={this.props.handleJoinTable}\r\n                              listType={\"join\"}\r\n                            />\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <hr className=\"m-0\"></hr>\r\n                  </ul>\r\n                </div>\r\n              </TabPanel>\r\n            </Tabs>\r\n          </div>\r\n        )\r\n      }\r\n      // Else, we have not selected a table yet. In this case, wrapperEle should be equal to actionEle\r\n      else {  \r\n        wrapperEle = actionEle;\r\n      }\r\n    }\r\n    return (\r\n      <div>\r\n        <div>\r\n          {titleEle}\r\n        </div>\r\n        <div>\r\n          {wrapperEle}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ActionPanel;\r\n\r\n// // The following helper function creates HTML elements from previewInfoArray, \r\n// // an array of key-val pairs containing the info for a cell's preview.\r\n\r\n// // It also makes use of niceRender, so that preview looks clean.\r\n\r\n// function renderPreview(previewInfoArray) {\r\n//   // console.log(previewInfoArray);\r\n//   let infoEle = [];\r\n//   for (let i = 0; i < previewInfoArray.length; ++i) {\r\n//     let keyLiteral = previewInfoArray[i].key;\r\n//     // We get the first element from value Array\r\n//     let valLiteral = niceRender(previewInfoArray[i].value[0]);\r\n//     // Since we have already included thte first element, we start the index from 1\r\n//     for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\r\n//       valLiteral = valLiteral + \"; \"+niceRender(previewInfoArray[i].value[j]);\r\n//     }\r\n//     infoEle.push(\r\n//       <p><b>{keyLiteral}</b>{\":\"}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{valLiteral}</p>\r\n//     )\r\n//   }\r\n//   return infoEle;\r\n// }\r\n\r\n// // This function renders this.props.tableData[i][j].data in a nicer way. \r\n// // It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\n// function niceRender(str) {\r\n//   return str.replace(/_\\(.*?\\)/g, \"\")\r\n//             .replace(/_/g, \" \");\r\n// }\r\n\r\n// This function creates neighbourArrayText from neighbourArray\r\n\r\nfunction createNeighbourText(neighbourArray) {\r\n  let neighbourArrayText = \"\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    if (i > 0) {\r\n      neighbourArrayText+=\" OR \";\r\n    }\r\n    let curNeighbourText = neighbourArray[i].type === \"object\" ? \"is \" + neighbourArray[i].value + \" of\" : neighbourArray[i].value;\r\n    neighbourArrayText+=curNeighbourText;\r\n  }\r\n  return neighbourArrayText;\r\n}\r\n\r\n","import React, { Component } from \"react\";\r\n\r\nclass PagePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    let pageEle = null;\r\n    let wikiPageClass = \"small-padding wiki-page-hidden\";\r\n    let buttonClass = \"btn btn-sm btn-info toggle-button\";\r\n    if (this.props.iframeURL !== \"\") {\r\n      let buttonhideShow = (\r\n        <button\r\n          className={buttonClass}\r\n          onClick={() => this.props.toggleWikiPage()}\r\n        >\r\n          <i class=\"fa fa-chevron-up\" aria-hidden=\"true\"></i>\r\n          Show\r\n        </button>\r\n      );\r\n      if (!this.props.pageHidden) {\r\n        wikiPageClass = \"small-padding wiki-page\";\r\n        buttonhideShow = (\r\n          <div>\r\n            <hr className=\"m-1\"></hr>\r\n            <button\r\n              className={buttonClass}\r\n              onClick={() => this.props.toggleWikiPage()}\r\n            >\r\n              <i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i>\r\n              Hide\r\n            </button>\r\n          </div>\r\n        );\r\n      }\r\n      pageEle = (\r\n        <div className=\"page-panel text-right\">\r\n          {buttonhideShow}\r\n          <div className={wikiPageClass}>\r\n            <iframe\r\n              id=\"iframe\"\r\n              title=\"URLPage\"\r\n              src={this.props.iframeURL}\r\n              className=\"iframe-cls\"\r\n            ></iframe>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n    return <div>{pageEle}</div>;\r\n  }\r\n}\r\n\r\nexport default PagePanel;\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\nimport { combinations } from \"mathjs\";\r\nimport Header from \"../components/Header\";\r\nimport Footer from \"../components/Footer\";\r\nimport SettingModal from \"../components/SettingModal\";\r\nimport FilterModal from \"../components/FilterModal\";\r\nimport JoinModal from \"../components/JoinModal\";\r\nimport LandingPage from \"../components/LandingPage\";\r\nimport TablePanel from \"../components/TablePanel\";\r\nimport ActionPanel from \"../components/ActionPanel\";\r\nimport PagePanel from \"../components/PagePanel\";\r\nimport _ from \"lodash\";\r\n\r\nconst maxNeighbourCount = 10;\r\nconst initialColNum = 4;\r\nconst initialRowNum = 45;\r\n\r\nclass MainBody extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    let tableData = [];\r\n    let tableHeader = [];\r\n    let optionsMap = [];\r\n    for (let i = 0; i < initialRowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < initialColNum; ++j) {\r\n        // Initially, cell has no data or origin\r\n        // data field is a string\r\n        // origin field is an array of strings\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    for (let j = 0; j < initialColNum; ++j) {\r\n      let emptyOptions = [];\r\n      optionsMap.push(emptyOptions);\r\n      tableHeader.push([]);\r\n    }\r\n    this.state = {\r\n      // states below are general states used throughout the app\r\n      urlPasted: \"\",  \r\n      tablePasted: \"\",\r\n      usecaseSelected: \"\",\r\n      pageHidden: false,\r\n      iframeURL: \"\",\r\n      curActionInfo: null, // object storing the current action that should be displayed in ActionPanel. Initially null.\r\n      lastAction: \"\",      // string storing the last action that has modified the result table in the table panel\r\n      prevState: \"\",       // objects storing the information needed to undo the last step. Information stored depends on lastAction\r\n      showSetting: false,    // boolean storing whether setting modal is shown or not. Default to false.\r\n      showTableSelection: false,    // boolean storing whether the list of tables from page is shown. Default to false.\r\n      tabIndex: 1,         // integer storing the index of the tab currently displaying. Default to 1.\r\n      showUnionTables: false,  // boolean storing whether all the unionable pages and tables is shown. Default to false.\r\n      showJoinTables: false,   // boolean storing whether the page storing joinable tables is shown. Default to false.\r\n\r\n      // states below are useful for startSubject\r\n      keyColIndex: 0,   // number storing the index of the search column. initially the key column is the first column\r\n      // 1D array of objects with four properties storing the table headers. This array is used to create the column headers in table panel\r\n      // 1) label:  string storing the label of an option (ex: spouse)\r\n      // 2) value:  string storing the value of an option (ex: spouse)\r\n      // 3) type:   string that's either \"subject\" or \"object\". Storing whether the current option is ?s or ?o with respect to key column. Can be empty.\r\n      // 4) range:  string storing the rdfs:range of the current option.\r\n      tableHeader: tableHeader,\r\n      tableData: tableData, // 2D array of objects storing the table data (not including the table headers).\r\n      optionsMap: optionsMap, // 2D array storing the options map\r\n      keyColNeighbours: [], // 1D array storing the neighbours of the key column\r\n      // An object with two attributes: subject and object\r\n      // Subject and Object are both 1D arrays \r\n      // - Length tableData.length\r\n      // - Each element is an object with multiple attributes. Ex: {birthdate:[1998-01-01], almaMater:[a, b, c]}\r\n      firstDegNeighbours: [],\r\n\r\n      // states below are useful for first column header selection\r\n      firstColSelection: [],   // 1D array of objects storing information about the starting subject's neighbours\r\n      firstColChecked: [],     // 1D array of booleans storing whether a neighbour of the starting subject is selected or not\r\n      firstColFilled: false,   // boolean indicating whether the first column has been filled. \r\n                               // Will be set to true and remain that way after calling populateKeyColumn, or handleStartTable\r\n      keyCheckedIndex: -1,     // index storing the most recent index that has just been toggled for the first column. Initially -1.\r\n      firstColHeaderInfo: [],  // 2D array of objects storing information needed to create the first column's header. (since both AND and OR need to be considered)\r\n\r\n      // states below are useful for other column header selection\r\n      otherColSelection: [],    // 1D array of objects storing information about the search column's neighbours\r\n      otherColChecked: [],      // 1D array of booleans storing whether a neighbour of the search column is selected or not\r\n      otherCheckedIndex: -1,    // index storing the most recent index that has just been toggled for a non-first column. Initially -1.\r\n\r\n      // states below are useful for startTable\r\n      originTableArray: [], // 1D array storing all tables found on pasted URL\r\n      tableOpenList: [], // 1D array storing whether each table in originTableArray has been toggled open or not\r\n      selectedTableIndex: -1, // index of table selected by user. If it's -1, take user to table selection. Else, show the table in Table Panel.\r\n      selectedClassAnnotation: [], // semantic class annotation for each column of selected table\r\n      // 2D arary of objects with three properties, which store the table data from explore table task. Similar to tableData above. \r\n      // Three properties: data, origin, rowSpan, colSpan.\r\n      tableDataExplore: [], \r\n      // array of objects with four properties storing the status/content for each property neighbour\r\n      // 1) predicate: string storing the predicate (ex. dbp:league)\r\n      // 2) object: string storing the object (ex. dbo:NBA)\r\n      // 3) isOpen: boolean storing whether the current property neighbour is toggled on or not\r\n      // 4) siblingArary: array of objects with two properties storing the staus/content for each sibling URL\r\n      //    4.1) isOpen:      boolean storing whether the current sibling is toggled on or not\r\n      //    4.2) tableArray:  array of objects storing the status/content for each \"same\" table on the sibling URL\r\n      //         4.2.1) isOepn:        boolean storing whether the current table is toggled on or not\r\n      //         4.2.2) unionScore:    number storing teh union score of the current table (how \"similar\" it is to the original table)\r\n      //         4.2.3) colMapping:    array of numbers storing the column mapping between the current table and the selected table\r\n      //         4.2.4) data:          HTML of a table\r\n      //         4.2.5) title:         array of strings storing the column headers of the current table\r\n      propertyNeighbours: [],\r\n      semanticEnabled: \"disabled\", // boolean value indicating whether semantic mapping is enabled or not. Default to true\r\n      unionCutOff: 0.75, // number representing the union percentage a table must have to be considered unionable (>=)\r\n\r\n      // states below are for column filter\r\n      showFilter: false,        // boolean storing whether we want to show column filter or not. Initially false.\r\n      curFilterIndex: -1,       // number storing the index of the column on which we apply the filter. Initially -1 (no filter.)\r\n      dataAndChecked: [],       // array of [data, checked] pairs storing which data are in the filter column, and whether we should keep them.\r\n    \r\n      // states below are for table join\r\n      showJoinModal: false,    // boolean storing whether the join option modal is show or not. Default to false.\r\n      joinTableIndex: -1,      // number storing the index of the table we want to join from originTableArray.\r\n      joinTableData: [],       // 2D array storing the data of the table we want to join from originTableArray. Initially empty.\r\n      originColOptions: [],    // 1D array storing the selection options for the original table.\r\n      joinColOptions: [],      // 1D array storing the selection options for the newly selected table.\r\n      originJoinIndex: -1,     // number storing the index of the column of the original table that we are joining.\r\n      joinJoinIndex: -1,       // number storing the index of the column of the newly selected table that we are joining.\r\n\r\n      // states below are for column preview\r\n      previewColIndex: -1,     // number storing the index of the column that we want to show preview for. \r\n                               // When -1, we do not want to show any preview. This state needs to be passed to TablePanel\r\n                               // It should only be set to non -1 when we have toggled some selections on, but haven't confirmed on selections yet. \r\n      // states below are useful for cell preview and origin\r\n      selectedCell: null,      // data in the format of tableData[i][j] (has both data and origin attribute). \r\n                               // (origin element can be determined from this)\r\n      previewInfoArray: [],    // array storing the information used to create the preview element. \r\n                               // It contains categories, subject, object first degree neighbours.\r\n      previewInfoExpanded: [], // array of booleans storing whether each element from previewInfoArray is expanded or not.\r\n                               // This can only be set to true for previewInfoArray elements that have value length longer than 1.\r\n    };\r\n\r\n    // functions below are useful during start up\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n    this.handleStartSubject = this.handleStartSubject.bind(this);\r\n    this.handleStartTable = this.handleStartTable.bind(this);\r\n\r\n    // functions below are useful for startSubject\r\n    this.cellChange = this.cellChange.bind(this);\r\n    this.selectColHeader = this.selectColHeader.bind(this);\r\n    this.getKeyOptions = this.getKeyOptions.bind(this);\r\n    this.getOtherOptions = this.getOtherOptions.bind(this);\r\n    this.getNeighbourPromise = this.getNeighbourPromise.bind(this);\r\n    this.populateKeyColumn = this.populateKeyColumn.bind(this);\r\n    this.getOtherColPromise = this.getOtherColPromise.bind(this);\r\n    // this.getOtherColPromiseTwo = this.getOtherColPromiseTwo.bind(this);\r\n    this.populateOtherColumn = this.populateOtherColumn.bind(this);\r\n    this.addAllNeighbour = this.addAllNeighbour.bind(this);\r\n    this.getTableStates = this.getTableStates.bind(this);\r\n    this.sameNeighbourDiffRow = this.sameNeighbourDiffRow.bind(this);\r\n    this.sameNeighbourOneRow = this.sameNeighbourOneRow.bind(this);\r\n    this.populateRecommendation = this.populateRecommendation.bind(this);\r\n\r\n    // functions below are for column processing\r\n    this.contextAddColumn = this.contextAddColumn.bind(this);\r\n    this.contextDeleteColumn = this.contextDeleteColumn.bind(this);\r\n    this.contextSetColumn = this.contextSetColumn.bind(this);\r\n    // this.contextCellOrigin = this.contextCellOrigin.bind(this);\r\n    this.originPreviewPage = this.originPreviewPage.bind(this);\r\n    this.contextSortColumn = this.contextSortColumn.bind(this);\r\n    this.contextDedupColumn = this.contextDedupColumn.bind(this);\r\n    this.showFilterMethods = this.showFilterMethods.bind(this);\r\n\r\n    // functions below are useful for startTable\r\n    this.toggleTable = this.toggleTable.bind(this);\r\n    this.togglePropertyNeighbours = this.togglePropertyNeighbours.bind(this);\r\n    this.toggleSibling = this.toggleSibling.bind(this);\r\n    this.toggleOtherTable = this.toggleOtherTable.bind(this);\r\n    this.unionTable = this.unionTable.bind(this);\r\n    this.unionPage = this.unionPage.bind(this);\r\n    this.unionProperty = this.unionProperty.bind(this);\r\n    this.toggleSemantic = this.toggleSemantic.bind(this);\r\n    this.unionCutOffChange = this.unionCutOffChange.bind(this);\r\n\r\n    // functions below are generally usefull\r\n    this.copyTable = this.copyTable.bind(this);\r\n    this.toggleWikiPage = this.toggleWikiPage.bind(this);\r\n    this.undoPreviousStep = this.undoPreviousStep.bind(this);\r\n    this.handleTabSwitch = this.handleTabSwitch.bind(this);\r\n    this.openModal = this.openModal.bind(this);\r\n    this.closeModal = this.closeModal.bind(this);\r\n    this.toggleTableSelection = this.toggleTableSelection.bind(this);\r\n    this.toggleUnionJoin = this.toggleUnionJoin.bind(this);\r\n\r\n    // functions below are for column filter\r\n    this.openFilter = this.openFilter.bind(this);\r\n    this.cancelFilter = this.cancelFilter.bind(this);\r\n    this.toggleChecked = this.toggleChecked.bind(this);\r\n    this.applyFilter = this.applyFilter.bind(this);\r\n\r\n    // functions below are for join feature\r\n    this.handleJoinTable = this.handleJoinTable.bind(this);\r\n    this.cancelJoin = this.cancelJoin.bind(this);\r\n    this.selectJoinColumn = this.selectJoinColumn.bind(this);\r\n    this.runJoin = this.runJoin.bind(this);\r\n\r\n    // functions below are for first column selection\r\n    this.toggleFirstNeighbour = this.toggleFirstNeighbour.bind(this);\r\n    this.handlePlusClick = this.handlePlusClick.bind(this);\r\n    this.addToFirstCol = this.addToFirstCol.bind(this);\r\n    this.confirmAddFirstCol = this.confirmAddFirstCol.bind(this);\r\n\r\n    // functions below are for other column selection\r\n    this.toggleOtherNeighbour = this.toggleOtherNeighbour.bind(this);\r\n\r\n    // functions below are for cell preview and origin\r\n    this.togglePreviewElement = this.togglePreviewElement.bind(this);\r\n  }\r\n\r\n  // As soon as the URL has been pasted, we want to fetch all tables from the pasted URL.\r\n  // We then update the originTableArray, which stores all the tables found on the pasted URL\r\n  // We also initialize tableOpenList to all false\r\n  handleURLPaste(urlPasted) {\r\n    document.body.classList.add('waiting');\r\n\r\n    // We first check if user has pasted a valid wikipedia page.\r\n\r\n    if (!urlPasted.includes(\"https://en.wikipedia.org/wiki/\")) {\r\n      document.body.classList.remove('waiting');\r\n      alert(\"Please paste a valid Wikipedia link.\");\r\n    }\r\n\r\n    // If yes, we fetch the tables from the pasted Wikipedia page\r\n    else {\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchText(urlPasted));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // We first parse the pasted URL and store the list of tables from the pasted URL\r\n        let htmlText = values[0];\r\n        let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\r\n        let originTableArray = doc.getElementsByClassName(\"wikitable\");\r\n        let tableOpenList = [];\r\n        for (let i = 0; i < originTableArray.length; ++i) {\r\n          tableOpenList.push(false);\r\n        }\r\n\r\n        // Adding support for undo:\r\n        document.body.classList.remove('waiting');\r\n\r\n        let lastAction = \"handleURLPaste\";\r\n        let prevState = \r\n          {\r\n            \"urlPasted\":\"\",\r\n            \"iframeURL\":\"\",\r\n            \"originTableArray\":[],\r\n            \"tableOpenList\":[],\r\n          };\r\n\r\n        this.setState({\r\n          originTableArray: originTableArray,\r\n          tableOpenList: tableOpenList,\r\n          urlPasted: urlPasted,\r\n          iframeURL: urlPasted,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function copies the table content to clipboard\r\n\r\n  copyTable() {\r\n    const textArea = document.createElement(\"textarea\"); // this line allows the use of select() function\r\n    let copiedText = \"\";\r\n    // // We handle the case for startTable and startSubject differently\r\n\r\n    // // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\r\n    // if (this.state.usecaseSelected === \"startTable\") {\r\n    //   // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\r\n    //   const rowNum = this.state.tableDataExplore.length;\r\n    //   const colNum = this.state.tableDataExplore[0].length;\r\n    //   for (let i = 0; i < rowNum; ++i) {\r\n    //     for (let j = 0; j < colNum - 1; ++j) {\r\n    //       copiedText =\r\n    //         copiedText + this.state.tableDataExplore[i][j].data + \"\\t\";\r\n    //     }\r\n    //     copiedText =\r\n    //       copiedText + this.state.tableDataExplore[i][colNum - 1].data + \"\\n\";\r\n    //   }\r\n    // }\r\n\r\n    // This case handles the copy table for start subject\r\n    if (this.state.usecaseSelected === \"startSubject\" || this.state.usecaseSelected === \"startTable\") {\r\n      // We first push on the text for column headers (using the labels)\r\n      let tableHeader = this.state.tableHeader;\r\n      for (let i = 0; i < tableHeader.length; ++i) {\r\n        let curText = tableHeader[i].label;\r\n        // console.log(curText);\r\n        if (curText === undefined && tableHeader[i].length > 0) {\r\n          curText = \"\";\r\n          for (let j = 0; j < tableHeader[i].length; ++j) {\r\n            if (j > 0) {\r\n              if (i === 0) {\r\n                curText += \" AND \";\r\n              }\r\n              else {\r\n                curText += \" OR \";\r\n              }\r\n            }\r\n            curText += niceRender(tableHeader[i][j].label);\r\n          }\r\n        }\r\n        if (curText !== undefined && curText !== \"\") {\r\n          copiedText = copiedText + curText + \"\\t\";\r\n        }\r\n      }\r\n      copiedText += \"\\n\";\r\n      // Now we need to fetch the rows that are not column headers\r\n      let tableData = this.state.tableData;\r\n      const rowNum = tableData.length;\r\n      const colNum = tableData[0].length;\r\n      for (let i = 0; i < rowNum; ++i) {\r\n        for (let j = 0; j < colNum; ++j) {\r\n          let curText = niceRender(tableData[i][j].data);\r\n          if (curText !== undefined && curText !== \"\") {\r\n            copiedText = copiedText + curText + \"\\t\";\r\n          }\r\n        }\r\n        copiedText += \"\\n\";\r\n      }\r\n    }\r\n    textArea.value = copiedText;\r\n    document.body.appendChild(textArea);\r\n    textArea.select();\r\n    document.execCommand(\"copy\");\r\n    document.body.removeChild(textArea);\r\n    alert(\"Table content has been pasted!\");\r\n  }\r\n\r\n  // This function handles the toggling of the WikiPage at bottom\r\n\r\n  toggleWikiPage() {\r\n    let pageHidden = this.state.pageHidden;\r\n    this.setState({\r\n      pageHidden: !pageHidden,\r\n    });\r\n  }\r\n\r\n  // This function handles the selection of the starting task \"startSubject\"\r\n\r\n  handleStartSubject(e, taskSelected) {\r\n\r\n    if (taskSelected === \"startSubject\") {\r\n      \r\n      // Change the cursor since we are making a fetch request\r\n      document.body.classList.add('waiting');\r\n\r\n      // Since the starting task is \"startSubject\", we set the URL to be the first cell in the table\r\n      const subject = decodeURIComponent(this.state.urlPasted.slice(30)); \r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      tableData[0][0].data = subject;\r\n\r\n      // Let's run some queries here to fetch some first degree properties \r\n\r\n      // The query we will run is simply as follows\r\n      // select ?p ?o\r\n      // where {\r\n      // dbr:Barack_Obama ?p ?o.\r\n      // }\r\n\r\n      // Note: we are not taking account of the object neighbours. Subject neighbours only.\r\n\r\n      let prefixURL = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL = \r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBody = \r\n        \"select+%3Fp+%3Fo%0D%0Awhere+%7B%0D%0Adbr%3A\" + \r\n        regexReplace(subject) +\r\n        \"+%3Fp+%3Fo.%0D%0A%7D&\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      \r\n      let promiseArray = [fetchJSON(queryURL)]\r\n      \r\n      allPromiseReady(promiseArray).then((values) => {\r\n\r\n        // We set up the firstColSelection and firstColChecked states here\r\n        let firstColSelection = updateFirstColSelection(values[0].results.bindings);\r\n        let firstColChecked = [];\r\n        // Initially, firstColChecked is all false\r\n        for (let i = 0; i < firstColSelection.length; ++i) {\r\n          firstColChecked.push(false);\r\n        }\r\n        // console.log(firstColSelection);\r\n        // console.log(firstColChecked);\r\n\r\n        // We create the InfoObject needed for Action Panel\r\n        let tempObj = {\r\n          \"task\":\"afterStartSubject\",\r\n        };\r\n\r\n        // Adding support for undo:\r\n        let lastAction = \"handleStartSubject\";\r\n        let prevState = \r\n          {\r\n            \"usecaseSelected\":this.state.usecaseSelected,\r\n            \"tableData\":this.state.tableData,\r\n            \"tabIndex\":this.state.tabIndex,\r\n            \"curActionInfo\":this.state.curActionInfo,\r\n            \"firstColSelection\":this.state.firstColSelection,\r\n            \"firstColChecked\":this.state.firstColChecked,\r\n          };\r\n        \r\n        // Check the cursor back because we are done with the function\r\n        document.body.classList.remove('waiting');\r\n\r\n        this.setState({\r\n          usecaseSelected: taskSelected,\r\n          tableData: tableData,\r\n          firstColSelection: firstColSelection,\r\n          firstColChecked: firstColChecked,\r\n          curActionInfo: tempObj,\r\n          tabIndex: 0,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      })\r\n    } \r\n  }\r\n\r\n  // This function handles the toggling of the starting subject's neighbours\r\n  // Also, we store this toggledIndex, so that we can display the suggestion text at the right location.\r\n  // Obviously, we need to update this.state.firstColChecked array.\r\n\r\n  toggleFirstNeighbour(e, index) {\r\n    // console.log(\"Toggled index is \"+index);\r\n    \r\n    // We first create a copy of firstColChecked\r\n    let firstColChecked = this.state.firstColChecked.slice();\r\n\r\n    // Now we deal with keyCheckedIndex\r\n    let keyCheckedIndex = index;\r\n  \r\n    // We handle the toggling here\r\n    firstColChecked[index] = !firstColChecked[index];\r\n\r\n    // Lastly, we make the state changes\r\n    this.setState({\r\n      firstColChecked:firstColChecked,\r\n      keyCheckedIndex:keyCheckedIndex,\r\n    })\r\n  }\r\n\r\n  // This function handles the toggling of a non-first column's attribute selection\r\n  // Note: since the preview feature is being addded, this function needs to handle preview as well.\r\n  // It will handle the preview similarly to how it handles populateOtherColumn, \r\n  // Except it sets previewData attribute, instead of data attribute.\r\n  toggleOtherNeighbour(e, neighbourIndex, colIndex) {\r\n    // We first get all the variables we needed\r\n    let previewColIndex;\r\n    let tableData = _.cloneDeep(this.state.tableData); \r\n    let otherColChecked = _.cloneDeep(this.state.otherColChecked);\r\n\r\n    // We first deal with the toggling of otherCheckedIndex and otherColChecked\r\n    let otherCheckedIndex = neighbourIndex;\r\n    otherColChecked[neighbourIndex] = !otherColChecked[neighbourIndex];\r\n\r\n    // We then deal with column preview.\r\n\r\n    // First step is to create a selectedNeighbours array for preview, similar to OtherColSelection.\r\n    // We will create the selectedNeighbours array from otherColSelection and otherColChecked\r\n    let selectedNeighbours = [];\r\n    for (let i = 0; i < otherColChecked.length; ++i) {\r\n      if (otherColChecked[i] === true) {\r\n        selectedNeighbours.push(this.state.otherColSelection[i]);\r\n      }\r\n    }\r\n    // console.log(selectedNeighbours);\r\n    // console.log(colIndex);\r\n    \r\n    // If selectedNeighbours is non-empty, we need to set previewColIndex to colIndex, and set tableData's previewData attribute\r\n    if (selectedNeighbours.length > 0) {\r\n      // We first set tableData, based on selectedNeighbours and colIndex. The following part will be similar to populateOtherColumn.\r\n      for (let i = 0; i < tableData.length; ++i) {\r\n        // curColumnArray is the previewData array, for each entry in search column, for all neighbours in selectedNeighbours\r\n        let curColumnArray = [];\r\n        // We loop through selectedNeighbours\r\n        for (let j = 0; j < selectedNeighbours.length; ++j) {\r\n          let curNeighbour = selectedNeighbours[j];\r\n          let firstDegNeighbours = \r\n            curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n          let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n          if (curNeighbourData !== undefined) {\r\n            curColumnArray = curColumnArray.concat(curNeighbourData);\r\n          }\r\n        }\r\n        // If curColumnArray is empty, that means this entry in search column do not have any of the attributes from selectedNeighbours\r\n        // We want to set previewData to N/A\r\n        if (curColumnArray.length === 0) {\r\n          tableData[i][colIndex].previewData = \"N/A\";\r\n        }\r\n        // Else, we have found at least one value. We want to set previewData to curColumnArray[0]\r\n        else {\r\n          tableData[i][colIndex].previewData = curColumnArray[0];\r\n        }\r\n      }\r\n\r\n      // Now that we are done with setting tableData, we set previewColIndex.\r\n      previewColIndex = colIndex;\r\n    }\r\n    // In this case, selectedNeighbours is empty, we want to set previewColIndex back to -1.\r\n    else {\r\n      previewColIndex = -1;\r\n    }\r\n\r\n    // Support for undo:\r\n    let lastAction = \"toggleOtherNeighbour\";\r\n    let prevState = \r\n    {\r\n      otherColChecked: this.state.otherColChecked,\r\n      otherColCheckedIndex: this.state.otherCheckedIndex,\r\n      tableData: this.state.tableData,\r\n      previewColIndex: this.state.previewColIndex,\r\n    }\r\n\r\n    this.setState({\r\n      otherColChecked: otherColChecked,\r\n      otherCheckedIndex: otherCheckedIndex,\r\n      tableData: tableData,\r\n      previewColIndex: previewColIndex,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // This function is a simple function that creates an object and passes to Action Panel\r\n  handlePlusClick() {\r\n    this.setState({\r\n      curActionInfo:{\"task\":\"plusClicked\"},\r\n      tabIndex: 0,\r\n    })\r\n  }\r\n\r\n  // This function handles when users want to add more entities to the first column\r\n  addToFirstCol() {\r\n    // We need to make the Action Panel display FirstColSelection component again.\r\n    // Before doing so, we need to first clear out this.state.firstColChecked, and this.state.keyCheckedIndex\r\n    // So that we do not have information carried over from the previous first column selection.\r\n\r\n    // First we update firstColChecked\r\n    let firstColCheckedUpdated = [];\r\n    for (let i = 0; i < this.state.firstColChecked.length; ++i) {\r\n      firstColCheckedUpdated.push(false);\r\n    }\r\n\r\n    // Then we reset keyCheckedIndex\r\n    let keyCheckedIndexUpdated = -1;\r\n\r\n    // We now set up tempObj for Action Panel\r\n    let tempObj = {\r\n      \"task\":\"afterStartSubject\",\r\n    };\r\n\r\n    // Finallym we set the states.\r\n    this.setState({\r\n      firstColChecked:firstColCheckedUpdated,\r\n      keyCheckedIndex:keyCheckedIndexUpdated,\r\n      curActionInfo:tempObj,\r\n    })\r\n  }\r\n\r\n  // This function handles manually changing cell in a table\r\n\r\n  cellChange(e, i, j) {\r\n    e.preventDefault();\r\n    let tableData = this.state.tableData.slice();\r\n    tableData[i][j].data = e.target.value;\r\n    this.setState({\r\n      tableData: tableData,\r\n    });\r\n  }\r\n\r\n  // This function updates the options for selections when we click on selection for a key column\r\n  // based on cells already filled in this column\r\n\r\n  getKeyOptions(e, colIndex) {\r\n    if (colIndex === this.state.keyColIndex) {\r\n      \r\n      // We first get all the non-empty values from the key column\r\n      let allSubject = [];\r\n      for (let i = 0; i < this.state.tableData.length; ++i) {\r\n        if (this.state.tableData[i][colIndex].data === \"\") {\r\n          break;\r\n        } else {\r\n          allSubject.push(regexReplace(this.state.tableData[i][colIndex].data));\r\n        }\r\n      }\r\n\r\n      // In here we fetch the options for first column's selection\r\n      // It uses the common dct:subject of all cells entered in the key column\r\n\r\n      // Modification: let's also find the common rdf:type dbo:xxx of cells filled.\r\n\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n      for (let i = 0; i < allSubject.length; ++i) {\r\n        queryBody +=\r\n          \"%0D%0A++++++++dbr%3A\" + allSubject[i] + \"+%28dct%3Asubject%7Crdf%3Atype%29+%3Fsomevar.\";\r\n      }\r\n      let suffixURL =\r\n        \"%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchJSON(queryURL));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let myJson = values[0];\r\n        let keyColOptions = [];\r\n        // We loop through the result bindings. \r\n        // If it's from dct:subject, or rdf:type dbo:xxxx, we push it onto keyColOptions\r\n        for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n          let curValue = myJson.results.bindings[i].somevar.value;\r\n          // This clause deals with dct:subject\r\n          if (curValue.includes(\"dbpedia.org/resource/Category:\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(37);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"dct\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n          // This clause deals with rdf:type dbo:xxxx\r\n          else if (curValue.includes(\"dbpedia.org/ontology/\") && !curValue.includes(\"Wikidata\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(28);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"rdf\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n        }\r\n        // Take a look at keyColOptions\r\n        // console.log(keyColOptions);\r\n        // We create a copy of the optionsMap.\r\n        // Then change the entry in the optionsMap corresponding to the key column to what we have just fetched: keyColOptions.\r\n        let optionsMap = this.state.optionsMap.slice();\r\n        optionsMap[this.state.keyColIndex] = keyColOptions;\r\n        this.setState({\r\n          optionsMap: optionsMap,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function updates the options for selections when we want to open selection for non-key column\r\n  // based on cells already filled in this column, and the cells in the key column\r\n  // aka: Michelle Obama is Barack Obama' wife\r\n\r\n  // It needs to update Action Panel to display the correct content.\r\n\r\n  // If this column is empty or completely filled, it will just pass keyColNeighbours to Action Panel.\r\n\r\n  getOtherOptions(e, colIndex) {\r\n\r\n    // console.log(\"Column index clicked is \"+colIndex);\r\n\r\n    // The first thing we need to do is to determine the content for otherColSelection\r\n    let otherColSelection = [];\r\n\r\n    // We check if this column is all-empty, or all filled\r\n    let colEmpty = true;\r\n    let colFilled = true;\r\n    let nonEmptyInfo = [];\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      // If some data is not \"\", that means this column is not empty\r\n      if (this.state.tableData[i][colIndex].data !== \"\") {\r\n        colEmpty = false;\r\n        nonEmptyInfo.push([i, this.state.tableData[i][colIndex].data]);\r\n      }\r\n      // If some data is \"\", that means this column is not filled\r\n      else {\r\n        colFilled = false;\r\n      }\r\n    }\r\n\r\n    // Case 1:\r\n    // If this column is non-empty, and not completely filled, we want to deal with special otherColSelection\r\n    if (colEmpty === false && colFilled === false) {\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL =\r\n        \"%0D%0A%7D%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n      for (let i = 0; i < nonEmptyInfo.length; ++i) {\r\n        let curKeySubject = regexReplace(\r\n          this.state.tableData[nonEmptyInfo[i][0]][this.state.keyColIndex]\r\n            .data\r\n        );\r\n        let curEnteredSubject = regexReplace(nonEmptyInfo[i][1]);\r\n        queryBody +=\r\n          \"%0D%0A++++++++dbr%3A\" +\r\n          curKeySubject +\r\n          \"+%3Fsomevar+dbr%3A\" +\r\n          curEnteredSubject +\r\n          \".\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchJSON(queryURL));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n      let myJson = values[0];\r\n      // we create a temporary variable to hold results from myJson.results.bindings\r\n      let tempSelection = [];\r\n      for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n        let tempObj = {};\r\n        let neighbour = myJson.results.bindings[i].somevar.value.slice(28);\r\n        tempObj[\"label\"] = neighbour;\r\n        tempObj[\"value\"] = neighbour;\r\n        tempObj[\"type\"] = \"subject\"; // for now we only allow the subject search\r\n        tempSelection.push(tempObj);\r\n      }\r\n      // We push onto otherColSelection the right elements from keyColNeighbours, based on tempSelection\r\n      // console.log(this.state.keyColNeighbours);\r\n      // console.log(tempSelection);\r\n      for (let i = 0; i < tempSelection.length; ++i) {\r\n        for (let j = 0; j < this.state.keyColNeighbours.length; ++j) {\r\n          if (tempSelection[i].value === this.state.keyColNeighbours[j].value \r\n              && tempSelection[i].type === this.state.keyColNeighbours[j].type) {\r\n            otherColSelection.push(this.state.keyColNeighbours[j]);\r\n            break; \r\n          }\r\n        }\r\n      }\r\n      // Now, we do not want to have an empty otherColSelection.\r\n      // Thus, if it is, we just want to set it as this.state.keyColNeighbours\r\n      if (otherColSelection.length === 0) {\r\n        otherColSelection = this.state.keyColNeighbours;\r\n      }\r\n      // Take a look at otherColSelection\r\n      // console.log(otherColSelection);\r\n\r\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\r\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\r\n\r\n      let otherColChecked = [];\r\n      for (let i = 0; i < otherColSelection.length; ++i) {\r\n        otherColChecked.push(false);\r\n      }\r\n      let otherCheckedIndex = -1;\r\n\r\n      let tempObj = \r\n        {\r\n          \"task\":\"showOtherColSelection\",\r\n          \"colIndex\":colIndex,\r\n        }\r\n\r\n      this.setState({\r\n        otherColSelection:otherColSelection,\r\n        otherColChecked:otherColChecked,\r\n        otherCheckedIndex:otherCheckedIndex,\r\n        curActionInfo:tempObj,\r\n      })\r\n      })\r\n    }\r\n\r\n    // Case 2:\r\n    // If this column is empty or completely filled, we just set otherColSelection to be keyColNeighbours\r\n    else {\r\n      otherColSelection = this.state.keyColNeighbours;\r\n      // Take a look at otherColSelection\r\n      // console.log(otherColSelection);\r\n\r\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\r\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\r\n\r\n      // Maybe some modifications need to be done here when colFilled === true\r\n      let otherColChecked = [];\r\n      for (let i = 0; i < otherColSelection.length; ++i) {\r\n        otherColChecked.push(false);\r\n      }\r\n      let otherCheckedIndex = -1;\r\n\r\n      let tempObj = \r\n        {\r\n          \"task\":\"showOtherColSelection\",\r\n          \"colIndex\":colIndex,\r\n        }\r\n\r\n      window.scrollTo(0, 0);\r\n      this.setState({\r\n        otherColSelection:otherColSelection,\r\n        otherColChecked:otherColChecked,\r\n        otherCheckedIndex:otherCheckedIndex,\r\n        curActionInfo:tempObj,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function handles the the selection of a column header.\r\n  // Note: we want to deal with the selection of key column header vs non key column header differently\r\n\r\n  selectColHeader(e, colIndex) {\r\n\r\n    let tableHeader = this.state.tableHeader.slice();\r\n\r\n    if (e !== null) {\r\n\r\n      // We first get the selectedOptions\r\n      let selectedOptions = _.cloneDeep(e);\r\n      // console.log(selectedOptions);\r\n      tableHeader[colIndex] = selectedOptions;\r\n\r\n      // This part deals with the selection of a key column header\r\n      if (colIndex === this.state.keyColIndex) {\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"populateKeyColumn\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbourArray\"] = [];\r\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          tempObj.neighbourArray.push(selectedOptions[i]);\r\n        }\r\n        // console.log(tempObj);\r\n        this.setState({\r\n          tableHeader: tableHeader,\r\n          curActionInfo: tempObj,\r\n        })\r\n      }\r\n\r\n      // This part deals with the selection of a non key column header\r\n      else {\r\n        // We want to change the label of non-key column headers with respect to the label of key column\r\n        // First step: set up the label text for the key column\r\n        let keyColLabel = \"\";\r\n        for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\r\n          let labelToAdd = i > 0 ? \"&\" + tableHeader[this.state.keyColIndex][i].label : tableHeader[this.state.keyColIndex][i].label;\r\n          keyColLabel+=labelToAdd;\r\n        }\r\n        // Then, since tableHeader[colIndex] is an array, we update all element's label from the array\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          let ownLabel = tableHeader[colIndex][i].type === \"subject\" ? tableHeader[colIndex][i].value : \"is \" + tableHeader[colIndex][i].value + \" of\";\r\n          tableHeader[colIndex][i].label = ownLabel + \"--\" + keyColLabel;\r\n        }\r\n        // console.log(tableHeader);\r\n\r\n        // Now, we want to ask in ActionPanel whether user wants to populate the column based on the chosen column names\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"populateOtherColumn\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbourArray\"] = [];\r\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          tempObj.neighbourArray.push(selectedOptions[i]);\r\n        }\r\n        // Because we are allowing multi-selects now, type and range are no long two single strings.\r\n        // Rather, their values can be figured out from neighbourArray\r\n        // console.log(tempObj);\r\n        this.setState({\r\n          tableHeader: tableHeader,\r\n          curActionInfo: tempObj,\r\n        })\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // // console.log(\"Check table header here\");\r\n    // // console.log(this.state.tableHeader);\r\n    // //  We first create a copy of the existing table headers\r\n    // let tableHeader = this.state.tableHeader.slice();\r\n\r\n    // // This part deals with the selection of key column header\r\n    // if (colIndex === this.state.keyColIndex) {\r\n    //   // We create a copy of the selected option\r\n    //   if (e !== null) {\r\n    //     let selectedOptions = e.slice();\r\n    //     // console.log(selectedOptions);\r\n    //     tableHeader[colIndex] = selectedOptions;\r\n    //     let tempObj = {};\r\n    //     tempObj[\"task\"] = \"populateKeyColumn\";\r\n    //     tempObj[\"colIndex\"] = colIndex;\r\n    //     tempObj[\"neighbourArray\"] = [];\r\n    //     // Modification here: instead of simplying passing the value, we want to pass the selectedOptions as a whole\r\n    //     // Because we need its \"dataset\" attribute\r\n    //     for (let i = 0; i < selectedOptions.length; ++i) {\r\n    //       tempObj.neighbourArray.push(selectedOptions[i]);\r\n    //     }\r\n    //     // console.log(tempObj);\r\n    //     this.setState({\r\n    //       tableHeader: tableHeader,\r\n    //       curActionInfo: tempObj,\r\n    //     });\r\n    //   }\r\n    // }\r\n    // // This part deals with the selection of non key column header\r\n    // else {\r\n    //   // The first few lines fix some pass by reference problems\r\n    //   let evalue = e.value;\r\n    //   let elabel = e.label;\r\n    //   // let ecount = e.count;\r\n    //   tableHeader[colIndex] = { value: evalue, label: elabel };\r\n    //   // We want to change the label of non-key column headers with respect to the label of key column\r\n    //   // We first create the label text for the key column\r\n    //   let keyColLabel = \"\";\r\n    //   if (this.state.keyColIndex === 0) {\r\n    //     for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\r\n    //       if (i > 0) {\r\n    //         keyColLabel += \"&\";\r\n    //       }\r\n    //       keyColLabel += tableHeader[this.state.keyColIndex][i].label;\r\n    //     }\r\n    //   } else {\r\n    //     keyColLabel = tableHeader[this.state.keyColIndex].label;\r\n    //   }\r\n    //   // Bugfix for Go Table Creation: if at this stage, keyColLable is still \"\", that means we came from the tabel union task first.\r\n    //   // In this case, tableHeader[keyColIndex] is an object, not an array. \r\n    //   // So we just set keyColLabel as tableHeader[this.state.keyColIndex].label\r\n    //   if (keyColLabel === \"\") {\r\n    //     keyColLabel = tableHeader[this.state.keyColIndex].label;\r\n    //   }\r\n    //   // We then append the current column's label to it\r\n    //   // console.log(keyColLabel);\r\n    //   tableHeader[colIndex].label =\r\n    //     tableHeader[colIndex].label + \"--\" + keyColLabel;\r\n    //   // After we have selected the column header, not only do we want to fill in the name of the column, we also want to\r\n    //   // ask in ActionPanel whether user wants to populate the column based on the chosen column name\r\n    //   let tempObj = {};\r\n    //   tempObj[\"task\"] = \"populateOtherColumn\";\r\n    //   tempObj[\"colIndex\"] = colIndex;\r\n    //   tempObj[\"neighbour\"] = e.value;\r\n    //   tempObj[\"type\"] = e.type;\r\n\r\n    //   // If type is subject, let's check if this neighbour also has a \"range\" (rdfs:range)\r\n    //   if (e.type === \"subject\" && e.range !== undefined) {\r\n    //     tempObj[\"range\"] = e.range;\r\n    //   }\r\n    //   // console.log(tempObj);\r\n\r\n    //   this.setState({\r\n    //     tableHeader: tableHeader,\r\n    //     curActionInfo: tempObj,\r\n    //   });\r\n    // }\r\n  }\r\n\r\n  // This function is a helper function for populateKeyColumn. It is similar to getOtherColPromise.\r\n  // It makes an array of queries to find the union of neighbours for the first column (key column).\r\n\r\n  // Some modification needs to be made to the queries\r\n  // So that ?o in the first query and ?s in the second query have to be included as well.\r\n\r\n  // It takes in three parameters\r\n  // 1) tableData: tableData (with updated values in the first column)\r\n  // 2) type: either \"subject\" or \"object\"\r\n  // 3) colIndex:  integer representing which column's neighbours we are fetching\r\n\r\n  getNeighbourPromise(tableData, type, colIndex) {\r\n    // console.log(tableData);\r\n    // console.log(type);\r\n\r\n    // Query we make if type is subject\r\n\r\n    // select ?p ?o ?range ?subPropertyOf\r\n    // where {\r\n    // dbr:Barack_Obama ?p ?o.\r\n    // OPTIONAL {?p rdfs:range ?range}.\r\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\r\n    // }\r\n\r\n    // Query we make if type is object\r\n\r\n    // select ?s ?p ?range ?subPropertyOf\r\n    // where {\r\n    // ?s ?p dbr:Barack_Obama.\r\n    // OPTIONAL {?p rdfs:range ?range}.\r\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\r\n    // }\r\n\r\n    let promiseArray = [];\r\n    let prefixURL =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURL =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      let cellValue = tableData[i][colIndex].data === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(tableData[i][colIndex].data);\r\n      // console.log(cellValue);\r\n      let queryBody;\r\n      if (type === \"subject\") {\r\n        queryBody =\r\n          \"select+%3Fp+%3Fo+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0Adbr%3A\" +\r\n          cellValue +\r\n          \"+%3Fp+%3Fo.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\r\n      }\r\n      else {\r\n        queryBody = \r\n          \"select+%3Fs+%3Fp+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" +\r\n          cellValue +\r\n          \".%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n    return promiseArray;\r\n  }\r\n\r\n  // This function populates the key column\r\n  // It also fetches the neighbours of the key column (based on the first cell in the table)\r\n  // as well as setting the origins of cells in the key column\r\n\r\n  // Note: we need to do some modification here. Instead of having a fixed number of entries in the key column,\r\n  // Let's make it more flexible. (but also pose a limit, so we don't get way too many entries)\r\n\r\n  populateKeyColumn(e, colIndex, neighbourArray) {\r\n    // Let's first take a look at parameters passed in\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n\r\n    // Let's create a helper function to generate the query text.\r\n    let queryURL = keyQueryGen(neighbourArray)\r\n    // console.log(queryURL);\r\n\r\n    // If queryURL is error, we have encountered some previously unseen datatypes. In this case we just print an error.\r\n    if (queryURL === \"ERROR\") {\r\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\")\r\n    }\r\n\r\n    // Else we run the body of the funnction\r\n\r\n    else {\r\n      document.body.classList.add('waiting');\r\n\r\n      let promiseArray = [fetchJSON(queryURL)];\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // let's first work with the first promise result: fill in table data with the entities we have fetched\r\n  \r\n        // console.log(values[0].results.bindings);\r\n\r\n        // We set the tableHeader[0] here, from a deep copy of tableHeader\r\n        // tableHeader[0] should be set as neighbourArray\r\n        let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n        tableHeader[0] = neighbourArray;\r\n\r\n        // Addition: we want to display the first column's header correctly. Let's add support for that\r\n        let firstColHeaderInfo = [];\r\n        firstColHeaderInfo.push(neighbourArray);\r\n  \r\n        // This part sets the data for each cell\r\n        let tableData = _.cloneDeep(this.state.tableData);\r\n  \r\n        if (this.state.tableHeader[0].length === 0) {\r\n          tableData = setFirstColumnData(\r\n            values[0].results.bindings,\r\n            tableData,\r\n            tableHeader,\r\n            colIndex\r\n          )\r\n        }\r\n  \r\n        // console.log(tableData);\r\n  \r\n        // We need to make modification here: find neighbours of a column, instead of neighbours of a cell\r\n        // To do this, we need to use this tableData to ask more queries (number of queires is equal to tableData.length)\r\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\r\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\r\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n          // We call updateNeighbourInfo here because we are changing the rows\r\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n  \r\n          // Support for undo: \r\n          // Let's save the previous state in an object\r\n          let lastAction = \"populateKeyColumn\";\r\n          let prevState = \r\n            {\r\n              \"keyColIndex\":this.state.keyColIndex,\r\n              \"keyColNeighbours\":this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n              \"curActionInfo\":this.state.curActionInfo,\r\n              \"tableData\":this.state.tableData,\r\n              \"tableHeader\":this.state.tableHeader,\r\n              \"firstColFilled\":this.state.firstColFilled,\r\n              \"firstColHeaderInfo\":this.state.firstColHeaderInfo,\r\n            };\r\n\r\n          document.body.classList.remove('waiting');\r\n  \r\n          this.setState({\r\n            keyColIndex: colIndex,\r\n            keyColNeighbours: keyColNeighbours,\r\n            firstDegNeighbours: firstDegNeighbours,\r\n            curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n            tableData: tableData,\r\n            tableHeader: tableHeader,\r\n            firstColFilled: true,\r\n            firstColHeaderInfo: firstColHeaderInfo,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n          });\r\n        })\r\n        })\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function adds more entities to the first column.\r\n  // It should be similar to populateKeyColumn, with some differences\r\n\r\n  confirmAddFirstCol(e, neighbourArray) {\r\n    // console.log(neighbourArray);\r\n    let queryURL = keyQueryGen(neighbourArray);\r\n\r\n    // Let's first make sure that the neighbourArray do not contain attributes of unknown datatypes.\r\n    if (queryURL === \"ERROR\") {\r\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\");\r\n    }\r\n\r\n    else {\r\n      document.body.classList.add(\"waiting\");\r\n\r\n      let promiseArray = [fetchJSON(queryURL)];\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // console.log(values[0].results.bindings);\r\n        // Now we append the new query results to tableData\r\n        let numNewRows = Math.min(values[0].results.bindings.length, initialRowNum);\r\n        let tableData = [];\r\n        // We first push on numNewRows number of rows, while setting up data and origin\r\n        for (let i = 0; i < numNewRows; ++i) {\r\n          let tempRow = [];\r\n          for (let j = 0; j < this.state.tableHeader.length; ++j) {\r\n            if (j === 0) {\r\n              tempRow.push({\r\n                data: values[0].results.bindings[i].somevar.value.slice(28),\r\n                origin: [values[0].results.bindings[i].somevar.value.slice(28)]\r\n              })\r\n            }\r\n            else {\r\n              tempRow.push({ data: \"\", origin: []});\r\n            }\r\n          }\r\n          tableData.push(tempRow);\r\n        }\r\n        // We concat this.state.tableData and tableData together, and dedup by first column's data\r\n        tableData = _.cloneDeep(this.state.tableData).concat(tableData);\r\n        tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\r\n        // console.log(tableData);\r\n\r\n        // Now, we move on to update firstDegNeighbours and keyColNeighbours\r\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", 0);\r\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", 0);\r\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n  \r\n          // We call updateNeighbourInfo here because we are changing the rows\r\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n          document.body.classList.remove('waiting');\r\n\r\n          let firstColHeaderInfo = _.cloneDeep(this.state.firstColHeaderInfo);\r\n          firstColHeaderInfo.push(neighbourArray);\r\n\r\n          // Support for undo\r\n          let lastAction = \"confirmAddFirstCol\";\r\n          let prevState = \r\n            {\r\n              \"tableData\": this.state.tableData,\r\n              \"keyColNeighbours\": this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n              \"firstColHeaderInfo\": this.state.firstColHeaderInfo,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n            }\r\n  \r\n          this.setState({\r\n            tableData: tableData,\r\n            keyColNeighbours: keyColNeighbours,\r\n            firstDegNeighbours: firstDegNeighbours,\r\n            firstColHeaderInfo: firstColHeaderInfo,\r\n            curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n            previewColIndex: -1,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n          });\r\n        })\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  // // TEST FUNCTION----------------------------------------------------\r\n\r\n  // getOtherColPromiseTwo(neighbour, type) {\r\n  //   let promiseArray = [];\r\n  //   // The following is the query we will make\r\n\r\n  //   // SELECT ?key ?val\r\n  //   // WHERE{\r\n  //   //       ?key (dbo:spouse|dbp:spouse) ?val.\r\n  //   //       VALUES ?key {dbr:Barack_Obama dbr:Ronald_Reagan dbr:Donald_Trump }\r\n  //   // }\r\n\r\n\r\n  //   let prefixURL = \r\n  //     \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  //   let suffixURL = \r\n  //     \"%7D%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=300000&debug=on&run=+Run+Query+\";\r\n  //   let queryBody;\r\n  //   // This clause handles the case of \"Obama -> property -> object\"\r\n  //   if (type === \"subject\") {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fkey+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fval.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   } \r\n  //   // This clause handles the case of \"subject -> property -> Obama\"\r\n  //   else {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fval+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fkey.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   }\r\n  //   for (let i = 0; i < this.state.tableData.length; ++i) {\r\n  //     let cellValue = regexReplace(\r\n  //       this.state.tableData[i][this.state.keyColIndex].data\r\n  //     );\r\n  //     // N/A's will block the search, let's replace it with some string that does not block the search\r\n  //     if (cellValue === \"N/A\") {\r\n  //       cellValue = \"NONEXISTINGSTRING\";\r\n  //     }\r\n  //     let curQueryText = \"dbr%3A\"+cellValue+\"+\";\r\n  //     queryBody+=curQueryText;\r\n  //   }\r\n  //   let queryURL = prefixURL + queryBody + suffixURL;\r\n  //   // console.log(queryURL);\r\n  //   promiseArray.push(fetchJSON(queryURL));\r\n  //   return promiseArray;\r\n  // }\r\n\r\n  // The following function serves as a helper function for \"populateOtherColumn\" and \"populateSameNeighbour\"\r\n  // It makes an array of queries, which may affect the performance of our system. Let's change it now.\r\n\r\n  getOtherColPromise(neighbour, type) {\r\n    let promiseArray = [];\r\n    let prefixURL =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURL =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      let cellValue = regexReplace(\r\n        this.state.tableData[i][this.state.keyColIndex].data\r\n      );\r\n      // N/A's will block the search, let's replace it with some string that does not block the search\r\n      if (cellValue === \"N/A\") {\r\n        cellValue = \"NONEXISTINGSTRING\";\r\n      }\r\n      let queryBody;\r\n      if (type === \"subject\") {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\" +\r\n          cellValue +\r\n          \"+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+%3Fsomevar.%0D%0A%7D%0D%0A%0D%0A&\";\r\n      } else {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A++++++++%3Fsomevar+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+dbr%3A\" +\r\n          cellValue +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n    return promiseArray;\r\n  }\r\n\r\n  // document.body.classList.add('waiting');\r\n\r\n  // console.log(neighbourIndex);\r\n\r\n  // Support for \"populateSameRange\":\r\n\r\n  // When the range is not equal to undefined, we want to ask user if they want to populate all other attributes from this range\r\n  // console.log(range);\r\n\r\n  // we need to make a number of queries in the form of: dbr:somekeycolumnentry dbp:neighbour|dbo:neighbour somevar\r\n  // let promiseArrayTwo = this.getOtherColPromiseTwo(neighbour, type); // this is for testing\r\n  // let promiseArray = this.getOtherColPromise(neighbour, type);\r\n\r\n  // allPromiseReady(promiseArray).then((values) => {\r\n  // // allPromiseReady(promiseArrayTwo).then((testValues) => {\r\n\r\n  // //   // Let's compare the different values we get from getOtherColPromise and getOtherColPromiseTwo\r\n  // //   console.log(values);\r\n  // //   console.log(testValues);\r\n\r\n  // //   // Now we need to process the testValues\r\n\r\n  // //   let pairArray = [];\r\n\r\n  // //   // First we removed the prefixes from resultArray\r\n  // //   for (let i=0; i<testValues[0].results.bindings.length; ++i) {\r\n  // //     pairArray.push(\r\n  // //       {\r\n  // //         \"key\":removePrefix(testValues[0].results.bindings[i].key.value),\r\n  // //         \"value\":removePrefix(testValues[0].results.bindings[i].val.value)\r\n  // //       }\r\n  // //     )\r\n  // //   }\r\n  // //   console.log(pairArray);\r\n\r\n  // //   // Then we create a keyArray\r\n  // //   let keyArray = [];\r\n\r\n  // //   for (let i=0; i<this.state.tableData.length; ++i) {\r\n  // //     keyArray.push(this.state.tableData[i][this.state.keyColIndex].data);\r\n  // //   }\r\n  // //   console.log(keyArray);\r\n  populateOtherColumn(e, colIndex, neighbourArray) {\r\n\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // We use a boolean to keep track of if any cell contains multiple values\r\n    let hasMultiple = false;\r\n\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\r\n      let curColumnArray = [];\r\n      // We loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours = \r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        // console.log(firstDegNeighbours);\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        tableData[i][colIndex].data = \"N/A\";\r\n      }\r\n      // Otherwise, we have found at least one value.\r\n      else {\r\n        // we first set the data for the cell using curColumnArray[0]\r\n        tableData[i][colIndex].data = curColumnArray[0];\r\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n        // console.log(keyOrigin)\r\n\r\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\r\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\r\n        if (curColumnArray.length > 1) {\r\n          hasMultiple = true;\r\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\r\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\r\n        } \r\n      }\r\n    }\r\n    // Now, we are done with updating tableData.\r\n    // We want to update tableHeader as well.\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n    tableHeader[colIndex] = neighbourArray;\r\n\r\n    // We start setting up the content for the Action Panel.\r\n\r\n    let recommendArray = createRecommendArray(neighbourArray);\r\n    // console.log(recommendArray);\r\n\r\n    // tempObj stores the information passed to ActionPanel\r\n    let tempObj = {};\r\n\r\n    // Case 1: hasMultiple is true, and there are recommendations\r\n    if (hasMultiple === true && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"sameNeighbourAndRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    // Case 2: only hasMultiple is true\r\n    else if (hasMultiple === true) {\r\n      tempObj[\"task\"] = \"populateSameNeighbour\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n    }\r\n    // Case 3: only hasRecommendation is true\r\n    else if (recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray; \r\n    }\r\n    // Case 4: neither hasMultiple or hasRecommendation is true. In which case we just tell users that they can fill more columns.\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for undo: \r\n    // Let's save the previous state in an object\r\n    let lastAction = \"populateOtherColumn\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n        \"tableHeader\":this.state.tableHeader,\r\n        \"previewColIndex\":this.state.previewColIndex,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      previewColIndex: -1,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n\r\n\r\n    // let tableData = _.cloneDeep(this.state.tableData);\r\n    // let firstDegNeighbours = type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n    // let longestDataArray = [];\r\n    // for (let i = 0; i < tableData.length; ++i) {\r\n    //   let dataArray = firstDegNeighbours[i][neighbour];\r\n    //   // console.log(dataArray);\r\n    //   // If dataArray is empty, this current entry in search column does not have this neighbour at all.\r\n    //   if (dataArray === undefined) {\r\n    //     tableData[i][colIndex].data = \"N/A\";\r\n    //   } \r\n    //   // Otherwise, we have found at least one value. Let's use dataArray[0]\r\n    //   else {\r\n    //     // we first set data for the cell\r\n    //     tableData[i][colIndex].data = dataArray[0];\r\n    //     // we then set origin for the cell. The origin depends on whether type is \"subject\" or \"object\"\r\n    //     let originToAdd = type === \"subject\" ? neighbour + \":\" + dataArray[0] : \"is \" + neighbour + \" of:\" + dataArray[0];\r\n    //     let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n    //     keyOrigin.push(originToAdd);\r\n    //     tableData[i][colIndex].origin = keyOrigin;\r\n    //     // If dataArray's length is longer than longestDataArray's length, we want to update it\r\n    //     if (dataArray.length > longestDataArray.length) {\r\n    //       longestDataArray = dataArray;\r\n    //     }\r\n    //   }\r\n    // }\r\n    // // console.log(longestDataArray);\r\n    // let maxCount = Math.min(longestDataArray.length, maxNeighbourCount);\r\n    // let remainNeighbourCount = maxCount - 1;\r\n\r\n    // console.log(remainNeighbourCount);\r\n    \r\n    // // Now we set up the content for ActionPanel\r\n    // let tempObj = {};\r\n\r\n    // // In this case, we give users option to populate duplicate neighbours\r\n    // if (remainNeighbourCount > 0) {\r\n    //   tempObj[\"task\"] = \"populateSameNeighbour\";\r\n    //   tempObj[\"colIndex\"] = colIndex;\r\n    //   tempObj[\"neighbour\"] = neighbour;\r\n    //   tempObj[\"type\"] = type;\r\n    //   tempObj[\"numCols\"] = remainNeighbourCount;\r\n    //   if (range !== undefined) {\r\n    //     tempObj[\"range\"] = range;\r\n    //   }\r\n    // }\r\n    // // In this case, users are not populating column with duplicate names, but it has a range.\r\n    // // We may need to ask user if they want to populate other columns from the same range\r\n    // else if (range !== undefined) {\r\n    //   let siblingNeighbour = [];\r\n    //   // console.log(\"Range is \"+range);\r\n    //   // console.log(this.state.keyColNeighbours);\r\n    //   for (let i = 0; i < this.state.keyColNeighbours.length; ++i) {\r\n    //     if (\r\n    //       this.state.keyColNeighbours[i].range === range &&\r\n    //       this.state.keyColNeighbours[i].value !== neighbour\r\n    //     ) {\r\n    //       siblingNeighbour.push(this.state.keyColNeighbours[i]);\r\n    //     }\r\n    //   }\r\n    //   // If we have found columns from the same range (other than the current neighbour),\r\n    //   console.log(siblingNeighbour);\r\n    //   // If sibling neighbour is non-empty, we give user the option to populate other columns from the same range.\r\n    //   if (siblingNeighbour.length > 0) {\r\n    //     // Let's do some string processing to improve UI clarity\r\n    //     let rangeLiteral = \"\";\r\n    //     if (range.includes(\"http://dbpedia.org/ontology/\")) {\r\n    //       rangeLiteral = range.slice(28);\r\n    //     } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\r\n    //       rangeLiteral = range.slice(33);\r\n    //     } else {\r\n    //       rangeLiteral = range;\r\n    //     }\r\n    //     tempObj[\"task\"] = \"populateSameRange\";\r\n    //     tempObj[\"colIndex\"] = colIndex;\r\n    //     tempObj[\"range\"] = rangeLiteral;\r\n    //     // console.log(siblingNeighbour);\r\n    //     tempObj[\"siblingNeighbour\"] = siblingNeighbour;\r\n    //   }\r\n    //   // Else, if we have NOT found anything from the same range, we tell user that they can populate more columns\r\n    //   else {\r\n    //     tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    //   }\r\n    // }\r\n    // // In this case, we tell users that they can populate more columns\r\n    // else {\r\n    //   tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    // }\r\n    // // Support for undo: \r\n    // // Let's save the previous state in an object\r\n    // let lastAction = \"populateOtherColumn\";\r\n    // let prevState = \r\n    //   {\r\n    //     \"curActionInfo\":this.state.curActionInfo,\r\n    //     \"tableData\":this.state.tableData,\r\n    //   };\r\n\r\n    // this.setState({\r\n    //   curActionInfo: tempObj,\r\n    //   tableData: tableData,\r\n    //   lastAction: lastAction,\r\n    //   prevState: prevState,\r\n    // });\r\n  }\r\n\r\n  // This function is a helper function that takes in 9 parameters:\r\n  // Note: this function does not make any fetch requests, thus does NOT involve promises.\r\n\r\n  // 1) colIndex:          index of the column that we just filled (ex. 1, if we just filled in column 1)\r\n  // 2) neighbourArray:    an array of neighbour objects (two important attributes: value, type)\r\n  // 3) numCols:           number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\r\n  \r\n  // 4) keyColIndex:                 original key column index\r\n  // 5) tableHeader:                 original tableHeader\r\n  // 6) tableData:                   original tableData\r\n  // 7) optionsMap:                  original optionsMap\r\n  // 8) selectedClassAnnotation:     original selectedClassAnnotation\r\n\r\n  // 9) fillRecommendation:              When true, decrement requiredLength in code by 1.\r\n\r\n  // and returns an object with 5 values:\r\n  // 1) tableHeader:                tableHeader after modification\r\n  // 2) tableData:                  tableData after modification\r\n  // 3) optionsMap:                 optionsMap after modification\r\n  // 4) selectedClassAnnotation:    selectedClassAnnotation after modification\r\n  // 5) keyColIndex:                keyColIndex after modification\r\n\r\n  addAllNeighbour(\r\n    colIndex,\r\n    neighbourArray,\r\n    numCols,\r\n    keyColIndex,\r\n    tableHeader,\r\n    tableData,\r\n    optionsMap,\r\n    selectedClassAnnotation,\r\n    fillRecommendation\r\n  ) {\r\n    // Let's first check if all the variables are as expected\r\n\r\n    // console.log(\"Column index is: \"+colIndex);\r\n    // console.log(\"NeighbourArray is: \");\r\n    // console.log(neighbourArray);\r\n    // console.log(\"Number of columns to fill is: \"+numCols);\r\n    // console.log(\"Key column index \"+keyColIndex);\r\n    // console.log(\"Table header is: \");\r\n    // console.log(tableHeader);\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Options map is: \");\r\n    // console.log(optionsMap);\r\n    // console.log(\"selected class annotation is \");\r\n    // console.log(selectedClassAnnotation);\r\n    // console.log(\"End of attributes check\\n\\n\\n\\n\");\r\n\r\n    // First thing should be to insert \"numCols\" number of empty columns right after column with index \"colIndex\"\r\n    const rowNum = tableData.length;\r\n    const colNum = tableData[0].length;\r\n\r\n    // Let's check if we need to modify keyColIndex:\r\n    // if colIndex < keyColIndex, we need to increase keyColIndex by numCols\r\n    let keyColIndexUpdated = keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      keyColIndexUpdated+=numCols;\r\n    }\r\n    // console.log(\"Updated key column index is \"+keyColIndexUpdated);\r\n\r\n    // We first take care of table data's (empty) additions\r\n    let tableDataUpdated = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(tableData[i][j]);\r\n      }\r\n      // we add in numCols number of empty columns\r\n      for (let j = 0; j < numCols; ++j) {\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(tableData[i][k]);\r\n      }\r\n      tableDataUpdated.push(tempRow);\r\n    }\r\n    // console.log(\"Updated table data is \");\r\n    // console.log(tableDataUpdated);\r\n\r\n    // we now take care of table header's addition.\r\n    let tableHeaderUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeaderUpdated.push(tableHeader[j]);\r\n    }\r\n    // Now we decide what the newly pushed tableHeader should look like\r\n    let newTableHeader;\r\n    // If we are not populating new suggestions, we simply use tableHeader[colIndex]\r\n    if (fillRecommendation === false) {\r\n      newTableHeader = tableHeader[colIndex];\r\n    }\r\n    // else, it is an length one array of object. Object has 2 properties: value and label\r\n    else {\r\n      // We need to figure out what this label is\r\n      let keyColLabel = \"\";\r\n      for (let i = 0; i < tableHeader[keyColIndex].length; ++i) {\r\n        let labelToAdd = i > 0 ? \"&\" + tableHeader[keyColIndex][i].label : tableHeader[keyColIndex][i].label;\r\n        keyColLabel+=labelToAdd;\r\n      }\r\n      let ownLabel = neighbourArray[0].type === \"subject\" ? neighbourArray[0].value : \"is \" + neighbourArray[0].value + \" of\";\r\n      newTableHeader = [\r\n        {\r\n          \"value\" : neighbourArray[0].value,\r\n          \"label\" : ownLabel + \"--\" + keyColLabel,\r\n          \"type\"  : neighbourArray[0].type,\r\n        }\r\n      ]\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      tableHeaderUpdated.push(newTableHeader);\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeaderUpdated.push(tableHeader[k]);\r\n    }\r\n    // console.log(\"Updated table header is \");\r\n    // console.log(tableHeaderUpdated);\r\n\r\n    // We now take care of selectedClassAnnotation. For now, we just add some empty arrays to it\r\n    let selectedClassAnnotationUpdated = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      selectedClassAnnotationUpdated.push([]);\r\n    }\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[k]);\r\n    }\r\n    // console.log(\"Updated class annotation is \");\r\n    // console.log(selectedClassAnnotationUpdated);\r\n\r\n    // we now take care of optionMap's addition. We just need to add some empty arrays to it\r\n    let optionsMapUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      optionsMapUpdated.push(optionsMap[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      optionsMapUpdated.push([]);\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      optionsMapUpdated.push(optionsMap[k]);\r\n    }\r\n    // console.log(\"Updated options map is \");\r\n    // console.log(optionsMapUpdated);\r\n\r\n    // Finally, we fill in the actual data for tableData. We need to take care of both data and origin\r\n\r\n    // Outer loop loops over all rows in the table\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray corresponds to the dataArray for each entry from the search column\r\n      let curColumnArray = [];\r\n      // we loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours =\r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // console.log(curColumnArray);\r\n      for (let curCol = colIndex + 1; curCol < colIndex + 1 + numCols; ++curCol) {\r\n        // Starting value for requiredLength is 2\r\n        let requiredLength = fillRecommendation === true ? curCol - colIndex : curCol - colIndex + 1;\r\n        // If curColumnArray's length does not meet the required length, we simply set data to N/A\r\n        if (curColumnArray.length < requiredLength) {\r\n          tableDataUpdated[i][curCol].data = \"N/A\";\r\n        }\r\n        else {\r\n          // We first set the data of the cell\r\n          let value = curColumnArray[requiredLength - 1];\r\n          tableDataUpdated[i][curCol].data = value;\r\n          // We then set the origin of the cell\r\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + value;\r\n          let keyOrigin = tableDataUpdated[i][keyColIndexUpdated].origin.slice();\r\n          keyOrigin.push(originToAdd);\r\n          tableDataUpdated[i][curCol].origin = keyOrigin;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      tableHeader: tableHeaderUpdated,\r\n      tableData: tableDataUpdated,\r\n      optionsMap: optionsMapUpdated,\r\n      selectedClassAnnotation: selectedClassAnnotationUpdated,\r\n      keyColIndex: keyColIndexUpdated,\r\n    };\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in different rows, if that neighbour has multiple occurences.\r\n  // It should modify both tableData and firstDegNeighbours, but not keyColNeighbours.\r\n  // This is because we are not removing, or adding anything new, to the search column.\r\n\r\n  sameNeighbourDiffRow(e,colIndex,neighbourArray) {\r\n\r\n    // First we take a look at the parameters passed in\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n    // console.log(this.state.tableData);\r\n\r\n    let tableDataUpdated = [];\r\n    let subjectNeighbours = [];\r\n    let objectNeighbours = [];\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    let firstDegNeighbours = _.cloneDeep(this.state.firstDegNeighbours);\r\n\r\n    // The first loop deals with tableData's additions \r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We first create a deep copy of the current row\r\n      let curRow = _.cloneDeep(tableData[i]);\r\n      // If the current cell in the selected column does NOT have dataArray attribute, we push it onto tableData as it is\r\n      if (curRow[colIndex].dataArray === undefined) {\r\n        tableDataUpdated.push(curRow);\r\n      }\r\n      // Else, we have to push on dataArray.length number of new rows onto tableData.\r\n      // We need to take care of the new cell's data, origin, and dataArray\r\n      else {\r\n        // First, we still need to push on curRow\r\n        tableDataUpdated.push(curRow);\r\n        // Then, we deal with rows that are not in the original table\r\n        for (let j = 0; j < curRow[colIndex].dataArray.length; ++j) {\r\n          let rowToAdd = _.cloneDeep(curRow);\r\n          // We set data\r\n          rowToAdd[colIndex].data = curRow[colIndex].dataArray[j];\r\n          // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + curRow[colIndex].dataArray[j];\r\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n          keyOrigin.push(originToAdd);\r\n          rowToAdd[colIndex].origin = keyOrigin;\r\n          // Lastly, we remove the dataArray attribute from rowToAdd\r\n          delete rowToAdd[colIndex].dataArray;\r\n          tableDataUpdated.push(rowToAdd);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The second loop deals with firstDegNeighbours's additions\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We first create a deep copy of the current row\r\n      let curRow = _.cloneDeep(tableData[i]);\r\n      // If the current cell in the selected column does NOT have dataArray attribute\r\n      // We push onto subjectNeighbours and objectNeighbours once\r\n      if (curRow[colIndex].dataArray === undefined) {\r\n        subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\r\n        objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\r\n      }\r\n      // Else, we have to push onto subject/objectNeighbours 1 + dataArray.length times.\r\n      else {\r\n        for (let j = 0; j < 1 + curRow[colIndex].dataArray.length; ++j) {\r\n          subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\r\n          objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\r\n        }\r\n      }\r\n    }\r\n    let firstDegNeighboursUpdated = \r\n      {\r\n        \"subject\":subjectNeighbours,\r\n        \"object\":objectNeighbours,\r\n      }\r\n    // We take a look at updated tableData and firstDegNeighbours\r\n    // console.log(tableDataUpdated);\r\n    // console.log(firstDegNeighboursUpdated);\r\n\r\n    // Now we set up the obj for Action Panel\r\n    let tempObj = {};\r\n    let recommendArray = createRecommendArray(neighbourArray);\r\n    if (recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray; \r\n    }\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for undo: \r\n    // Let's save the previous state in an object\r\n    let lastAction = \"sameNeighbourDiffRow\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n        \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableDataUpdated,\r\n      firstDegNeighbours: firstDegNeighboursUpdated,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in the same columns, if that neighbour has multiple occurences.\r\n\r\n  sameNeighbourOneRow(e, colIndex, neighbourArray) {\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n    // console.log(numCols);\r\n\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // Outer loop loops over all rows in the table\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray corresponds to the dataArray for each entry from the search column\r\n      let curColumnArray = [];\r\n      // we loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        // console.log(curNeighbour.value);\r\n        let firstDegNeighbours =\r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(firstDegNeighbours);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          // console.log(curNeighbourData);\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // console.log(curColumnArray);\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        tableData[i][colIndex].data = \"N/A\";\r\n      }\r\n      // Otherwise, we have found at least one value. And we want to set up the data and origin. \r\n      else {\r\n        // we first set the data for the cell using all values from curColumnArray (this is different from populateOtherColumn)\r\n        let curData = \"\";\r\n        for (let k = 0; k < curColumnArray.length; ++k) {\r\n          let dataToAdd = k > 0 ? \";\" + curColumnArray[k] : curColumnArray[k];\r\n          curData+=dataToAdd;\r\n          // console.log(\"Data to add is \"+dataToAdd);\r\n          // console.log(\"Current data is \"+curData);\r\n        }\r\n        tableData[i][colIndex].data = curData;\r\n        // we then set the origin for the cell\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n    }\r\n\r\n    // Now we set up the obj for Action Panel\r\n    let tempObj = {};\r\n    let recommendArray = createRecommendArray(neighbourArray);\r\n    if (recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray; \r\n    }\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for undo: \r\n    let lastAction = \"sameNeighbourOneRow\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following function populates one recommendation neighbour\r\n  populateRecommendation(e, colIndex, neighbourArray) {\r\n    console.log(colIndex);\r\n    console.log(neighbourArray);\r\n    let numCols = 0;\r\n    // We need to figure out what numCols should be, based on firstDegNeighbours\r\n    let firstDegNeighbours = neighbourArray[0].type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n    for (let i = 0; i < firstDegNeighbours.length; ++i) {\r\n      let neighbourData = firstDegNeighbours[i][neighbourArray[0].value];\r\n      if (neighbourData !== undefined && neighbourData.length > numCols) {\r\n        numCols = neighbourData.length;\r\n      }\r\n    }\r\n    // console.log(numCols);\r\n    // At this stage, we have gathered all the parameters needed for addAllNeighbours\r\n    let newState = this.addAllNeighbour(colIndex,\r\n                                        neighbourArray,\r\n                                        numCols,\r\n                                        this.state.keyColIndex,\r\n                                        this.state.tableHeader,\r\n                                        this.state.tableData,\r\n                                        this.state.optionsMap,\r\n                                        this.state.selectedClassAnnotation,\r\n                                        true);\r\n    // console.log(newState);\r\n\r\n    let curActionInfo = _.cloneDeep(this.state.curActionInfo);\r\n    curActionInfo[\"colIndex\"]+=numCols;\r\n\r\n    // Support for undo:\r\n    let lastAction = \"populateRecommendation\";\r\n    let prevState = \r\n      {\r\n        \"tableData\":this.state.tableData,\r\n        \"tableHeader\":this.state.tableHeader,\r\n        \"optionsMap\":this.state.optionsMap,\r\n        \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\r\n        \"keyColIndex\":this.state.keyColIndex,\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n      };\r\n    this.setState({\r\n      tableData:newState.tableData,\r\n      tableHeader:newState.tableHeader,\r\n      optionsMap:newState.optionsMap,\r\n      selectedClassAnnotation:newState.selectedClassAnnotation,\r\n      keyColIndex:newState.keyColIndex,\r\n      curActionInfo:curActionInfo,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // The following function adds a new column to the table, to the right of the selected column.\r\n  // In here, let's also set tabIndex to 0.\r\n\r\n  contextAddColumn(e, colIndex) {\r\n    const rowNum = this.state.tableData.length;\r\n    const colNum = this.state.tableData[0].length;\r\n\r\n    // we first take care of table data's addition\r\n    let tableData = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(this.state.tableData[i][j]);\r\n      }\r\n      // we add in one column of empty data\r\n      tempRow.push({ data: \"\", origin: [] });\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(this.state.tableData[i][k]);\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n\r\n    // we now take care of tabler header, optionMap, and selectedClassAnnotation's addition\r\n    // This added column will have options equal to the neighbours of the key column\r\n    let optionsMap = [];\r\n    let tableHeader = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      optionsMap.push(this.state.optionsMap[j]);\r\n      tableHeader.push(this.state.tableHeader[j]);\r\n    }\r\n    optionsMap.push(this.state.keyColNeighbours);\r\n    tableHeader.push(\"\");\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      optionsMap.push(this.state.optionsMap[k]);\r\n      tableHeader.push(this.state.tableHeader[k]);\r\n    }\r\n\r\n    // we now take care of selectedClassAnnotation\r\n    let selectedClassAnnotation = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\r\n    }\r\n    selectedClassAnnotation.push([]);\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\r\n    }\r\n\r\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\r\n    let keyColIndex = this.state.keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      ++keyColIndex;\r\n    }\r\n\r\n    // console.log(this.state.selectedClassAnnotation);\r\n    // console.log(tableHeader);\r\n\r\n    // Support for undo: \r\n    let lastAction = \"contextAddColumn\";\r\n    let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"tableHeader\": this.state.tableHeader,\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n          \"keyColIndex\": this.state.keyColIndex,\r\n          \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n          \"tabIndex\": this.state.tabIndex,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n      keyColIndex: keyColIndex,\r\n      selectedClassAnnotation: selectedClassAnnotation,\r\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n      previewColIndex: -1, // we want to set the preview column index to -1\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n  \r\n  // The following function handles the deletion of a selected column.\r\n  // This function should be largely similar to contextAddColumn\r\n\r\n  contextDeleteColumn(e, colIndex) {\r\n    // console.log(\"This is the column we are trying to delete \"+colIndex);\r\n\r\n    // We disable the deletion of the search column\r\n    if (colIndex === this.state.keyColIndex) {\r\n      alert(\"The current column is the search column.\\n\\nPlease set another search column before deleting the current column.\");\r\n    }\r\n\r\n    // We also disable the deletion of the first column\r\n    else if (colIndex === 0) {\r\n      alert(\"Deleting the first column causes unexpected behavior.\\n\\nPlease do not delete the first column.\");\r\n    }\r\n\r\n    // Else, we can proceed to deletion.\r\n    else {\r\n      // We handle tableData, tableHeader, optionsMap, and selectedClassAnnotation's deletion\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      let tableHeader = this.state.tableHeader.slice();\r\n      let optionsMap = this.state.optionsMap.slice();\r\n      let selectedClassAnnotation = this.state.selectedClassAnnotation.slice();\r\n\r\n      // tableData\r\n      for (let i = 0; i < tableData.length; ++i) {\r\n        tableData[i].splice(colIndex, 1);\r\n      }\r\n      // tableHeader, optionsMap, and selectedClassAnnotation\r\n      tableHeader.splice(colIndex, 1);\r\n      optionsMap.splice(colIndex, 1);\r\n      if (colIndex > 0) {\r\n        selectedClassAnnotation.splice(colIndex-1, 1);\r\n      }\r\n      // If colIndex is less than keyColIndex, we need to decrease keyColIndex by 1, if keyColIndex > 0\r\n      let keyColIndex = this.state.keyColIndex;\r\n      if (colIndex < keyColIndex) {\r\n        --keyColIndex;\r\n      }\r\n\r\n      // When we are deleting a column, we do not necessarily want to go to tab 0.\r\n      // However, if we are in tab 1, we want to toggle off all property neighbours\r\n      let propertyNeighbours = _.cloneDeep(this.state.propertyNeighbours);\r\n      if (this.state.tabIndex === 1) {\r\n        for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n          propertyNeighbours[i].isOpen = false;\r\n        }\r\n      }\r\n\r\n      // Support for undo: \r\n      let lastAction = \"contextDeleteColumn\";\r\n      let prevState = \r\n          {\r\n            \"tableData\": this.state.tableData,\r\n            \"tableHeader\": this.state.tableHeader,\r\n            \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n            \"keyColIndex\": this.state.keyColIndex,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n            \"propertyNeighbours\": this.state.propertyNeighbours,\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n          };\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        tableHeader: tableHeader,\r\n        selectedClassAnnotation: selectedClassAnnotation,\r\n        keyColIndex: keyColIndex,\r\n        previewColIndex: -1, // we want to set the preview column index to -1\r\n        propertyNeighbours: propertyNeighbours,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the sorting of a column from context menu.\r\n  // It is a prototype. Needs to be refined in the future.\r\n\r\n  contextSortColumn(e, colIndex, order) {\r\n    // console.log(\"The column we are sorting is \"+colIndex);\r\n    document.body.classList.add('waiting');\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // We first loop through this column to determine if it's a numeric column or a string column\r\n    let numericCol = true;\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We only care about entries that are not N/A\r\n      if (tableData[i][colIndex].data !== \"N/A\") {\r\n        if (isNaN(Number(tableData[i][colIndex].data))) {\r\n          numericCol = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // In this case we are sorting a numerical column\r\n    if (numericCol) {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return Number(aValue) - Number(bValue);\r\n          }\r\n          else {\r\n            return Number(bValue) - Number(aValue);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // In this case we are sorting a string-based column\r\n    else {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return aValue < bValue ? -1 : 1;\r\n          }\r\n          else {\r\n            return aValue < bValue ? 1 : -1;\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n\r\n    // We need a bugfix here: since tableData is reordered, firstColSelection now do not have the correct data anymore.\r\n    // We have to update firstColSelection to include the correct data.\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo: \r\n      let lastAction = \"contextSortColumn\";\r\n      let prevState = \r\n          {\r\n            \"tableData\": this.state.tableData,\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n            \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function dedups the selected column.\r\n  // Note: this function has to make modifications to both firstDegNeighbours and keyColNeighbours\r\n\r\n  contextDedupColumn(e, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(colIndex);\r\n    // console.log(tableData);\r\n\r\n    // We simply dedup this column by calling the uniqBy function from the lodash library\r\n    tableData = _.uniqBy(tableData, function(x) {return x[colIndex].data;});\r\n    // console.log(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Now we deal with firstDegNeighbours and keyColNeighbours' updates\r\n    // Since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo:\r\n      let lastAction = \"contextDedupColumn\";\r\n      let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"keyColNeighbours\": this.state.keyColNeighbours,\r\n          \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n          \"tabIndex\": this.state.tabIndex,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n        }\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        tabIndex: 0,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function handles click event on the filter icon.\r\n  // We want to let the Action Panel display 4 different filtering methods:\r\n  // 1) Sort ascending\r\n  // 2) Sort descending\r\n  // 3) Filter\r\n  // 4) Dedup\r\n\r\n  showFilterMethods(e, colIndex) {\r\n    // console.log(\"Selected column is \"+colIndex);\r\n    // We just need to pass on the colIndex\r\n    let tempObj = {};\r\n    tempObj[\"task\"] = \"showFilterMethods\";\r\n    tempObj[\"colIndex\"] = colIndex;\r\n    \r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n    })\r\n  }\r\n\r\n  // The following functions sets the selected column to be the search column.\r\n\r\n  contextSetColumn(e, colIndex) {\r\n\r\n    // console.log(\"Col index of search cell is \"+colIndex);\r\n\r\n    // Let's do a preliminary check here to make sure that users do not set empty columns as search columns\r\n    let colEmpty = true;\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      if (this.state.tableData[i][colIndex].data !== \"\") {\r\n        colEmpty = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // We give users an alert if they try to set an empty columns as the search column\r\n    if (colEmpty === true) {\r\n      alert(\"This column is currently empty. Try set the data for this column before setting it as the search column.\");\r\n    }\r\n    else {\r\n      document.body.classList.add('waiting');\r\n\r\n      // Code here should largely be similar to what we have in populateKeyColumn\r\n\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n      // We need to find neighbours of a column.\r\n      // We need to use tableData to ask more queries (number of queries is equal to tableData.length)\r\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\r\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\r\n\r\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n        // We call updateNeighbourInfo here because we are changing the rows\r\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n        document.body.classList.remove('waiting');\r\n\r\n        // Support for undo: \r\n        let lastAction = \"contextSetColumn\";\r\n        let prevState = \r\n            {\r\n              \"keyColIndex\": this.state.keyColIndex,\r\n              \"keyColNeighbours\": this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n              \"curActionInfo\": this.state.curActionInfo,\r\n              \"tabIndex\": this.state.tabIndex,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n            };\r\n\r\n        this.setState({\r\n          keyColIndex: colIndex,\r\n          keyColNeighbours: keyColNeighbours,\r\n          firstDegNeighbours: firstDegNeighbours,\r\n          curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n          tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n          previewColIndex: -1,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      })\r\n      })\r\n    }\r\n  }\r\n\r\n  // // The following function displays the origin of a cell in the Action Panel.\r\n\r\n  // contextCellOrigin(e, rowIndex, colIndex) {\r\n  //   // To get the origin of a cell, we simply returns its \"origin field\"\r\n  //   // The trick is to set the origin field correctly in previous functions\r\n  //   // The place to do that should be in the two populating columns\r\n\r\n  //   let cellSelected = this.state.tableData[rowIndex][colIndex];\r\n\r\n  //   let originElement = [];\r\n  //   for (let i = 0; i < cellSelected.origin.length; ++i) {\r\n  //     originElement.push(<p>{niceRender(cellSelected.origin[i])}</p>);\r\n  //   }\r\n\r\n  //   // This origin literal correctly contains the cell Origin we want to display\r\n  //   // Now we just need to show it in the ActionPanel\r\n  //   let tempObj = {};\r\n  //   tempObj[\"task\"] = \"contextCellOrigin\";\r\n  //   tempObj[\"origin\"] = originElement;\r\n\r\n  //   // Support for undo: \r\n  //   let lastAction = \"contextCellOrigin\";\r\n  //   let prevState = \r\n  //       {\r\n  //         \"curActionInfo\": this.state.curActionInfo,\r\n  //         \"tabIndex\": this.state.tabIndex,\r\n  //       };\r\n    \r\n  //   this.setState({\r\n  //     curActionInfo: tempObj,\r\n  //     tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n  //     lastAction: lastAction,\r\n  //     prevState: prevState,\r\n  //   });\r\n  // }\r\n\r\n  // This function has three functionalities: \r\n  // Show the selected cell's origin, show the selected cell's preview, and update the bottom iframe's URL\r\n\r\n  originPreviewPage(e, rowIndex, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    // console.log(\"Row index is \"+rowIndex);\r\n    // console.log(\"Col index is \"+colIndex);\r\n\r\n    // This first part deals with preview\r\n\r\n    // Let's first run queries to fetch the dbp neighbours and dbo neighbours for the selected cell (withe some filtering)\r\n    // In here, we need both the ?p and ?o. This is different from before.\r\n\r\n    let promiseArray = [];\r\n\r\n    // Below is the first query we will make. In here we are using the tableCell as SUBJECT\r\n\r\n    // select ?p ?value\r\n    // where {\r\n    // dbr:Barack_Obama ?p ?value.\r\n    // }\r\n\r\n    let prefixURLOne = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne = \r\n      \"select+%3Fp+%3Fvalue%0D%0Awhere+%7B%0D%0Adbr%3A\" + \r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \"+%3Fp+%3Fvalue.%0D%0A%7D&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let otherColPromiseSubject = fetchJSON(queryURLOne);\r\n    promiseArray.push(otherColPromiseSubject);\r\n\r\n    // Below is the second query we will make. In here we are using the tableCell as OBJECT.\r\n\r\n    // select ?p ?value\r\n    // where {\r\n    // ?value ?p dbr:Barack_Obama.\r\n    // }\r\n\r\n    let prefixURLTwo = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"select+%3Fp+%3Fvalue%0D%0Awhere+%7B%0D%0A%3Fvalue+%3Fp+dbr%3A\" +\r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \".%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    let otherColPromiseObject = fetchJSON(queryURLTwo);\r\n    promiseArray.push(otherColPromiseObject);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      // console.log(values[0]);\r\n      // console.log(values[1]);\r\n      // let previewInfoArray = [];\r\n      let subjectInfoArray = \r\n        updatePreviewInfo(\r\n          values[0].results.bindings,\r\n          \"subject\"\r\n        );\r\n      let objectInfoArray = \r\n        updatePreviewInfo(\r\n          values[1].results.bindings,\r\n          \"object\"\r\n        );\r\n      // console.log(subjectInfoArray);\r\n      // console.log(objectInfoArray);\r\n      \r\n      // Here is where we make the modifications: instead of passing information to Action Panel, let's store them as states\r\n      let previewInfoArray = subjectInfoArray.concat(objectInfoArray);\r\n      let previewInfoExpanded = [];\r\n      for (let i = 0; i < previewInfoArray.length; ++i) {\r\n        previewInfoExpanded.push(false);\r\n      }\r\n      let selectedCell = _.cloneDeep(this.state.tableData[rowIndex][colIndex]);\r\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\r\n\r\n      let tempObj = {};\r\n      tempObj[\"task\"] = \"originPreviewPage\";\r\n      // // previewInfoArray correctly contains the cell preview we want to display\r\n      // // Now we just need to show it in the ActionPanel\r\n      // let tempObj = {};\r\n      // tempObj[\"task\"] = \"originPreviewPage\";\r\n      // tempObj[\"cellValue\"] = this.state.tableData[rowIndex][colIndex].data;\r\n      // tempObj[\"preview\"] = previewInfoArray;\r\n\r\n      // // Now, everything about cell preview has been completed. \r\n      // // Let's move on to deal with open link.\r\n      // let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\r\n\r\n      // // Lastly, let's deal with cell origin\r\n      // let cellSelected = this.state.tableData[rowIndex][colIndex];\r\n\r\n      // let originElement = [];\r\n      // for (let i = 0; i < cellSelected.origin.length; ++i) {\r\n      //   originElement.push(<p>{niceRender(cellSelected.origin[i])}</p>);\r\n      // }\r\n      // // We push this property to tempObj\r\n      // tempObj[\"origin\"] = originElement;\r\n\r\n      // Support for undo: \r\n      document.body.classList.remove('waiting');\r\n      let lastAction = \"originPreviewPage\";\r\n      let prevState = \r\n          {\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n            \"tabIndex\": this.state.tabIndex,\r\n            \"pageHidden\": this.state.pageHidden,\r\n            \"iframeURL\": this.state.iframeURL,\r\n            \"previewInfoArray\": this.state.previewInfoArray,\r\n            \"previewInfoExpanded\": this.state.previewInfoExpanded,\r\n            \"selectedCell\": this.state.selectedCell,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        curActionInfo: tempObj,\r\n        tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n        previewColIndex: -1,\r\n        pageHidden: false,\r\n        iframeURL: iframeURL,\r\n        previewInfoArray: previewInfoArray,\r\n        previewInfoExpanded: previewInfoExpanded,\r\n        selectedCell: selectedCell,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n  }\r\n\r\n  toggleTable(e, index) {\r\n    let tableOpenList = this.state.tableOpenList.slice();\r\n    tableOpenList[index] = !tableOpenList[index];\r\n    // When we toggle on one table, we want to close all other tables\r\n    for (let i = 0; i < tableOpenList.length; ++i) {\r\n      if (i !== index) {\r\n        tableOpenList[i] = false;\r\n      }\r\n    }\r\n    // We should change the Action Panel here, if we just toggled open a table\r\n    if (tableOpenList[index] === true) {\r\n      this.setState({\r\n        tableOpenList: tableOpenList,\r\n        curActionInfo: { task: \"selectTableIndex\", tableIndex: index },\r\n      });\r\n    } else {\r\n      this.setState({\r\n        tableOpenList: tableOpenList,\r\n        curActionInfo: null,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function is a helper function for handleStartTable.\r\n\r\n  // It takes in 2 parameters:\r\n  // 1) tableDataExplore\r\n  // 2) selectedClassAnnotation\r\n\r\n  // It returns a Promise of an object with 5 properties:\r\n  // 1) keyColIndex\r\n  // 2) tableHeader\r\n  // 3) tableData\r\n  // 4) keyColNeighbours\r\n  // 5) optionsMap.\r\n\r\n  // This object contains all the information we needed for the Excel-style table.\r\n\r\n  getTableStates(tableDataExplore, selectedClassAnnotation) {\r\n    // We need to take care of keyColIndex, tableHeader, tableData, optionsMap, and keyColNeighbours\r\n\r\n    // tableDataExplore contains all the information we need to set the five states listed above\r\n    // We just need to make use of the \"data\" and \"origin\" attributes. rowSpan and colSpan have no impact here.\r\n    // Also, since we are not modifying tableDataExplore, we do not need to make a copy of it.\r\n\r\n    // First, let's deal with keyColIndex. \r\n    // We will use the first column such that it's class annotation is not [] or [\"Number\"] or [\"originURL\"]\r\n    // If no such column exists, we default it to the first column\r\n\r\n    // console.log(selectedClassAnnotation);\r\n\r\n    let keyColIndex = -1;\r\n    for (let i=0;i<selectedClassAnnotation.length;++i) {\r\n      if (selectedClassAnnotation[i].length > 0 \r\n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"Number\")\r\n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"originURL\")\r\n        ) {\r\n        keyColIndex = i+1; \r\n        break;\r\n      }\r\n    }\r\n    if (keyColIndex === -1) {\r\n      keyColIndex = 0;\r\n    }\r\n    // console.log(\"Key Column Index is: \");\r\n    // console.log(keyColIndex);\r\n\r\n    // Now, let's deal with tableHeader. Note: these tableHeaders only have value and label, no range or type\r\n    // Also note that since table headers can be multi-selects, each tableHeader element is in the form of a length one array\r\n    let tableHeader = [];\r\n    for (let j=0;j<tableDataExplore[0].length;++j) {\r\n      tableHeader.push(\r\n        [\r\n          {\"value\":tableDataExplore[0][j].data\r\n          ,\"label\":tableDataExplore[0][j].data}\r\n        ]\r\n      )\r\n    }\r\n    // console.log(\"Table header is: \");\r\n    // console.log(tableHeader);\r\n\r\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\r\n    let tableData = [];\r\n    // console.log(tableDataExplore);\r\n    // This starts the loop for rows\r\n    for (let i=1;i<tableDataExplore.length;++i) {\r\n      let tempRow = [];\r\n      // This starts the loop for columns\r\n      for (let j=0;j<tableDataExplore[i].length;++j) {\r\n        // First set the data\r\n        let data = tableDataExplore[i][j].data;\r\n        // Then set the origin\r\n        let origin = [];\r\n        let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j][0].value+\": \"+tableDataExplore[i][j].data;\r\n        origin.push(originText);\r\n        tempRow.push({\"data\":data,\"origin\":origin});\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    // console.log(\"Table data is: \");\r\n    // console.log(tableData);\r\n\r\n    // Now, let's deal with keyColNeighbours and optionsMap\r\n    // Note: the following part should be similar to what we have in contextSetColumn\r\n\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", keyColIndex);\r\n    return allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    return allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n      \r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      return Promise.resolve(\r\n        {\r\n          \"keyColIndex\":keyColIndex,\r\n          \"tableHeader\":tableHeader,\r\n          \"tableData\":tableData,\r\n          \"keyColNeighbours\":keyColNeighbours,\r\n          \"firstDegNeighbours\":firstDegNeighbours,\r\n        }\r\n      )\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function handles the selection of table.\r\n\r\n  handleStartTable(e, tableIndex) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // We need to let table panel display the selected table\r\n    // And we need to update the Action Panel to display the first degree properties of the origigitnal page\r\n    // We do a fetch request here (Sixth Query). It gets the property neighbours of the original page that are links, as well as dct:subject\r\n    // Lastly, we need to set usecaseSelected to \"startSubject\"\r\n\r\n    // First query gets the property neighbours\r\n    let queryPromise = [];\r\n    let prefixURLOne =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne =\r\n      \"SELECT+%3Fp+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(this.state.urlPasted.slice(30)) +\r\n      \"+%3Fp+%3Fo.%0D%0A++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++FILTER%28isIRI%28%3Fo%29+%26%26+regex%28%3FpString%2C%22property%22%2C%22i%22%29+%26%26+%28%21regex%28%3FpString%2C%22text%22%2C%22i%22%29%29%29.%0D%0A%7D%0D%0A&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let queryOne = fetchJSON(queryURLOne);\r\n    queryPromise.push(queryOne);\r\n\r\n    // Second query gets the dct:subject neighbours\r\n    let prefixURLTwo =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(this.state.urlPasted.slice(30)) +\r\n      \"+dct%3Asubject+%3Fo%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    // console.log(queryURLTwo);\r\n    let queryTwo = fetchJSON(queryURLTwo);\r\n    queryPromise.push(queryTwo);\r\n\r\n    // Third query here should get the class annotations\r\n    queryPromise.push(\r\n      findClassAnnotation(this.state.originTableArray[tableIndex])\r\n    );\r\n\r\n    // now we process the query results\r\n    allPromiseReady(queryPromise).then((queryResults) => {\r\n      // console.log(queryResults[0].results.bindings);\r\n      // console.log(queryResults[1].results.bindings);\r\n      // console.log(queryResults[2]);\r\n      let selectedClassAnnotation = queryResults[2];\r\n      console.log(selectedClassAnnotation);\r\n\r\n      // First we fetch the property neighbours\r\n      // Let's also do some prefetching at this stage: let's remove the propertyNeighbours with too many siblings (150)\r\n      // and remove the propertyNeighbours with only one child (aka the originally pasted page)\r\n\r\n      let propertyNeighboursPO = [];\r\n      let promiseArray = [];\r\n      let bindingArray = [];\r\n\r\n      // The part below deals with the property neighbours\r\n      bindingArray = queryResults[0].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let predicate = bindingArray[i].p.value.slice(28);\r\n        // console.log(\"Predicate is \"+predicate);\r\n        let object = bindingArray[i].o.value.slice(28);\r\n        // console.log(\"Object is \"+object);\r\n        // If object includes some weird literal values, we replace it with \"NONEXISTING\"\r\n        if (object.includes(\"/\")) {\r\n          object = \"NONEXISTING\";\r\n        }\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs+%0D%0AWHERE+%7B%0D%0A%09%3Fs+dbp%3A\" +\r\n          regexReplace(predicate) +\r\n          \"+dbr%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: predicate, object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below deals with the dct:subject neighbours\r\n      bindingArray = queryResults[1].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let object = bindingArray[i].o.value.slice(37);\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs%0D%0AWHERE+%7B%0D%0A++++++%3Fs+dct%3Asubject+dbc%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: \"subject\", object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below processes all the siblings and remove neighbours with too many or too few siblings\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let propertyNeighbours = [];\r\n        let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\r\n        // console.log(urlOrigin);\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let curSiblingArray = values[i].results.bindings;\r\n          // Note, this 150 below should also be adjustable by users\r\n          if (curSiblingArray.length > 1 && curSiblingArray.length < 150) {\r\n            let siblingArray = [];\r\n            for (let i = 0; i < curSiblingArray.length; ++i) {\r\n              let siblingName = curSiblingArray[i].s.value.slice(28);\r\n              siblingArray.push({\r\n                isOpen: false,\r\n                name: siblingName,\r\n                tableArray: [],\r\n              });\r\n            }\r\n            // console.log(siblingArray);\r\n            propertyNeighbours.push({\r\n              predicate: propertyNeighboursPO[i].predicate,\r\n              object: propertyNeighboursPO[i].object,\r\n              isOpen: false,\r\n              siblingArray: siblingArray,\r\n            });\r\n          }\r\n        }\r\n        // we do a rudimentary ranking here: sort the property neighbours by the length of siblingArray\r\n        propertyNeighbours.sort((a, b) =>\r\n          a.siblingArray.length < b.siblingArray.length ? 1 : -1\r\n        );\r\n        // Then we update the action in Action Panel\r\n        let curActionInfo = { task: \"showPropertyNeighbours\" };\r\n        // Then we call the parse table helper function to update the tableDataExplore\r\n        let selectedTableHTML = this.state.originTableArray[tableIndex];\r\n        // setTableFromHTML is the function that prepares the data for tableDataExplore\r\n        let tableDataExplore = setTableFromHTML(selectedTableHTML, urlOrigin);\r\n\r\n        // Modeless Change: We need to call the helper function this.getTableStates.\r\n        // By processing the tableDataExplore to get the right states for the Excel-style table.\r\n\r\n        // To do this, we need to call this.getTableStates here. We just need to pass in tableDataExplore and selectedClassAnnotation \r\n        let statePromise = [this.getTableStates(tableDataExplore, selectedClassAnnotation)];\r\n        allPromiseReady(statePromise).then((values) => {\r\n          let stateInfo = values[0];\r\n          // console.log(stateInfo);\r\n\r\n          document.body.classList.remove('waiting');\r\n          // Support for undo: \r\n          let lastAction = \"handleStartTable\";\r\n          let prevState = \r\n              {\r\n                \"firstColFilled\": this.state.firstColFilled,\r\n                \"selectedTableIndex\": this.state.selectedTableIndex,\r\n                \"propertyNeighbours\": this.state.propertyNeighbours,\r\n                \"curActionInfo\": this.state.curActionInfo,\r\n                \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n                \"keyColIndex\": this.state.keyColIndex,\r\n                \"keyColNeighbours\": this.state.keyColNeighbours,\r\n                \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n                \"tableData\": this.state.tableData,\r\n                \"tableHeader\": this.state.tableHeader,\r\n                \"usecaseSelected\": this.state.usecaseSelected,\r\n                \"tabIndex\": this.state.tabIndex,\r\n              };\r\n\r\n          this.setState({\r\n            firstColFilled: true,\r\n            selectedTableIndex: tableIndex,\r\n            propertyNeighbours: propertyNeighbours,\r\n            curActionInfo: curActionInfo,\r\n            selectedClassAnnotation: selectedClassAnnotation,\r\n            keyColIndex: stateInfo.keyColIndex,\r\n            keyColNeighbours: stateInfo.keyColNeighbours,\r\n            firstDegNeighbours: stateInfo.firstDegNeighbours,\r\n            tableData: stateInfo.tableData,\r\n            tableHeader: stateInfo.tableHeader,\r\n            usecaseSelected: \"startTable\",\r\n            tabIndex: 1,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n          });\r\n        })\r\n      });\r\n    });\r\n  }\r\n\r\n  togglePropertyNeighbours(e, index) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // First let's do the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    propertyNeighbours[index].isOpen = !propertyNeighbours[index].isOpen;\r\n\r\n    // we want to loop through all siblings if we are toggling a propertyNeighbour on\r\n    if (propertyNeighbours[index].isOpen === true) {\r\n      let bindingArray = propertyNeighbours[index].siblingArray;\r\n      let siblingArray = [];\r\n      let siblingNameArray = []; // this array keeps track of the sibling names\r\n      let promiseArray = [];\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let siblingName = bindingArray[i].name;\r\n        let siblingURL = \"https://en.wikipedia.org/wiki/\" + siblingName;\r\n        let curPromise = fetchText(siblingURL);\r\n        promiseArray.push(curPromise);\r\n        siblingNameArray.push(siblingName);\r\n      }\r\n\r\n      // Since we only want to display siblings with useful tables, we do some checking here\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // tableArrayPromise stores an array of promises that resolve to tableArray\r\n        let tableArrayPromise = [];\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let pageHTML = values[i];\r\n          // This is a helper function that fetches useful tables from pageHTML\r\n          // console.log(\"The class annotation for the selected table is: \");\r\n          // console.log(this.state.selectedClassAnnotation);\r\n          tableArrayPromise.push(\r\n            findTableFromHTML(\r\n              this.state.tableHeader,\r\n              pageHTML,\r\n              this.state.selectedClassAnnotation,\r\n              this.state.semanticEnabled,\r\n              this.state.unionCutOff,\r\n              siblingNameArray[i]\r\n            )\r\n          );\r\n          // we potentially want to do something different here if urlOrigin === siblingNameArray[i]\r\n          // We only want to keep siblings that do have useful tables\r\n          // if (tableArray.length !== 0) {\r\n          // siblingArray.push({\"isOpen\":false,\"name\":siblingNameArray[i],\"tableArray\":tableArray});\r\n          // }\r\n        }\r\n        allPromiseReady(tableArrayPromise).then((tableArrayValues) => {\r\n          for (let i = 0; i < tableArrayValues.length; ++i) {\r\n            siblingArray.push({\r\n              isOpen: false,\r\n              name: siblingNameArray[i],\r\n              tableArray: tableArrayValues[i],\r\n            });\r\n          }\r\n          // This following line sorts the siblingArray\r\n          siblingArray.sort(function (a, b) {\r\n            let aTableLength = a.tableArray.length;\r\n            let bTableLength = b.tableArray.length;\r\n            let aName = a.name;\r\n            let bName = b.name;\r\n            if (aTableLength === bTableLength) {\r\n              return aName < bName ? -1 : aName > bName ? 1 : 0;\r\n            } else {\r\n              return aTableLength > bTableLength ? -1 : 1;\r\n            }\r\n          });\r\n          propertyNeighbours[index].siblingArray = siblingArray;\r\n          document.body.classList.remove('waiting');\r\n          this.setState({\r\n            propertyNeighbours: propertyNeighbours,\r\n          });\r\n        });\r\n      });\r\n    } else {\r\n      document.body.classList.remove('waiting');\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of a sibling URL\r\n\r\n  toggleSibling(e, firstIndex, secondIndex) {\r\n    // Handle the toggling task\r\n    // console.log(\"Here we start the sibling toggle\");\r\n    // console.log(\"The current property neighbour is \");\r\n    // console.log(\r\n    //   \"The current property neighbour is \",\r\n    //   this.state.propertyNeighbours.slice()\r\n    // );\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    // console.log(propertyNeighbours);\r\n    let selectedSibling =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex];\r\n\r\n    // Note that if this sibling's tableArray is empty, we probably do not want to toggle it.\r\n    if (selectedSibling.tableArray.length === 0) {\r\n      // console.log(\"Selected sibling has no tables: \" + selectedSibling.name);\r\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n      this.setState({\r\n        pageHidden: false,\r\n        iframeURL: iframeURL,\r\n      });\r\n    } else {\r\n      // if the sibling's tableArray is not empty, we want to toggle it\r\n      selectedSibling.isOpen = !selectedSibling.isOpen;\r\n      // console.log(\"Let's take a look at the current property neighbour\");\r\n      // console.log(propertyNeighbours[firstIndex]);\r\n      // if (propertyNeighbours[firstIndex].isOpen === false) {\r\n      // propertyNeighbours[firstIndex].isOpen = true;\r\n      // console.log(\"In here we should have fixed the problem.\");\r\n      // console.log(propertyNeighbours);\r\n      // }\r\n      // We also want to change the iframe displayed at the bottom if we are toggling a sibling open\r\n      if (selectedSibling.isOpen === true) {\r\n        // console.log(\"If we get here, then sibling page should be opened\");\r\n        let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        propertyNeighbours[firstIndex].isOpen = true;\r\n        // console.log(propertyNeighbours[firstIndex]);\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        // console.log(\"First index is: \" + firstIndex);\r\n        // console.log(\"In here we should have fixed the problem.\");\r\n        // console.log(\"This is the property neighbour we will pass in\");\r\n        // console.log(propertyNeighbours);\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n          iframeURL: iframeURL,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of other table (that's the same as the selected table)\r\n\r\n  toggleOtherTable(e, firstIndex, secondIndex, thirdIndex) {\r\n    // First handle the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    const selectedTable =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray[\r\n        thirdIndex\r\n      ];\r\n    // console.log(selectedTable.data);\r\n    selectedTable.isOpen = !selectedTable.isOpen;\r\n    this.setState({\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // The following funcion unions the table that user has selected to the table in the TablePanel\r\n  // by changing tableDataExplore\r\n\r\n  unionTable(firstIndex, secondIndex, otherTableHTML, colMapping) {\r\n    document.body.classList.add('waiting');\r\n    // First we create a copy of the current tableData\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Then we get the clean data and set the origin for the other table.\r\n    // We do so by calling setTableFromHTML, and setUnionData.\r\n    let otherTableOrigin = this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\r\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\r\n    otherTableData = setUnionData(otherTableData);\r\n    // console.log(otherTableData);\r\n\r\n    // console.log(colMapping);\r\n\r\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\r\n    let tempMapping = colMapping.slice();\r\n    tableData = tableConcat(\r\n      tableData,\r\n      otherTableData,\r\n      tempMapping\r\n    );\r\n\r\n    // console.log(tableData);\r\n\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n      // Suppport for undo.\r\n      let lastAction = \"unionTable\";\r\n      let prevState = \r\n          {\r\n            \"tableData\":this.state.tableData,\r\n            \"keyColNeighbours\":this.state.keyColNeighbours,\r\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function unions all similar tables found under a sibling page with the selected table\r\n  unionPage(firstIndex, secondIndex) {\r\n    document.body.classList.add('waiting');\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // We get the tableArray and name of the current sibling page\r\n    let tableArray = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray;\r\n    let otherTableOrigin = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\r\n\r\n    for (let i = 0; i < tableArray.length; ++i) {\r\n      // We get the clean data for the current \"other table\"\r\n      let otherTableData = setTableFromHTML(\r\n        tableArray[i].data,\r\n        otherTableOrigin\r\n      );\r\n      // We fetch the header row now\r\n      let headerRow = otherTableData[0];\r\n      otherTableData = setUnionData(otherTableData);\r\n      // console.log(headerRow);\r\n      // console.log(this.state.tableHeader);\r\n\r\n      // Let's do some checking here: we do not want to union the same table with itself\r\n      let sameTable = false;\r\n      if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n        let diffColFound = false;\r\n        for (let m=0; m<headerRow.length; ++m) {\r\n          if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n            diffColFound = true;\r\n            break;\r\n          }\r\n        }\r\n        if (diffColFound === false) {\r\n          sameTable = true;\r\n        }\r\n      }\r\n      // We create a copy of the colMapping of the current \"other table\"\r\n      let tempMapping = tableArray[i].colMapping.slice();\r\n\r\n      // if sameTable is false, we can safely union the data\r\n      if (sameTable === false) {\r\n        tableData = tableConcat(\r\n          tableData,\r\n          otherTableData,\r\n          tempMapping\r\n        );\r\n      }\r\n    }\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n      // Suppport for undo.\r\n      let lastAction = \"unionPage\";\r\n      let prevState = \r\n          {\r\n            \"tableData\":this.state.tableData,\r\n            \"keyColNeighbours\":this.state.keyColNeighbours,\r\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function unions all similar tables found under a property(parent) neighbour with the selected table\r\n  // This is the highest level of union.\r\n\r\n  unionProperty(firstIndex) {\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // we get the siblingArray of the current property neighbour\r\n    let siblingArray = this.state.propertyNeighbours[firstIndex].siblingArray;\r\n\r\n    for (let i = 0; i < siblingArray.length; ++i) {\r\n      // We get the tableArray and name of the current sibling page\r\n      let tableArray = siblingArray[i].tableArray;\r\n      let otherTableOrigin = siblingArray[i].name;\r\n      // console.log(otherTableOrigin);\r\n      // If the current sibling has no tables that are unionable, we break out of the loop.\r\n      // Because siblingArray is sorted by the length of their tableArray\r\n      if (tableArray.length === 0) {\r\n        break;\r\n      }\r\n      // Else, we want to union all unionable tables from the current sibling page\r\n      else {\r\n        for (let j = 0; j < tableArray.length; ++j) {\r\n          // We get the clean data for the current \"other table\"\r\n          let otherTableData = setTableFromHTML(\r\n            tableArray[j].data,\r\n            otherTableOrigin\r\n          );\r\n          // We fetch the column header row\r\n          let headerRow = otherTableData[0];\r\n          otherTableData = setUnionData(otherTableData);\r\n          // Let's do some checking here: we do not want to union the same table with itself\r\n          let sameTable = false;\r\n          if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n            let diffColFound = false;\r\n            for (let m=0; m<headerRow.length; ++m) {\r\n              if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n                diffColFound = true;\r\n                break;\r\n              }\r\n            }\r\n            if (diffColFound === false) {\r\n              sameTable = true;\r\n            }\r\n          }\r\n          // We create a copy of the colMapping of the current \"oother table\"\r\n          let tempMapping = tableArray[j].colMapping.slice();\r\n\r\n          // if sameTable is false, we can safely union the data\r\n          if (sameTable === false) {\r\n            tableData = tableConcat(\r\n              tableData,\r\n              otherTableData,\r\n              tempMapping\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Support for undo: \r\n    let lastAction = \"unionProperty\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of \"semanticEnabled\" setting\r\n\r\n  toggleSemantic(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing semanticEnabled changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n\r\n    this.setState({\r\n      semanticEnabled: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of the unionCutoff percentage\r\n\r\n  unionCutOffChange(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing union cutoff changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n    this.setState({\r\n      unionCutOff: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles opening the filter for a particular column\r\n\r\n  openFilter(e, colIndex) {\r\n    // In this function, we want to set showFilter to true, and update dataAndChecked based on colIndex\r\n\r\n    let dataArray = [];\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      dataArray.push(this.state.tableData[i][colIndex].data);\r\n    }\r\n    dataArray = [...new Set(dataArray)];\r\n    // Let's sort this dataArray a bit: we put N/A at the beginning of the array\r\n    dataArray.sort(\r\n      function(a,b) { \r\n        return a === \"N/A\" ? -1 : b === \"N/A\" ? 1 : 0; \r\n      }\r\n    );\r\n\r\n    let dataAndChecked = [];\r\n    for (let i=0;i<dataArray.length;++i) {\r\n      dataAndChecked.push(\r\n        {\r\n          \"data\":dataArray[i],\r\n          \"checked\":true\r\n        }\r\n      )\r\n    }\r\n    // console.log(dataAndChecked);\r\n\r\n    this.setState({\r\n      dataAndChecked: dataAndChecked,\r\n      showFilter: true,\r\n      curFilterIndex: colIndex,\r\n    })\r\n  }\r\n\r\n  // This function handles cancelling the filter (so we close it).\r\n\r\n  cancelFilter(e) {\r\n    this.setState({\r\n      dataAndChecked: [],\r\n      showFilter: false,\r\n      curFilterIndex: -1,\r\n    })\r\n  }\r\n\r\n  // This function handles toggling the data checkboxes in filter modal.\r\n\r\n  toggleChecked(e, checkIndex) {\r\n    let dataAndChecked = this.state.dataAndChecked;\r\n    dataAndChecked[checkIndex].checked = !dataAndChecked[checkIndex].checked;\r\n    this.setState({\r\n      dataAndChecked:dataAndChecked,\r\n    })\r\n  }\r\n\r\n  // This function handles applying the filter to tableData, based on dataAndChecked\r\n\r\n  applyFilter(e) {\r\n    // console.log(this.state.dataAndChecked);\r\n    // console.log(this.state.curFilterIndex);\r\n\r\n    let valuesToKeep = [];\r\n    for (let i=0;i<this.state.dataAndChecked.length;++i) {\r\n      if (this.state.dataAndChecked[i].checked === true) {\r\n        valuesToKeep.push(this.state.dataAndChecked[i].data);\r\n      }\r\n    }\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    for (let i=0;i<tableData.length;++i) {\r\n      if (!valuesToKeep.includes(tableData[i][this.state.curFilterIndex].data)) {\r\n        tableData.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      // Suppport for undo.\r\n      let lastAction = \"applyFilter\";\r\n      let prevState = \r\n          {\r\n            \"tableData\":this.state.tableData,\r\n            \"curActionInfo\":this.state.curActionInfo,\r\n            \"keyColNeighbours\":this.state.keyColNeighbours,\r\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        dataAndChecked: [],\r\n        showFilter: false,\r\n        curFilterIndex: -1,\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function hanles switching tabs\r\n\r\n  handleTabSwitch(index) {\r\n    // If we are switching to \"Union Table\" tab from \"Wrangling Actions\" tab, we want to toggle off all the property neighbours.\r\n    // Since we might have potentially changed the table in table panel, thus changed the search criteria as well\r\n    if (index === 1) {\r\n      let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n      for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n        propertyNeighbours[i].isOpen = false;\r\n      }\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n        tabIndex: index,\r\n      });\r\n    }\r\n    else {\r\n      this.setState({\r\n        tabIndex: index,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function undos the previous change that user has made to the result table in table panel\r\n\r\n  undoPreviousStep() {\r\n    // We first get which action we need to undo\r\n    let lastAction = this.state.lastAction;\r\n    // Then we fetch the previous state\r\n    let prevState = this.state.prevState;\r\n    // console.log(lastAction);\r\n    // console.log(prevState);\r\n\r\n    // Note, since we are allowing one step undo only, we set lastAction to \"\" everytime we run this function\r\n\r\n    // Case 1: Undo the ULR Paste. \r\n    // In this case we need to restore urlPasted, iframeURL, originTableArray, and tableOpenList\r\n    if (lastAction === \"handleURLPaste\") {\r\n      this.setState({\r\n        urlPasted: prevState.urlPasted,\r\n        iframeURL: prevState.iframeURL,\r\n        originTableArray: prevState.originTableArray,\r\n        tableOpenList: prevState.tableOpenList,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 2: Undo the selection of the task: startSubject.\r\n    // In this case we need to restore usecaseSelected, tableData, firstColSelection, firstColChecked, tabIndex, and curActionInfo\r\n\r\n    else if (lastAction === \"handleStartSubject\") {\r\n      this.setState({\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tableData: prevState.tableData,\r\n        firstColSelection: prevState.firstColSelection,\r\n        firstColChecked: prevState.firstColChecked,\r\n        tabIndex: prevState.tabIndex,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 3: Undo the selection of the task: startTable.\r\n    // In this case we need to restore many states. See code below.\r\n\r\n    else if (lastAction === \"handleStartTable\") {\r\n      this.setState({\r\n        firstColFilled: prevState.firstColFilled,\r\n        selectedTableIndex: prevState.selectedTableIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 4: Undo the population of key column.\r\n    // In this case we need to restore keyColIndex, keyColNeighbours, firstDegNeighbours, firstColFilled, \r\n    //                                 curActionInfo, tableData, tableHeader\r\n\r\n    else if (lastAction === \"populateKeyColumn\") {\r\n      this.setState({\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        firstColFilled: prevState.firstColFilled,\r\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 5: Undo the population of a new column.\r\n    // In this case we need to restore curActionInfo, tableData.\r\n    else if (lastAction === \"populateOtherColumn\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 6: Undo the population of same neighbour in different columns.\r\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap.\r\n    else if (lastAction === \"sameNeighbourDiffRow\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 7: Undo the population of same neighbour in the same column.\r\n    // In this case we need to restore the curActionInfo, tableData.\r\n    else if (lastAction === \"sameNeighbourOneRow\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 9: Undo the union of tables.\r\n    // In this case we need to restore tableData\r\n    else if (lastAction === \"unionTable\" || lastAction === \"unionPage\" || lastAction === \"unionProperty\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 10: Undo the addition of a new column\r\n    else if (lastAction === \"contextAddColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        curActionInfo: prevState.curActionInfo,\r\n        keyColIndex: prevState.keyColIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 11: Undo the set of search cell.\r\n    else if (lastAction === \"contextSetColumn\") {\r\n      this.setState({\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // // Case 12: Undo the showing of cell origin.\r\n    // else if (lastAction === \"contextCellOrigin\") {\r\n    //   this.setState({\r\n    //     curActionInfo: prevState.curActionInfo,\r\n    //     tabIndex: prevState.tabIndex,\r\n    //     lastAction: \"\",\r\n    //   })\r\n    // }\r\n\r\n    // Case 12: Undo the showing of cell preview.\r\n    else if (lastAction === \"originPreviewPage\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        pageHidden: prevState.pageHidden,\r\n        iframeURL: prevState.iframeURL,\r\n        previewInfoArray: prevState.previewInfoArray,\r\n        previewInfoExpanded: prevState.previewInfoExpanded,\r\n        selectedCell: prevState.selectedCell,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 13: Undo the deletion of column.\r\n    else if (lastAction === \"contextDeleteColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 14: Undo the sorting of a column.\r\n    else if (lastAction === \"contextSortColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        curActionInfo: prevState.curActionInfo,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 14: Undo the deduping of a column.\r\n    else if (lastAction === \"contextDedupColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 15: Undo the row filtering based on column filters.\r\n    else if (lastAction === \"applyFilter\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 16: Undo the joining of two tables.\r\n    else if (lastAction === \"runJoin\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"confirmAddFirstCol\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"toggleOtherNeighbour\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        previewColIndex: prevState.previewColIndex,\r\n        otherColChecked: prevState.otherColChecked,\r\n        otherColCheckedIndex: prevState.otherColCheckedIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // This is an empty else clause.\r\n    else {\r\n\r\n    }\r\n  }\r\n\r\n  // The two following functions opens/closes the modal for union table settings.\r\n\r\n  openModal() {\r\n    this.setState({\r\n      showSetting: true,\r\n    })\r\n  }\r\n\r\n  closeModal() {\r\n    this.setState({\r\n      showSetting: false,\r\n    })\r\n  }\r\n\r\n  // The following function toggles this.state.showTableSelection.\r\n\r\n  toggleTableSelection() {\r\n    let showTableSelection = !this.state.showTableSelection;\r\n    this.setState({\r\n      showTableSelection: showTableSelection,\r\n    })\r\n  }\r\n\r\n  // The following function handles the toggling of \"show unionable tables\" and \"show joinable tables\".\r\n  // based on whether the string passed in is \"union\" or \"join\"\r\n\r\n  toggleUnionJoin(e, str) {\r\n    // In this case we are toggling on/off unionable tables \r\n    if (str === \"union\") {\r\n      this.setState({\r\n        showUnionTables: !this.state.showUnionTables,\r\n        showJoinTables: false,\r\n      })\r\n    }\r\n    // In this case we are toggling on/off joinable tables \r\n    else {\r\n      // Note: every time before we toggle on joinable tables, let's set all this.state.tableOpenList to false\r\n      let tableOpenList = this.state.tableOpenList.slice();\r\n      for (let i = 0; i < tableOpenList.length; ++i) {\r\n        tableOpenList[i] = false;\r\n      }\r\n      this.setState({\r\n        showUnionTables: false,\r\n        showJoinTables: !this.state.showJoinTables,\r\n        tableOpenList: tableOpenList,\r\n      })\r\n    }\r\n  }\r\n\r\n  // The following function handles the join of a selected table with the table in tablePanel.\r\n\r\n  handleJoinTable(e, i) {\r\n    // We need to get two arrays of column headers. One for the table panel table, one for the selected table to join.\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n    let originTableHeader = [];\r\n    let joinTableHeader = [];\r\n\r\n    // Note: both originTableHeader and joinTableHeader are array of objects with three properties: label, value, and index\r\n\r\n    // First we get the header for the origin table\r\n    console.log(tableHeader);\r\n    // Let's loop through this tableHeader to fill the originTableHeader\r\n    for (let i = 0; i < tableHeader.length; ++i) {\r\n      // If the current element in table header has length of 0, it means it's empty\r\n      if (tableHeader[i].length === 0) {\r\n        break;\r\n      }\r\n      else {\r\n        // We loop through the tableHeader[i]\r\n        let value = \"\";\r\n        for (let j = 0; j < tableHeader[i].length; ++j) {\r\n          let valueToAdd = j > 0 ? \"&\" + tableHeader[i][j].value : tableHeader[i][j].value;\r\n          value+=valueToAdd;\r\n        }\r\n        originTableHeader.push(\r\n          {\r\n            \"value\":value,\r\n            \"label\":value,\r\n            \"index\":i\r\n          }\r\n        )\r\n      }\r\n    }\r\n    console.log(originTableHeader);\r\n\r\n    // Now that we have originTableHeader working correctly, let's get the joinTableHeader\r\n    let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\r\n    let joinTableData = setTableFromHTML(this.state.originTableArray[i], urlOrigin);\r\n    // console.log(joinTable);\r\n\r\n    // We start the index from 1, because 0 index corresponds to OriginURL\r\n    for (let i = 0; i < joinTableData[0].length; ++i) {\r\n      joinTableHeader.push(\r\n        {\r\n          \"value\":joinTableData[0][i].data,\r\n          \"label\":joinTableData[0][i].data,\r\n          \"index\":i\r\n        }\r\n      )\r\n    }\r\n\r\n    // Now we take a look at originTableHeader, joinTableHeader, and joinTable\r\n    // console.log(originTableHeader);\r\n    // console.log(joinTableHeader);\r\n    // console.log(joinTableData);\r\n\r\n    // It seems like we have fetched the right values. \r\n    // Now we use these to update states, so that jon modal can display the right content.\r\n\r\n    this.setState({\r\n      showJoinModal: true,\r\n      joinTableIndex: i,\r\n      joinTableData: joinTableData,\r\n      originColOptions: originTableHeader,\r\n      joinColOptions: joinTableHeader,\r\n    })\r\n  }\r\n\r\n  // The following function handles cancelling the join operation.\r\n\r\n  cancelJoin(e) {\r\n    this.setState({\r\n      showJoinModal: false,\r\n    })\r\n  }\r\n\r\n  // The following function handles the selection of join columns.\r\n  // It updates either originJoinIndex, or joinJoinIndex, based on the second parameter passed in\r\n\r\n  selectJoinColumn(e, table) {\r\n    // console.log(e.index);\r\n    if (table === \"originTable\") {\r\n      this.setState({\r\n        originJoinIndex: e.index,\r\n      })\r\n    }\r\n    else {\r\n      this.setState({\r\n        joinJoinIndex: e.index,\r\n      })\r\n    }\r\n  }\r\n\r\n  // The function handles the actual join of two selected tables. \r\n  // Currently, the only join type supported is left join\r\n\r\n  // Since join is equal to column addition, we need to update tableData, tableHeader, optionsMap, and selectedClassAnnotation\r\n  runJoin(e) {\r\n    // First check all the info that we needed\r\n    let joinTableData = this.state.joinTableData.slice();\r\n    let originJoinIndex = this.state.originJoinIndex;\r\n    let joinJoinIndex = this.state.joinJoinIndex;\r\n    // console.log(joinTableData);\r\n    // console.log(originJoinIndex);\r\n    // console.log(joinJoinIndex);\r\n    \r\n    // If the join table has n columns, then we are adding n-1 new columns to the table in table panel.\r\n    // Since we only allow join of one column from each table.\r\n\r\n    // Let's deal with tableHeader, optionsMap, and selectedCalssAnnotation, before we move on to tableData.\r\n    let tableHeaderUpdated = this.state.tableHeader.slice();\r\n    let optionsMapUpdated = this.state.optionsMap.slice();\r\n    let selectedClassAnnotationUpdated = this.state.selectedClassAnnotation.slice();\r\n\r\n    // First we handle tableHeader's addition.\r\n    // We first loop through tableHeader to remove all the empty ones\r\n    for (let i = 0; i < tableHeaderUpdated.length; ++i) {\r\n      if (tableHeaderUpdated[i] === \"\") {\r\n        tableHeaderUpdated.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n    // Now we push on the new columns. Note that it has to be in the form of an array\r\n    for (let i = 0; i < joinTableData[0].length; ++i) {\r\n      if (i !== joinJoinIndex) {\r\n        tableHeaderUpdated.push(\r\n          [\r\n            {\r\n              \"value\":joinTableData[0][i].data,\r\n              \"label\":joinTableData[0][i].data\r\n            }\r\n          ]\r\n        )\r\n      }\r\n    }\r\n    // console.log(tableHeaderUpdated); \r\n\r\n    // Then we handle optionsMap's addition. We do not need to do much here.\r\n    // We start the index from 1, because we only add in n-1 new columns.\r\n    for (let i = 1; i < joinTableData[0].length; ++i) {\r\n      optionsMapUpdated.push([]);\r\n    }\r\n    // console.log(optionsMapUpdated);\r\n\r\n    // Then we handle selectedClassAnnotation's addition.\r\n    let queryPromise = [findClassAnnotation(this.state.originTableArray[this.state.joinTableIndex])];\r\n    allPromiseReady(queryPromise).then((values) => {\r\n    // Note, we need to push on an empty [] to values here, corresponding to the originURL column's class annotation\r\n    values[0].splice(0, 0, []);\r\n    for (let i = 0; i < values[0].length; ++i) {\r\n      if (i !== joinJoinIndex) {\r\n        selectedClassAnnotationUpdated.push(values[0][i]);\r\n      }\r\n    }\r\n    console.log(selectedClassAnnotationUpdated);\r\n    \r\n    // Lastly, and most importantly, we want to handle tableData's change.\r\n    // Let's start with an empty tableDataUpdated. Loop through tableData. \r\n    // Use a bool to keep track of if tableData[i][originJoinIndex] is in join table. For every yes, we push one element onto tableDataUpdated.\r\n    // If at the end, the bool is still no, we push on tableData[i] with a bunch of N/A's at the position of the newly added columns.\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    let tableDataUpdated = [];\r\n    // Let's first run some code to process joinTableData, so that it shares the same format as tableData\r\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\r\n    let joinTableHeader = [];\r\n    for (let j=0;j<joinTableData[0].length;++j) {\r\n      joinTableHeader.push(\r\n        {\"value\":joinTableData[0][j].data\r\n        ,\"label\":joinTableData[0][j].data}\r\n      )\r\n    }\r\n    let joinTableDataUpdated = [];\r\n    // console.log(tableDataExplore);\r\n    // This starts the loop for rows\r\n    for (let i=1;i<joinTableData.length;++i) {\r\n      let tempRow = [];\r\n      // This starts the loop for columns\r\n      for (let j=0;j<joinTableData[i].length;++j) {\r\n        // First set the data\r\n        let data = joinTableData[i][j].data;\r\n        // Then set the origin\r\n        let origin = [];\r\n        let originText = joinTableData[i][j].origin+\": \"+joinTableHeader[j].value+\": \"+joinTableData[i][j].data;\r\n        origin.push(originText);\r\n        tempRow.push({\"data\":data,\"origin\":origin});\r\n      }\r\n      joinTableDataUpdated.push(tempRow);\r\n    }\r\n\r\n    // Take a look at tableData, and joinTableDataUpdated\r\n    // console.log(tableData);\r\n    // console.log(joinTableDataUpdated);\r\n\r\n    // Now we can finally start the join operator\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      let curJoinEntry = tableData[i][originJoinIndex].data;\r\n      console.log(\"Current entry to join is \"+curJoinEntry);\r\n      let curEntryFound = false;\r\n      // We start the index from 1 because the first column in joinTableData is the header\r\n      for (let j = 0; j < joinTableDataUpdated.length; ++j) {\r\n        if (joinTableDataUpdated[j][joinJoinIndex].data === curJoinEntry) {\r\n          // console.log(\"A match has been found at index \"+j);\r\n          // Let's create the tempRow that we want to push onto tableDataUpdated\r\n\r\n          let tempRow = _.cloneDeep(tableData[i]);\r\n          for (let k = 0; k < joinTableDataUpdated[j].length; ++k) {\r\n            if (k !== joinJoinIndex) {\r\n              tempRow.push(joinTableDataUpdated[j][k]);\r\n            }\r\n          }\r\n          tableDataUpdated.push(tempRow);\r\n          curEntryFound = true;\r\n        }\r\n      }\r\n      // If this current entry does NOT have a corresponding entry in the join table,\r\n      // We push it directly onto tableDataUpdated, with the addtion of some N/A's.\r\n      if (curEntryFound === false) {\r\n        // Let's create the tempRow that we want to push onto tableDataUpdated\r\n\r\n        // Code Placeholder\r\n        let tempRow = _.cloneDeep(tableData[i]);\r\n        for (let k = 0; k < joinTableDataUpdated[0].length; ++k) {\r\n          if (k !== joinJoinIndex) {\r\n            tempRow.push(\r\n              {\r\n                \"data\":\"N/A\",\r\n                \"origin\":[]\r\n              }\r\n            );\r\n          }\r\n        }\r\n        tableDataUpdated.push(tempRow);\r\n      }\r\n    }\r\n    // console.log(tableDataUpdated);\r\n\r\n    // Now, we have correctly got everything we needed: tableDataUpdated, tableHeaderUpdated, optionsMapUpdated, selectedClassAnnotationUpdated\r\n    // Let's add some support for undo, and do not forget to close the joinModal\r\n\r\n    // Bugfix: since this function potentially changes the number of rows too, we need to update firstDegNeighbours and keyColNeighbours\r\n    let promiseArrayOne = this.getNeighbourPromise(tableDataUpdated, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableDataUpdated, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      // Support for undo: \r\n      let lastAction = \"runJoin\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n          \"tableHeader\":this.state.tableHeader,\r\n          \"keyColNeighbours\":this.state.keyColNeighbours,\r\n          \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo:{\"task\":\"afterPopulateColumn\"},\r\n        tableData:tableDataUpdated,\r\n        tableHeader:tableHeaderUpdated,\r\n        keyColNeighbours:keyColNeighbours,\r\n        firstDegNeighbours:firstDegNeighbours,\r\n        selectedClassAnnotation:selectedClassAnnotationUpdated,\r\n        showJoinModal: false,\r\n        previewColIndex: -1,\r\n        lastAction:lastAction,\r\n        prevState:prevState,\r\n      })\r\n    })\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function handles the expansion/collapse of an attribute in cell preview and origin\r\n  togglePreviewElement(e, i) {\r\n    let previewInfoExpanded = this.state.previewInfoExpanded.slice();\r\n    previewInfoExpanded[i] = !previewInfoExpanded[i];\r\n    this.setState({\r\n      previewInfoExpanded: previewInfoExpanded,\r\n    })\r\n  }\r\n\r\n  render() {\r\n    let bodyEle;\r\n    let bottomContentClass = \" bottom-content\";\r\n    let topContentClass = \"row top-content\";\r\n    if (this.state.pageHidden) {\r\n      bottomContentClass = \" bottom-content-hidden\";\r\n      topContentClass = \"row top-content-large\";\r\n    }\r\n    // If user has not pasted the URL, we want to display the landing page\r\n    if (this.state.urlPasted === \"\") {\r\n      bodyEle = \r\n        <LandingPage \r\n          handleURLPaste={this.handleURLPaste} \r\n        />;\r\n    }\r\n    // Else, we show the three panels: TablePanel, ActionPanel, and PagePanel\r\n    else {\r\n      bodyEle = (\r\n        <div>\r\n          <div className=\"header\">\r\n            <Header \r\n              // Following states are passed for general purposes\r\n              copyTable={this.copyTable}\r\n              undoPreviousStep={this.undoPreviousStep}\r\n              openModal = {this.openModal}\r\n            />\r\n          </div> \r\n          <div className=\"mainbody\">\r\n            <div className=\"\">\r\n              <div className={topContentClass}>\r\n                <div className=\"col-md-7 small-padding table-panel\">\r\n                  <TablePanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    // Following states are passed to \"startSubject\"\r\n                    tableHeader={this.state.tableHeader}\r\n                    tableData={this.state.tableData}\r\n                    keyColIndex={this.state.keyColIndex}\r\n                    onCellChange={this.cellChange}\r\n                    selectColHeader={this.selectColHeader}\r\n                    getKeyOptions={this.getKeyOptions}\r\n                    optionsMap={this.state.optionsMap}\r\n                    contextAddColumn={this.contextAddColumn}\r\n                    contextDeleteColumn={this.contextDeleteColumn}\r\n                    contextSetColumn={this.contextSetColumn}\r\n                    originPreviewPage={this.originPreviewPage}\r\n                    showFilterMethods={this.showFilterMethods}\r\n                    // Following states control the render of first column header\r\n                    firstColFilled={this.state.firstColFilled}\r\n                    handlePlusClick={this.handlePlusClick}\r\n                    firstColHeaderInfo={this.state.firstColHeaderInfo}\r\n                    // Following states control the render of other column header\r\n                    getOtherOptions={this.getOtherOptions}\r\n                    // Following states control the render of column preview\r\n                    previewColIndex={this.state.previewColIndex}\r\n                  />\r\n                </div>\r\n                <div className=\"col-md-5 small-padding action-panel\">\r\n                  <ActionPanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    curActionInfo={this.state.curActionInfo}\r\n                    handleStartSubject={this.handleStartSubject}\r\n                    populateKeyColumn={this.populateKeyColumn}\r\n                    populateOtherColumn={this.populateOtherColumn}\r\n                    sameNeighbourDiffRow={this.sameNeighbourDiffRow}\r\n                    sameNeighbourOneRow={this.sameNeighbourOneRow}\r\n                    populateRecommendation={this.populateRecommendation}\r\n                    // Folloiwng states are passed to \"startTable\"\r\n                    handleStartTable={this.handleStartTable}\r\n                    propertyNeighbours={this.state.propertyNeighbours}\r\n                    togglePropertyNeighbours={this.togglePropertyNeighbours}\r\n                    toggleSibling={this.toggleSibling}\r\n                    toggleOtherTable={this.toggleOtherTable}\r\n                    unionTable={this.unionTable}\r\n                    unionPage={this.unionPage}\r\n                    unionProperty={this.unionProperty}\r\n                    // Follow state handles tab switch\r\n                    tabIndex={this.state.tabIndex}\r\n                    handleTabSwitch={this.handleTabSwitch}\r\n                    // Following states are passed during start up\r\n                    showTableSelection={this.state.showTableSelection}\r\n                    toggleTableSelection={this.toggleTableSelection}\r\n                    originTableArray={this.state.originTableArray}\r\n                    tableOpenList={this.state.tableOpenList}\r\n                    toggleTable={this.toggleTable}\r\n                    selectedTableIndex={this.state.selectedTableIndex}\r\n                    // Following states are for union/join tables\r\n                    showUnionTables={this.state.showUnionTables}\r\n                    showJoinTables={this.state.showJoinTables}\r\n                    toggleUnionJoin={this.toggleUnionJoin}\r\n                    handleJoinTable={this.handleJoinTable}\r\n                    // Following states are for first column's header selection\r\n                    firstColSelection={this.state.firstColSelection}\r\n                    firstColChecked={this.state.firstColChecked}\r\n                    firstColFilled={this.state.firstColFilled}\r\n                    keyColIndex={this.state.keyColIndex}\r\n                    toggleFirstNeighbour={this.toggleFirstNeighbour}\r\n                    tableHeader={this.state.tableHeader}\r\n                    keyCheckedIndex={this.state.keyCheckedIndex}\r\n                    addToFirstCol={this.addToFirstCol}\r\n                    confirmAddFirstCol={this.confirmAddFirstCol}\r\n                    // Following states are for other column's header selection\r\n                    otherColSelection={this.state.otherColSelection}\r\n                    otherColChecked={this.state.otherColChecked}\r\n                    otherCheckedIndex={this.state.otherCheckedIndex}\r\n                    toggleOtherNeighbour={this.toggleOtherNeighbour}\r\n                    // Following states are for column's processing methods\r\n                    contextSortColumn={this.contextSortColumn}\r\n                    contextDedupColumn={this.contextDedupColumn}\r\n                    openFilter={this.openFilter}\r\n                    // Following states are for displaying cell's preview and origin\r\n                    previewInfoArray={this.state.previewInfoArray}\r\n                    previewInfoExpanded={this.state.previewInfoExpanded}\r\n                    selectedCell={this.state.selectedCell}\r\n                    togglePreviewElement={this.togglePreviewElement}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div className={bottomContentClass}>\r\n                <div>\r\n                  <PagePanel\r\n                    pageHidden={this.state.pageHidden}\r\n                    iframeURL={this.state.iframeURL}\r\n                    toggleWikiPage={this.toggleWikiPage}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div>\r\n                <SettingModal \r\n                  showSetting={this.state.showSetting}\r\n                  closeModal={this.closeModal}\r\n                  semanticEnabled={this.state.semanticEnabled}\r\n                  toggleSemantic={this.toggleSemantic}\r\n                  unionCutOff={this.state.unionCutOff}\r\n                  unionCutOffChange={this.unionCutOffChange}\r\n                />\r\n              </div>\r\n              <div>\r\n                <FilterModal\r\n                  showFilter={this.state.showFilter}\r\n                  dataAndChecked={this.state.dataAndChecked}\r\n                  applyFilter={this.applyFilter}\r\n                  cancelFilter={this.cancelFilter}\r\n                  toggleChecked={this.toggleChecked}\r\n                />\r\n              </div>\r\n              <div>\r\n                <JoinModal \r\n                  showJoin={this.state.showJoinModal}\r\n                  cancelJoin={this.cancelJoin}\r\n                  originColOptions={this.state.originColOptions}\r\n                  joinColOptions={this.state.joinColOptions}\r\n                  originJoinIndex={this.state.originJoinIndex}\r\n                  joinJoinIndex={this.state.joinJoinIndex}\r\n                  selectJoinColumn={this.selectJoinColumn}\r\n                  runJoin={this.runJoin}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"footer\">\r\n            <Footer />\r\n          </div> \r\n        </div>\r\n      );\r\n    }\r\n    return <div>{bodyEle}</div>;\r\n  }\r\n}\r\n\r\nexport default MainBody;\r\n\r\n// This function takes in a queryURL and returns its JSON format\r\nfunction fetchJSON(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS)\r\n        .then(function (response) {\r\n          if (!response.ok) {\r\n            throw Error(1);\r\n          }\r\n          return response;\r\n        })\r\n        .then(function (response) {\r\n          return response.json();\r\n        })\r\n        .catch(function (error) {\r\n          document.body.classList.remove('waiting');\r\n          alert(\"Some error occured when accessing SPARQL public endpoint. If semantic mapping is enabled, disable it and try again.\");\r\n          return 1;\r\n        })\r\n}\r\n\r\n// This function takes in a queryURL and returns its Text format\r\nfunction fetchText(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS).then((response) => response.text());\r\n}\r\n\r\n// This function ensures that all promises in promiseArray are ready\r\nfunction allPromiseReady(promiseArray) {\r\n  return Promise.all(promiseArray);\r\n}\r\n\r\n// This function replaces string so that the result can be used in queryURL.\r\n// It currently replaces \"(\", \")\", \"'\", \"-\", \" \", \"&\", \".\", \"\"\",and \"/\"\r\nfunction regexReplace(str) {\r\n  return str\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/%/g, \"%5Cu0025\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\");\r\n}\r\n\r\n// This function replaces the URL pasted\r\nfunction urlReplace(str) {\r\n  return str\r\n    .replace(/%E2%80%93/g, \"%5Cu2013\")\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\");\r\n}\r\n\r\n// This function removes the prefix \"http://dbpedia.org/resource/\" from query results, if it includes one\r\n\r\nfunction removePrefix(str) {\r\n  let prefixToRemove = \"http://dbpedia.org/resource/\";\r\n  // If dbResult contains prefix of \"http://dbpedia.org/resource/\", we want to remove it\r\n  if (str.includes(prefixToRemove) === true) {\r\n     str = str.slice(28);\r\n  }\r\n  return str;\r\n}\r\n\r\n// This function updates the key column's neighbours for ONE entry from the search column.\r\n\r\n// It taks three parameters:\r\n//  1) array \"keyColNeighbour\" storing list of neighbours for the key column\r\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  3) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns the updated keyColNeighbours\r\nfunction updateKeyColNeighbours(keyColNeighbours, resultsBinding, type) {\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 &&\r\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         )\r\n  );\r\n\r\n  // We then do some filtering based on subPropertyOf.\r\n  // Because of our observation, we only want to keep entries whose subPropertyOf attribute is from the DUL dataset.\r\n  // processedBinding = processedBinding.filter(a => a.subPropertyOf === undefined || a.subPropertyOf.value.includes(\"DUL.owl\"));\r\n  processedBinding = processedBinding.filter(function(a) {\r\n    if (a.subPropertyOf !== undefined) {\r\n      return a.subPropertyOf.value.includes(\"DUL.owl\");\r\n    }\r\n    return true;\r\n  })\r\n\r\n  // we then sort the resultsBinding by p.value.slice(28)\r\n  processedBinding = processedBinding.sort((a, b) =>\r\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n  );\r\n\r\n  // we take a look at processedBinding at this stage\r\n  // console.log(processedBinding);\r\n\r\n  // Let's only start the loop is processedBinding is non-empty\r\n  if (processedBinding.length > 0) {\r\n    // We set count of neighbour ready to be added\r\n    let neighbourCount = 1;  \r\n\r\n    // We set literal of neighbour ready to be added.\r\n    // Morever, we get the value of the neighbour ready to be added, depending on type.\r\n    // Initialized with the first neighbour.\r\n\r\n    let neighbourToAdd = processedBinding[0].p.value.slice(28); \r\n    let valuesToAdd = [];\r\n    valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[0].o.value) : removePrefix(processedBinding[0].s.value))\r\n\r\n    // we set range of neighbour ready to be added. \"\" if doesn't exist.\r\n    let neighbourRange = processedBinding[0].range !== undefined ? processedBinding[0].range.value : \"\";\r\n\r\n    // we the subPropertyOf of neighbour ready to be added. \"\" if doesn't exist.\r\n    let neighbourSubPropertyOf = processedBinding[0].subPropertyOf !== undefined ? processedBinding[0].subPropertyOf.value : \"\";\r\n    \r\n    // We loop over processedBinding\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      // If the current neighbour is equal to neighbourToAdd, we increment the count, and push onto valuesToAdd\r\n      if (curNeighbour === neighbourToAdd) {\r\n        ++neighbourCount;\r\n        valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value))\r\n      }\r\n      // else, we push neighbourToAdd to keyColNeighbours. \r\n      else {\r\n        // set value.\r\n        let objValue = neighbourToAdd;\r\n        // set label. We want to change the neighbour label if type === \"object\".\r\n        let objLabel = neighbourToAdd;\r\n        if (type === \"object\") {\r\n          objLabel = \"is \" + objLabel + \" of\";\r\n        }\r\n        // set type\r\n        let objType = type;\r\n        // set count\r\n        let objCount = neighbourCount;\r\n        // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\r\n        let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\r\n        // set range\r\n        let objRange = neighbourRange;\r\n        // set subPropertyOf\r\n        let objSubPropertyOf = neighbourSubPropertyOf;\r\n\r\n        // Set object from all its attributes\r\n        let tempObj = {\r\n          \"value\":objValue, \r\n          \"label\":objLabel, \r\n          \"type\":objType, \r\n          \"count\":objCount, \r\n          \"filledCount\":1, \r\n          \"data\":objData,\r\n          \"range\":objRange,\r\n          \"subPropertyOf\":objSubPropertyOf\r\n        };\r\n        // We push this tempObj onto keyColNeighbours\r\n        keyColNeighbours.push(tempObj)\r\n\r\n        // We now need to reset neighbourCount, neighbourToAdd, neighbourRange, neighbourSubPropertyOf, and valuesToAdd\r\n        neighbourCount = 1;\r\n        neighbourToAdd = curNeighbour;\r\n        valuesToAdd = [type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value)];\r\n        neighbourRange = processedBinding[i].range !== undefined ? processedBinding[i].range.value : \"\";\r\n        neighbourSubPropertyOf = processedBinding[i].subPropertyOf !== undefined ? processedBinding[i].subPropertyOf.value : \"\";\r\n      }\r\n    }\r\n    // Now, after the loop is done, we need to do one more iteration to determine how we want to add the last neighbour.\r\n    \r\n    // set value.\r\n    let objValue = neighbourToAdd;\r\n    // set label. We want to change the neighbour label if type === \"object\".\r\n    let objLabel = neighbourToAdd;\r\n    if (type === \"object\") {\r\n      objLabel = \"is \" + objLabel + \" of\";\r\n    }\r\n    // set type\r\n    let objType = type;\r\n    // set count\r\n    let objCount = neighbourCount;\r\n    // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\r\n    let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\r\n    // set range\r\n    let objRange = neighbourRange;\r\n    // set subPropertyOf\r\n    let objSubPropertyOf = neighbourSubPropertyOf;\r\n\r\n    // Set object from all its attributes\r\n    let tempObj = {\r\n        \"value\":objValue, \r\n        \"label\":objLabel, \r\n        \"type\":objType, \r\n        \"count\":objCount, \r\n        \"filledCount\":1, \r\n        \"data\":objData,\r\n        \"range\":objRange,\r\n        \"subPropertyOf\":objSubPropertyOf\r\n      };\r\n    // we push this tempObj onto keyColNeighbours\r\n    keyColNeighbours.push(tempObj)\r\n  }\r\n\r\n  // console.log(keyColNeighbours);\r\n  // console.log(processedBinding);\r\n\r\n  return keyColNeighbours;\r\n}\r\n\r\n// This helper function is designed to process the result bindings passed from contextCellPreview.\r\n// It should share some similarity with updateKeyColNeighbours\r\n\r\n// It takes two parameters:\r\n//  1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  2) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns previewInfoArray, a list of objects used to display a cell's preview info\r\n// This object has two properties:\r\n// 1) key: a string\r\n// 2) value: an array of strings\r\nfunction updatePreviewInfo(resultsBinding, type) {\r\n  // console.log(previewInfoArray);\r\n  // console.log(resultsBinding);\r\n  // console.log(type);\r\n\r\n  // Let's do some preprocessing of resultsBinding. We want to do sorting, deduping, and some filtering.\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 &&\r\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         )\r\n  );\r\n\r\n\r\n  // we then sort the resultsBinding by p.value.slice(28)\r\n  processedBinding = processedBinding.sort((a, b) =>\r\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n  );\r\n\r\n  // Now let's create the previewInfoArray based on processedBinding\r\n  // console.log(processedBinding);\r\n\r\n  let previewInfoArray = [];\r\n\r\n  if (processedBinding.length > 1) {\r\n    // We first push on the first element from processedBinding\r\n\r\n    previewInfoArray.push(\r\n      {\r\n        \"key\": type === \"subject\" ? processedBinding[0].p.value.slice(28) : \"is \"+processedBinding[0].p.value.slice(28)+\" of\",\r\n        \"value\": [removePrefix(processedBinding[0].value.value)],\r\n      }\r\n    )\r\n    let curIndex = 0;\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      let prevNeighbour = processedBinding[i-1].p.value.slice(28);\r\n      // console.log(curNeighbour);\r\n      // console.log(prevNeighbour);\r\n\r\n      // If this neighbour is the same as the previous one, we want to append this neighbour's value\r\n      // to the element's value array in previewInfoArray at curIndex\r\n      if (curNeighbour === prevNeighbour) {\r\n        // Note, we dont want each element in previewInfoArray to contain too many elements (5), so we do a check here.\r\n        if (previewInfoArray[curIndex].value.length < maxNeighbourCount) {\r\n          previewInfoArray[curIndex].value.push(removePrefix(processedBinding[i].value.value));\r\n        }\r\n      }\r\n      // Else, we push a fresh element onto previewInforArray, and update curIndex\r\n      else {\r\n        previewInfoArray.push(\r\n          {\r\n            \"key\": type === \"subject\" ? processedBinding[i].p.value.slice(28) : \"is \"+processedBinding[i].p.value.slice(28)+\" of\",\r\n            \"value\":[removePrefix(processedBinding[i].value.value)],\r\n          }\r\n        )\r\n        ++curIndex;\r\n      }\r\n    }\r\n  }\r\n\r\n  // At the current stage, previewInfoArray contains all the dbo and dbp neighbours. \r\n  // Let's also add support for the DB categories, so that those can be displayed in cell preview as well.\r\n  let categoryPreviewInfoArray = [];\r\n  if (type === \"subject\") {\r\n    let categoryBinding = resultsBinding.filter(\r\n      a => a.p.value.includes(\"dc/terms/subject\")\r\n    ) \r\n    // console.log(categoryBinding);\r\n    if (categoryBinding.length > 0) {\r\n      categoryPreviewInfoArray.push(\r\n        {\r\n          \"key\": \"Category\",\r\n          \"value\": [categoryBinding[0].value.value.slice(37)]\r\n        }\r\n      );\r\n      for (let i = 1; i < categoryBinding.length; ++i) {\r\n        categoryPreviewInfoArray[0].value.push(categoryBinding[i].value.value.slice(37));\r\n      }\r\n    }\r\n  }\r\n  // We concat categoryPreviewInfoArray with previewInfoArray.\r\n  previewInfoArray = categoryPreviewInfoArray.concat(previewInfoArray);\r\n  // console.log(previewInfoArray);\r\n\r\n  return previewInfoArray;\r\n}\r\n\r\n// This function processes the resultsBinding passed from handleStartSubject, to create the info needed for Action Panel.\r\n// It should share some similarity with updatePreviewInfo\r\n\r\n// It takes one parameter:\r\n// 1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n// Note: \"type\" parameter is not needed, since we are not dealing with object neighbours\r\n\r\nfunction updateFirstColSelection(resultsBinding) {\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n  // Note: the second criteria is a bit different from updateKeyColNeighbours and updatePreviewInfo\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\", \"property\", or \"dc/terms/subject\" (so it is one of dbo:XXXX, dbp:XXXX, or dct:subject)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 \r\n         &&\r\n         (a.p.value.includes(\"ontology\") \r\n         || a.p.value.includes(\"property\")\r\n         || a.p.value.includes(\"dc/terms/subject\")\r\n         ) \r\n         &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         )\r\n  );\r\n  \r\n  // We then sort the processedBinding by some criterias.\r\n\r\n  // First Criteria: dct:subjects should show up at the top of the list, sorted by o.value.slice(37).\r\n\r\n  // Since a customized sort is a bit hard to write, let's break this array into two, sort each one, then concat them back together\r\n  let dctArray = [];\r\n  let dbopArray = [];\r\n  for (let i = 0; i < processedBinding.length; ++i) {\r\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\r\n      dctArray.push(processedBinding[i]);\r\n    }\r\n    else {\r\n      dbopArray.push(processedBinding[i]);\r\n    }\r\n  }\r\n\r\n  // We first sort the dctArray by o.value.slice(37).\r\n\r\n  dctArray.sort((a, b) => (a.o.value.slice(37) < b.o.value.slice(37) ? -1 : 1));\r\n\r\n  // We then sort dbop array by the following rules:\r\n  // Those that are dbr (so without a datatype) shows up higher\r\n  // Then those with a smaller count shows up higher\r\n  // Then alphabetical order.\r\n\r\n  // The following code gets the count for each property(or neighbour)\r\n  dbopArray.sort((a, b) => (a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1));\r\n  if (dbopArray.length > 0) {\r\n    dbopArray[0].p.count = getPCount(dbopArray[0].p.value, dbopArray);\r\n  }\r\n  for (let i = 1; i < dbopArray.length; ++i) {\r\n    let prevNeighbour = dbopArray[i-1];\r\n    let curNeighbour = dbopArray[i];\r\n    if (prevNeighbour.p.value === curNeighbour.p.value) {\r\n      curNeighbour.p.count = prevNeighbour.p.count;\r\n    }\r\n    else {\r\n      curNeighbour.p.count = getPCount(dbopArray[i].p.value, dbopArray);\r\n    }\r\n  }\r\n\r\n  // The following code sorts the array\r\n  dbopArray.sort(function (a, b) {\r\n    if (a.o.datatype === undefined && b.o.datatype !== undefined) {\r\n      return -1;\r\n    }\r\n    else if (b.o.datatype === undefined && a.o.datatype !== undefined) {\r\n      return 1;\r\n    }\r\n    else {\r\n      if (a.p.count === b.p.count) {\r\n        return a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1;\r\n      }\r\n      else {\r\n        return a.p.count < b.p.count ? -1 : 1;\r\n      }\r\n    }\r\n  });\r\n  // console.log(dbopArray);\r\n\r\n  // At this stage, we have finished sorting both dctArray and dbopArray. Let's put them back together.\r\n  processedBinding = dctArray.concat(dbopArray);\r\n\r\n  // console.log(processedBinding);\r\n\r\n  // Now we need to loop over the processedBinding, and create an array of objects. \r\n  // This array should have length equal to processedBinding.length.\r\n  // Each object should have 6 attributes.\r\n  // 1) pValue: value of predicate\r\n  // 2) pDataset: which dataset does this predicate belong to (one of dbo, dbp, and dct)\r\n  // 3) oValue: value of object\r\n  // 4) oType: datatype of object, such as \"http://www.w3.org/2001/XMLSchema#date\". This can be empty.\r\n\r\n  // 5) value: same as pValue: historical code\r\n  // 6) label: same as pValue: historical code\r\n\r\n  let firstColSelection = [];\r\n\r\n  for (let i = 0; i < processedBinding.length; ++i) {\r\n    // First case: current neighbour is from dct:subject\r\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\r\n      firstColSelection.push(\r\n        {\r\n          \"pValue\":\"category\",\r\n          \"pDataset\":\"dct\",\r\n          \"oValue\":processedBinding[i].o.value.slice(37),\r\n          \"oType\":\"\",\r\n          \"value\":\"category\",\r\n          \"label\":processedBinding[i].o.value.slice(37),\r\n        }\r\n      )\r\n    }\r\n    // Second case: current neighbour is from dbo or dbp\r\n    else {\r\n      firstColSelection.push(\r\n        {\r\n          \"pValue\":processedBinding[i].p.value.slice(28),\r\n          \"pDataset\":processedBinding[i].p.value.includes(\"property\") ? \"dbp\" : \"dbo\",\r\n          \"oValue\":removePrefix(processedBinding[i].o.value),\r\n          \"oType\":processedBinding[i].o.datatype === undefined ? \"\" : processedBinding[i].o.datatype,\r\n          \"value\":processedBinding[i].p.value.slice(28),\r\n          \"label\":processedBinding[i].p.value.slice(28)+\":\"+removePrefix(processedBinding[i].o.value),\r\n        }\r\n      )\r\n    }\r\n  }\r\n  return firstColSelection;\r\n}\r\n\r\n\r\n// This function takes in the clean data for the first table, clean data for the second table, and colMapping between these two tables\r\n// And returns the unioned clean data for the first table\r\n\r\nfunction tableConcat(tableData, otherTableData, tempMapping) {\r\n  // We want to correctly modify tableDataExplore, based on colMapping.\r\n  // If colMapping is null for some column, we want to set the data as \"N/A\"\r\n  // console.log(tableDataExplore);\r\n\r\n  // We first make some small modifications to colMapping, as we have inserted a new column into otherTableData and tableDataExplore\r\n  for (let j = 0; j < tempMapping.length; ++j) {\r\n    if (tempMapping[j] !== \"null\") {\r\n      tempMapping[j]++;\r\n    }\r\n  }\r\n  tempMapping.splice(0, 0, 0); // insert element 0 at the first position of colMapping, deleting 0 elements\r\n\r\n  // Now we insert the data into dataToAdd. dataToAdd will be concatenated with tableDataExplore\r\n  let dataToAdd = [];\r\n  for (let i = 0; i < otherTableData.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < tempMapping.length; ++j) {\r\n      let colInNew = tempMapping[j];\r\n      if (colInNew !== \"null\") {\r\n        tempRow.push(otherTableData[i][colInNew]);\r\n      } else {\r\n        tempRow.push({ data: \"N/A\" });\r\n      }\r\n    }\r\n    dataToAdd.push(tempRow);\r\n  }\r\n  return tableData.concat(dataToAdd);\r\n}\r\n\r\nfunction HTMLCleanCell(str) {\r\n  // Note that this function also removes leading and trailing whitespaces\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1).trim().split(\"[\")[0];\r\n  } else {\r\n    return str.trim().split(\"[\")[0];\r\n  }\r\n}\r\n\r\n// This function returns an array of table objects that are unionable with the selected table.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"tableHTML\" storing the HTML of the selected table\r\n//  2) HTML \"pageHTML\", storing the HTML of a sibling page\r\n\r\n// Table object has four attributes: isOpen, data, unionScore, colMapping\r\n\r\n// Once semantic mapping feature is added, the colMapping will be updated\r\n\r\nfunction findTableFromHTML(\r\n  tableHeader,\r\n  pageHTML,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // We first get the column names of the table in the table panel, using this.state.tableHeader.\r\n  // Note: the index starts from 1 because we don't care about the originURL column (column 0). ***\r\n  let originCols = [];\r\n  // BUGFIX needs to be applied here. (Seems to be fixed)\r\n  // console.log(tableHeader);\r\n  for (let j = 1; j < tableHeader.length; ++j) {\r\n    let curValue = \"\"\r\n    for (let k = 0; k < tableHeader[j].length; ++k) {\r\n      curValue+=tableHeader[j][k].value;\r\n    }\r\n    originCols.push(curValue);\r\n  }\r\n\r\n  // We now fetch all the tables from pageHTML (the current sibling page)\r\n  let doc = new DOMParser().parseFromString(pageHTML, \"text/html\");\r\n  let wikiTablesFound = doc.getElementsByClassName(\"wikitable\");\r\n  let tablesFound = [];\r\n  for (let i = 0; i < wikiTablesFound.length; ++i) {\r\n    if (wikiTablesFound[i].tagName !== \"TH\") {\r\n      tablesFound.push(wikiTablesFound[i]);\r\n    }\r\n  }\r\n\r\n  // console.log(tablesFound);\r\n\r\n  // This is the array we will return.\r\n  let tableArray = [];\r\n\r\n  // We now loop through all the tables found on this sibling page, and see if they are unionable with the selected table\r\n  let tablePromise = [];\r\n  for (let i = 0; i < tablesFound.length; ++i) {\r\n    tablePromise.push(\r\n      findTableFromTable(\r\n        tablesFound[i],\r\n        originCols,\r\n        selectedClassAnnotation,\r\n        semanticEnabled,\r\n        unionCutOff,\r\n        pageName\r\n      )\r\n    );\r\n  }\r\n\r\n  return allPromiseReady(tablePromise).then((values) => {\r\n    for (let i = 0; i < values.length; ++i) {\r\n      tableArray.push(values[i]);\r\n    }\r\n    // we filter the tableArray here by removing those tables that do not have a high enough unionScore\r\n    // Note: In the unfiltered table array, we are using -1 to represent tables with a low unionScore\r\n    tableArray = tableArray.filter(function (x) {\r\n      return x !== -1;\r\n    });\r\n    // console.log(tableArray);\r\n    // We sort the tableArray here by unionScore\r\n    tableArray.sort((a, b) => (a.unionScore < b.unionScore ? 1 : -1));\r\n    return Promise.resolve(tableArray);\r\n  });\r\n}\r\n\r\n// This function takes in four parameters:\r\n\r\n// 1) a tableHTML\r\n// 2) originCols (denoting the columns names of the selected table)\r\n// 3) class annotation of the selected table\r\n// 4) whether semantic mapping is enabled or not\r\n\r\n// and return a table Object with properties: isOpen, unionScore, colMapping, and data\r\nfunction findTableFromTable(\r\n  tableHTML,\r\n  originCols,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // Define some constants\r\n  const ontologySize = 780;\r\n  const matchCutOff = 0.999;\r\n\r\n  // We first fetch the cleaned column names of the current table\r\n  let curHeaderCells = tableHTML.rows[0].cells;\r\n  let newCols = []; // stores the cleaned column names of the this table. Let's consider using this value for display as well.\r\n  let remainCols = []; // stores an array of the indices of the columns of the current table that are not yet mapped\r\n  let searchCols = []; // stores an array of the indices of the columns from the selected table that are not yet mapped\r\n\r\n  // We potentially need to resort to semantic mapping. So let's create a promiseArray.\r\n  // This promiseArray will only contain one element\r\n  let promiseArray = [];\r\n\r\n  for (let j = 0; j < curHeaderCells.length; ++j) {\r\n    let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\r\n    newCols.push(headerName);\r\n    remainCols.push(j);\r\n  }\r\n\r\n  // we want to make sure that newTable has more than half of the columns of the selectedTable\r\n  // because we require a >50% unionScore\r\n  // If it does not, we ignore this table automatically\r\n\r\n  if (newCols.length >= originCols.length * unionCutOff) {\r\n    // We use the proposed algo here.\r\n    // First we set the union score and column Mapping\r\n    let unionScore = 0;\r\n    let colMapping = [];\r\n    // We loop through the column headers in originCol, and see if they exist in newCols.\r\n    for (let k = 0; k < originCols.length; ++k) {\r\n      let curIndex = newCols.indexOf(originCols[k]);\r\n      if (curIndex !== -1) {\r\n        // This means the new table also contains column k from the selected table\r\n        // Thus we have found a mapping. We push it onto colMapping.\r\n        colMapping.push(curIndex);\r\n        unionScore += 1 / originCols.length;\r\n      } else {\r\n        colMapping.push(\"null\");\r\n      }\r\n    }\r\n    // In here we do a bit of string matching\r\n    // Chances are: tables from sibling pages with the same number of columns as the selected table, with structual invariability,\r\n    // is likely to be the \"same\" table as the selected on, we give it a chance for string matching\r\n    if (newCols.length === originCols.length) {\r\n      let sameStructure = true;\r\n      for (let i = 0; i < colMapping.length; ++i) {\r\n        if (colMapping[i] !== \"null\" && colMapping[i] !== i) {\r\n          sameStructure = false;\r\n          break;\r\n        }\r\n      }\r\n      if (sameStructure === true) {\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            if (\r\n              newCols[i].includes(originCols[i]) ||\r\n              originCols[i].includes(newCols[i])\r\n            ) {\r\n              colMapping[i] = i;\r\n              unionScore += 1 / originCols.length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // console.log(colMapping);\r\n      // If unionScore is 1, and newCols.length is equal to originCols.length, we want to reward it with 0.01 unionScore\r\n      // This helps us to rank the tables with the exact same column headers a bit higher\r\n      if (unionScore === 1) {\r\n        unionScore += 0.01;\r\n      }\r\n    }\r\n\r\n    // We proceed differently based on whether semantic mapping is enabled or not\r\n\r\n    // Case 1: semantic mapping is enabled\r\n\r\n    if (semanticEnabled === \"enabled\") {\r\n      // If we are not finding a perfect match, we want to do use semantic mapping here to see if it's possible to map the unmapped columns\r\n      // Note: this part is expected to take quite some time. Now it's implemented just for testing purposes\r\n      if (unionScore < 0.999) {\r\n        // We want to remove from remainCols the columns that are already mapped\r\n        // The remaining will be the columns that we can still use from the current table\r\n        remainCols = remainCols.filter(function (x) {\r\n          return colMapping.indexOf(x) < 0;\r\n        });\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            searchCols.push(i);\r\n          }\r\n        }\r\n        // if (newCols[1] === \"Scorer\") {\r\n        // console.log(\"We still need to find these columns from the original table: \"+searchCols);\r\n        // console.log(\"These columns are still available for use: \"+remainCols);\r\n        // console.log(\"The current column mappings are \"+colMapping);\r\n        // console.log(\"Here are the class annotations of the search columns: \")\r\n        // for (let i=0;i<searchCols.length;++i) {\r\n        //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n        // }\r\n        // }\r\n\r\n        // Now, searchCols stores the columns from the selected table that have not been mapped yet\r\n        // and remainCols stores the columns from the current table that can still be used for mapping\r\n        // Let's ask a query to find the class annotations for the remainCols\r\n        // if (remainCols.length > 0) {\r\n        promiseArray.push(findClassAnnotation(tableHTML, remainCols, pageName));\r\n        // }\r\n      }\r\n\r\n      // Because the return statement is here, it may be possible that we are pushing nothing onto the promiseArray!!!\r\n      // There is no need to worry about it.\r\n      return allPromiseReady(promiseArray).then((values) => {\r\n        // First, if we are in the perfect match case, we want to retrun straight away\r\n        if (unionScore >= 0.999) {\r\n          return Promise.resolve({\r\n            isOpen: false,\r\n            unionScore: unionScore,\r\n            colMapping: colMapping,\r\n            data: tableHTML,\r\n            title: newCols,\r\n          });\r\n        }\r\n        // Else, we want to look for semantic mapping opportunities\r\n        else {\r\n          // create a copy of values\r\n\r\n          // Note!!!! Sometimes the tableHTML only has one row, so values[0] would have a length of zero, in which case our algo breaks down\r\n          // Let's prevent it from happening\r\n          let remainClassAnnotation = values[0].slice();\r\n          if (remainClassAnnotation.length > 0) {\r\n            // let remainColsCopy = remainCols.slice();\r\n            // let remainClassAnnotationCopy = remainClassAnnotation.slice();\r\n            for (let i = 0; i < searchCols.length; ++i) {\r\n              let curSearchIndex = searchCols[i];\r\n              // console.log(curSearchIndex);\r\n              // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n              // If the class annotation for this column is empty, we skip it because there's no hope for semantic match.\r\n              // Otherwise we can work with it\r\n              if (selectedClassAnnotation[curSearchIndex].length > 0) {\r\n                // console.log(\"Current column being searched has index: \"+curSearchIndex);\r\n                // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n                // we loop through the remain cols and check their class annotations\r\n                for (let j = 0; j < remainCols.length; ++j) {\r\n                  // Let make sure this column does have a class annotation. Otherwise we skip it\r\n                  // console.log(remainClassAnnotation[j]);\r\n                  // Note: sometimes remainClassAnnotation[j] is undefined, which causes an error\r\n                  // if (remainClassAnnotation[j] === undefined) {\r\n                  //   console.log(\"This case is causing an error\");\r\n                  //   console.log(\"Remain cols are \"+remainCols);\r\n                  //   console.log(\"Remain class annotations are \"+remainClassAnnotation);\r\n                  //   console.log(\"Original remain cols are \"+remainColsCopy);\r\n                  //   console.log(\"original remain class annotations are \"+remainClassAnnotationCopy);\r\n                  //   console.log(\"Table HTML is \");\r\n                  //   console.log(tableHTML);\r\n                  //   console.log(values[0]);\r\n                  // }\r\n                  if (remainClassAnnotation[j].length > 0) {\r\n                    // console.log(\"Remain column index is \"+remainCols[j]);\r\n                    // console.log(\"Its class annotation is \"+remainClassAnnotation[j]);\r\n                    // Let make special cases when the any of search column class and current column class is [Number]\r\n                    // If they are both [Number], we will give it a match\r\n                    // Else it's not a match\r\n                    if (\r\n                      selectedClassAnnotation[curSearchIndex][0] === \"Number\" ||\r\n                      remainClassAnnotation[j][0] === \"Number\"\r\n                    ) {\r\n                      // This case we have a match\r\n                      if (\r\n                        selectedClassAnnotation[curSearchIndex][0] ===\r\n                        remainClassAnnotation[j][0]\r\n                      ) {\r\n                        // We need to update the colMapping and unionScore\r\n                        colMapping[curSearchIndex] = remainCols[j];\r\n                        unionScore += 1 / originCols.length;\r\n                        // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                        remainCols.splice(j, 1);\r\n                        remainClassAnnotation.splice(j, 1);\r\n                        // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                        // j to go back to the correct posiition\r\n                        --j;\r\n                        // Also we need to call break to prevent further looping: we are done with this search column\r\n                        break;\r\n                      }\r\n                      // Else there is no match. We simply ignore it.\r\n                    }\r\n                    // If neither of them is [Number], we need to use the test statistic\r\n                    else {\r\n                      // Let's first find the array intersection of selectedClassAnnotation[curSearchIndex] and remainClassAnnotation[j]\r\n                      let intersection = selectedClassAnnotation[\r\n                        curSearchIndex\r\n                      ].filter(function (x) {\r\n                        return remainClassAnnotation[j].indexOf(x) >= 0;\r\n                      });\r\n                      // console.log(\"Intersection is \"+intersection);\r\n                      // We only want to consider two column unionable if they at least have some intersections.\r\n                      if (intersection.length > 0) {\r\n                        let totalSuccess =\r\n                          selectedClassAnnotation[curSearchIndex].length;\r\n                        let numTrial = remainClassAnnotation[j].length;\r\n                        let numSuccess = intersection.length;\r\n                        let testStat = hyperCDF(\r\n                          numSuccess,\r\n                          ontologySize,\r\n                          totalSuccess,\r\n                          numTrial\r\n                        );\r\n                        // If testStat is larger than matchCutOff, we consider it a match\r\n                        if (testStat > matchCutOff) {\r\n                          // We need to update the colMapping and unionScore\r\n                          colMapping[curSearchIndex] = remainCols[j];\r\n                          unionScore += 1 / originCols.length;\r\n                          // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                          remainCols.splice(j, 1);\r\n                          remainClassAnnotation.splice(j, 1);\r\n                          // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                          // j to go back to the correct posiition\r\n                          --j;\r\n                          // Also we need to call break to prevent further looping: we are done with this search column\r\n                          break;\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          // console.log(\"Remain columns are \"+)\r\n          // console.log(\"Here is table HTML\");\r\n          // console.log(tableHTML);\r\n          // console.log(\"Here are the class annotations for columns that still need mapping\");\r\n          // for (let i=0;i<searchCols.length;++i) {\r\n          //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n          // }\r\n          // console.log(\"The remain columns are \"+remainCols);\r\n          // console.log(\"Here are the class annotations for the remaining columns\");\r\n          // console.log(values);\r\n          // console.log(\"This is column mapping \"+colMapping);\r\n          // console.log(\"Union score is \"+unionScore);\r\n\r\n          // We need to loop through the searchCols\r\n\r\n          // We push on tables with unionScore > unionCutOff\r\n          if (unionScore >= unionCutOff) {\r\n            // console.log(\"This table is unionable!\");\r\n            // console.log(\"Table is \"+tableHTML);\r\n            // console.log(\"Union Score is \"+unionScore);\r\n            // console.log(\"Column mapping is \"+colMapping);\r\n            // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n            // console.log(colMapping);\r\n            return Promise.resolve({\r\n              isOpen: false,\r\n              unionScore: unionScore,\r\n              colMapping: colMapping,\r\n              data: tableHTML,\r\n              title: newCols,\r\n            });\r\n          } else {\r\n            return Promise.resolve(-1);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Case 2: semantic mapping is disabled.\r\n    // In this case we check if the unionScore is high enough directly, without going through the semantic mapping process\r\n    else {\r\n      // We push on tables with unionScore > unionCutOff\r\n      if (unionScore >= unionCutOff) {\r\n        // console.log(\"This table is unionable!\");\r\n        // console.log(\"Table is \"+tableHTML);\r\n        // console.log(\"Union Score is \"+unionScore);\r\n        // console.log(\"Column mapping is \"+colMapping);\r\n        // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n        // console.log(colMapping);\r\n        return Promise.resolve({\r\n          isOpen: false,\r\n          unionScore: unionScore,\r\n          colMapping: colMapping,\r\n          data: tableHTML,\r\n          title: newCols,\r\n        });\r\n      } else {\r\n        return Promise.resolve(-1);\r\n      }\r\n    }\r\n  }\r\n  // This else clause means that this table does not even have enough number of columns.\r\n  // So we know right away it cannot be a match. So we return -1 (failure)\r\n  else {\r\n    return Promise.resolve(-1);\r\n  }\r\n}\r\n\r\n// This function takes in the HTML of a table, and returns a Promise that resolves to the class annotation for all the columns of the table\r\nfunction findClassAnnotation(tableHTML, remainCols, pageName) {\r\n  // console.log(\"Page Name is: \"+pageName);\r\n  // console.log(\"Table HTML is: \");\r\n  // console.log(tableHTML);\r\n  // console.log(remainCols);\r\n  let selectedTable = tableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // Note: this function potentially needs to be modified.\r\n  // Instead of using innerText for cell data, if its href exists, we should use its href instead\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n\r\n      // Note: We want to use the href as data for the first column (if such href exists) instead of its innerText.\r\n      if (i === 1) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = hrefArray[hrefArray.length - 1];\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            rowSpan: 1,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(\"Table data is: \");\r\n  // console.log(tempTable);\r\n\r\n  // Now tempTable contains the clean data we can use\r\n  let promiseArray = [];\r\n  // We take the minimum of (1, tempTable.length-1) number of values from each column to determine its class annotation\r\n  // Note!! This -1 here is important. It excludes the row corresponding to the column headers\r\n  let remainEntries = Math.min(1, tempTable.length - 1);\r\n\r\n  // This is a placeholder array to solve the 2D problem. It's a 1D array containing remainEntries number of -1's\r\n  // let placeHolderArray = [];\r\n  // let notFoundArray = [];\r\n  // for (let i=0;i<remainEntries;++i) {\r\n  //   placeHolderArray.push(-1);\r\n  //   notFoundArray.push(\"null\");\r\n  // }\r\n\r\n  // Let's loop through the table to ask our queries.\r\n  // If remainCols are undefined, we take every columns from the tempTable;\r\n  if (remainCols === undefined) {\r\n    remainCols = [];\r\n    for (let j = 0; j < tempTable[0].length; ++j) {\r\n      remainCols.push(j);\r\n    }\r\n  }\r\n\r\n  // console.log(\"Remain columns are: \"+remainCols);\r\n  for (let j = 0; j < remainCols.length; ++j) {\r\n    // console.log(\"We are taking this number of entries from this table: \"+remainEntries);\r\n    // Find the current column index\r\n    let curColIndex = remainCols[j];\r\n    // console.log(\"Current column index is: \"+curColIndex);\r\n\r\n    // Loop through the first three (or one) entries from this column\r\n    for (let i = 1; i <= remainEntries; ++i) {\r\n      // Here we make the query\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL =\r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      // console.log(tempTable[i][j].data);\r\n      // console.log(regexReplace(tempTable[i][j].data));\r\n      // console.log(tempTable[i][curColIndex]);\r\n      let curEntry =\r\n        tempTable[i][curColIndex] === undefined\r\n          ? \"NONEXISTING\"\r\n          : regexReplace(tempTable[i][curColIndex].data);\r\n      // console.log(curEntry);\r\n      // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n      // console.log(!isNaN(Number(curEntry)));\r\n      // console.log(\"Replaced data is \"+curEntry);\r\n      // console.log(curEntry === \"\");\r\n\r\n      // If we found out that the current entry is a number, we do not want to send a query.\r\n      // Note: Number(\"\") will show up as a number!! This was one of the bugs that we fixed\r\n      if (!isNaN(Number(curEntry)) && curEntry !== \"\") {\r\n        promiseArray.push(Promise.resolve([\"Number\"]));\r\n      }\r\n      // Else if we find the curEntry is too long, it will likely not exist in DBPedia\r\n      else if (curEntry.length > 40) {\r\n        promiseArray.push(Promise.resolve([\"Null\"]));\r\n      }\r\n      // Else we construct the query\r\n      else {\r\n        // console.log(\"Cur Entry is \"+curEntry);\r\n        if (curEntry === undefined || curEntry === \"\") {\r\n          curEntry = \"NONEXISTING\";\r\n        }\r\n        // if (curEntry === \"Sergio_Agero\") {\r\n        //   console.log(\"We have another problem here\");\r\n        // }\r\n        // console.log(curEntry);\r\n        // console.log(tempTable[i][curColIndex].data);\r\n        // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n        let queryBody =\r\n          \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n          curEntry +\r\n          \"+rdf%3Atype+%3Fo.%0D%0A++++++BIND%28STR%28%3Fo%29+AS+%3FoString+%29.%0D%0A++++++FILTER%28regex%28%3FoString%2C%22dbpedia.org%2Fontology%2F%22%2C%22i%22%29%29%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        // if (curEntry === \"Bangor_City_F%5Cu002EC%5Cu002E\") {\r\n        //   console.log(\"There is something wrong with this entry\")\r\n        //   console.log(queryURL);\r\n        // }\r\n        // console.log(\"Query is constructed!\");\r\n        // if (queryURL === \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\") {\r\n        //   console.log(\"Here is where the problem occurs\");\r\n        // }\r\n        // console.log(queryURL);\r\n        promiseArray.push(fetchJSON(queryURL));\r\n        // console.log(\"Query pushed successfully. This is queryBody: \");\r\n        // console.log(queryBody);\r\n      }\r\n    }\r\n  }\r\n  return allPromiseReady(promiseArray).then((values) => {\r\n    // console.log(values);\r\n    // for (let i=0;i<values.length;++i) {\r\n    //   console.log(values[i]);\r\n    // }\r\n    // console.log(\"Query results from Virtuoso are:\");\r\n    // console.log(values);\r\n    let classAnnotation = [];\r\n    for (let j = 0; j < remainCols.length; ++j) {\r\n      // console.log(\"Number of remain cols is \"+remainCols.length);\r\n      let curColumnClass = [];\r\n      // If we are dealing with number results, we just want to push on an array with one element \"Number\"\r\n      if (values[remainEntries * j] !== undefined) {\r\n        if (values[remainEntries * j][0] !== undefined) {\r\n          if (values[remainEntries * j][0] === \"Number\") {\r\n            classAnnotation.push([\"Number\"]);\r\n          }\r\n          // If we are dealing with invalid results, we just want to push on an empty array\r\n          else if (values[remainEntries * j][0] === \"Null\") {\r\n            classAnnotation.push([]);\r\n          }\r\n        }\r\n        // if (values[remainEntries*j][0] === -1) {\r\n        //   classAnnotation.push([\"Number\"]);\r\n        // }\r\n        // // If we are dealing with invalid results, we just want to push on an empty array\r\n        // else if (values[remainEntries*j][0] === \"null\") {\r\n        //   classAnnotation.push([]);\r\n        // }\r\n        // Else, we find its class annotation from query results\r\n        else {\r\n          for (let i = 0; i < remainEntries; ++i) {\r\n            let curCellClass = [];\r\n            // console.log(remainEntries*j+i);\r\n            let bindingArray = values[remainEntries * j + i].results.bindings;\r\n            for (let k = 0; k < bindingArray.length; ++k) {\r\n              curCellClass.push(bindingArray[k].o.value.slice(28));\r\n            }\r\n            curColumnClass = [...new Set([...curColumnClass, ...curCellClass])];\r\n          }\r\n          classAnnotation.push(curColumnClass);\r\n        }\r\n      }\r\n    }\r\n    // return classAnnotation;\r\n    // console.log(\"Current class annotation is \");\r\n    // if (pageName === \"200910_Premier_League\") {\r\n    //   console.log(\"TableData is \");\r\n    //   console.log(tempTable);\r\n    //   console.log(classAnnotation);\r\n    // }\r\n    // console.log(classAnnotation);\r\n\r\n    return Promise.resolve(classAnnotation);\r\n  });\r\n}\r\n\r\n// This function returns a 2D array of objects representing the data for tableDataExplore.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"selectedTableHTML\" storing the HTML of a table\r\n//  2) string \"urlOrigin\", storing which page this table is from\r\n\r\n// It returns a 2D array of objects representing the data for tableDataExplore.\r\nfunction setTableFromHTML(selecteTableHTML, urlOrigin) {\r\n  let selectedTable = selecteTableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // This is the part where we make the modification: use links instead of cell literals\r\n\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n      // Note: We want to use the href as data (if such href exists) instead of its innerText.\r\n      if (i > 0) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = decodeURIComponent(hrefArray[hrefArray.length - 1]);\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        origin: urlOrigin,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            origin: urlOrigin,\r\n            rowSpan: tempTable[i][j].rowSpan,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              origin: urlOrigin,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now add in an additional column: the originURL of the page\r\n  tempTable[0].splice(0, 0, {\r\n    data: \"OriginURL\",\r\n    origin: urlOrigin,\r\n    rowSpan: 1,\r\n    colSpan: 1,\r\n  });\r\n  for (let i = 1; i < tempTable.length; ++i) {\r\n    tempTable[i].splice(0, 0, {\r\n      data: urlOrigin,\r\n      origin: \"null\",\r\n      rowSpan: 1,\r\n      colSpan: 1,\r\n    });\r\n  }\r\n  return tempTable; // tempTable is a 2D array of objects storing the table data. Object has two fields: data(string) and origin(string).\r\n}\r\n\r\n// This function takes in 1 parameter\r\n// 1) tableDataExplore, returned from setTableFromHTML.\r\n\r\n// And returns tableData (with no header rows) that can be unioned with the selected table.\r\n\r\nfunction setUnionData(tableDataExplore) {\r\n\r\n  // We first need to set the tableHeader, so that cells have the correct origins\r\n  let tableHeader = [];\r\n  for (let j=0;j<tableDataExplore[0].length;++j) {\r\n    tableHeader.push(\r\n      {\"value\":tableDataExplore[0][j].data\r\n      ,\"label\":tableDataExplore[0][j].data}\r\n    )\r\n  }\r\n  // We then need to handle both data and origin.\r\n  let tableData = [];\r\n  // console.log(tableDataExplore);\r\n  // This starts the loop for rows\r\n  for (let i=1;i<tableDataExplore.length;++i) {\r\n    let tempRow = [];\r\n    // This starts the loop for columns\r\n    for (let j=0;j<tableDataExplore[i].length;++j) {\r\n      // First set the data\r\n      let data = tableDataExplore[i][j].data;\r\n      // Then set the origin\r\n      let origin = [];\r\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\r\n      origin.push(originText);\r\n      tempRow.push({\"data\":data,\"origin\":origin});\r\n    }\r\n    tableData.push(tempRow);\r\n  }\r\n  return tableData;\r\n}\r\n\r\n// This function takes in four parameters and return the CDF for hypergeometric distribution, for x\r\n// N: total number of elements (780 in our case)\r\n// K: total number of successful elements (length of selected column's class annotation)\r\n// n: number of trials (length of test column's class annotation)\r\n// x: (length of intersection of selected column and test column)\r\n\r\nfunction hyperCDF(x, N, K, n) {\r\n  let count = 0;\r\n  // console.log(combinations(5,2));\r\n  let denom = combinations(N, n);\r\n  for (let i = 0; i <= x; ++i) {\r\n    count += (combinations(K, i) * combinations(N - K, n - i)) / denom;\r\n  }\r\n  return count;\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\nfunction niceRender(str) {\r\n  let resultStr = str;\r\n  let bracketIndex = str.indexOf(\"(\");\r\n  // If ( is present in a string, we want to remove it\r\n  // We include the -1 because usually ( is preceeded by _\r\n  if (bracketIndex !== -1) {\r\n    resultStr = resultStr.slice(0, bracketIndex-1);\r\n  }\r\n  // now we turn all \"_\" into \" \"\r\n  return resultStr.replace(/_/g, \" \");\r\n}\r\n\r\n// This function takes in four parameters: \r\n// 1) resultsBinding: an array of JSON values representing entities satisfying the first column\r\n// 2) tableData:      the tableData before update\r\n// 3) tableHeader:    this.state.tableHeader\r\n// 4) colIndex:       which column usersa are filling (usually 0)\r\n\r\n// and returns the updated tableData, after updates have been made to the first column.\r\n\r\nfunction setFirstColumnData(resultsBinding, tableData, tableHeader, colIndex) {\r\n  // First we get the correct number of rows, which is equal to min(values[0].results.bindings.length, initialRowNum)\r\n  let updatedRowCount = Math.min(resultsBinding.length, initialRowNum);\r\n  // console.log(\"Original length is \"+values[0].results.bindings.length);\r\n  // console.log(\"Row Count is: \"+updatedRowCount);\r\n\r\n  // If tableData currently has too many rows, we slice it.\r\n  if (tableData.length > updatedRowCount) {\r\n    tableData = tableData.slice(0,updatedRowCount);\r\n  }\r\n  // Else, if tableData currently has too few rows, we need to add some empty rows.\r\n  else if (tableData.length < updatedRowCount) {\r\n    let rowsToAdd = updatedRowCount - tableData.length;\r\n    for (let i = 0; i < rowsToAdd; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < initialColNum; ++j) {\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n  }\r\n\r\n  let rowNum = tableData.length;\r\n  // console.log(\"Number of rows is \"+rowNum);\r\n\r\n  // We do not want to overwrite entries that users have filled in.\r\n  // Let's calculate how many entries we want to fill in.\r\n  let emptyEntryCount = rowNum;\r\n  for (let i = 0; i < rowNum; ++i) {\r\n    if (tableData[i][colIndex].data !== \"\") {\r\n      emptyEntryCount--;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  // console.log(\"number of empty entries is \"+emptyEntryCount);\r\n\r\n  let startingIndex = rowNum - emptyEntryCount;\r\n  // console.log(\"Starting index is\"+startingIndex);\r\n\r\n  for (let i = 0; i < emptyEntryCount; ++i) {\r\n    tableData[i + startingIndex][colIndex].data = \r\n      resultsBinding[i].somevar.value.slice(28);\r\n  }\r\n\r\n  // second part sets the origin for each cell\r\n  for (let i = 0; i < rowNum; ++i) {\r\n    // For the first column, let's just use its data as the origin\r\n    let tempOrigin = tableData[i][colIndex].data;\r\n    tableData[i][colIndex].origin.push(tempOrigin);\r\n  }\r\n\r\n  // Now we dedup by tableData by tableData[i][0].data\r\n  tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\r\n\r\n  // console.log(tableData);\r\n  return tableData;\r\n}\r\n\r\n// The following function takes in 2D array recording information of neighbours for the search column\r\n\r\n// It return a desired oneD keyColNeighbours that we can give to selection Headers.\r\n\r\nfunction processAllNeighbours(allNeighboursArray) {\r\n  let keyColNeighbours = [];\r\n  // console.log(allNeighboursArray);\r\n  let allNeighboursArrayCopy = _.cloneDeep(allNeighboursArray);\r\n\r\n  for (let i = 0; i < allNeighboursArrayCopy.length; ++i) {\r\n    keyColNeighbours = keyColNeighbours.concat(allNeighboursArrayCopy[i]);\r\n  }\r\n\r\n  // Now we sort keyColNeighbours based on value\r\n  keyColNeighbours.sort((a,b) => a.value < b.value ? -1 : 1);\r\n  // console.log(keyColNeighbours);\r\n\r\n  // Now, we run a loop to remove duplicates, and update count and filledCount\r\n  if (keyColNeighbours.length > 0) {\r\n    for (let i = 1; i < keyColNeighbours.length; ++i) {\r\n      let prevEntry = keyColNeighbours[i-1];\r\n      let curEntry = keyColNeighbours[i];\r\n\r\n      // If the current entry's data is equal to the previous entry's data, we want to \r\n      // 1) delete curEntry\r\n      // 2) (maybe) update prevEntry's count\r\n      // 3) increment prevEntry's filledCount\r\n      if (prevEntry.value === curEntry.value) {\r\n        keyColNeighbours[i-1].filledCount = keyColNeighbours[i-1].filledCount + 1;\r\n        keyColNeighbours[i-1].count = Math.max(prevEntry.count, curEntry.count);\r\n        keyColNeighbours.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n  }\r\n  // Now we want to sort (and potentially filter) keyColNeighbours, by filledCount \r\n  keyColNeighbours.sort((a,b) => a.filledCount < b.filledCount ? 1 : -1);\r\n\r\n  // Before we return, let's change the label to include filledCount\r\n  for (let i = 0; i < keyColNeighbours.length; ++i) {\r\n    let filledPercent = Math.round(keyColNeighbours[i].filledCount/allNeighboursArrayCopy.length * 100) / 100;\r\n    keyColNeighbours[i].label = keyColNeighbours[i].label + \" (\" + filledPercent + \")\";\r\n  }\r\n\r\n  // Take a look at keyColNeighbours\r\n  // console.log(keyColNeighbours);\r\n\r\n  return keyColNeighbours;\r\n}\r\n\r\n// The following function stores both predicate and object array for all entries in search column.\r\n// Its return value is an array, length is tableData.length\r\n\r\nfunction storeFirstDeg(neighbourArray) {\r\n  // console.log(neighbourArray);\r\n  let firstDegNeighbours = [];\r\n  let neighbourArrayCopy = _.cloneDeep(neighbourArray);\r\n  for (let i = 0; i < neighbourArrayCopy.length; ++i) {\r\n    let tempObj = {};\r\n    for (let j = 0; j < neighbourArrayCopy[i].length; ++j) {\r\n      // The following line creates a deduped version of neighbourArrayCopy[i][j].data, since some bug seems to exist in DBpedia\r\n      let dedupedData = _.uniq(neighbourArrayCopy[i][j].data.slice())\r\n      tempObj[neighbourArrayCopy[i][j].value] = dedupedData;\r\n      // console.log(neighbourArrayCopy[i][j].data.slice());\r\n      // console.log(_.uniq(neighbourArrayCopy[i][j].data.slice()));\r\n      // tempObj[neighbourArrayCopy[i][j].value] = neighbourArrayCopy[i][j].data;\r\n    }\r\n    firstDegNeighbours.push(tempObj);\r\n  } \r\n  // console.log(firstDegNeighbours);\r\n  return firstDegNeighbours;\r\n}\r\n\r\n// This function creates neighbourArrayText from neighbourArray\r\n\r\nfunction createNeighbourText(neighbourArray) {\r\n  let neighbourArrayText = \"\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    if (i > 0) {\r\n      neighbourArrayText+=\" OR \";\r\n    }\r\n    let curNeighbourText = neighbourArray[i].type === \"subject\" ? neighbourArray[i].value : \"is \" + neighbourArray[i].value + \" of\";\r\n    neighbourArrayText+=curNeighbourText;\r\n  }\r\n  return neighbourArrayText;\r\n}\r\n\r\n// This function add in the recommendNeighbours to objects in processedNeighbours.\r\n// It takes in processedSubject(object)Neighbours, and returns the updated version.\r\n\r\n// For each element from processedNeighbours, we want to add an attribute called recommendNeighbours\r\n// recommendNeighbours is an array of objects with three attributes\r\n// 1) value:        value of the recommend attribute\r\n// 2) type:         type of the recommend attribute\r\n// 3) relation:     how the recommend attribute is related to the original attribute: string, or semantic\r\n\r\nfunction addRecommendNeighbours(processedNeighboursCopy) {\r\n  // console.log(processedNeighbours);\r\n  let processedNeighbours = _.cloneDeep(processedNeighboursCopy);\r\n\r\n  // To do this, we need to a double loop over the processedNeighbours\r\n  for (let i = 0; i < processedNeighbours.length; ++i) {\r\n\r\n    // Initialize the recommendNeighbours array\r\n    let recommendNeighbours = [];\r\n    \r\n    for (let j = 0; j < processedNeighbours.length; ++j) {\r\n      // We only look at cases where i !== j\r\n      if (i !== j) {\r\n        // We consider three types of matching\r\n\r\n        // 1st type is String Similarity: if X is a substring of Y, or Y is a substring of X \r\n        let upperStrOne = processedNeighbours[i].value.toUpperCase();\r\n        let upperStrTwo = processedNeighbours[j].value.toUpperCase();\r\n        if (upperStrOne.includes(upperStrTwo) || upperStrTwo.includes(upperStrOne)) {\r\n          recommendNeighbours.push(\r\n            {\r\n              \"value\": processedNeighbours[j].value,\r\n              \"type\": processedNeighbours[j].type,\r\n              \"relation\": \"string\"\r\n            }\r\n          )\r\n        }\r\n\r\n        // 2nd type is semantic: if X and Y has the same range, or same subPropertyOf \r\n        if ((processedNeighbours[i].range === processedNeighbours[j].range && processedNeighbours[i].range !== \"\") ||\r\n            (processedNeighbours[i].subPropertyOf === processedNeighbours[j].subPropertyOf && processedNeighbours[i].subPropertyOf !== \"\")) {\r\n          recommendNeighbours.push(\r\n            {\r\n              \"value\": processedNeighbours[j].value,\r\n              \"type\": processedNeighbours[j].type,\r\n              \"relation\": \"semantic\"\r\n            }\r\n          )\r\n        }\r\n      }\r\n    }\r\n    // We take a look at the recommendNeighbours\r\n    // console.log(\"Current neighbour is \"+processedNeighbours[i].value);\r\n    // if (recommendNeighbours.length > 0) {console.log(recommendNeighbours);}\r\n\r\n    // Now, we create the recommendNeighbours attributes for the current element in processedNeighbours\r\n    processedNeighbours[i][\"recommendNeighbours\"] = recommendNeighbours;\r\n  }\r\n  // console.log(processedNeighbours);\r\n  return processedNeighbours;\r\n}\r\n\r\n// The following function creates the list of recommend attributes passed to the ActionPanel.\r\n\r\n// It takes in one parameter: neighbourArray\r\n// returns an array: recommendArray\r\n\r\nfunction createRecommendArray(neighbourArray) {\r\n  // We create the recommendArray variable using a simple rule:\r\n  // It should be union of recommendNeighbours of all neighbours from neighbourArray, minus the neighbours from neighbourArray\r\n  let recommendArray = [];\r\n\r\n  // First we run a loop to take the union of recommendNeighbours\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    recommendArray = recommendArray.concat(neighbourArray[i].recommendNeighbours);\r\n  }\r\n\r\n  // console.log(neighbourArray);\r\n  // console.log(recommendArray);\r\n\r\n  // We then remove recommendations that are completely duplicated\r\n  recommendArray = _.uniqBy(recommendArray, function(x) {\r\n    return x.value || x.type || x.relation;\r\n  });\r\n  // We then remove recommendations that are already in neighbourArray\r\n  recommendArray = _.differenceBy(recommendArray, neighbourArray, function(x) {\r\n    return x.value || x.type;\r\n  });\r\n  // console.log(recommendArray);\r\n  return recommendArray;\r\n}\r\n\r\n// The following function is a helper function for sorting used in updateFirstColSelection.\r\n\r\nfunction getPCount(str, myArray) {\r\n  let count = 0;\r\n  for (let i = 0; i < myArray.length; ++i) {\r\n    if (myArray[i].p.value === str) {\r\n      ++count\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n// The following function scans through a string, and changes all \" \" to \"+\"\r\n\r\nfunction blankToPlus(str) {\r\n  return str.replace(/\\s/g, \"+\");\r\n}\r\n\r\n// The following function generates queryURL needed for Virtuoso, using information from neighbourArray (or tableHeader[0])\r\n\r\nfunction keyQueryGen(neighbourArray) {\r\n\r\n  // Following boolean is for error detection\r\n  let error = false;\r\n\r\n  // Following is a complete query.\r\n\r\n  // select ?somevar\r\n  // where {\r\n  // ?somevar dct:subject dbc:Obama_family.\r\n  // ?somevar dbp:district \"13\"^^<http://www.w3.org/2001/XMLSchema#integer>.\r\n  // ?somevar dbo:birthPlace dbr:Hawaii.\r\n  // ?somevar dbp:name \"Barack Obama\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#langString>.\r\n  // ?somevar dbo:activeYearsEndDate \"2004-11-04\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n  // }\r\n\r\n  let prefixURL = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  let suffixURL = \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n  let queryBody = \"select+%3Fsomevar%0D%0Awhere+%7B\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    // There are 5 cases that we have to deal with in total\r\n    let textToAdd = \"\"\r\n    // Case 1: dct (%0D%0A%3Fsomevar+dct%3Asubject+dbc%3AObama_family.)\r\n    if (neighbourArray[i].pDataset === \"dct\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+dct%3Asubject+dbc%3A\" \r\n        + regexReplace(neighbourArray[i].oValue) \r\n        + \".\";\r\n    }\r\n    // Case 2: oType is date (%0D%0A%3Fsomevar+dbo%3AactiveYearsEndDate+%222004-11-04%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#date\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\" \r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.\";\r\n    }\r\n    // Case 3: oType is integer (%0D%0A%3Fsomevar+dbp%3Adistrict+%2213%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#integer\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.\";\r\n    }\r\n    // Case 4: oType is string literal (%0D%0A%3Fsomevar+dbp%3Aname+%22Barack+Obama%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + blankToPlus(neighbourArray[i].oValue) // Note no regexReplace here, but blankToPlus is needed\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.\";\r\n    }\r\n    // Case 5: oType is nonnegative integer\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23nonNegativeInteger%3E.\";\r\n    }\r\n    // Case 6: oType is \"\", in this case the object value is some dbr\r\n    else if (neighbourArray[i].oType === \"\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+dbr%3A\"\r\n        + regexReplace(neighbourArray[i].oValue)\r\n        + \".\";\r\n    }\r\n    // Otherwise, we have run into some error potentially\r\n    else {\r\n      console.log(neighbourArray[i].oType);\r\n      error = true;\r\n    }\r\n    queryBody+=textToAdd;\r\n  }\r\n  // Finally we add in the last bit of text to queryBody\r\n  queryBody+=\"%0D%0A%7D%0D%0A&\";\r\n\r\n  // Create the queryURL and take a look\r\n  let queryURL = prefixURL + queryBody + suffixURL;\r\n  \r\n  // We now return. If error is true, we return error, else, we return queryURL\r\n  if (error === true) {\r\n    return \"ERROR\";\r\n  }\r\n  else {\r\n    return queryURL;\r\n  }\r\n}\r\n\r\n// The following is a helper function used to update firstDegNeighbours and keyColNeighbours.\r\n// It makes use of two query result arrays.\r\n\r\n// It return an object with two attributes: firstDegNeighbours and keyColNeighbours\r\n\r\n// This function should be called whenever number of rows are changed.\r\n\r\nfunction updateNeighbourInfo(valuesOne, valuesTwo) {\r\n  // console.log(valuesOne);\r\n  // console.log(valuesTwo);\r\n\r\n  // To support the firstDegNeighbours prefetching, let's store the first degree neighbours in state firstDegNeighbours\r\n  let firstDegNeighbours = {};\r\n\r\n  // First we deal with subject neighbours, so valuesOne\r\n  let subjectNeighbourArray = [];\r\n  for (let i = 0; i < valuesOne.length; ++i) {\r\n    let temp = updateKeyColNeighbours(\r\n      [],\r\n      valuesOne[i].results.bindings,\r\n      \"subject\"\r\n    )\r\n    subjectNeighbourArray.push(temp);\r\n  }\r\n  firstDegNeighbours[\"subject\"] = storeFirstDeg(subjectNeighbourArray);\r\n  let processedSubjectNeighbours = processAllNeighbours(subjectNeighbourArray);\r\n  processedSubjectNeighbours = addRecommendNeighbours(processedSubjectNeighbours);\r\n\r\n  // Then we deal with object neighbours, so valuesTwo\r\n  let objectNeighbourArray = [];\r\n  for (let i = 0; i < valuesTwo.length; ++i) {\r\n    let temp = updateKeyColNeighbours(\r\n      [],\r\n      valuesTwo[i].results.bindings,\r\n      \"object\"\r\n    )\r\n    objectNeighbourArray.push(temp);\r\n  }\r\n  firstDegNeighbours[\"object\"] = storeFirstDeg(objectNeighbourArray);\r\n  let processedObjectNeighbours = processAllNeighbours(objectNeighbourArray);\r\n  processedObjectNeighbours = addRecommendNeighbours(processedObjectNeighbours);\r\n\r\n  // we now concat subjectNeighbours and objectNeighbours together\r\n  let keyColNeighbours = processedSubjectNeighbours.concat(processedObjectNeighbours);\r\n\r\n  // console.log(keyColNeighbours);\r\n  // console.log(firstDegNeighbours);\r\n  return {\r\n    \"firstDegNeighbours\":firstDegNeighbours,\r\n    \"keyColNeighbours\":keyColNeighbours,\r\n  }\r\n}\r\n\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\n// import Header from \"../components/Header\";\r\n// import Footer from \"../components/Footer\";\r\nimport MainBody from \"../components/MainBody\";\r\n\r\nclass App extends Component {\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"wrapper \">\r\n        <div className=\"font-body\">\r\n          {/* <div className=\"header\">\r\n            <Header />\r\n          </div> */}\r\n          <div>\r\n            <MainBody />\r\n          </div>\r\n          {/* <div className=\"footer\">\r\n            <Footer />\r\n          </div> */}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n\r\n\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport \"./assets/custom.css\";\r\nimport \"./assets/layout.css\";\r\n// import \"./assets/font-awesome.min.css\";\r\nimport App from \"./layouts/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}