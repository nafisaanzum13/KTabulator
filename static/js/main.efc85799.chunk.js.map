{"version":3,"sources":["components/Header.jsx","components/Footer.jsx","components/SettingModal.jsx","components/URLForm.jsx","components/LandingPage.jsx","components/TablePanel.jsx","components/TableSelection.jsx","components/TaskMenu.jsx","components/ActionPanel.jsx","components/PagePanel.jsx","components/MainBody.jsx","layouts/App.jsx","index.js"],"names":["Header","state","className","href","class","title","onClick","props","copyTable","openModal","undoPreviousStep","Component","Footer","SettingModal","isOpen","this","showModal","onChange","e","toggleSemantic","type","value","checked","semanticEnabled","unionCutOff","unionCutOffChange","min","max","step","closeModal","URLForm","handleURLPaste","bind","preventDefault","urlPasted","clipboardData","window","getData","placeholder","onPaste","LandingPage","TablePanel","createSuperTable","createSelectedTableView","rowNum","tableData","length","colNum","table","tempRow","colIndex","tempHeader","keyColIndex","multiAllowed","getKeyOptions","tableHeader","selectColHeader","options","optionsMap","isMulti","contextSetCell","getOtherOptions","push","rows","i","j","tempID","cellColor","keyEntryIndex","backgroundColor","style","id","data","onCellChange","tableDataExplore","tableHeaderRow","tableRows","tableEle","menuArray","contextAddColumn","divider","contextCellOrigin","border","TableSelection","createButtonArray","originTableArray","buttonArray","buttonText","headerCells","cells","headerData","removeNewLine","innerText","slice","tableContent","dangerouslySetInnerHTML","__html","outerHTML","selectButton","tableOpenList","handleStartTable","toggleTable","Collapse","originTableArrayEle","str","TaskMenu","subject","replace","handleStartSubject","toggleTableSelection","showTableSelection","CardBody","Card","selectedTableIndex","ActionPanel","createPropertyArray","createSiblingArray","createTableArray","firstIndex","secondIndex","tableArray","propertyNeighbours","siblingArray","tableElement","thirdIndex","tableTitleText","Button","toggleOtherTable","unionTable","colMapping","siblingElement","zeroDividerSet","tooltipText","name","listClassSib","toggleSibling","unionPage","propertyElement","predicate","object","propertyText","listClass","togglePropertyNeighbours","unionProperty","actionEle","wrapperEle","titleEle","usecaseSelected","curActionInfo","actionInfo","task","neighbourArrayText","neighbourArray","populateKeyColumn","neighbourText","neighbour","populateOtherColumn","neighbourIndex","range","sameNeighbourOneCol","numCols","sameNeighbourDiffCol","siblingText","siblingNeighbour","populateSameRange","origin","curIndex","tabIndex","selectedIndex","onSelect","index","handleTabSwitch","PagePanel","pageEle","wikiPageClass","iframeURL","buttonhideShow","toggleWikiPage","aria-hidden","pageHidden","src","MainBody","tablePasted","lastAction","prevState","keyColNeighbours","selectedClassAnnotation","handleTablePaste","cellChange","getOtherColPromise","addAllNeighbour","promiseArray","fetchText","allPromiseReady","then","values","htmlText","DOMParser","parseFromString","getElementsByClassName","setState","textArea","document","createElement","copiedText","curText","label","undefined","body","appendChild","select","execCommand","removeChild","alert","taskSelected","decodeURIComponent","_","cloneDeep","target","allSubject","regexReplace","queryBody","queryURL","fetchJSON","myJson","keyColOptions","results","bindings","tempObj","somevar","colEmpty","nonEmptyInfo","otherColOptions","selectedOptions","evalue","elabel","keyColLabel","arr","split","isNaN","Number","queryBodyOne","keyColPromise","otherColPromiseSubject","otherColPromiseObject","updatedRowCount","Math","emptyEntryCount","startingIndex","labelText","tempOrigin","updateKeyColNeighbours","cellValue","curPromise","requiredLength","dbResult","removePrefix","originToAdd","keyOrigin","remainNeighbourCount","siblingUnique","Set","siblingCount","count","filter","x","rangeLiteral","includes","keyColIndexUpdated","tableDataUpdated","k","tableHeaderUpdated","curLabel","selectedClassAnnotationUpdated","optionsMapUpdated","curCol","newState","updatedOrigin","promiseArrayTwoD","curPromiseArray","tempData","tempOptions","tempAnnotation","tempKeyColIndex","curColIndex","curValueArray","rowIndex","cellSelected","originElement","tableIndex","queryPromise","queryOne","urlReplace","queryTwo","findClassAnnotation","queryResults","propertyNeighboursPO","bindingArray","p","o","urlOrigin","curSiblingArray","siblingName","s","sort","a","b","getTableStates","setTableFromHTML","stateInfo","siblingNameArray","tableArrayPromise","pageHTML","findTableFromHTML","tableArrayValues","aTableLength","bTableLength","aName","bName","selectedSibling","selectedTable","otherTableHTML","otherTableData","tableConcat","setUnionData","otherTableOrigin","headerRow","sameTable","diffColFound","m","tempMapping","bodyEle","bottomContentClass","topContentClass","url","fetch","response","json","text","Promise","all","resultsBinding","neighbourCount","curNeighbourLiteral","curNeighbourValue","curNeighbourLabel","nextNeighbourValue","splice","dataToAdd","colInNew","concat","HTMLCleanCell","trim","pageName","originCols","wikiTablesFound","tablesFound","tagName","tablePromise","findTableFromTable","unionScore","resolve","tableHTML","curHeaderCells","newCols","remainCols","searchCols","headerName","indexOf","sameStructure","remainClassAnnotation","curSearchIndex","intersection","totalSuccess","numTrial","hyperCDF","tempTable","curCellText","anchorArray","getElementsByTagName","hrefArray","curRowSpan","rowSpan","curColSpan","colSpan","remainEntries","curEntry","classAnnotation","curColumnClass","curCellClass","selecteTableHTML","originText","N","K","n","denom","combinations","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.efc85799.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { FaCopy, FaUndo } from \"react-icons/fa\";\nimport { FiSettings } from \"react-icons/fi\";\n\nclass Header extends Component {\n  state = {};\n  render() {\n    return (\n      <>\n        <div className=\"row header-body\">\n          <div className=\"col-md-8\">\n            <a href=\"index.html\" class=\"logo\">\n              <b>\n                <span>KG</span>Wrangler\n              </b>\n            </a>\n          </div>\n          <div className=\"offset-md-2 col-md-2 row\">\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"copy table to csv\"\n                onClick={() => this.props.copyTable()}\n              >\n                <FaCopy className=\"logo-left-color\" />\n              </button>\n            </div>\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"Union Table Settings\"\n              >\n                <FiSettings\n                  className=\"logo-left-color\"\n                  onClick={() => this.props.openModal()}\n                />\n              </button>\n            </div>\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"undo previous action\"\n                onClick={() => this.props.undoPreviousStep()}\n              >\n                <FaUndo className=\"color-wrangler\" />\n              </button>\n            </div>\n          </div>\n        </div>\n        <hr class=\"header-hr\"></hr>\n      </>\n    );\n  }\n}\n\nexport default Header;\n","import React, { Component } from \"react\";\nclass Footer extends Component {\n  state = {};\n  render() {\n    return (\n      <>\n        {/* <hr className=\"m-0\"></hr> */}\n        <div className=\"text-center text-sm\">\n          <small>University of Waterloo, 2020</small>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default Footer;\n","import React, { Component } from \"react\";\nimport Modal from 'react-modal';\n// The two following lines are for range sliders\nimport RangeSlider from \"react-bootstrap-range-slider\";\nimport \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\n\nclass SettingModal extends Component {\n  state = {};\n  render() {\n    return (\n      <div>\n        <Modal \n          isOpen={this.props.showModal}\n          className=\"setting-modal\"\n        >\n          <div className=\"container\">\n            <div className=\"row\">\n              <div className=\"col-md-6 offset-md-3\">\n                <h4>Table Union Search Settings</h4>\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4\">Semantic Mapping:</div>\n              <div className=\"col-md-6\">\n                <div onChange={(e) => this.props.toggleSemantic(e)}>\n                  <input\n                  type=\"radio\"\n                  value=\"enabled\"\n                  checked={this.props.semanticEnabled === \"enabled\"}\n                  />{\" \"}\n                  Enabled\n                  <input\n                    type=\"radio\"\n                    value=\"disabled\"\n                    checked={this.props.semanticEnabled === \"disabled\"}\n                  />{\" \"}\n                  Disabled\n                </div>\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4\">Percentage of Columns to Union:</div>\n              <div className=\"col-md-6\">\n                <RangeSlider\n                  value={this.props.unionCutOff}\n                  onChange={(e) => this.props.unionCutOffChange(e)}\n                  min={0}\n                  max={1}\n                  step={0.05}\n                />\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4 offset-md-4\">\n                <button onClick={() => this.props.closeModal()}>Confirm Settings</button>\n              </div>\n            </div>\n          </div>\n        </Modal>\n      </div>\n    );\n  }\n}\n\nexport default SettingModal;\n","import React, { Component } from \"react\";\n\nclass URLForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.handleURLPaste = this.handleURLPaste.bind(this);\n  }\n\n  handleURLPaste(e) {\n    e.preventDefault();\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\n    this.props.handleURLPaste(urlPasted);\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"row text-center\">\n          <div className=\"col-md-6 offset-md-3\">\n            <input\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\n              onPaste={this.handleURLPaste}\n              className=\" form-control\"\n            ></input>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default URLForm;\n","import React, { Component } from \"react\";\nimport URLForm from \"../components/URLForm\";\n\nclass LandingPage extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    return (\n      <>\n        <div class=\"landing-page\">\n          <div class=\" row text-center\">\n            <div class=\"white-form col-md-5\">\n              <h1 class=\"\"> Welcome!</h1>\n              <hr className=\"header-hr\"></hr>\n              <h4>Enter the URL of a Wikipedia page and start wrangling!</h4>\n              <URLForm handleURLPaste={this.props.handleURLPaste} />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default LandingPage;\n","import React, { Component } from \"react\";\n// import TableSelection from \"../components/TableSelection\";\n// import Tooltip from '@atlaskit/tooltip';\nimport Select from \"react-select\";\nimport { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\nimport { FaSearch } from \"react-icons/fa\";\n\nclass TablePanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createSuperTable = this.createSuperTable.bind(this);\n    this.createSelectedTableView = this.createSelectedTableView.bind(this);\n  }\n\n  // This function takes the states tableData, keyColIndex, keyEntryIndex, tableHeader, optionsMap\n  // And convert them into HTML for the super table\n\n  createSuperTable() {\n    // console.log(this.props.tableData);\n    const rowNum = this.props.tableData.length;\n    const colNum = this.props.tableData[0].length;\n\n    let table = [];\n\n    // This part creates the table header row\n    let tempRow = [];\n    for (let colIndex = 0; colIndex < colNum; ++colIndex) {\n      let tempHeader;\n      // This part deals with the key column headers\n      if (colIndex === this.props.keyColIndex) {\n        let multiAllowed = colIndex === 0 ? true : false;\n        tempHeader = (\n          <th className=\"table-head\">\n            <div\n              onClick={(e) => this.props.getKeyOptions(e, colIndex)}\n              className=\"super-header-div\"\n            >\n              <Select\n                className=\"selection-header\"\n                value={this.props.tableHeader[colIndex]}\n                onChange={(e) => this.props.selectColHeader(e, colIndex)}\n                placeholder={\"Choose header\"}\n                options={this.props.optionsMap[this.props.keyColIndex]}\n                isMulti={multiAllowed}\n              />\n              <FaSearch\n                className=\"search-icon\"\n                title={\"Set as key column\"}\n                onClick={(e) => this.props.contextSetCell(e, 0, colIndex)}\n              />\n            </div>\n          </th>\n        );\n      }\n      // This part deals with the non-key column headers\n      else {\n        tempHeader = (\n          <th className=\"table-head\">\n            <div\n              onClick={(e) => this.props.getOtherOptions(e, colIndex)}\n              className=\"super-header-div\"\n            >\n              <Select\n                className=\"selection-header\"\n                value={this.props.tableHeader[colIndex]}\n                onChange={(e) => this.props.selectColHeader(e, colIndex)}\n                placeholder={\"Choose header\"}\n                options={this.props.optionsMap[colIndex]}\n                isMulti={false}\n              />\n              <FaSearch\n                className=\"search-icon\"\n                title={\"Set as key column\"}\n                onClick={(e) => this.props.contextSetCell(e, 0, colIndex)}\n              />\n            </div>\n          </th>\n        );\n      }\n      tempRow.push(tempHeader);\n    }\n    table.push(\n      <thead className=\"table-head\">\n        <tr>{tempRow}</tr>\n      </thead>\n    );\n\n    // i corresponds to the row number, j corresponds to the column number\n\n    // We are adding an ID for each cell for contextmenu\n    let rows = [];\n    for (let i = 0; i < rowNum; i++) {\n      let tempRow = [];\n      //Inner loop to create each cell of the row\n      for (let j = 0; j < colNum; j++) {\n        // Create the each cell\n        let tempID = \"cellRow\" + i + \"Col\" + j;\n        let cellColor;\n        if (j === this.props.keyColIndex) {\n          if (i === this.props.keyEntryIndex) {\n            cellColor = { backgroundColor: \"Yellow\" };\n          } else {\n            cellColor = { backgroundColor: \"LightBlue\" };\n          }\n        } else {\n          cellColor = { backgroundColor: \"White\" };\n        }\n        tempRow.push(\n          <td style={cellColor}>\n            <ContextMenuTrigger id={tempID}>\n              <input\n                className=\"twenty-vw\"\n                type=\"text\"\n                value={this.props.tableData[i][j].data}\n                // onClick={() => {alert(\"hmm\");}}\n                onChange={(e) => this.props.onCellChange(e, i, j)}\n              />\n            </ContextMenuTrigger>\n          </td>\n        );\n      }\n      //Create the parent and add the children\n      rows.push(<tr>{tempRow}</tr>);\n    }\n    table.push(<tbody>{rows}</tbody>);\n    return table;\n  }\n\n  // This function makes no modification of the data at all.\n  // It takes all the data from this.props.tableDataExplore, and convert them into HTML\n  createSelectedTableView() {\n    // console.log(rowNum);\n    // console.log(colNum);\n    // console.log(this.props.tableDataExplore[0][0].data);\n    // console.log(this.props.tableDataExplore[0][0].origin);\n    const rowNum = this.props.tableDataExplore.length;\n    const colNum = this.props.tableDataExplore[0].length;\n\n    let table = [];\n\n    // This part creates the table header row\n    let tempRow = [];\n    for (let j = 0; j < colNum; ++j) {\n      let tempHeader = (\n        <th className=\"table-head table-col\">\n          {this.props.tableDataExplore[0][j].data}\n        </th>\n      );\n      tempRow.push(tempHeader);\n    }\n    let tableHeaderRow = <tr className=\"table-head table-col\">{tempRow}</tr>;\n    table.push(<thead>{tableHeaderRow}</thead>);\n\n    // i corresponds to the row number, j corresponds to the column number\n    let tableRows = [];\n    for (let i = 1; i < rowNum; i++) {\n      let tempRow = [];\n      //Inner loop to create each cell of the row\n      for (let j = 0; j < colNum; j++) {\n        // Create the each cell\n        tempRow.push(\n          <td className=\"table-col\">\n            {this.props.tableDataExplore[i][j].data}\n          </td>\n        );\n      }\n      //Create the parent and add the children\n      tableRows.push(<tr>{tempRow}</tr>);\n    }\n    table.push(<tbody>{tableRows}</tbody>);\n    return table;\n  }\n\n  render() {\n    let tableEle = null;\n\n    // // Case one: user hasn't selected any task yet\n    // if (this.props.usecaseSelected === \"\") {\n    //   tableEle = <h4 className=\"text-center\">Welcome!</h4>;\n    // }\n    // // Case two: user has chosen task \"startSubject\"\n    // else if (this.props.usecaseSelected === \"startSubject\") {\n    //   let menuArray = [];\n    //   for (let i = 0; i < this.props.tableData.length; ++i) {\n    //     for (let j = 0; j < this.props.tableData[0].length; ++j) {\n    //       let tempID = \"cellRow\" + i + \"Col\" + j;\n    //       menuArray.push(\n    //         <ContextMenu id={tempID}>\n    //           <MenuItem onClick={(e) => this.props.contextAddColumn(e, j)}>\n    //             Add Column to the Right\n    //           </MenuItem>\n    //           <MenuItem divider />\n    //           <MenuItem onClick={(e) => this.props.contextSetCell(e, i, j)}>\n    //             Set as Search Cell\n    //           </MenuItem>\n    //           <MenuItem divider />\n    //           <MenuItem onClick={(e) => this.props.contextCellOrigin(e, i, j)}>\n    //             Show Origin of Cell\n    //           </MenuItem>\n    //         </ContextMenu>\n    //       );\n    //     }\n    //   }\n    //   tableEle = (\n    //     // class table-fixed helps with sticky column headers\n    //     <div>\n    //       <table class border=\"1\" className=\"table table-sm table-bordered\">\n    //         {this.createSuperTable()}\n    //       </table>\n    //       {menuArray}\n    //     </div>\n    //   );\n    // }\n    // // Case three: user has chosen task \"startTable\"\n    // else if (this.props.usecaseSelected === \"startTable\") {\n    //   // Case 3.1: User has not selected a table yet\n    //   if (this.props.selectedTableIndex === -1) {\n    //     tableEle = (\n    //       <TableSelection\n    //         originTableArray={this.props.originTableArray}\n    //         tableOpenList={this.props.tableOpenList}\n    //         toggleTable={this.props.toggleTable}\n    //         selectedTableIndex={this.props.selectedTableIndex}\n    //       />\n    //     );\n    //   }\n    //   // Case 3.2: User has selected a table\n    //   // Make the second part into its own component\n    //   else {\n    //     let menuArray = [];\n    //     for (let i = 0; i < this.props.tableData.length; ++i) {\n    //       for (let j = 0; j < this.props.tableData[0].length; ++j) {\n    //         let tempID = \"cellRow\" + i + \"Col\" + j;\n    //         menuArray.push(\n    //           <ContextMenu id={tempID}>\n    //             <MenuItem onClick={(e) => this.props.contextAddColumn(e, j)}>\n    //               Add Column to the Right\n    //             </MenuItem>\n    //             <MenuItem divider />\n    //             <MenuItem onClick={(e) => this.props.contextSetCell(e, i, j)}>\n    //               Set as Search Cell\n    //             </MenuItem>\n    //             <MenuItem divider />\n    //             <MenuItem onClick={(e) => this.props.contextCellOrigin(e, i, j)}>\n    //               Show Origin of Cell\n    //             </MenuItem>\n    //           </ContextMenu>\n    //         );\n    //       }\n    //     }\n    //     tableEle = (\n    //       // class table-fixed helps with sticky column headers\n    //       <div>\n    //         <table class border=\"1\" className=\"table table-sm table-bordered\">\n    //           {this.createSuperTable()}\n    //         </table>\n    //         {menuArray}\n    //       </div>\n    //     );\n    //   }\n    // } else {\n    // }\n\n    // In all cases, once we have pasted the URL. We want to display the super table in the table panel.\n    let menuArray = [];\n    for (let i = 0; i < this.props.tableData.length; ++i) {\n      for (let j = 0; j < this.props.tableData[0].length; ++j) {\n        let tempID = \"cellRow\" + i + \"Col\" + j;\n        menuArray.push(\n          <ContextMenu id={tempID}>\n            <MenuItem onClick={(e) => this.props.contextAddColumn(e, j)}>\n              Add Column to the Right\n            </MenuItem>\n            <MenuItem divider />\n            <MenuItem onClick={(e) => this.props.contextSetCell(e, i, j)}>\n              Set as Search Cell\n            </MenuItem>\n            <MenuItem divider />\n            <MenuItem onClick={(e) => this.props.contextCellOrigin(e, i, j)}>\n              Show Origin of Cell\n            </MenuItem>\n          </ContextMenu>\n        );\n      }\n    }\n    tableEle = (\n      // class table-fixed helps with sticky column headers\n      <div>\n        <table class border=\"1\" className=\"table table-sm table-bordered\">\n          {this.createSuperTable()}\n        </table>\n        {menuArray}\n      </div>\n    );\n    return <div>{tableEle}</div>;\n  }\n}\n\nexport default TablePanel;\n","import React, { Component } from \"react\";\nimport { Collapse } from \"reactstrap\";\nimport { FaTable } from \"react-icons/fa\";\n\nclass TableSelection extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createButtonArray = this.createButtonArray.bind(this);\n  }\n\n  createButtonArray() {\n    const originTableArray = this.props.originTableArray;\n    let buttonArray = [];\n    for (let i = 0; i < originTableArray.length; ++i) {\n      // This first part create the buttons with text: table index plus column names\n      // It also removes some newline characters\n      let buttonText = \"Table \" + i + \": \";\n      let headerCells = originTableArray[i].rows[0].cells;\n      for (let j = 0; j < headerCells.length; ++j) {\n        let headerData = removeNewLine(headerCells[j].innerText);\n        if (headerData[headerData.length - 1] === \"\\n\") {\n          headerData = headerData.slice(0, -1);\n        }\n        buttonText = buttonText + headerData + \"| \";\n      }\n      // Now let's update the table content\n      let tableContent = (\n        <div\n          dangerouslySetInnerHTML={{\n            __html: this.props.originTableArray[i].outerHTML,\n          }}\n        />\n      );\n      let selectButton;\n      if (this.props.tableOpenList[i] === true) {\n        selectButton = \n          <button\n            onClick={(e) => this.props.handleStartTable(e, i)}\n          >\n            Select\n          </button>\n      }\n      buttonArray.push(\n        <li\n          className=\"list-group-item\"\n          // onClick={(e) => this.props.toggleTable(e, i)}\n        >\n        <span \n          onClick={(e) => this.props.toggleTable(e, i)}\n        >\n          {buttonText} {}\n          <FaTable />\n        </span>\n        {selectButton}\n          <Collapse isOpen={this.props.tableOpenList[i]}>\n            <div>{tableContent}</div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">{buttonArray}</ul>\n    );\n  }\n\n  render() {\n    const numTables = this.props.originTableArray.length;\n    let originTableArrayEle = null;\n    if (numTables !== 0) {\n      originTableArrayEle = <div>{this.createButtonArray()}</div>;\n    }\n    return <div>{originTableArrayEle}</div>;\n  }\n}\n\nexport default TableSelection;\n\nfunction removeNewLine(str) {\n  if (str[str.length - 1] === \"\\n\") {\n    return str.slice(0, -1);\n  } else {\n    return str;\n  }\n}\n","import React, { Component } from \"react\";\nimport { Collapse, CardBody, Card } from \"reactstrap\";\nimport { FaList } from \"react-icons/fa\";\nimport TableSelection from \"../components/TableSelection\";\n\nclass TaskMenu extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const subject = reverseReplace(this.props.urlPasted.slice(30));\n    return (\n      <div>\n        <ul class=\"list-group list-css list-group-flush\">\n          <hr className=\"m-0\"></hr>\n          <li\n            className=\"list-group-item\"\n            onClick={(e) => this.props.handleStartSubject(e, \"startSubject\")}\n          >\n            Start with creating a table about {subject}\n          </li>\n          <li\n            className=\"list-group-item\"\n          >\n            <span \n              onClick={() => this.props.toggleTableSelection()}\n            >\n              Start with an existing table from page <FaList />\n            </span>\n\n            <Collapse isOpen={this.props.showTableSelection}>\n              <CardBody>\n                <Card>\n                  <div>\n                    <TableSelection\n                      originTableArray={this.props.originTableArray}\n                      tableOpenList={this.props.tableOpenList}\n                      toggleTable={this.props.toggleTable}\n                      selectedTableIndex={this.props.selectedTableIndex}\n                      handleStartTable={this.props.handleStartTable}\n                    />\n                  </div>\n                </Card>\n              </CardBody>\n            </Collapse>\n          </li>\n          <hr className=\"m-0\"></hr>\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TaskMenu;\n\n// This function changes the copied text \"%E2%80%93\" to \"-\" when we copy a URL from google. \n\nfunction reverseReplace(str) {\n  return str.replace(/%E2%80%93/, \"–\");\n}\n","import React, { Component } from \"react\";\nimport TaskMenu from \"../components/TaskMenu\";\nimport { Collapse, Button, CardBody, Card } from \"reactstrap\";\nimport { FaList, FaTable } from \"react-icons/fa\";\nimport TableSelection from \"../components/TableSelection\";\n// The two following lines are for tabs\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\nimport \"react-tabs/style/react-tabs.css\";\n// The two following lines are for range sliders\n// import RangeSlider from \"react-bootstrap-range-slider\";\n// import \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\n\nclass ActionPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createPropertyArray = this.createPropertyArray.bind(this);\n    this.createSiblingArray = this.createSiblingArray.bind(this);\n    this.createTableArray = this.createTableArray.bind(this);\n  }\n\n  createTableArray(firstIndex, secondIndex) {\n    const tableArray = this.props.propertyNeighbours[firstIndex].siblingArray[\n      secondIndex\n    ].tableArray;\n    let tableElement = [];\n    for (let thirdIndex = 0; thirdIndex < tableArray.length; ++thirdIndex) {\n      // console.log(\"Hello\");\n      // console.log(tableArray[thirdIndex].title);\n      let tableTitleText = \"Table \" + thirdIndex + \": \";\n      for (let i = 0; i < tableArray[thirdIndex].title.length; ++i) {\n        tableTitleText = tableTitleText + tableArray[thirdIndex].title[i] + \"|\";\n      }\n      tableElement.push(\n        <div>\n          <Button\n            onClick={(e) =>\n              this.props.toggleOtherTable(\n                e,\n                firstIndex,\n                secondIndex,\n                thirdIndex\n              )\n            }\n          >\n            {tableTitleText}\n            <FaTable />\n          </Button>\n          <Collapse isOpen={tableArray[thirdIndex].isOpen}>\n            <Card>\n              <CardBody>\n                <div>\n                  <ul className=\"list-group list-css\">\n                    <li\n                      className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\n                      onClick={(e) =>\n                        this.props.unionTable(\n                          firstIndex,\n                          secondIndex,\n                          tableArray[thirdIndex].data,\n                          tableArray[thirdIndex].colMapping\n                        )}\n                    >\n                      Union table\n                    </li>\n                  </ul>\n                  <div\n                    dangerouslySetInnerHTML={{\n                      __html: tableArray[thirdIndex].data.outerHTML,\n                    }}\n                  ></div>\n                </div>\n              </CardBody>\n            </Card>\n          </Collapse>\n        </div>\n      );\n    }\n    return tableElement;\n  }\n\n  createSiblingArray(firstIndex) {\n    const siblingArray = this.props.propertyNeighbours[firstIndex].siblingArray;\n    let siblingElement = [];\n    let zeroDividerSet = false;\n    for (\n      let secondIndex = 0;\n      secondIndex < siblingArray.length;\n      ++secondIndex\n    ) {\n      let tooltipText =\n        \"Examine tables on page \" + siblingArray[secondIndex].name;\n      // let divider = null;\n      let listClassSib = \"list-group-item\";\n      if (siblingArray[secondIndex].isOpen) {\n        listClassSib = \"list-group-item list-with-background\";\n      }\n      if (\n        zeroDividerSet === false &&\n        siblingArray[secondIndex].tableArray.length === 0\n      ) {\n        zeroDividerSet = true;\n        // divider = (\n        //   <li>\n        //     <h5>\n        //       Below are sibling pages on which no similar tables are found:\n        //     </h5>\n        //     <hr />\n        //   </li>\n        // );\n        siblingElement.push(\n          <li className=\"list-group-item\">\n            <hr />\n            <h5>\n              Below are sibling pages on which no similar tables are found:\n            </h5>\n            <hr />\n          </li>\n        );\n      }\n\n      siblingElement.push(\n        <li \n          className={listClassSib} \n          title={tooltipText}\n          // onClick={(e) =>\n          //   this.props.toggleSibling(e, firstIndex, secondIndex)\n          // }\n        >\n          <span\n            onClick={(e) =>\n              this.props.toggleSibling(e, firstIndex, secondIndex)\n            }\n          >\n            {siblingArray[secondIndex].name + \" \"}\n            <FaList />\n          </span>\n\n          <Collapse isOpen={siblingArray[secondIndex].isOpen}>\n            <div>\n              <ul className=\"list-group list-css\">\n                <li\n                  className=\"col-md-4 list-group-item list-button\"\n                  onClick={(e) => this.props.unionPage(firstIndex, secondIndex)}\n                >\n                  Union from page\n                </li>\n              </ul>\n              {this.createTableArray(firstIndex, secondIndex)}\n            </div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">\n        {\" \"}\n        {siblingElement}{\" \"}\n      </ul>\n    );\n  }\n\n  createPropertyArray() {\n    // console.log(\"Getting here meaning we are recreating the property array\");\n    const propertyNeighbours = this.props.propertyNeighbours;\n    // console.log(propertyNeighbours);\n    let propertyElement = [];\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      // We create the text for property buttons: table index plus column names\n      const predicate = propertyNeighbours[i].predicate;\n      const object = propertyNeighbours[i].object;\n      let propertyText = predicate + \": \" + object + \" \";\n      let tooltipText = \"Show other pages with \" + predicate + \": \" + object;\n\n      let listClass = \"list-group-item\";\n      if (this.props.propertyNeighbours[i].isOpen) {\n        listClass = \"list-group-item list-with-background\";\n      }\n\n      propertyElement.push(\n        <li class={listClass} title={tooltipText}>\n          <span onClick={(e) => this.props.togglePropertyNeighbours(e, i)}>\n            {propertyText}\n            <FaList />\n          </span>\n\n          <Collapse isOpen={this.props.propertyNeighbours[i].isOpen}>\n            <div>\n              <hr />\n              <ul className=\"list-group list-css\">\n                <li\n                  className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\n                  onClick={(e) => this.props.unionProperty(i)}\n                >\n                  Union from all pages\n                </li>\n              </ul>\n              {this.createSiblingArray(i)}\n            </div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">\n        {propertyElement}\n      </ul>\n    );\n  }\n\n  render() {\n    let actionEle;  // contains either wrangling actions or unionable tables for the action panel\n    let wrapperEle; // wrapper element for actionEle. This is what we will render in the HTML.\n    let titleEle;   // contains what we will display as the title for the action panel\n\n    // We first decide the content for the titleElement\n    if (\n      this.props.usecaseSelected === \"\" \n      // ||\n      // (this.props.usecaseSelected === \"startTable\" &&\n      //   this.props.selectedTableIndex === -1)\n    ) {\n      titleEle = (\n        <div className=\"row\">\n          <div className=\"col-md-8\">\n            <h4 className=\"logo-left-color\">\n              ACTIONS\n              <span> </span>\n              <span className=\"logo-right-color xsmall\">\n                Select your starting action\n              </span>\n            </h4>\n          </div>\n        </div>\n      );\n    } \n    else {\n      titleEle = (\n        <div className=\"row action-header\">\n          <div className=\"col-md-8\">\n            <h4 className=\"logo-left-color\">\n              ACTIONS\n              <span> </span>\n              <span className=\"logo-right-color xsmall\">\n                Select your next action\n              </span>\n            </h4>\n          </div>\n        </div>\n      );\n    }\n\n    // We now decide the content for the actionElement\n    // Case 1: URL has been pasted, but task has not been selected. User needs to select task.\n    if (this.props.usecaseSelected === \"\") {\n      wrapperEle = \n        <TaskMenu \n          handleStartSubject={this.props.handleStartSubject} \n          urlPasted={this.props.urlPasted}\n          showTableSelection={this.props.showTableSelection}\n          toggleTableSelection={this.props.toggleTableSelection}\n          originTableArray={this.props.originTableArray}\n          tableOpenList={this.props.tableOpenList}\n          toggleTable={this.props.toggleTable}\n          selectedTableIndex={this.props.selectedTableIndex}\n          handleStartTable={this.props.handleStartTable}\n        />;\n    }\n    // Case 2: Task has been selected. curActionInfo is not null, meaning we have to display some task in ActionPanel\n    else if (this.props.curActionInfo !== null) {\n      const actionInfo = this.props.curActionInfo;\n      if (actionInfo.task === \"populateKeyColumn\") {\n        let neighbourArrayText = \"\";\n        for (let i = 0; i < actionInfo.neighbourArray.length; ++i) {\n          if (i > 0) {\n            neighbourArrayText += \" & \";\n          }\n          neighbourArrayText += actionInfo.neighbourArray[i];\n        }\n        actionEle = (\n          <div>\n            <p>Populate this column with column header:</p>\n            <p>{neighbourArrayText}</p>\n            <p>?</p>\n            <button\n              onClick={(e) =>\n                this.props.populateKeyColumn(\n                  e,\n                  actionInfo.colIndex,\n                  actionInfo.neighbourArray\n                )\n              }\n            >\n              OK\n            </button>\n          </div>\n        );\n      } \n      else if (actionInfo.task === \"populateOtherColumn\") {\n        let neighbourText =\n          actionInfo.type === \"subject\"\n            ? actionInfo.neighbour\n            : \"is \" + actionInfo.neighbour + \" of\";\n        actionEle = (\n          <div>\n            <p>Populate this column with column header:</p>\n            <p>{neighbourText} ?</p>\n            <button\n              onClick={(e) =>\n                this.props.populateOtherColumn(\n                  e,\n                  actionInfo.colIndex,\n                  actionInfo.neighbour,\n                  actionInfo.neighbourIndex,\n                  actionInfo.type,\n                  actionInfo.range\n                )\n              }\n            >\n              OK\n            </button>\n          </div>\n        );\n      } \n      else if (actionInfo.task === \"populateSameNeighbour\") {\n        let neighbourText =\n          actionInfo.type === \"subject\"\n            ? actionInfo.neighbour\n            : \"is \" + actionInfo.neighbour + \" of\";\n        actionEle = (\n          <div>\n            <p>Populate all other properties with name:</p>\n            <p>{neighbourText} ?</p>\n            <div className=\"row\">\n              <button\n                className=\"col-md-4\"\n                onClick={(e) =>\n                  this.props.sameNeighbourOneCol(\n                    e,\n                    actionInfo.colIndex,\n                    actionInfo.neighbour,\n                    actionInfo.neighbourIndex,\n                    actionInfo.type,\n                    actionInfo.numCols\n                  )\n                }\n              >\n                In One Column\n              </button>\n              <button\n                className=\"offset-md-1 col-md-4\"\n                onClick={(e) =>\n                  this.props.sameNeighbourDiffCol(\n                    e,\n                    actionInfo.colIndex,\n                    actionInfo.neighbour,\n                    actionInfo.neighbourIndex,\n                    actionInfo.type,\n                    actionInfo.numCols,\n                    actionInfo.range\n                  )\n                }\n              >\n                In Separate Columns\n              </button>\n            </div>\n          </div>\n        );\n      } \n      else if (actionInfo.task === \"populateSameRange\") {\n        let siblingText = \"\";\n        for (let i = 0; i < actionInfo.siblingNeighbour.length; ++i) {\n          if (i > 0) {\n            siblingText += \", \";\n          }\n          siblingText += actionInfo.siblingNeighbour[i].name;\n        }\n        actionEle = (\n          <div>\n            <p>Populate attribute: {siblingText} </p>\n            <p>that are also of type: {actionInfo.range} ?</p>\n            <button\n              onClick={(e) =>\n                this.props.populateSameRange(\n                  e,\n                  actionInfo.colIndex,\n                  actionInfo.range,\n                  actionInfo.siblingNeighbour\n                )\n              }\n            >\n              OK\n            </button>\n          </div>\n        );\n      } \n      else if (actionInfo.task === \"contextCellOrigin\") {\n        actionEle = (\n          <div>\n            <p>Origin of selected cell is:</p>\n            <div>{actionInfo.origin}</div>\n          </div>\n        );\n      } \n      else if (actionInfo.task === \"showPropertyNeighbours\") {\n        // actionEle = (\n        //   <div>\n        //     <Tabs>\n        //       <TabList>\n        //         <Tab>Results</Tab>\n        //         <Tab>Setting</Tab>\n        //       </TabList>\n        //       <TabPanel>\n        //         <small>\n        //           Explore relations below to look for other pages with similar\n        //           tables:\n        //         </small>{\" \"}\n        //         <br></br>\n        //         {this.createPropertyArray()}\n        //       </TabPanel>\n        //       <TabPanel>\n        //         <div className=\"row\">\n        //           <div className=\"col-md-4\">Semantic Mapping:</div>\n        //           <div className=\"col-md-6\">\n        //             <div onChange={(e) => this.props.toggleSemantic(e)}>\n        //               <input\n        //                 type=\"radio\"\n        //                 value=\"enabled\"\n        //                 checked={this.props.semanticEnabled === \"enabled\"}\n        //               />{\" \"}\n        //               Enabled\n        //               <input\n        //                 type=\"radio\"\n        //                 value=\"disabled\"\n        //                 checked={this.props.semanticEnabled === \"disabled\"}\n        //               />{\" \"}\n        //               Disabled\n        //             </div>\n        //           </div>\n        //         </div>\n        //         <br />\n        //         <div className=\"row\">\n        //           <div className=\"col-md-4\">Union Cutoff Percentage:</div>\n        //           <div className=\"col-md-6\">\n        //             <RangeSlider\n        //               value={this.props.unionCutOff}\n        //               onChange={(e) => this.props.unionCutOffChange(e)}\n        //               min={0}\n        //               max={1}\n        //               step={0.05}\n        //             />\n        //           </div>\n        //         </div>\n        //       </TabPanel>\n        //     </Tabs>\n        //   </div>\n        // );\n      }\n    } \n    // This is an empty else clause\n    else {\n    }\n\n    // Now we have to determine whether we are rendering one tab or two tabs.\n    // One tab for startSubject. Two tabs for startTable.\n    // console.log(this.props.usecaseSelected);\n    // In the startSubject case, we will have one tab: wrangling actions\n\n    if (this.props.usecaseSelected === \"startSubject\") {\n      let curIndex = this.props.tabIndex;\n      wrapperEle = (\n        <div>\n          <Tabs\n            selectedIndex={curIndex}\n            onSelect={(index) => this.props.handleTabSwitch(index)}\n          >\n            <TabList>\n              <Tab>Wrangling Actions</Tab>\n            </TabList>\n            <TabPanel>\n              <div className=\"wrangling-actions\">\n                {actionEle}\n              </div>\n              <div className=\"table-list\">\n                <ul class=\"list-group list-css list-group-flush\">\n                  <hr className=\"m-0\"></hr>\n                  <li\n                    className=\"list-group-item\"\n                  >\n                    <span \n                      onClick={() => this.props.toggleTableSelection()}\n                    >\n                      Restart with an existing table from page <FaList />\n                    </span>\n\n                    <Collapse isOpen={this.props.showTableSelection}>\n                      <CardBody>\n                        <Card>\n                          <div>\n                            <TableSelection\n                              originTableArray={this.props.originTableArray}\n                              tableOpenList={this.props.tableOpenList}\n                              toggleTable={this.props.toggleTable}\n                              selectedTableIndex={this.props.selectedTableIndex}\n                              handleStartTable={this.props.handleStartTable}\n                            />\n                          </div>\n                        </Card>\n                      </CardBody>\n                    </Collapse>\n                  </li>\n                </ul>\n              </div>\n            </TabPanel>\n          </Tabs>\n        </div>\n      );\n    }\n    else if (this.props.usecaseSelected === \"startTable\") {\n      // If we have not selected a table, we show both tabs, as we are fully ready.\n      if (this.props.selectedTableIndex !== -1) {\n        let curIndex = this.props.tabIndex;\n        wrapperEle = (\n          <div>\n            <Tabs \n              selectedIndex={curIndex}\n              onSelect={(index) => this.props.handleTabSwitch(index)}\n            >\n              <TabList>\n                <Tab>Wrangling Actions</Tab>\n                <Tab>Union Tables</Tab>\n              </TabList>\n              <TabPanel>\n                {actionEle}\n              </TabPanel>\n              <TabPanel>\n                <small>\n                  Explore relations below to look for other pages with similar\n                  tables:\n                </small>{\" \"}\n                <br></br>\n                {this.createPropertyArray()}\n              </TabPanel>\n            </Tabs>\n          </div>\n        )\n      }\n      // Else, we have not selected a table yet. In this case, wrapperEle should be equal to actionEle\n      else {  \n        wrapperEle = actionEle;\n      }\n    }\n    return (\n      <div>\n        {titleEle}\n        {wrapperEle}\n      </div>\n    );\n  }\n}\n\nexport default ActionPanel;\n","import React, { Component } from \"react\";\n\nclass PagePanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    let pageEle = null;\n    let wikiPageClass = \"small-padding wiki-page-hidden\";\n    let buttonClass = \"btn btn-sm btn-info toggle-button\";\n    if (this.props.iframeURL !== \"\") {\n      let buttonhideShow = (\n        <button\n          className={buttonClass}\n          onClick={() => this.props.toggleWikiPage()}\n        >\n          <i class=\"fa fa-chevron-up\" aria-hidden=\"true\"></i>\n          Show\n        </button>\n      );\n      if (!this.props.pageHidden) {\n        wikiPageClass = \"small-padding wiki-page\";\n        buttonhideShow = (\n          <div>\n            <hr className=\"m-1\"></hr>\n            <button\n              className={buttonClass}\n              onClick={() => this.props.toggleWikiPage()}\n            >\n              <i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i>\n              Hide\n            </button>\n          </div>\n        );\n      }\n      pageEle = (\n        <div className=\"page-panel text-right\">\n          {buttonhideShow}\n          <div className={wikiPageClass}>\n            <iframe\n              id=\"iframe\"\n              title=\"URLPage\"\n              src={this.props.iframeURL}\n              className=\"iframe-cls\"\n            ></iframe>\n          </div>\n        </div>\n      );\n    }\n    return <div>{pageEle}</div>;\n  }\n}\n\nexport default PagePanel;\n","// import { Route, Switch, Link } from \"react-router-dom\";\nimport React, { Component } from \"react\";\nimport { combinations } from \"mathjs\";\nimport Header from \"../components/Header\";\nimport Footer from \"../components/Footer\";\nimport SettingModal from \"../components/SettingModal\";\nimport LandingPage from \"../components/LandingPage\";\nimport TablePanel from \"../components/TablePanel\";\nimport ActionPanel from \"../components/ActionPanel\";\nimport PagePanel from \"../components/PagePanel\";\nimport _ from \"lodash\";\n\nconst maxNeighbourCount = 50;\nconst initialColNum = 4;\nconst initialRowNum = 50;\n\nclass MainBody extends Component {\n  constructor(props) {\n    super(props);\n    let tableData = [];\n    let tableHeader = [];\n    let optionsMap = [];\n    for (let i = 0; i < initialRowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < initialColNum; ++j) {\n        // Initially, cell has no data or origin\n        // data field is a string\n        // origin field is an array of strings\n        tempRow.push({ data: \"\", origin: [] });\n      }\n      tableData.push(tempRow);\n    }\n    for (let j = 0; j < initialColNum; ++j) {\n      let emptyOptions = [];\n      optionsMap.push(emptyOptions);\n      tableHeader.push(\"\");\n    }\n    this.state = {\n      // states below are general states used throughout the app\n      urlPasted: \"\",  \n      tablePasted: \"\",\n      usecaseSelected: \"\",\n      pageHidden: false,\n      iframeURL: \"\",\n      curActionInfo: null, // object storing the current action that should be displayed in ActionPanel. Initially null.\n      lastAction: \"\",      // string storing the last action that has modified the result table in the table panel\n      prevState: \"\",       // objects storing the information needed to undo the last step. Information stored depends on lastAction\n      showModal: false,    // boolean storing whether setting modal is shown or not. Default to false.\n      showTableSelection: false,    // boolean storing whether the list of tables from page is shown. Default to false.\n      tabIndex: 1,         // integer storing the index of the tab currently displaying. Default to 1.\n\n      // states below are useful for startSubject\n      keyColIndex: 0,   // number storing the index of the search column. initially the key column is the first column\n      keyEntryIndex: 0, // number storing the index of the search entry in the search column. initially 0. (the first entry in the search column)\n      // 1D array of objects with four properties storing the table headers. This array is used to create the column headers in table panel\n      // 1) label:  string storing the label of an option (ex: spouse)\n      // 2) value:  string storing the value of an option (ex: spouse)\n      // 3) type:   string that's either \"subject\" or \"object\". Storing whether the current option is ?s or ?o with respect to key column. Can be empty.\n      // 4) range:  string storing the rdfs:range of the current option.\n      tableHeader: tableHeader,\n      tableData: tableData, // 2D array of objects storing the table data (not including the table headers).\n      optionsMap: optionsMap, // 2D array storing the options map\n      keyColNeighbours: [], // 1D array storing the neighbours of the key column\n\n      // startes below are useful for startTable\n      originTableArray: [], // 1D array storing all tables found on pasted URL\n      tableOpenList: [], // 1D array storing whether each table in originTableArray has been toggled open or not\n      selectedTableIndex: -1, // index of table selected by user. If it's -1, take user to table selection. Else, show the table in Table Panel.\n      selectedClassAnnotation: [], // semantic class annotation for each column of selected table\n      // 2D arary of objects with three properties, which store the table data from explore table task. Similar to tableData above. \n      // Three properties: data, origin, rowSpan, colSpan.\n      tableDataExplore: [], \n      // array of objects with four properties storing the status/content for each property neighbour\n      // 1) predicate: string storing the predicate (ex. dbp:league)\n      // 2) object: string storing the object (ex. dbo:NBA)\n      // 3) isOpen: boolean storing whether the current property neighbour is toggled on or not\n      // 4) siblingArary: array of objects with two properties storing the staus/content for each sibling URL\n      //    4.1) isOpen:      boolean storing whether the current sibling is toggled on or not\n      //    4.2) tableArray:  array of objects storing the status/content for each \"same\" table on the sibling URL\n      //         4.2.1) isOepn:        boolean storing whether the current table is toggled on or not\n      //         4.2.2) unionScore:    number storing teh union score of the current table (how \"similar\" it is to the original table)\n      //         4.2.3) colMapping:    array of numbers storing the column mapping between the current table and the selected table\n      //         4.2.4) data:          HTML of a table\n      //         4.2.5) title:         array of strings storing the column headers of the current table\n      propertyNeighbours: [],\n      semanticEnabled: \"disabled\", // boolean value indicating whether semantic mapping is enabled or not. Default to true\n      unionCutOff: 0.75, // number representing the union percentage a table must have to be considered unionable (>=)\n    };\n\n    // functions below are useful during start up\n    this.handleURLPaste = this.handleURLPaste.bind(this);\n    this.handleTablePaste = this.handleTablePaste.bind(this);\n    this.handleStartSubject = this.handleStartSubject.bind(this);\n    this.handleStartTable = this.handleStartTable.bind(this);\n\n    // functions below are useful for startSubject\n    this.cellChange = this.cellChange.bind(this);\n    this.selectColHeader = this.selectColHeader.bind(this);\n    this.getKeyOptions = this.getKeyOptions.bind(this);\n    this.getOtherOptions = this.getOtherOptions.bind(this);\n    this.populateKeyColumn = this.populateKeyColumn.bind(this);\n    this.getOtherColPromise = this.getOtherColPromise.bind(this);\n    // this.getOtherColPromiseTwo = this.getOtherColPromiseTwo.bind(this);\n    this.populateOtherColumn = this.populateOtherColumn.bind(this);\n    this.addAllNeighbour = this.addAllNeighbour.bind(this);\n    this.sameNeighbourDiffCol = this.sameNeighbourDiffCol.bind(this);\n    this.sameNeighbourOneCol = this.sameNeighbourOneCol.bind(this);\n    this.populateSameRange = this.populateSameRange.bind(this);\n    this.contextAddColumn = this.contextAddColumn.bind(this);\n    this.contextSetCell = this.contextSetCell.bind(this);\n    this.contextCellOrigin = this.contextCellOrigin.bind(this);\n\n    // functions below are useful for startTable\n    this.toggleTable = this.toggleTable.bind(this);\n    this.togglePropertyNeighbours = this.togglePropertyNeighbours.bind(this);\n    this.toggleSibling = this.toggleSibling.bind(this);\n    this.toggleOtherTable = this.toggleOtherTable.bind(this);\n    this.unionTable = this.unionTable.bind(this);\n    this.unionPage = this.unionPage.bind(this);\n    this.unionProperty = this.unionProperty.bind(this);\n    this.toggleSemantic = this.toggleSemantic.bind(this);\n    this.unionCutOffChange = this.unionCutOffChange.bind(this);\n\n    // functions below are generally usefull\n    this.copyTable = this.copyTable.bind(this);\n    this.toggleWikiPage = this.toggleWikiPage.bind(this);\n    this.undoPreviousStep = this.undoPreviousStep.bind(this);\n    this.handleTabSwitch = this.handleTabSwitch.bind(this);\n    this.openModal = this.openModal.bind(this);\n    this.closeModal = this.closeModal.bind(this);\n    this.toggleTableSelection = this.toggleTableSelection.bind(this);\n  }\n\n  handleURLPaste(urlPasted) {\n    // As soon as the URL has been pasted, we want to fetch all tables from the pasted URL.\n    // We then update the originTableArray, which stores all the tables found on the pasted URL\n    // We also initialize tableOpenList to all false\n\n    // Lastly, we updated the urlPasted and iframeURL\n\n    let promiseArray = [];\n    promiseArray.push(fetchText(urlPasted));\n    allPromiseReady(promiseArray).then((values) => {\n      // We first parse the pasted URL and store the list of tables from the pasted URL\n      let htmlText = values[0];\n      let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\n      let originTableArray = doc.getElementsByClassName(\"wikitable\");\n      let tableOpenList = [];\n      for (let i = 0; i < originTableArray.length; ++i) {\n        tableOpenList.push(false);\n      }\n\n      // Adding support for undo:\n\n      let lastAction = \"handleURLPaste\";\n      let prevState = \n        {\n          \"urlPasted\":\"\",\n          \"iframeURL\":\"\",\n          \"originTableArray\":[],\n          \"tableOpenList\":[],\n        };\n\n      this.setState({\n        originTableArray: originTableArray,\n        tableOpenList: tableOpenList,\n        urlPasted: urlPasted,\n        iframeURL: urlPasted,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    });\n  }\n\n  handleTablePaste(tablePasted) {\n    this.setState({\n      tablePasted: tablePasted,\n    });\n  }\n\n  // This function copies the table content to clipboard\n\n  copyTable() {\n    const textArea = document.createElement(\"textarea\"); // this line allows the use of select() function\n    let copiedText = \"\";\n    // // We handle the case for startTable and startSubject differently\n\n    // // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\n    // if (this.state.usecaseSelected === \"startTable\") {\n    //   // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\n    //   const rowNum = this.state.tableDataExplore.length;\n    //   const colNum = this.state.tableDataExplore[0].length;\n    //   for (let i = 0; i < rowNum; ++i) {\n    //     for (let j = 0; j < colNum - 1; ++j) {\n    //       copiedText =\n    //         copiedText + this.state.tableDataExplore[i][j].data + \"\\t\";\n    //     }\n    //     copiedText =\n    //       copiedText + this.state.tableDataExplore[i][colNum - 1].data + \"\\n\";\n    //   }\n    // }\n\n    // This case handles the copy table for start subject\n    if (this.state.usecaseSelected === \"startSubject\" || this.state.usecaseSelected === \"startTable\") {\n      // We first push on the text for column headers (using the labels)\n      let tableHeader = this.state.tableHeader;\n      for (let i = 0; i < tableHeader.length; ++i) {\n        let curText = tableHeader[i].label;\n        // console.log(curText);\n        if (curText === undefined && tableHeader[i].length > 0) {\n          curText = \"\";\n          for (let j = 0; j < tableHeader[i].length; ++j) {\n            if (j > 0) {\n              curText += \"&\";\n            }\n            curText += tableHeader[i][j].label;\n          }\n        }\n        if (curText !== undefined && curText !== \"\") {\n          copiedText = copiedText + curText + \"\\t\";\n        }\n      }\n      copiedText += \"\\n\";\n      // Now we need to fetch the rows that are not column headers\n      let tableData = this.state.tableData;\n      const rowNum = tableData.length;\n      const colNum = tableData[0].length;\n      for (let i = 0; i < rowNum; ++i) {\n        for (let j = 0; j < colNum; ++j) {\n          let curText = tableData[i][j].data;\n          if (curText !== undefined && curText !== \"\") {\n            copiedText = copiedText + curText + \"\\t\";\n          }\n        }\n        copiedText += \"\\n\";\n      }\n    } else {\n    }\n    textArea.value = copiedText;\n    document.body.appendChild(textArea);\n    textArea.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(textArea);\n    alert(\"Table content has been pasted!\");\n  }\n\n  // This function handles the toggling of the WikiPage at bottom\n\n  toggleWikiPage() {\n    let pageHidden = this.state.pageHidden;\n    this.setState({\n      pageHidden: !pageHidden,\n    });\n  }\n\n  // This function handles the selection of the starting task \"startSubject\"\n\n  handleStartSubject(e, taskSelected) {\n\n    if (taskSelected === \"startSubject\") {\n      // Since the starting task is\"startSubject\", we set the URL to be the first cell in the table\n      const subject = decodeURIComponent(this.state.urlPasted.slice(30)); // add a decodeURIComponent here\n      let tableData = _.cloneDeep(this.state.tableData);\n      tableData[0][0].data = subject;\n\n      // Adding support for undo:\n      let lastAction = \"handleStartSubject\";\n      let prevState = \n        {\n          \"usecaseSelected\":this.state.usecaseSelected,\n          \"tableData\":this.state.tableData,\n          \"tabIndex\":this.state.tabIndex,\n        };\n\n      this.setState({\n        usecaseSelected: taskSelected,\n        tableData: tableData,\n        lastAction: lastAction,\n        prevState: prevState,\n        tabIndex: 0,\n      });\n    } \n  }\n\n  // This function handles manually changing cell in a table\n\n  cellChange(e, i, j) {\n    e.preventDefault();\n    let tableData = this.state.tableData.slice();\n    tableData[i][j].data = e.target.value;\n    this.setState({\n      tableData: tableData,\n    });\n  }\n\n  // This function updates the options for selections when we click on selection for a key column\n  // based on cells already filled in this column\n\n  getKeyOptions(e, colIndex) {\n    if (colIndex === this.state.keyColIndex) {\n      \n      // We first get all the non-empty values from the key column\n      let allSubject = [];\n      for (let i = 0; i < this.state.tableData.length; ++i) {\n        if (this.state.tableData[i][colIndex].data === \"\") {\n          break;\n        } else {\n          allSubject.push(regexReplace(this.state.tableData[i][colIndex].data));\n        }\n      }\n\n      // In here we fetch the options for first column's selection\n      // It uses the common dct:subject of all cells entered in the key column\n\n      let prefixURL =\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\n      for (let i = 0; i < allSubject.length; ++i) {\n        queryBody +=\n          \"%0D%0A++++++++dbr%3A\" + allSubject[i] + \"+dct%3Asubject+%3Fsomevar.\";\n      }\n      let suffixURL =\n        \"%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let promiseArray = [];\n      promiseArray.push(fetchJSON(queryURL));\n      allPromiseReady(promiseArray).then((values) => {\n        let myJson = values[0];\n        let keyColOptions = [];\n        for (let i = 0; i < myJson.results.bindings.length; ++i) {\n          let tempObj = {};\n          let neighbour = myJson.results.bindings[i].somevar.value.slice(37);\n          tempObj[\"label\"] = neighbour;\n          tempObj[\"value\"] = neighbour;\n          keyColOptions.push(tempObj);\n        }\n        // We create a copy of the optionsMap.\n        // Then change the entry in the optionsMap corresponding to the key column to what we have just fetched: keyColOptions.\n        let optionsMap = this.state.optionsMap.slice();\n        optionsMap[this.state.keyColIndex] = keyColOptions;\n        this.setState({\n          optionsMap: optionsMap,\n        });\n      });\n    }\n  }\n\n  // This function updates the options for selections when we click on selection for non-key column\n  // based on cells already filled in this column, and the cells in the key column\n  // aka: Michelle Obama is Barack Obama' wife\n\n  getOtherOptions(e, colIndex) {\n    if (colIndex !== this.state.keyColIndex) {\n      // first we want to check if this column is all-empty\n      let colEmpty = true;\n      let nonEmptyInfo = [];\n      for (let i = 0; i < this.state.tableData.length; ++i) {\n        if (this.state.tableData[i][colIndex].data !== \"\") {\n          colEmpty = false;\n          nonEmptyInfo.push([i, this.state.tableData[i][colIndex].data]);\n        }\n      }\n      // We only want to update the options if the column is non-empty\n      // Make sure to modify this relation here to include only dbo and dbp\n      if (colEmpty === false) {\n        let prefixURL =\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n        let suffixURL =\n          \"%0D%0A%7D%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n        let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\n        for (let i = 0; i < nonEmptyInfo.length; ++i) {\n          let curKeySubject = regexReplace(\n            this.state.tableData[nonEmptyInfo[i][0]][this.state.keyColIndex]\n              .data\n          );\n          let curEnteredSubject = regexReplace(nonEmptyInfo[i][1]);\n          queryBody +=\n            \"%0D%0A++++++++dbr%3A\" +\n            curKeySubject +\n            \"+%3Fsomevar+dbr%3A\" +\n            curEnteredSubject +\n            \".\";\n        }\n        let queryURL = prefixURL + queryBody + suffixURL;\n        let promiseArray = [];\n        promiseArray.push(fetchJSON(queryURL));\n        allPromiseReady(promiseArray).then((values) => {\n          let myJson = values[0];\n          let otherColOptions = [];\n          for (let i = 0; i < myJson.results.bindings.length; ++i) {\n            let tempObj = {};\n            let neighbour = myJson.results.bindings[i].somevar.value.slice(\n              28\n            );\n            tempObj[\"label\"] = neighbour;\n            tempObj[\"value\"] = neighbour;\n            tempObj[\"type\"] = \"subject\"; // for now we only allow the subject search\n            otherColOptions.push(tempObj);\n          }\n          let optionsMap = this.state.optionsMap.slice();\n          optionsMap[colIndex] = otherColOptions;\n          this.setState({\n            optionsMap: optionsMap,\n          });\n        });\n      } \n      // If this non-key column is empty, we just use keyColNeighbours for the list of options\n      else {\n        let optionsMap = this.state.optionsMap.slice();\n        optionsMap[colIndex] = this.state.keyColNeighbours;\n        this.setState({\n          optionsMap: optionsMap,\n        });\n      }\n    }\n  }\n\n  // This function handles the the selection of a column header.\n  // Note: we want to deal with the selection of key column header vs non key column header differently\n\n  selectColHeader(e, colIndex) {\n    // console.log(\"Check table header here\");\n    // console.log(this.state.tableHeader);\n    //  We first create a copy of the existing table headers\n    let tableHeader = this.state.tableHeader.slice();\n\n    // This part deals with the selection of key column header\n    if (colIndex === this.state.keyColIndex) {\n      // We create a copy of the selected option\n      if (e !== null) {\n        let selectedOptions = e.slice();\n        // console.log(selectedOptions);\n        tableHeader[colIndex] = selectedOptions;\n        let tempObj = {};\n        tempObj[\"task\"] = \"populateKeyColumn\";\n        tempObj[\"colIndex\"] = colIndex;\n        tempObj[\"neighbourArray\"] = [];\n        for (let i = 0; i < selectedOptions.length; ++i) {\n          tempObj.neighbourArray.push(selectedOptions[i].value);\n        }\n        this.setState({\n          tableHeader: tableHeader,\n          curActionInfo: tempObj,\n        });\n      }\n    }\n    // This part deals with the selection of non key column header\n    else {\n      // The first few lines fix some pass by reference problems\n      let evalue = e.value;\n      let elabel = e.label;\n      tableHeader[colIndex] = { value: evalue, label: elabel };\n      // We want to change the label of non-key column headers with respect to the label of key column\n      // We first create the label text for the key column\n      let keyColLabel = \"\";\n      if (this.state.keyColIndex === 0) {\n        for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\n          if (i > 0) {\n            keyColLabel += \"&\";\n          }\n          keyColLabel += tableHeader[this.state.keyColIndex][i].label;\n        }\n      } else {\n        keyColLabel = tableHeader[this.state.keyColIndex].label;\n      }\n      // Bugfix for Go Table Creation: if at this stage, keyColLable is still \"\", that means we came from the tabel union task first.\n      // In this case, tableHeader[keyColIndex] is an object, not an array. \n      // So we just set keyColLabel as tableHeader[this.state.keyColIndex].label\n      if (keyColLabel === \"\") {\n        keyColLabel = tableHeader[this.state.keyColIndex].label;\n      }\n      // We then append the current column's label to it\n      // console.log(keyColLabel);\n      tableHeader[colIndex].label =\n        tableHeader[colIndex].label + \"--\" + keyColLabel;\n      // After we have selected the column header, not only do we want to fill in the name of the column, we also want to\n      // ask in ActionPanel whether user wants to populate the column based on the chosen column name\n      let tempObj = {};\n      tempObj[\"task\"] = \"populateOtherColumn\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbour\"] = e.value;\n      tempObj[\"type\"] = e.type;\n      // We want to deal with duplicate neighbour names since we are selecting column headers for non-key columns\n      let arr = elabel.split(\"-\");\n      if (arr.length > 1 && !isNaN(Number(arr[1]) - 1)) {\n        // arr[1] stores the index of the neighbour with duplicate names\n        tempObj[\"neighbourIndex\"] = Number(arr[1]) - 1;\n      } else {\n        // If neighbourIndex is equal to -1, that means this property has no duplicate names\n        tempObj[\"neighbourIndex\"] = -1;\n      }\n\n      // If type is subject, let's check if this neighbour also has a \"range\" (rdfs:range)\n      if (e.type === \"subject\" && e.range !== undefined) {\n        tempObj[\"range\"] = e.range;\n      }\n      // console.log(tempObj);\n\n      this.setState({\n        tableHeader: tableHeader,\n        curActionInfo: tempObj,\n      });\n    }\n  }\n\n  // This function populates the key column\n  // It also fetches the neighbours of the key column (based on the first cell in the table)\n  // as well as setting the origins of cells in the key column\n\n  // Note: we need to do some modification here. Instead of having a fixed number of entries in the key column,\n  // Let's make it more flexible. (but also pose a limit, so we don't get way too many entries)\n\n  populateKeyColumn(e, colIndex, neighbour) {\n    // We will populate this column based on query: ?p dct:subject dbc:Presidents_of_United_States\n    // We also need to fetch the neighbours of this key column, both using the key column entries as subject and object\n\n    // Since we need to make multiple (three) queries, we make a promise array\n    let promiseArray = [];\n\n    // Below is the first query we will make.\n    // This query populates the first columns.\n    // Note: since neighbour is now an array instead of a single value (as we are allowing multiselects), we need to adjust our query\n    // let prefixURLOne = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    // let suffixURLOne = \"%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    // let queryBodyOne = \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A%09%3Fsomevar+dct%3Asubject+dbc%3A\"\n    //                     +regexReplace(neighbour)\n    //                     +\".%0D%0A%7D%0D%0ALIMIT+\"+emptyEntryCount;\n    let prefixURLOne =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    // let suffixURLOne =\n    //   \"%0D%0A%7D+%0D%0Alimit+\" +\n    //   emptyEntryCount +\n    //   \"&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let suffixURLOne =\n      \"%0D%0A%7D+%0D%0A\" +\n      \"&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyOne = \"select+%3Fsomevar%0D%0Awhere+%7B\";\n    // We are using a loop here because multi-select is possible\n    for (let i = 0; i < neighbour.length; ++i) {\n      queryBodyOne =\n        queryBodyOne +\n        \"%0D%0A+++++++%3Fsomevar+dct%3Asubject+dbc%3A\" +\n        regexReplace(neighbour[i]) +\n        \".\";\n    }\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n    let keyColPromise = fetchJSON(queryURLOne);\n    promiseArray.push(keyColPromise);\n\n    // Below is the second query we will make.\n    // This query fetches the neighbours for tableData[0][colIndex], so the first cell in column with index colIndex\n    // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\n\n    // SELECT ?p\n    // WHERE {\n    //         dbr:Barack_Obama ?p ?o.\n    //         BIND(STR(?p) AS ?pString ).\n    //         FILTER(\n    //               !(regex(?pString,\"abstract|wikiPage|align|caption|image|width|thumbnail|blank\",\"i\"))\n    //               && regex(?pString, \"ontology|property\", \"i\")\n    //               )\n    // }\n\n    // Let's modify the query below to support the \"populate from same range feature\"\n\n    // let prefixURLTwo = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    // let suffixURLTwo = \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    // let queryBodyTwo =\n    //   \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\"\n    //   +regexReplace(this.state.tableData[0][colIndex].data)\n    //   +\"+%3Fp+%3Fo.%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A%0D%0A&\";\n    let prefixURLTwo =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLTwo =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyTwo =\n      \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\n      regexReplace(this.state.tableData[0][colIndex].data) +\n      \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n    let otherColPromiseSubject = fetchJSON(queryURLTwo);\n    promiseArray.push(otherColPromiseSubject);\n\n    // Below is the third query we will make.\n    // Difference with the previous query is that we are using tableData[0][colIndex] as OBJECT\n    let prefixURLThree =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLThree =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyThree =\n      \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\n      regexReplace(this.state.tableData[0][colIndex].data) +\n      \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\n    let queryURLThree = prefixURLThree + queryBodyThree + suffixURLThree;\n    let otherColPromiseObject = fetchJSON(queryURLThree);\n    promiseArray.push(otherColPromiseObject);\n\n    allPromiseReady(promiseArray).then((values) => {\n      // let's first work with the first promise result: fill in table data with the entities we have fetched\n\n      // This part sets the data for each cell\n      let tableData = _.cloneDeep(this.state.tableData);\n\n      // First we get the correct number of rows, which is equal to min(values[0].results.bindings.length, initialRowNum)\n      let updatedRowCount = Math.min(values[0].results.bindings.length, initialRowNum);\n      // console.log(\"Original length is \"+values[0].results.bindings.length);\n      // console.log(\"Row Count is: \"+updatedRowCount);\n\n      // If tableData has too many rows, we slice it. Else we keep it the same way.\n      if (tableData.length > updatedRowCount) {\n        tableData = tableData.slice(0,updatedRowCount);\n      }\n      let rowNum = tableData.length;\n      // console.log(\"Number of rows is \"+rowNum);\n\n      // We do not want to overwrite entries that users have filled in.\n      // Let's calculate how many entries we want to fill in.\n      let emptyEntryCount = rowNum;\n      for (let i = 0; i < rowNum; ++i) {\n        if (tableData[i][colIndex].data !== \"\") {\n          emptyEntryCount--;\n        } else {\n          break;\n        }\n      }\n      // console.log(\"number of empty entries is \"+emptyEntryCount);\n\n      let startingIndex = rowNum - emptyEntryCount;\n\n      for (let i = 0; i < emptyEntryCount; ++i) {\n        tableData[i + startingIndex][colIndex].data = \n          values[0].results.bindings[i].somevar.value.slice(28);\n      }\n\n      // second part sets the origin for each cell\n      for (let i = 0; i < rowNum; ++i) {\n        // We need to process the tableHeader[colIndex] array to get the correct text for origin\n        let labelText = \"\";\n        for (let j = 0; j < this.state.tableHeader[colIndex].length; ++j) {\n          if (j > 0) {\n            labelText += \"&\";\n          }\n          labelText += this.state.tableHeader[colIndex][j].value;\n        }\n        let tempOrigin = labelText + \":\" + tableData[i][colIndex].data;\n        tableData[i][colIndex].origin.push(tempOrigin);\n      }\n\n      // let's now work with the second and third promise result: update the selection options for non-key columns\n\n      let keyColNeighbours = [];\n      keyColNeighbours = updateKeyColNeighbours(\n        keyColNeighbours,\n        values[1].results.bindings,\n        \"subject\"\n      );\n      keyColNeighbours = updateKeyColNeighbours(\n        keyColNeighbours,\n        values[2].results.bindings,\n        \"object\"\n      );\n      // console.log(keyColNeighbours);\n\n      let optionsMap = this.state.optionsMap.slice();\n      for (let i = 0; i < optionsMap.length; ++i) {\n        if (i !== colIndex) {\n          optionsMap[i] = keyColNeighbours;\n        }\n      }\n\n      // Support for undo: \n      // Let's save the previous state in an object\n      let lastAction = \"populateKeyColumn\";\n      let prevState = \n        {\n          \"keyColIndex\":this.state.keyColIndex,\n          \"keyColNeighbours\":this.state.keyColNeighbours,\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n          \"optionsMap\":this.state.optionsMap\n        };\n\n\n      this.setState({\n        keyColIndex: colIndex,\n        keyColNeighbours: keyColNeighbours,\n        curActionInfo: null,\n        tableData: tableData,\n        optionsMap: optionsMap,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    });\n  }\n\n  // TEST FUNCTION----------------------------------------------------\n\n  // getOtherColPromiseTwo(neighbour, type) {\n  //   let promiseArray = [];\n  //   // The following is the query we will make\n\n  //   // SELECT ?key ?val\n  //   // WHERE{\n  //   //       ?key (dbo:spouse|dbp:spouse) ?val.\n  //   //       VALUES ?key {dbr:Barack_Obama dbr:Ronald_Reagan dbr:Donald_Trump }\n  //   // }\n\n\n  //   let prefixURL = \n  //     \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n  //   let suffixURL = \n  //     \"%7D%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=300000&debug=on&run=+Run+Query+\";\n  //   let queryBody;\n  //   // This clause handles the case of \"Obama -> property -> object\"\n  //   if (type === \"subject\") {\n  //     queryBody = \n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fkey+%28dbo%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%7Cdbp%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%29+%3Fval.%0D%0A++++++VALUES+%3Fkey+%7B\";\n  //   } \n  //   // This clause handles the case of \"subject -> property -> Obama\"\n  //   else {\n  //     queryBody = \n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fval+%28dbo%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%7Cdbp%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%29+%3Fkey.%0D%0A++++++VALUES+%3Fkey+%7B\";\n  //   }\n  //   for (let i = 0; i < this.state.tableData.length; ++i) {\n  //     let cellValue = regexReplace(\n  //       this.state.tableData[i][this.state.keyColIndex].data\n  //     );\n  //     // N/A's will block the search, let's replace it with some string that does not block the search\n  //     if (cellValue === \"N/A\") {\n  //       cellValue = \"NONEXISTINGSTRING\";\n  //     }\n  //     let curQueryText = \"dbr%3A\"+cellValue+\"+\";\n  //     queryBody+=curQueryText;\n  //   }\n  //   let queryURL = prefixURL + queryBody + suffixURL;\n  //   // console.log(queryURL);\n  //   promiseArray.push(fetchJSON(queryURL));\n  //   return promiseArray;\n  // }\n\n  // The following function serves as a helper function for \"populateOtherColumn\" and \"populateSameNeighbour\"\n  // It makes an array of querie, which may affect the performance of our system. Let's change it now.\n\n  getOtherColPromise(neighbour, type) {\n    let promiseArray = [];\n    let prefixURL =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURL =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    for (let i = 0; i < this.state.tableData.length; ++i) {\n      let cellValue = regexReplace(\n        this.state.tableData[i][this.state.keyColIndex].data\n      );\n      // N/A's will block the search, let's replace it with some string that does not block the search\n      if (cellValue === \"N/A\") {\n        cellValue = \"NONEXISTINGSTRING\";\n      }\n      let queryBody;\n      if (type === \"subject\") {\n        queryBody =\n          \"SELECT+%3Fsomevar%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\" +\n          cellValue +\n          \"+%28dbo%3A\" +\n          regexReplace(neighbour) +\n          \"%7Cdbp%3A\" +\n          regexReplace(neighbour) +\n          \"%29+%3Fsomevar.%0D%0A%7D%0D%0A%0D%0A&\";\n      } else {\n        queryBody =\n          \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A++++++++%3Fsomevar+%28dbo%3A\" +\n          regexReplace(neighbour) +\n          \"%7Cdbp%3A\" +\n          regexReplace(neighbour) +\n          \"%29+dbr%3A\" +\n          cellValue +\n          \"%0D%0A%7D%0D%0A&\";\n      }\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let curPromise = fetchJSON(queryURL);\n      promiseArray.push(curPromise);\n    }\n    return promiseArray;\n  }\n\n  populateOtherColumn(e, colIndex, neighbour, neighbourIndex, type, range) {\n\n    // Support for \"populateSameRange\":\n\n    // When the range is not equal to undefined, we want to ask user if they want to populate all other attributes from this range\n    // console.log(range);\n\n    // we need to make a number of queries in the form of: dbr:somekeycolumnentry dbp:neighbour|dbo:neighbour somevar\n    // let promiseArrayTwo = this.getOtherColPromiseTwo(neighbour, type); // this is for testing\n    let promiseArray = this.getOtherColPromise(neighbour, type);\n\n    allPromiseReady(promiseArray).then((values) => {\n    // allPromiseReady(promiseArrayTwo).then((testValues) => {\n\n      // // Now we need to process the testValues\n\n      // let pairArray = [];\n\n      // // First we removed the prefixes from resultArray\n      // for (let i=0; i<testValues[0].results.bindings.length; ++i) {\n      //   pairArray.push(\n      //     {\n      //       \"key\":removePrefix(testValues[0].results.bindings[i].key.value),\n      //       \"value\":removePrefix(testValues[0].results.bindings[i].val.value)\n      //     }\n      //   )\n      // }\n      // console.log(pairArray);\n\n      // // Then we create a keyArray\n      // let keyArray = [];\n\n      // for (let i=0; i<this.state.tableData.length; ++i) {\n      //   keyArray.push(this.state.tableData[i][this.state.keyColIndex].data);\n      // }\n      // console.log(keyArray);\n\n      let tableData = _.cloneDeep(this.state.tableData);\n      let requiredLength = neighbourIndex === -1 ? 1 : neighbourIndex + 1;\n      for (let i = 0; i < values.length; ++i) {\n        if (values[i].results.bindings.length < requiredLength) {\n          // this means results is not found\n          // or if there is not enough results, in duplicate neighbour name case\n          if (tableData[i][this.state.keyColIndex].data === \"\") {\n            tableData[i][colIndex].data = \"\";\n          } else {\n            tableData[i][colIndex].data = \"N/A\";\n          }\n        } else {\n          // let's determine if we need to truncate\n          // Note: In here we are fetching the first value from the binding array. But sometimes there will be more than 1.\n          // Think about what to do when there are duplicates\n          // console.log(\"Current value is \");\n          // console.log(values[])\n          let dbResult =\n            values[i].results.bindings[requiredLength - 1].somevar.value;\n          dbResult = removePrefix(dbResult);\n          // We first set the data of the cell\n          tableData[i][colIndex].data = dbResult;\n          // We then set the origin of the cell\n          // This origin depends on whether type is \"subject\" or \"object\"\n          let originToAdd;\n          // console.log(type);\n          if (type === \"subject\") {\n            originToAdd = neighbour + \":\" + dbResult;\n          } else {\n            originToAdd = \"is \" + neighbour + \" of:\" + dbResult;\n          }\n          // console.log(originToAdd);\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\n          // console.log(keyOrigin);\n          keyOrigin.push(originToAdd);\n          // console.log(keyOrigin);\n          tableData[i][colIndex].origin = keyOrigin;\n        }\n      }\n\n      // If we just populated a column with duplicate names, we want to give users an option to \"populate all other columns of this name\"\n\n      // Note: the index we use in the values array has to be this.state.keyEntryIndex, because that one is the entry currently in effect\n      let maxCount = Math.min(\n        values[this.state.keyEntryIndex].results.bindings.length,\n        maxNeighbourCount\n      );\n      // console.log(\"neighbour index is \"+neighbourIndex);\n      // console.log(\"max count is \"+maxCount);\n      let remainNeighbourCount = maxCount - neighbourIndex - 1;\n      // console.log(\"remain neighbour count is \"+remainNeighbourCount);\n      let tempObj = {};\n      if (neighbourIndex !== -1 && remainNeighbourCount > 0) {\n        tempObj[\"task\"] = \"populateSameNeighbour\";\n        tempObj[\"colIndex\"] = colIndex;\n        tempObj[\"neighbour\"] = neighbour;\n        tempObj[\"neighbourIndex\"] = neighbourIndex;\n        tempObj[\"type\"] = type;\n        tempObj[\"numCols\"] = remainNeighbourCount;\n        // Note that if we populateSameNeighbour in different columns, we may also need this range attribute\n        if (range !== undefined) {\n          tempObj[\"range\"] = range;\n        }\n      } \n      // If we are not populating a column with duplicate names, but it has a range, we ask user if they want to populate\n      // other columns from the same range\n      else if (range !== undefined) {\n        let siblingNeighbour = [];\n        // console.log(\"Range is \"+range);\n        // console.log(this.state.keyColNeighbours);\n        for (let i = 0; i < this.state.keyColNeighbours.length; ++i) {\n          if (\n            this.state.keyColNeighbours[i].range === range &&\n            this.state.keyColNeighbours[i].value !== neighbour\n          ) {\n            siblingNeighbour.push(this.state.keyColNeighbours[i].value);\n          }\n        }\n        // If we have found columns from the same range (other than the current neighbour),\n        // we give user the option to populate other columns from the same range.\n        if (siblingNeighbour.length > 0) {\n          // First, we want to keep track of the number of occurences for each sibling attribute\n          let siblingUnique = [...new Set(siblingNeighbour)];\n          let siblingCount = [];\n          for (let i = 0; i < siblingUnique.length; ++i) {\n            // console.log(siblingNeighbour);\n            siblingCount.push({\n              name: siblingUnique[i],\n              count: siblingNeighbour.filter((x) => x === siblingUnique[i])\n                .length,\n            });\n          }\n          // console.log(siblingCount);\n          // Let's do some string processing to improve UI clarity\n          let rangeLiteral = \"\";\n          if (range.includes(\"http://dbpedia.org/ontology/\")) {\n            rangeLiteral = range.slice(28);\n          } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\n            rangeLiteral = range.slice(33);\n          } else {\n            rangeLiteral = range;\n          }\n          tempObj[\"task\"] = \"populateSameRange\";\n          tempObj[\"colIndex\"] = colIndex;\n          tempObj[\"range\"] = rangeLiteral;\n          tempObj[\"siblingNeighbour\"] = siblingCount;\n        }\n      }\n      // This is an empty else clause\n      else {\n      }\n      // console.log(tempObj);\n\n      // Support for undo: \n      // Let's save the previous state in an object\n      let lastAction = \"populateOtherColumn\";\n      let prevState = \n        {\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n        };\n\n      this.setState({\n        curActionInfo: tempObj,\n        tableData: tableData,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    });\n    // });\n  }\n\n  // This function is a helper function that takes in 10 parameters:\n  // Note: this function does not make any fetch requests, thus does NOT involve promises.\n\n  // 1) colIndex:        index of the column that we just filled     (ex. 1, if we just filled in column 1)\n  // 2) neighbour:       attribute name of the column we just filled (ex. almaMater)\n  // 3) neighbourIndex:  index of the attribute we just filled       (ex. 0, if we have filled in almaMater-1)\n  // 4) type:            type of the attribute. Either \"subject\" or \"object\"\n  // 5) numCols:         number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\n  // 6) values:          query results that are passed in\n\n  // 7) tableHeader:                 original tableHeader\n  // 8) tableData:                   original tableData\n  // 9) optionsMap:                  original optionsMap\n  // 10) selectedClassAnnotation:    original selectedClassAnnotation\n\n  // and returns an object with 5 values:\n  // 1) tableHeader:                tableHeader after modification\n  // 2) tableData:                  tableData after modification\n  // 3) optionsMap:                 optionsMap after modification\n  // 4) selectedClassAnnotation:    selectedClassAnnotation after modification\n  // 5) keyColIndex:                keyColIndex after modification\n\n  addAllNeighbour(\n    colIndex,\n    neighbour,\n    neighbourIndex,\n    type,\n    numCols,\n    values,\n    tableHeader,\n    tableData,\n    optionsMap,\n    selectedClassAnnotation,\n    keyColIndex,\n  ) {\n    // Let's first check if all the variables are as expected\n\n    // console.log(\"Column index is: \"+colIndex);\n    // console.log(\"Neighbour is: \"+neighbour);\n    // console.log(\"Neighbour index is: \"+neighbourIndex);\n    // console.log(\"Type is: \"+type);\n    // console.log(\"Number of columns to fill is: \"+numCols);\n    // console.log(\"Table header is: \");\n    // console.log(tableHeader);\n    // console.log(\"Table Data is: \");\n    // console.log(tableData);\n    // console.log(\"Options map is: \");\n    // console.log(optionsMap);\n    // console.log(values);\n\n    // Now we need to write the body for this function\n\n    // First thing should be to insert \"numCols\" number of empty columns right after column with index \"colIndex\"\n    const rowNum = tableData.length;\n    const colNum = tableData[0].length;\n\n    // Let's check if we need to modify keyColIndex:\n    // if colIndex < keyColIndex, we need to increase keyColIndex by numCols\n    let keyColIndexUpdated = keyColIndex;\n    if (colIndex < keyColIndex) {\n      keyColIndexUpdated+=numCols;\n    }\n\n    // We first take care of table data's (empty) additions\n    let tableDataUpdated = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(tableData[i][j]);\n      }\n      // we add in numCols number of empty columns\n      for (let j = 0; j < numCols; ++j) {\n        tempRow.push({ data: \"\", origin: [] });\n      }\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(tableData[i][k]);\n      }\n      tableDataUpdated.push(tempRow);\n    }\n\n    // we now take care of table header's addition.\n    let tableHeaderUpdated = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      tableHeaderUpdated.push(tableHeader[j]);\n    }\n    // some modification needs to be made here\n    let labelText = \"\";\n    if (keyColIndex === 0) {\n      for (\n        let i = 0;\n        i < tableHeader[0].length;\n        ++i\n      ) {\n        if (i > 0) {\n          labelText += \"&\";\n        }\n        labelText += tableHeader[0][i].value;\n      }\n    } else {\n      // there's a bug somewhere here. Needs to fix it later.\n      labelText = tableHeader[keyColIndex].label;\n    }\n    for (let j = 0; j < numCols; ++j) {\n      let curLabel = \"\";\n      // First case is for type \"subject\"\n      if (type === \"subject\") {\n        curLabel =\n          curLabel +\n          neighbour +\n          \"-\" +\n          (neighbourIndex + 2 + j) +\n          \"--\" +\n          labelText;\n      }\n      // Second case is for type \"object\"\n      else {\n        curLabel =\n          curLabel +\n          \"is \" +\n          neighbour +\n          \" of-\" +\n          (neighbourIndex + 2 + j) +\n          \"--\" +\n          labelText;\n      }\n      tableHeaderUpdated.push({ value: neighbour, label: curLabel });\n    }\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      tableHeaderUpdated.push(tableHeader[k]);\n    }\n\n    // We now take care of selectedClassAnnotation. For now, we just add some empty arrays to it\n    let selectedClassAnnotationUpdated = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[j]);\n    }\n    for (let j = 0; j < numCols; ++j) {\n      selectedClassAnnotationUpdated.push([]);\n    }\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[k]);\n    }\n\n    // we now take care of optionMap's addition. We just need to add some empty arrays to it\n    let optionsMapUpdated = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      optionsMapUpdated.push(optionsMap[j]);\n    }\n    for (let j = 0; j < numCols; ++j) {\n      optionsMapUpdated.push([]);\n    }\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      optionsMapUpdated.push(optionsMap[k]);\n    }\n\n    // Finally, we fill in the actual data for tableData. We need to take care of both data and origin\n    // for (let i=0;i<values.length;++i) {\n    //   console.log(values[i].results.bindings);\n    // }\n    for (let curCol = colIndex + 1; curCol < colIndex + 1 + numCols; ++curCol) {\n      // curNeighbourIndex represents the required length\n      let requiredLength = neighbourIndex + curCol - colIndex + 1;\n      for (let i = 0; i < values.length; ++i) {\n        // Firt case: result is not found, or there is not enough results (in duplicate neighbour case)\n        // console.log(values[i]);\n        if (values[i].results.bindings.length < requiredLength) {\n          tableDataUpdated[i][curCol].data = \"N/A\";\n        }\n        // Second case: result is found. We need to process them.\n        else {\n          // let's determine if we need to truncate\n          // Note: In here we are fetching the first value from the binding array. But sometimes there will be more than 1.\n          // Think about what to do when there are duplicates\n          let dbResult =\n            values[i].results.bindings[requiredLength - 1].somevar.value;\n          dbResult = removePrefix(dbResult);\n          // We first set the data of the cell\n          tableDataUpdated[i][curCol].data = dbResult;\n          // We then set the origin of the cell\n          // This origin depends on whether type is \"subject\" or \"object\"\n          let originToAdd;\n          // console.log(type);\n          if (type === \"subject\") {\n            originToAdd = neighbour + \":\" + dbResult;\n          } else {\n            originToAdd = \"is \" + neighbour + \" of:\" + dbResult;\n          }\n          // console.log(originToAdd);\n          let keyOrigin = tableDataUpdated[i][\n            keyColIndexUpdated\n          ].origin.slice();\n          // console.log(keyOrigin);\n          keyOrigin.push(originToAdd);\n          // console.log(keyOrigin);\n          tableDataUpdated[i][curCol].origin = keyOrigin;\n        }\n      }\n    }\n    return {\n      tableHeader: tableHeaderUpdated,\n      tableData: tableDataUpdated,\n      optionsMap: optionsMapUpdated,\n      selectedClassAnnotation: selectedClassAnnotationUpdated,\n      keyColIndex: keyColIndexUpdated,\n    };\n  }\n\n  // This function populates all neighbour with the same names in different columns, if that neighbour has multiple occurences.\n\n  // It takes in 6 parameters:\n  // 1) colIndex:        index of the column that we just filled     (ex. 1, if we just filled in column 1)\n  // 2) neighbour:       attribute name of the column we just filled (ex. almaMater)\n  // 3) neighbourIndex:  index of the attribute we just filled       (ex. 0, if we have filled in almaMater-1)\n  // 4) type:            type of the attribute. Either \"subject\" or \"object\"\n  // 5) numCols:         number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\n  // 6) range:           range for the neighbour to be filled (ex: Person for vicePresident)\n  \n  // Note: currently it only populates \"later\" neighbour with same name.\n\n  sameNeighbourDiffCol(e,colIndex,neighbour,neighbourIndex,type,numCols,range) {\n\n    // The following is testing for 2D Promise arrays. Turns out it works!\n    // let promiseArrayOne = this.getOtherColPromise(neighbour,type);\n    // let promiseArrayTwo = this.getOtherColPromise(neighbour,type);\n    // let twoD = [promiseArrayOne,promiseArrayTwo];\n    // allPromiseReady(twoD).then((values) => {\n    //   console.log(values);\n    // })\n\n    // console.log(neighbourIndex);\n    // console.log(range);\n\n    let promiseArray = this.getOtherColPromise(neighbour,type);\n    allPromiseReady(promiseArray).then((values) => {\n      let newState = this.addAllNeighbour(colIndex,\n                                        neighbour,\n                                        neighbourIndex,\n                                        type,\n                                        numCols,\n                                        values,\n                                        this.state.tableHeader,\n                                        this.state.tableData,\n                                        this.state.optionsMap,\n                                        this.state.selectedClassAnnotation,\n                                        this.state.keyColIndex);\n      // Let's also create the object we need for populateSameRange\n      // Note: the following code is identical to what we have in populateOtherColumn\n      let tempObj = {};\n      let siblingNeighbour = [];\n      // console.log(\"Range is \"+range);\n      // console.log(this.state.keyColNeighbours);\n      for (let i=0;i<this.state.keyColNeighbours.length;++i) {\n        if (range !== undefined\n            &&this.state.keyColNeighbours[i].range === range \n            && this.state.keyColNeighbours[i].value !== neighbour) {\n          siblingNeighbour.push(this.state.keyColNeighbours[i].value);\n        }\n      }\n      // If we have found columns from the same range (other than the current neighbour), \n      // we give user the option to populate other columns from the same range.\n      if (siblingNeighbour.length > 0) {\n        // This needs some additional checking to prevent bugs\n        // console.log(\"We may have a bug here\");\n        // console.log(\"Range is: \"+range);\n        // console.log(\"SiblingNeighbour is \"+siblingNeighbour);\n        // console.log(\"Is undefined equal to undefined? \"+(undefined === undefined));\n        // First, we want to keep track of the number of occurences for each sibling attribute\n        let siblingUnique = [...new Set(siblingNeighbour)];\n        let siblingCount = [];\n        for (let i=0;i<siblingUnique.length;++i) {\n          // console.log(siblingNeighbour);\n          siblingCount.push({\"name\":siblingUnique[i],\"count\":siblingNeighbour.filter(x => x === siblingUnique[i]).length})\n        }\n        // console.log(siblingCount);\n        // Let's do some string processing to improve UI clarity\n        let rangeLiteral = \"\";\n        if (range.includes(\"http://dbpedia.org/ontology/\")) {\n          rangeLiteral = range.slice(28);\n        } \n        else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\n          rangeLiteral = range.slice(33);\n        } \n        else {\n          rangeLiteral = range;\n        }\n        tempObj[\"task\"] = \"populateSameRange\";\n        tempObj[\"colIndex\"] = colIndex+numCols;  // Small change here: we need to adjust the position of the column index\n        tempObj[\"range\"] = rangeLiteral;\n        tempObj[\"siblingNeighbour\"] = siblingCount;\n      }\n\n      // Support for undo: \n      // Let's save the previous state in an object\n      let lastAction = \"sameNeighbourDiffCol\";\n      let prevState = \n        {\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n          \"tableHeader\":this.state.tableHeader,\n          \"optionsMap\":this.state.optionsMap,\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\n          \"keyColIndex\":this.state.keyColIndex,\n        };\n\n      this.setState({\n        curActionInfo:tempObj,\n        tableData:newState.tableData,\n        tableHeader:newState.tableHeader,\n        optionsMap:newState.optionsMap,\n        selectedClassAnnotation:newState.selectedClassAnnotation,\n        keyColIndex:newState.keyColIndex,\n        lastAction: lastAction,\n        prevState: prevState,\n      })\n    })\n  }\n\n  // This function populates all neighbour with the same names in the same columns, if that neighbour has multiple occurences.\n\n  sameNeighbourOneCol(e, colIndex, neighbour, neighbourIndex, type, numCols) {\n    // console.log(colIndex);\n    // console.log(neighbour);\n    // console.log(neighbourIndex);\n    // console.log(type);\n    // console.log(numCols);\n\n    // In this option, we just need to change data in column \"ColIndex\", by putting \"numCols\" numbers of new values into it\n    let tableData = _.cloneDeep(this.state.tableData);\n    let promiseArray = this.getOtherColPromise(neighbour, type);\n    allPromiseReady(promiseArray).then((values) => {\n      for (\n        let requiredLength = neighbourIndex + 2;\n        requiredLength < neighbourIndex + numCols + 2;\n        ++requiredLength\n      ) {\n        for (let i = 0; i < values.length; ++i) {\n          if (values[i].results.bindings.length >= requiredLength) {\n            let dbResult =\n              values[i].results.bindings[requiredLength - 1].somevar.value;\n            dbResult = removePrefix(dbResult);\n            tableData[i][colIndex].data =\n              tableData[i][colIndex].data + \";\" + dbResult;\n            let updatedOrigin = tableData[i][colIndex].origin.slice();\n            updatedOrigin[updatedOrigin.length - 1] =\n              updatedOrigin[updatedOrigin.length - 1] + \";\" + dbResult;\n            tableData[i][colIndex].origin = updatedOrigin;\n          }\n        }\n      }\n\n      // Support for undo: \n      let lastAction = \"sameNeighbourOneCol\";\n      let prevState = \n        {\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n        };\n\n      this.setState({\n        curActionInfo: null,\n        tableData: tableData,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    });\n  }\n\n  // The following function populates all neighbour from the same range (ex. all neighbours with rdfs:range Person)\n  // This function should use addAllNeighbour as a helper function\n  populateSameRange(e, colIndex, range, siblingNeighbour) {\n\n    // console.log(\"Column index is \"+colIndex);\n    // console.log(\"Range is \"+range);\n    // console.log(\"Sibling neighbours are: \");\n    // console.log(siblingNeighbour);\n    // for (let i=0;i<siblingNeighbour.length;++i) {\n    //   console.log(\"Neighbour name is: \"+siblingNeighbour[i].name);\n    //   console.log(\"Count is: \"+siblingNeighbour[i].count);\n    // }\n    let promiseArrayTwoD = [];\n    for (let i=0;i<siblingNeighbour.length;++i) {\n      let curPromiseArray = this.getOtherColPromise(siblingNeighbour[i].name,\"subject\");\n      for (let j=0;j<curPromiseArray.length;++j) {\n        promiseArrayTwoD.push(curPromiseArray[j]);\n      }\n      // promiseArrayTwoD.push(this.getOtherColPromise(siblingNeighbour[i].name,\"subject\"));\n    } \n    allPromiseReady(promiseArrayTwoD).then((values) => {\n\n      // for (let i=0;i<values.length;++i) {\n      //   console.log(values[i]);\n      // }\n\n      // first we fetch the initial state of tableHeader, tableData, optionsMap, and selectedClassAnnotation\n      let tempHeader = this.state.tableHeader;\n      let tempData = this.state.tableData;\n      let tempOptions = this.state.optionsMap;\n      let tempAnnotation = this.state.selectedClassAnnotation;\n      let tempKeyColIndex = this.state.keyColIndex;\n      let curColIndex = colIndex;\n      for (let i=0;i<siblingNeighbour.length;++i) {\n        let curValueArray = [];\n        for (let j=0;j<tempData.length;++j) {\n          curValueArray.push(values[tempData.length*i+j]) // since working with 2D promise array is not figured out yet, we need to manipulate index\n        }\n        let newState = this.addAllNeighbour(curColIndex,\n                                            siblingNeighbour[i].name,    // this is name of the neighbour\n                                            -1,                          // this is neighbour index. -1 indicates that we have not populated any neighbour of this name\n                                            \"subject\",                   // for now, type can only be subject\n                                            siblingNeighbour[i].count,   // we need to populate this number of columns for this neighbour\n                                            curValueArray,               // This is the fetched data\n                                            tempHeader,\n                                            tempData,\n                                            tempOptions,\n                                            tempAnnotation,\n                                            tempKeyColIndex);\n        curColIndex+=siblingNeighbour[i].count;\n        tempHeader = newState.tableHeader;\n        tempData = newState.tableData;\n        tempOptions = newState.optionsMap;\n        tempAnnotation = newState.selectedClassAnnotation;\n        tempKeyColIndex = newState.keyColIndex;\n      }\n\n      // Support for undo: \n      let lastAction = \"populateSameRange\";\n      let prevState = \n        {\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n          \"tableHeader\":this.state.tableHeader,\n          \"optionsMap\":this.state.optionsMap,\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\n          \"keyColIndex\":this.state.keyColIndex,\n        };\n\n      this.setState({\n        curActionInfo:null,\n        tableData:tempData,\n        tableHeader:tempHeader,\n        optionsMap:tempOptions,\n        selectedClassAnnotation:tempAnnotation,\n        keyColIndex:tempKeyColIndex,\n        lastAction:lastAction,\n        prevState:prevState,\n      })\n    })\n  }\n\n  // The following function adds a new column to the table, to the right of the context-menu clicked column.\n  // In here, let's also set tabIndex to 0.\n\n  contextAddColumn(e, colIndex) {\n    const rowNum = this.state.tableData.length;\n    const colNum = this.state.tableData[0].length;\n\n    // we first take care of table data's addition\n    let tableData = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(this.state.tableData[i][j]);\n      }\n      // we add in one column of empty data\n      tempRow.push({ data: \"\", origin: [] });\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(this.state.tableData[i][k]);\n      }\n      tableData.push(tempRow);\n    }\n\n    // we now take care of tabler header, optionMap, and selectedClassAnnotation's addition\n    // This added column will have options equal to the neighbours of the key column\n    let optionsMap = [];\n    let tableHeader = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      optionsMap.push(this.state.optionsMap[j]);\n      tableHeader.push(this.state.tableHeader[j]);\n    }\n    optionsMap.push(this.state.keyColNeighbours);\n    tableHeader.push(\"\");\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      optionsMap.push(this.state.optionsMap[k]);\n      tableHeader.push(this.state.tableHeader[k]);\n    }\n\n    // we now take care of selectedClassAnnotation\n    let selectedClassAnnotation = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\n    }\n    selectedClassAnnotation.push([]);\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\n    }\n\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\n    let keyColIndex = this.state.keyColIndex;\n    if (colIndex < keyColIndex) {\n      ++keyColIndex;\n    }\n\n    // console.log(this.state.selectedClassAnnotation);\n    // console.log(tableHeader);\n    this.setState({\n      tableData: tableData,\n      tableHeader: tableHeader,\n      curActionInfo: null,\n      optionsMap: optionsMap,\n      keyColIndex: keyColIndex,\n      selectedClassAnnotation: selectedClassAnnotation,\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n    });\n  }\n\n  // The following functions sets the selected cell to be the search cell.\n  // As a result, the column of the cell needs to be set as the search column as well.\n  contextSetCell(e, rowIndex, colIndex) {\n    // console.log(\"Row index of search cell is \"+rowIndex);\n    // console.log(\"Col index of search cell is \"+colIndex);\n\n    // This is the function that we need to fill out\n    let promiseArray = [];\n    // Below is the first query we will make.\n    // This query fetches the neighbours for tableData[rowIndex][colIndex]. So the search cell in the search column.\n    // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\n\n    // Note: we need to modify this query so it looks for ranges of certain attributes as well\n    let prefixURLOne =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLOne =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyOne =\n      \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\n      \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n    let otherColPromiseSubject = fetchJSON(queryURLOne);\n    promiseArray.push(otherColPromiseSubject);\n\n    // Below is the second query we will make.\n    // Difference with the previous query is that we are using tableData[rowIndex][colIndex] as OBJECT\n    let prefixURLTwo =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLTwo =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyTwo =\n      \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\n      \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n    let otherColPromiseObject = fetchJSON(queryURLTwo);\n    promiseArray.push(otherColPromiseObject);\n\n    // continue from here\n    allPromiseReady(promiseArray).then((values) => {\n      let keyColNeighbours = [];\n      keyColNeighbours = updateKeyColNeighbours(\n        keyColNeighbours,\n        values[0].results.bindings,\n        \"subject\"\n      );\n      keyColNeighbours = updateKeyColNeighbours(\n        keyColNeighbours,\n        values[1].results.bindings,\n        \"object\"\n      );\n      // console.log(keyColNeighbours);\n      let optionsMap = this.state.optionsMap.slice();\n      for (let i = 0; i < optionsMap.length; ++i) {\n        if (i !== colIndex) {\n          optionsMap[i] = keyColNeighbours;\n        }\n      }\n      // console.log(keyColNeighbours);\n      this.setState({\n        keyEntryIndex: rowIndex,\n        keyColIndex: colIndex,\n        keyColNeighbours: keyColNeighbours,\n        curActionInfo: null,\n        optionsMap: optionsMap,\n        tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n      });\n    });\n  }\n\n  // The following function displays the origin of a cell in the Action Panel.\n\n  contextCellOrigin(e, rowIndex, colIndex) {\n    // To get the origin of a cell, we simply returns its \"origin field\"\n    // The trick is to set the origin field correctly in previous functions\n    // The place to do that should be in the two populating columns\n\n    let cellSelected = this.state.tableData[rowIndex][colIndex];\n\n    let originElement = [];\n    for (let i = 0; i < cellSelected.origin.length; ++i) {\n      if (i === 0) {\n        originElement.push(<p>{cellSelected.origin[i]}</p>);\n      } else {\n        originElement.push(<p>--> {cellSelected.origin[i]}</p>);\n      }\n    }\n\n    // This origin literal correctly contains the cell Origin we want to display\n    // Now we just need to show it in the ActionPanel\n    let tempObj = {};\n    tempObj[\"task\"] = \"contextCellOrigin\";\n    tempObj[\"origin\"] = originElement;\n    this.setState({\n      curActionInfo: tempObj,\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n    });\n  }\n\n  toggleTable(e, index) {\n    let tableOpenList = this.state.tableOpenList.slice();\n    tableOpenList[index] = !tableOpenList[index];\n    // When we toggle on one table, we want to close all other tables\n    for (let i = 0; i < tableOpenList.length; ++i) {\n      if (i !== index) {\n        tableOpenList[i] = false;\n      }\n    }\n    // We should change the Action Panel here, if we just toggled open a table\n    if (tableOpenList[index] === true) {\n      this.setState({\n        tableOpenList: tableOpenList,\n        curActionInfo: { task: \"selectTableIndex\", tableIndex: index },\n      });\n    } else {\n      this.setState({\n        tableOpenList: tableOpenList,\n        curActionInfo: null,\n      });\n    }\n  }\n\n  // The following function handles the selection of table.\n\n  handleStartTable(e, tableIndex) {\n    // We need to let table panel display the selected table\n    // And we need to update the Action Panel to display the first degree properties of the origigitnal page\n    // We do a fetch request here (Sixth Query). It gets the property neighbours of the original page that are links, as well as dct:subject\n    // Lastly, we need to set usecaseSelected to \"startSubject\"\n\n    // First query gets the property neighbours\n    let queryPromise = [];\n    let prefixURLOne =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLOne =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyOne =\n      \"SELECT+%3Fp+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n      urlReplace(this.state.urlPasted.slice(30)) +\n      \"+%3Fp+%3Fo.%0D%0A++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++FILTER%28isIRI%28%3Fo%29+%26%26+regex%28%3FpString%2C%22property%22%2C%22i%22%29+%26%26+%28%21regex%28%3FpString%2C%22text%22%2C%22i%22%29%29%29.%0D%0A%7D%0D%0A&\";\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n    let queryOne = fetchJSON(queryURLOne);\n    queryPromise.push(queryOne);\n\n    // Second query gets the dct:subject neighbours\n    let prefixURLTwo =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLTwo =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyTwo =\n      \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n      urlReplace(this.state.urlPasted.slice(30)) +\n      \"+dct%3Asubject+%3Fo%0D%0A%7D&\";\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n    // console.log(queryURLTwo);\n    let queryTwo = fetchJSON(queryURLTwo);\n    queryPromise.push(queryTwo);\n\n    // Third query here should get the class annotations\n    queryPromise.push(\n      findClassAnnotation(this.state.originTableArray[tableIndex])\n    );\n\n    // now we process the query results\n    allPromiseReady(queryPromise).then((queryResults) => {\n      // console.log(queryResults[0].results.bindings);\n      // console.log(queryResults[1].results.bindings);\n      // console.log(queryResults[2]);\n      let selectedClassAnnotation = queryResults[2];\n      // console.log(selectedClassAnnotation);\n\n      // First we fetch the property neighbours\n      // Let's also do some prefetching at this stage: let's remove the propertyNeighbours with too many siblings (150)\n      // and remove the propertyNeighbours with only one child (aka the originally pasted page)\n\n      let propertyNeighboursPO = [];\n      let promiseArray = [];\n      let bindingArray = [];\n\n      // The part below deals with the property neighbours\n      bindingArray = queryResults[0].results.bindings;\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let predicate = bindingArray[i].p.value.slice(28);\n        // console.log(\"Predicate is \"+predicate);\n        let object = bindingArray[i].o.value.slice(28);\n        // console.log(\"Object is \"+object);\n        // If object includes some weird literal values, we replace it with \"NONEXISTING\"\n        if (object.includes(\"/\")) {\n          object = \"NONEXISTING\";\n        }\n        let prefixURL =\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n        let suffixURL =\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n        let queryBody =\n          \"SELECT+%3Fs+%0D%0AWHERE+%7B%0D%0A%09%3Fs+dbp%3A\" +\n          regexReplace(predicate) +\n          \"+dbr%3A\" +\n          regexReplace(object) +\n          \"%0D%0A%7D%0D%0A&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        let curPromise = fetchJSON(queryURL);\n        propertyNeighboursPO.push({ predicate: predicate, object: object });\n        promiseArray.push(curPromise);\n      }\n\n      // The part below deals with the dct:subject neighbours\n      bindingArray = queryResults[1].results.bindings;\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let object = bindingArray[i].o.value.slice(37);\n        let prefixURL =\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n        let suffixURL =\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n        let queryBody =\n          \"SELECT+%3Fs%0D%0AWHERE+%7B%0D%0A++++++%3Fs+dct%3Asubject+dbc%3A\" +\n          regexReplace(object) +\n          \"%0D%0A%7D&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        let curPromise = fetchJSON(queryURL);\n        propertyNeighboursPO.push({ predicate: \"subject\", object: object });\n        promiseArray.push(curPromise);\n      }\n\n      // The part below processes all the siblings and remove neighbours with too many or too few siblings\n\n      allPromiseReady(promiseArray).then((values) => {\n        let propertyNeighbours = [];\n        let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\n        // console.log(urlOrigin);\n        for (let i = 0; i < values.length; ++i) {\n          let curSiblingArray = values[i].results.bindings;\n          // Note, this 150 below should also be adjustable by users\n          if (curSiblingArray.length > 1 && curSiblingArray.length < 150) {\n            let siblingArray = [];\n            for (let i = 0; i < curSiblingArray.length; ++i) {\n              let siblingName = curSiblingArray[i].s.value.slice(28);\n              siblingArray.push({\n                isOpen: false,\n                name: siblingName,\n                tableArray: [],\n              });\n            }\n            // console.log(siblingArray);\n            propertyNeighbours.push({\n              predicate: propertyNeighboursPO[i].predicate,\n              object: propertyNeighboursPO[i].object,\n              isOpen: false,\n              siblingArray: siblingArray,\n            });\n          }\n        }\n        // we do a rudimentary ranking here: sort the property neighbours by the length of siblingArray\n        propertyNeighbours.sort((a, b) =>\n          a.siblingArray.length < b.siblingArray.length ? 1 : -1\n        );\n        // Then we update the action in Action Panel\n        let curActionInfo = { task: \"showPropertyNeighbours\" };\n        // Then we call the parse table helper function to update the tableDataExplore\n        let selectedTableHTML = this.state.originTableArray[tableIndex];\n        // setTableFromHTML is the function that prepares the data for tableDataExplore\n        let tableDataExplore = setTableFromHTML(selectedTableHTML, urlOrigin);\n\n        // Modeless Change: We need to call the helper function getTableStates.\n        // By processing the tableDataExplore to get the right states for the Excel-style table.\n\n        // To do this, we need to call getTableStates here. We just need to pass in tableDataExplore and selectedClassAnnotation \n        let statePromise = [getTableStates(tableDataExplore, selectedClassAnnotation)];\n        allPromiseReady(statePromise).then((values) => {\n          let stateInfo = values[0];\n          // console.log(stateInfo);\n\n          // Support for undo: \n          let lastAction = \"handleStartTable\";\n          let prevState = \n              {\n                \"selectedTableIndex\": this.state.selectedTableIndex,\n                \"propertyNeighbours\": this.state.propertyNeighbours,\n                \"curActionInfo\": this.state.curActionInfo,\n                \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n                \"keyColIndex\": this.state.keyColIndex,\n                \"keyColNeighbours\": this.state.keyColNeighbours,\n                \"tableData\": this.state.tableData,\n                \"tableHeader\": this.state.tableHeader,\n                \"optionsMap\": this.state.optionsMap,\n                \"usecaseSelected\": this.state.usecaseSelected,\n                \"tabIndex\": this.state.tabIndex,\n              };\n\n          this.setState({\n            selectedTableIndex: tableIndex,\n            propertyNeighbours: propertyNeighbours,\n            curActionInfo: curActionInfo,\n            selectedClassAnnotation: selectedClassAnnotation,\n            keyColIndex: stateInfo.keyColIndex,\n            keyColNeighbours: stateInfo.keyColNeighbours,\n            tableData: stateInfo.tableData,\n            tableHeader: stateInfo.tableHeader,\n            optionsMap: stateInfo.optionsMap,\n            usecaseSelected: \"startTable\",\n            tabIndex: 1,\n            lastAction: lastAction,\n            prevState: prevState,\n          });\n          // this.handleTabSwitch(1);\n        })\n      });\n    });\n  }\n\n  togglePropertyNeighbours(e, index) {\n    // First let's do the toggling task\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    propertyNeighbours[index].isOpen = !propertyNeighbours[index].isOpen;\n\n    // we want to loop through all siblings if we are toggling a propertyNeighbour on\n    if (propertyNeighbours[index].isOpen === true) {\n      let bindingArray = propertyNeighbours[index].siblingArray;\n      let siblingArray = [];\n      let siblingNameArray = []; // this array keeps track of the sibling names\n      let promiseArray = [];\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let siblingName = bindingArray[i].name;\n        let siblingURL = \"https://en.wikipedia.org/wiki/\" + siblingName;\n        let curPromise = fetchText(siblingURL);\n        promiseArray.push(curPromise);\n        siblingNameArray.push(siblingName);\n      }\n\n      // Since we only want to display siblings with useful tables, we do some checking here\n      allPromiseReady(promiseArray).then((values) => {\n        // tableArrayPromise stores an array of promises that resolve to tableArray\n        let tableArrayPromise = [];\n        for (let i = 0; i < values.length; ++i) {\n          let pageHTML = values[i];\n          // This is a helper function that fetches useful tables from pageHTML\n          // console.log(\"The class annotation for the selected table is: \");\n          // console.log(this.state.selectedClassAnnotation);\n          tableArrayPromise.push(\n            findTableFromHTML(\n              this.state.tableHeader,\n              pageHTML,\n              this.state.selectedClassAnnotation,\n              this.state.semanticEnabled,\n              this.state.unionCutOff,\n              siblingNameArray[i]\n            )\n          );\n          // we potentially want to do something different here if urlOrigin === siblingNameArray[i]\n          // We only want to keep siblings that do have useful tables\n          // if (tableArray.length !== 0) {\n          // siblingArray.push({\"isOpen\":false,\"name\":siblingNameArray[i],\"tableArray\":tableArray});\n          // }\n        }\n        allPromiseReady(tableArrayPromise).then((tableArrayValues) => {\n          for (let i = 0; i < tableArrayValues.length; ++i) {\n            siblingArray.push({\n              isOpen: false,\n              name: siblingNameArray[i],\n              tableArray: tableArrayValues[i],\n            });\n          }\n          // This following line sorts the siblingArray\n          siblingArray.sort(function (a, b) {\n            let aTableLength = a.tableArray.length;\n            let bTableLength = b.tableArray.length;\n            let aName = a.name;\n            let bName = b.name;\n            if (aTableLength === bTableLength) {\n              return aName < bName ? -1 : aName > bName ? 1 : 0;\n            } else {\n              return aTableLength > bTableLength ? -1 : 1;\n            }\n          });\n          propertyNeighbours[index].siblingArray = siblingArray;\n          this.setState({\n            propertyNeighbours: propertyNeighbours,\n          });\n        });\n      });\n    } else {\n      this.setState({\n        propertyNeighbours: propertyNeighbours,\n      });\n    }\n  }\n\n  // The following function handles the toggling of a sibling URL\n\n  toggleSibling(e, firstIndex, secondIndex) {\n    // Handle the toggling task\n    // console.log(\"Here we start the sibling toggle\");\n    // console.log(\"The current property neighbour is \");\n    // console.log(\n    //   \"The current property neighbour is \",\n    //   this.state.propertyNeighbours.slice()\n    // );\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    // console.log(propertyNeighbours);\n    let selectedSibling =\n      propertyNeighbours[firstIndex].siblingArray[secondIndex];\n\n    // Note that if this sibling's tableArray is empty, we probably do not want to toggle it.\n    if (selectedSibling.tableArray.length === 0) {\n      // console.log(\"Selected sibling has no tables: \" + selectedSibling.name);\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\n      this.setState({\n        pageHidden: false,\n        iframeURL: iframeURL,\n      });\n    } else {\n      // if the sibling's tableArray is not empty, we want to toggle it\n      selectedSibling.isOpen = !selectedSibling.isOpen;\n      // console.log(\"Let's take a look at the current property neighbour\");\n      // console.log(propertyNeighbours[firstIndex]);\n      // if (propertyNeighbours[firstIndex].isOpen === false) {\n      // propertyNeighbours[firstIndex].isOpen = true;\n      // console.log(\"In here we should have fixed the problem.\");\n      // console.log(propertyNeighbours);\n      // }\n      // We also want to change the iframe displayed at the bottom if we are toggling a sibling open\n      if (selectedSibling.isOpen === true) {\n        // console.log(\"If we get here, then sibling page should be opened\");\n        let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\n        // console.log(propertyNeighbours[firstIndex].isOpen);\n        propertyNeighbours[firstIndex].isOpen = true;\n        // console.log(propertyNeighbours[firstIndex]);\n        // console.log(propertyNeighbours[firstIndex].isOpen);\n        // console.log(\"First index is: \" + firstIndex);\n        // console.log(\"In here we should have fixed the problem.\");\n        // console.log(\"This is the property neighbour we will pass in\");\n        // console.log(propertyNeighbours);\n        this.setState({\n          propertyNeighbours: propertyNeighbours,\n          iframeURL: iframeURL,\n        });\n      } else {\n        this.setState({\n          propertyNeighbours: propertyNeighbours,\n        });\n      }\n    }\n  }\n\n  // The following function handles the toggling of other table (that's the same as the selected table)\n\n  toggleOtherTable(e, firstIndex, secondIndex, thirdIndex) {\n    // First handle the toggling task\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    const selectedTable =\n      propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray[\n        thirdIndex\n      ];\n    // console.log(selectedTable.data);\n    selectedTable.isOpen = !selectedTable.isOpen;\n    this.setState({\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // The following funcion unions the table that user has selected to the table in the TablePanel\n  // by changing tableDataExplore\n\n  unionTable(firstIndex, secondIndex, otherTableHTML, colMapping) {\n    // First we create a copy of the current tableData\n    let tableData = _.cloneDeep(this.state.tableData);\n    // console.log(tableData);\n\n    // Then we get the clean data and set the origin for the other table.\n    // We do so by calling setTableFromHTML, and setUnionData.\n    let otherTableOrigin = this.state.propertyNeighbours[firstIndex]\n      .siblingArray[secondIndex].name;\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\n    otherTableData = setUnionData(otherTableData);\n    // console.log(otherTableData);\n\n    // Start from here. We just need to modify function tableConcat\n    // console.log(colMapping);\n\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\n    let tempMapping = colMapping.slice();\n    tableData = tableConcat(\n      tableData,\n      otherTableData,\n      tempMapping\n    );\n\n    // console.log(tableData);\n\n    // Support for undo: \n    let lastAction = \"unionTable\";\n    let prevState = \n        {\n          \"tableData\":this.state.tableData,\n        };\n\n    this.setState({\n      tableData: tableData,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n\n  // The following function unions all similar tables found under a sibling page with the selected table\n  unionPage(firstIndex, secondIndex) {\n    // First we create a copy of the current tableDataExplore\n    let tableData = _.cloneDeep(this.state.tableData);\n    // We get the tableArray and name of the current sibling page\n    let tableArray = \n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray;\n    let otherTableOrigin = \n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\n\n    for (let i = 0; i < tableArray.length; ++i) {\n      // We get the clean data for the current \"other table\"\n      let otherTableData = setTableFromHTML(\n        tableArray[i].data,\n        otherTableOrigin\n      );\n      // We fetch the header row now\n      let headerRow = otherTableData[0];\n      otherTableData = setUnionData(otherTableData);\n      // console.log(headerRow);\n      // console.log(this.state.tableHeader);\n\n      // Let's do some checking here: we do not want to union the same table with itself\n      let sameTable = false;\n      if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\n        let diffColFound = false;\n        for (let m=0; m<headerRow.length; ++m) {\n          if (headerRow[m].data !== this.state.tableHeader[m].value) {\n            diffColFound = true;\n            break;\n          }\n        }\n        if (diffColFound === false) {\n          sameTable = true;\n        }\n      }\n      // We create a copy of the colMapping of the current \"other table\"\n      let tempMapping = tableArray[i].colMapping.slice();\n\n      // if sameTable is false, we can safely union the data\n      if (sameTable === false) {\n        tableData = tableConcat(\n          tableData,\n          otherTableData,\n          tempMapping\n        );\n      }\n    }\n    // Support for undo: \n    let lastAction = \"unionPage\";\n    let prevState = \n        {\n          \"tableData\":this.state.tableData,\n        };\n\n    this.setState({\n      tableData: tableData,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n\n  // The following function unions all similar tables found under a property(parent) neighbour with the selected table\n  // This is the highest level of union.\n\n  unionProperty(firstIndex) {\n    // First we create a copy of the current tableDataExplore\n    let tableData = _.cloneDeep(this.state.tableData);\n\n    // we get the siblingArray of the current property neighbour\n    let siblingArray = this.state.propertyNeighbours[firstIndex].siblingArray;\n\n    for (let i = 0; i < siblingArray.length; ++i) {\n      // We get the tableArray and name of the current sibling page\n      let tableArray = siblingArray[i].tableArray;\n      let otherTableOrigin = siblingArray[i].name;\n      // console.log(otherTableOrigin);\n      // If the current sibling has no tables that are unionable, we break out of the loop.\n      // Because siblingArray is sorted by the length of their tableArray\n      if (tableArray.length === 0) {\n        break;\n      }\n      // Else, we want to union all unionable tables from the current sibling page\n      else {\n        for (let j = 0; j < tableArray.length; ++j) {\n          // We get the clean data for the current \"other table\"\n          let otherTableData = setTableFromHTML(\n            tableArray[j].data,\n            otherTableOrigin\n          );\n          // We fetch the column header row\n          let headerRow = otherTableData[0];\n          otherTableData = setUnionData(otherTableData);\n          // Let's do some checking here: we do not want to union the same table with itself\n          let sameTable = false;\n          if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\n            let diffColFound = false;\n            for (let m=0; m<headerRow.length; ++m) {\n              if (headerRow[m].data !== this.state.tableHeader[m].value) {\n                diffColFound = true;\n                break;\n              }\n            }\n            if (diffColFound === false) {\n              sameTable = true;\n            }\n          }\n          // We create a copy of the colMapping of the current \"oother table\"\n          let tempMapping = tableArray[j].colMapping.slice();\n\n          // if sameTable is false, we can safely union the data\n          if (sameTable === false) {\n            tableData = tableConcat(\n              tableData,\n              otherTableData,\n              tempMapping\n            );\n          }\n        }\n      }\n    }\n\n    // Support for undo: \n    let lastAction = \"unionProperty\";\n    let prevState = \n        {\n          \"tableData\":this.state.tableData,\n        };\n\n    this.setState({\n      tableData: tableData,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n\n  // This function handles the change of \"semanticEnabled\" setting\n\n  toggleSemantic(e) {\n    // we want to toggle off all the property neighbours in the action panel\n    // because changing semanticEnabled changes our search criteria\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      propertyNeighbours[i].isOpen = false;\n    }\n\n    this.setState({\n      semanticEnabled: e.target.value,\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // This function handles the change of the unionCutoff percentage\n\n  unionCutOffChange(e) {\n    // we want to toggle off all the property neighbours in the action panel\n    // because changing union cutoff changes our search criteria\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      propertyNeighbours[i].isOpen = false;\n    }\n    this.setState({\n      unionCutOff: e.target.value,\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // This function hanles switching tabs\n\n  handleTabSwitch(index) {\n    // If we are switching to \"Union Table\" tab from \"Wrangling Actions\" tab, we want to toggle off all the property neighbours.\n    // Since we might have potentially changed the table in table panel, thus changed the search criteria as well\n    if (index === 1) {\n      let propertyNeighbours = this.state.propertyNeighbours.slice();\n      for (let i = 0; i < propertyNeighbours.length; ++i) {\n        propertyNeighbours[i].isOpen = false;\n      }\n      this.setState({\n        propertyNeighbours: propertyNeighbours,\n        tabIndex: index,\n      });\n    }\n    else {\n      this.setState({\n        tabIndex: index,\n      })\n    }\n  }\n\n  // This function undos the previous change that user has made to the result table in table panel\n\n  undoPreviousStep() {\n    // We first get which action we need to undo\n    let lastAction = this.state.lastAction;\n    // Then we fetch the previous state\n    let prevState = this.state.prevState;\n    // console.log(lastAction);\n    // console.log(prevState);\n\n    // Note, since we are allowing one step undo only, we set lastAction to \"\" everytime we run this function\n\n    // Case 1: Undo the ULR Paste. \n    // In this case we need to restore urlPasted, iframeURL, originTableArray, and tableOpenList\n    if (lastAction === \"handleURLPaste\") {\n      this.setState({\n        urlPasted: prevState.urlPasted,\n        iframeURL: prevState.iframeURL,\n        originTableArray: prevState.originTableArray,\n        tableOpenList: prevState.tableOpenList,\n      })\n    }\n\n    // Case 2: Undo the selection of the task: startSubject.\n    // In this case we need to restore usecaseSelected, and tableData\n\n    else if (lastAction === \"handleStartSubject\") {\n      this.setState({\n        usecaseSelected: prevState.usecaseSelected,\n        tableData: prevState.tableData,\n        tabIndex: prevState.tabIndex,\n        curActionInfo: \"\",\n        lastAction: \"\",\n      })\n    }\n\n    // Case 3: Undo the selection of the task: startTable.\n    // In this case we need to restore many states. See code below.\n\n    else if (lastAction === \"handleStartTable\") {\n      this.setState({\n        selectedTableIndex: prevState.selectedTableIndex,\n        propertyNeighbours: prevState.propertyNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        keyColIndex: prevState.keyColIndex,\n        keyColNeighbours: prevState.keyColNeighbours,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        optionsMap: prevState.optionsMap,\n        usecaseSelected: prevState.usecaseSelected,\n        tabIndex: prevState.tabIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 4: Undo the population of key column.\n    // In this case we need to restore keyColIndex, keyColNeighbours, curActionInfo, tableData, optionsMap\n    else if (lastAction === \"populateKeyColumn\") {\n      this.setState({\n        keyColIndex: prevState.keyColIndex,\n        keyColNeighbours: prevState.keyColNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        optionsMap: prevState.optionsMap,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 5: Undo the population of a new column.\n    // In this case we need to restore curActionInfo, tableData.\n    else if (lastAction === \"populateOtherColumn\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 6: Undo the population of same neighbour in different columns.\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap.\n    else if (lastAction === \"sameNeighbourDiffCol\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        optionsMap: prevState.optionsMap,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        keyColIndex: prevState.keyColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 7: Undo the population of same neighbour in the same column.\n    // In this case we need to restore the curActionInfo, tableData.\n    else if (lastAction === \"sameNeighbourOneCol\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 8: Undo the population of neighbours from the same range.\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap\n    else if (lastAction === \"populateSameRange\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        optionsMap: prevState.optionsMap,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        keyColIndex: prevState.keyColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 9: Undo the union of tables.\n    // In this case we need to restore tableData\n    else if (lastAction === \"unionTable\" || lastAction === \"unionPage\" || lastAction === \"unionProperty\") {\n      this.setState({\n        tableData: prevState.tableData,\n        lastAction: \"\",\n      })\n    }\n\n    // This is an empty else clause.\n    else {\n\n    }\n  }\n\n  // The two following functions opens/closes the modal for union table settings.\n\n  openModal() {\n    this.setState({\n      showModal: true,\n    })\n  }\n\n  closeModal() {\n    this.setState({\n      showModal: false,\n    })\n  }\n\n  // The following function toggles this.state.showTableSelection.\n\n  toggleTableSelection() {\n    let showTableSelection = !this.state.showTableSelection;\n    this.setState({\n      showTableSelection: showTableSelection,\n    })\n  }\n\n  render() {\n    let bodyEle;\n    let bottomContentClass = \" bottom-content\";\n    let topContentClass = \"row top-content\";\n    if (this.state.pageHidden) {\n      bottomContentClass = \" bottom-content-hidden\";\n      topContentClass = \"row top-content-large\";\n    }\n    // If user has not pasted the URL, we want to display the landing page\n    if (this.state.urlPasted === \"\") {\n      bodyEle = \n        <LandingPage \n          handleURLPaste={this.handleURLPaste} \n        />;\n    }\n    // Else, we show the three panels: TablePanel, ActionPanel, and PagePanel\n    else {\n      bodyEle = (\n        <div>\n          <div className=\"header\">\n            <Header \n              // Following states are passed for general purposes\n              copyTable={this.copyTable}\n              undoPreviousStep={this.undoPreviousStep}\n              openModal = {this.openModal}\n            />\n          </div> \n          <div className=\"mainbody\">\n            <div className=\"\">\n              <div className={topContentClass}>\n                <div className=\"col-md-7 small-padding  table-panel\">\n                  <TablePanel\n                    urlPasted={this.state.urlPasted}\n                    usecaseSelected={this.state.usecaseSelected}\n                    // Following states are passed to \"startSubject\"\n                    tableHeader={this.state.tableHeader}\n                    tableData={this.state.tableData}\n                    keyColIndex={this.state.keyColIndex}\n                    keyEntryIndex={this.state.keyEntryIndex}\n                    onCellChange={this.cellChange}\n                    selectColHeader={this.selectColHeader}\n                    getKeyOptions={this.getKeyOptions}\n                    getOtherOptions={this.getOtherOptions}\n                    optionsMap={this.state.optionsMap}\n                    contextAddColumn={this.contextAddColumn}\n                    contextSetCell={this.contextSetCell}\n                    contextCellOrigin={this.contextCellOrigin}\n                    // Folloiwng states are passed to \"startTable\"\n                    // tableDataExplore={this.state.tableDataExplore}\n                    // originTableArray={this.state.originTableArray}\n                    // tableOpenList={this.state.tableOpenList}\n                    // toggleTable={this.toggleTable}\n                    // selectedTableIndex={this.state.selectedTableIndex}\n                  />\n                </div>\n                <div className=\"col-md-5 small-padding action-panel\">\n                  <ActionPanel\n                    urlPasted={this.state.urlPasted}\n                    usecaseSelected={this.state.usecaseSelected}\n                    curActionInfo={this.state.curActionInfo}\n                    handleStartSubject={this.handleStartSubject}\n                    populateKeyColumn={this.populateKeyColumn}\n                    populateOtherColumn={this.populateOtherColumn}\n                    sameNeighbourDiffCol={this.sameNeighbourDiffCol}\n                    sameNeighbourOneCol={this.sameNeighbourOneCol}\n                    populateSameRange={this.populateSameRange}\n                    // Folloiwng states are passed to \"startTable\"\n                    handleStartTable={this.handleStartTable}\n                    propertyNeighbours={this.state.propertyNeighbours}\n                    togglePropertyNeighbours={this.togglePropertyNeighbours}\n                    toggleSibling={this.toggleSibling}\n                    toggleOtherTable={this.toggleOtherTable}\n                    unionTable={this.unionTable}\n                    unionPage={this.unionPage}\n                    unionProperty={this.unionProperty}\n                    // Follow state handles tab switch\n                    tabIndex={this.state.tabIndex}\n                    handleTabSwitch={this.handleTabSwitch}\n                    // Following states are passed during start up\n                    showTableSelection={this.state.showTableSelection}\n                    toggleTableSelection={this.toggleTableSelection}\n                    originTableArray={this.state.originTableArray}\n                    tableOpenList={this.state.tableOpenList}\n                    toggleTable={this.toggleTable}\n                    selectedTableIndex={this.state.selectedTableIndex}\n                  />\n                </div>\n              </div>\n              <div className={bottomContentClass}>\n                <div>\n                  <PagePanel\n                    pageHidden={this.state.pageHidden}\n                    iframeURL={this.state.iframeURL}\n                    toggleWikiPage={this.toggleWikiPage}\n                  />\n                </div>\n              </div>\n              <div>\n                <SettingModal \n                  showModal={this.state.showModal}\n                  closeModal={this.closeModal}\n                  semanticEnabled={this.state.semanticEnabled}\n                  toggleSemantic={this.toggleSemantic}\n                  unionCutOff={this.state.unionCutOff}\n                  unionCutOffChange={this.unionCutOffChange}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"footer\">\n            <Footer />\n          </div> \n        </div>\n      );\n    }\n    return <div>{bodyEle}</div>;\n  }\n}\n\nexport default MainBody;\n\n// This function takes in a queryURL and returns its JSON format\nfunction fetchJSON(url) {\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\n  return fetch(urlCORS).then((response) => response.json());\n}\n\n// This function takes in a queryURL and returns its Text format\nfunction fetchText(url) {\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\n  return fetch(urlCORS).then((response) => response.text());\n}\n\n// This function ensures that all promises in promiseArray are ready\nfunction allPromiseReady(promiseArray) {\n  return Promise.all(promiseArray);\n}\n\n// This function replaces string so that the result can be used in queryURL.\n// It currently replaces \"(\", \")\", \"'\", \"-\", \" \", \"&\", \".\", \"\"\",and \"/\"\nfunction regexReplace(str) {\n  return str\n    .replace(/\\$/g, \"%5Cu0024\")\n    .replace(/%/g, \"%5Cu0025\")\n    .replace(/!/g, \"%5Cu0021\")\n    .replace(/\"/g, \"%5Cu0022\")\n    .replace(/#/g, \"%5Cu0023\")\n    .replace(/&/g, \"%5Cu0026\")\n    .replace(/'/g, \"%5Cu0027\")\n    .replace(/\\(/g, \"%5Cu0028\")\n    .replace(/\\)/g, \"%5Cu0029\")\n    .replace(/\\*/g, \"%5Cu002A\")\n    .replace(/\\+/g, \"%5Cu002B\")\n    .replace(/-/g, \"%5Cu002D\")\n    .replace(/;/g, \"%5Cu003B\")\n    .replace(/=/g, \"%5Cu003D\")\n    .replace(/\\?/g, \"%5Cu003F\")\n    .replace(/\\./g, \"%5Cu002E\")\n    .replace(/\\//g, \"%5Cu002F\")\n    .replace(/,/g, \"%5Cu002C\")\n    .replace(/\\s/g, \"_\");\n}\n\n// This function replaces the URL pasted\nfunction urlReplace(str) {\n  return str\n    .replace(/%E2%80%93/g, \"%5Cu2013\")\n    .replace(/\\$/g, \"%5Cu0024\")\n    .replace(/!/g, \"%5Cu0021\")\n    .replace(/\"/g, \"%5Cu0022\")\n    .replace(/#/g, \"%5Cu0023\")\n    .replace(/&/g, \"%5Cu0026\")\n    .replace(/'/g, \"%5Cu0027\")\n    .replace(/\\(/g, \"%5Cu0028\")\n    .replace(/\\)/g, \"%5Cu0029\")\n    .replace(/\\*/g, \"%5Cu002A\")\n    .replace(/\\+/g, \"%5Cu002B\")\n    .replace(/-/g, \"%5Cu002D\")\n    .replace(/;/g, \"%5Cu003B\")\n    .replace(/=/g, \"%5Cu003D\")\n    .replace(/\\?/g, \"%5Cu003F\")\n    .replace(/\\./g, \"%5Cu002E\")\n    .replace(/\\//g, \"%5Cu002F\")\n    .replace(/,/g, \"%5Cu002C\")\n    .replace(/\\s/g, \"_\");\n}\n\n// This function removes the prefix \"http://dbpedia.org/resource/\" from query results, if it includes one\n\nfunction removePrefix(str) {\n  let prefixToRemove = \"http://dbpedia.org/resource/\";\n  // If dbResult contains prefix of \"http://dbpedia.org/resource/\", we want to remove it\n  if (str.includes(prefixToRemove) === true) {\n     str = str.slice(28);\n  }\n  return str;\n}\n\n\n// This function updates the key column's neighbours.\n\n// It taks three parameters:\n//  1) array \"keyColNeighbour\" storing list of neighbours for the key column\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\n//  3) string \"type\", either \"subject\" or \"object\"\n\n// It returns the updates keyColNeighbours\nfunction updateKeyColNeighbours(keyColNeighbours, resultsBinding, type) {\n  // Let's take a look at the resultsBinding\n  // console.log(\"Current type is \"+type);\n  // console.log(resultsBinding);\n  // console.log(resultsBinding);\n\n  // we first sort the resultsBinding by p.value.slice(28)\n  resultsBinding.sort((a, b) =>\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\n  );\n\n  // Then we give each option in the resultBinding the correct labels\n  let neighbourCount = 1;\n  for (let i = 0; i < resultsBinding.length; ++i) {\n    let tempObj = {};\n    let curNeighbourLiteral = resultsBinding[i].p.value.slice(28);\n    // Let's see if the current result has a \"range\"\n    // Note: if the result does not have the \"range\" variable, resultsBinding[i].range would be undefined\n    // if (type === \"subject\") {\n    //   console.log(resultsBinding[i].range);\n    // }\n    // We do not want to deal with any neighbours that's only one character long: we don't know what it means\n    if (curNeighbourLiteral.length > 1) {\n      // Let's deal with duplicate neighbour names here\n      let curNeighbourValue = curNeighbourLiteral;\n      let curNeighbourLabel;\n      if (type === \"subject\") {\n        curNeighbourLabel = curNeighbourLiteral;\n      } else {\n        curNeighbourLabel = \"is \" + curNeighbourLiteral + \" of\";\n      }\n      let nextNeighbourValue = \"\";\n      if (i < resultsBinding.length - 1) {\n        nextNeighbourValue = resultsBinding[i + 1].p.value.slice(28);\n      }\n      if (curNeighbourValue === nextNeighbourValue) {\n        if (type === \"subject\") {\n          curNeighbourLabel = curNeighbourLiteral + \"-\" + neighbourCount;\n        } else {\n          curNeighbourLabel =\n            \"is \" + curNeighbourLiteral + \" of-\" + neighbourCount;\n        }\n        if (neighbourCount <= maxNeighbourCount) {\n          tempObj[\"label\"] = curNeighbourLabel;\n          tempObj[\"value\"] = curNeighbourValue;\n          tempObj[\"type\"] = type;\n          // If the current type is \"subject\", we want to see if the current result has a range\n          if (type === \"subject\" && resultsBinding[i].range !== undefined) {\n            tempObj[\"range\"] = resultsBinding[i].range.value;\n          }\n          keyColNeighbours.push(tempObj);\n        }\n        neighbourCount++;\n      } else {\n        if (neighbourCount > 1) {\n          if (type === \"subject\") {\n            curNeighbourLabel = curNeighbourLiteral + \"-\" + neighbourCount;\n          } else {\n            curNeighbourLabel =\n              \"is \" + curNeighbourLiteral + \" of-\" + neighbourCount;\n          }\n        }\n        if (neighbourCount <= maxNeighbourCount) {\n          tempObj[\"label\"] = curNeighbourLabel;\n          tempObj[\"value\"] = curNeighbourValue;\n          tempObj[\"type\"] = type;\n          // If the current type is \"subject\", we want to see if the current result has a range\n          if (type === \"subject\" && resultsBinding[i].range !== undefined) {\n            tempObj[\"range\"] = resultsBinding[i].range.value;\n          }\n          keyColNeighbours.push(tempObj);\n        }\n        neighbourCount = 1;\n      }\n    }\n  }\n  // console.log(keyColNeighbours);\n  return keyColNeighbours;\n}\n\n// This function takes in the clean data for the first table, clean data for the second table, and colMapping between these two tables\n// And returns the unioned clean data for the first table\n\nfunction tableConcat(tableData, otherTableData, tempMapping) {\n  // We want to correctly modify tableDataExplore, based on colMapping.\n  // If colMapping is null for some column, we want to set the data as \"N/A\"\n  // console.log(tableDataExplore);\n\n  // We first make some small modifications to colMapping, as we have inserted a new column into otherTableData and tableDataExplore\n  for (let j = 0; j < tempMapping.length; ++j) {\n    if (tempMapping[j] !== \"null\") {\n      tempMapping[j]++;\n    }\n  }\n  tempMapping.splice(0, 0, 0); // insert element 0 at the first position of colMapping, deleting 0 elements\n\n  // Now we insert the data into dataToAdd. dataToAdd will be concatenated with tableDataExplore\n  let dataToAdd = [];\n  for (let i = 0; i < otherTableData.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < tempMapping.length; ++j) {\n      let colInNew = tempMapping[j];\n      if (colInNew !== \"null\") {\n        tempRow.push(otherTableData[i][colInNew]);\n      } else {\n        tempRow.push({ data: \"N/A\" });\n      }\n    }\n    dataToAdd.push(tempRow);\n  }\n  return tableData.concat(dataToAdd);\n}\n\nfunction HTMLCleanCell(str) {\n  // Note that this function also removes leading and trailing whitespaces\n  if (str[str.length - 1] === \"\\n\") {\n    return str.slice(0, -1).trim().split(\"[\")[0];\n  } else {\n    return str.trim().split(\"[\")[0];\n  }\n}\n\n// This function returns an array of table objects that are unionable with the selected table.\n\n// It taks two parameters:\n//  1) HTML \"tableHTML\" storing the HTML of the selected table\n//  2) HTML \"pageHTML\", storing the HTML of a sibling page\n\n// Table object has four attributes: isOpen, data, unionScore, colMapping\n\n// Once semantic mapping feature is added, the colMapping will be updated\n\nfunction findTableFromHTML(\n  tableHeader,\n  pageHTML,\n  selectedClassAnnotation,\n  semanticEnabled,\n  unionCutOff,\n  pageName\n) {\n  // We first get the column names of the table in the table panel, using this.state.tableHeader.\n  // Note: the index starts from 1 because we don't care about the originURL column (column 0).\n  let originCols = [];\n  for (let j = 1; j < tableHeader.length; ++j) {\n    originCols.push(tableHeader[j].value);\n  }\n  // console.log(originCols);\n\n  // We now fetch all the tables from pageHTML (the current sibling page)\n  let doc = new DOMParser().parseFromString(pageHTML, \"text/html\");\n  let wikiTablesFound = doc.getElementsByClassName(\"wikitable\");\n  let tablesFound = [];\n  for (let i = 0; i < wikiTablesFound.length; ++i) {\n    if (wikiTablesFound[i].tagName !== \"TH\") {\n      tablesFound.push(wikiTablesFound[i]);\n    }\n  }\n\n  // console.log(tablesFound);\n\n  // This is the array we will return.\n  let tableArray = [];\n\n  // We now loop through all the tables found on this sibling page, and see if they are unionable with the selected table\n  let tablePromise = [];\n  for (let i = 0; i < tablesFound.length; ++i) {\n    tablePromise.push(\n      findTableFromTable(\n        tablesFound[i],\n        originCols,\n        selectedClassAnnotation,\n        semanticEnabled,\n        unionCutOff,\n        pageName\n      )\n    );\n  }\n\n  return allPromiseReady(tablePromise).then((values) => {\n    for (let i = 0; i < values.length; ++i) {\n      tableArray.push(values[i]);\n    }\n    // we filter the tableArray here by removing those tables that do not have a high enough unionScore\n    // Note: In the unfiltered table array, we are using -1 to represent tables with a low unionScore\n    tableArray = tableArray.filter(function (x) {\n      return x !== -1;\n    });\n    // console.log(tableArray);\n    // We sort the tableArray here by unionScore\n    tableArray.sort((a, b) => (a.unionScore < b.unionScore ? 1 : -1));\n    return Promise.resolve(tableArray);\n  });\n}\n\n// This function takes in four parameters:\n\n// 1) a tableHTML\n// 2) originCols (denoting the columns names of the selected table)\n// 3) class annotation of the selected table\n// 4) whether semantic mapping is enabled or not\n\n// and return a table Object with properties: isOpen, unionScore, colMapping, and data\nfunction findTableFromTable(\n  tableHTML,\n  originCols,\n  selectedClassAnnotation,\n  semanticEnabled,\n  unionCutOff,\n  pageName\n) {\n  // Define some constants\n  const ontologySize = 780;\n  const matchCutOff = 0.999;\n\n  // We first fetch the cleaned column names of the current table\n  let curHeaderCells = tableHTML.rows[0].cells;\n  let newCols = []; // stores the cleaned column names of the this table. Let's consider using this value for display as well.\n  let remainCols = []; // stores an array of the indices of the columns of the current table that are not yet mapped\n  let searchCols = []; // stores an array of the indices of the columns from the selected table that are not yet mapped\n\n  // We potentially need to resort to semantic mapping. So let's create a promiseArray.\n  // This promiseArray will only contain one element\n  let promiseArray = [];\n\n  for (let j = 0; j < curHeaderCells.length; ++j) {\n    let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\n    newCols.push(headerName);\n    remainCols.push(j);\n  }\n\n  // we want to make sure that newTable has more than half of the columns of the selectedTable\n  // because we require a >50% unionScore\n  // If it does not, we ignore this table automatically\n\n  if (newCols.length >= originCols.length * unionCutOff) {\n    // We use the proposed algo here.\n    // First we set the union score and column Mapping\n    let unionScore = 0;\n    let colMapping = [];\n    // We loop through the column headers in originCol, and see if they exist in newCols.\n    for (let k = 0; k < originCols.length; ++k) {\n      let curIndex = newCols.indexOf(originCols[k]);\n      if (curIndex !== -1) {\n        // This means the new table also contains column k from the selected table\n        // Thus we have found a mapping. We push it onto colMapping.\n        colMapping.push(curIndex);\n        unionScore += 1 / originCols.length;\n      } else {\n        colMapping.push(\"null\");\n      }\n    }\n    // In here we do a bit of string matching for tables with the same number of columns\n    // Chances are: tables from sibling pages with the same number of columns as the selected table, with structual invariability,\n    // is likely to be the \"same\" table as the selected on, we give it a chance for string matching\n    if (newCols.length === originCols.length) {\n      let sameStructure = true;\n      for (let i = 0; i < colMapping.length; ++i) {\n        if (colMapping[i] !== \"null\" && colMapping[i] !== i) {\n          sameStructure = false;\n          break;\n        }\n      }\n      if (sameStructure === true) {\n        for (let i = 0; i < colMapping.length; ++i) {\n          if (colMapping[i] === \"null\") {\n            if (\n              newCols[i].includes(originCols[i]) ||\n              originCols[i].includes(newCols[i])\n            ) {\n              colMapping[i] = i;\n              unionScore += 1 / originCols.length;\n            }\n          }\n        }\n      }\n      // console.log(colMapping);\n      // If unionScore is 1, and newCols.length is equal to originCols.length, we want to reward it with 0.01 unionScore\n      // This helps us to rank the tables with the exact same column headers a bit higher\n      if (unionScore === 1) {\n        unionScore += 0.01;\n      }\n    }\n\n    // We proceed differently based on whether semantic mapping is enabled or not\n\n    // Case 1: semantic mapping is enabled\n\n    if (semanticEnabled === \"enabled\") {\n      // If we are not finding a perfect match, we want to do use semantic mapping here to see if it's possible to map the unmapped columns\n      // Note: this part is expected to take quite some time. Now it's implemented just for testing purposes\n      if (unionScore < 0.999) {\n        // We want to remove from remainCols the columns that are already mapped\n        // The remaining will be the columns that we can still use from the current table\n        remainCols = remainCols.filter(function (x) {\n          return colMapping.indexOf(x) < 0;\n        });\n        for (let i = 0; i < colMapping.length; ++i) {\n          if (colMapping[i] === \"null\") {\n            searchCols.push(i);\n          }\n        }\n        // if (newCols[1] === \"Scorer\") {\n        // console.log(\"We still need to find these columns from the original table: \"+searchCols);\n        // console.log(\"These columns are still available for use: \"+remainCols);\n        // console.log(\"The current column mappings are \"+colMapping);\n        // console.log(\"Here are the class annotations of the search columns: \")\n        // for (let i=0;i<searchCols.length;++i) {\n        //   console.log(selectedClassAnnotation[searchCols[i]]);\n        // }\n        // }\n\n        // Now, searchCols stores the columns from the selected table that have not been mapped yet\n        // and remainCols stores the columns from the current table that can still be used for mapping\n        // Let's ask a query to find the class annotations for the remainCols\n        // if (remainCols.length > 0) {\n        promiseArray.push(findClassAnnotation(tableHTML, remainCols, pageName));\n        // }\n      }\n\n      // Because the return statement is here, it may be possible that we are pushing nothing onto the promiseArray!!!\n      // There is no need to worry about it.\n      return allPromiseReady(promiseArray).then((values) => {\n        // First, if we are in the perfect match case, we want to retrun straight away\n        if (unionScore >= 0.999) {\n          return Promise.resolve({\n            isOpen: false,\n            unionScore: unionScore,\n            colMapping: colMapping,\n            data: tableHTML,\n            title: newCols,\n          });\n        }\n        // Else, we want to look for semantic mapping opportunities\n        else {\n          // create a copy of values\n\n          // Note!!!! Sometimes the tableHTML only has one row, so values[0] would have a length of zero, in which case our algo breaks down\n          // Let's prevent it from happening\n          let remainClassAnnotation = values[0].slice();\n          if (remainClassAnnotation.length > 0) {\n            // let remainColsCopy = remainCols.slice();\n            // let remainClassAnnotationCopy = remainClassAnnotation.slice();\n            for (let i = 0; i < searchCols.length; ++i) {\n              let curSearchIndex = searchCols[i];\n              // console.log(curSearchIndex);\n              // console.log(selectedClassAnnotation[curSearchIndex]);\n\n              // If the class annotation for this column is empty, we skip it because there's no hope for semantic match.\n              // Otherwise we can work with it\n              if (selectedClassAnnotation[curSearchIndex].length > 0) {\n                // console.log(\"Current column being searched has index: \"+curSearchIndex);\n                // console.log(selectedClassAnnotation[curSearchIndex]);\n\n                // we loop through the remain cols and check their class annotations\n                for (let j = 0; j < remainCols.length; ++j) {\n                  // Let make sure this column does have a class annotation. Otherwise we skip it\n                  // console.log(remainClassAnnotation[j]);\n                  // Note: sometimes remainClassAnnotation[j] is undefined, which causes an error\n                  // if (remainClassAnnotation[j] === undefined) {\n                  //   console.log(\"This case is causing an error\");\n                  //   console.log(\"Remain cols are \"+remainCols);\n                  //   console.log(\"Remain class annotations are \"+remainClassAnnotation);\n                  //   console.log(\"Original remain cols are \"+remainColsCopy);\n                  //   console.log(\"original remain class annotations are \"+remainClassAnnotationCopy);\n                  //   console.log(\"Table HTML is \");\n                  //   console.log(tableHTML);\n                  //   console.log(values[0]);\n                  // }\n                  if (remainClassAnnotation[j].length > 0) {\n                    // console.log(\"Remain column index is \"+remainCols[j]);\n                    // console.log(\"Its class annotation is \"+remainClassAnnotation[j]);\n                    // Let make special cases when the any of search column class and current column class is [Number]\n                    // If they are both [Number], we will give it a match\n                    // Else it's not a match\n                    if (\n                      selectedClassAnnotation[curSearchIndex][0] === \"Number\" ||\n                      remainClassAnnotation[j][0] === \"Number\"\n                    ) {\n                      // This case we have a match\n                      if (\n                        selectedClassAnnotation[curSearchIndex][0] ===\n                        remainClassAnnotation[j][0]\n                      ) {\n                        // We need to update the colMapping and unionScore\n                        colMapping[curSearchIndex] = remainCols[j];\n                        unionScore += 1 / originCols.length;\n                        // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\n                        remainCols.splice(j, 1);\n                        remainClassAnnotation.splice(j, 1);\n                        // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\n                        // j to go back to the correct posiition\n                        --j;\n                        // Also we need to call break to prevent further looping: we are done with this search column\n                        break;\n                      }\n                      // Else there is no match. We simply ignore it.\n                    }\n                    // If neither of them is [Number], we need to use the test statistic\n                    else {\n                      // Let's first find the array intersection of selectedClassAnnotation[curSearchIndex] and remainClassAnnotation[j]\n                      let intersection = selectedClassAnnotation[\n                        curSearchIndex\n                      ].filter(function (x) {\n                        return remainClassAnnotation[j].indexOf(x) >= 0;\n                      });\n                      // console.log(\"Intersection is \"+intersection);\n                      // We only want to consider two column unionable if they at least have some intersections.\n                      if (intersection.length > 0) {\n                        let totalSuccess =\n                          selectedClassAnnotation[curSearchIndex].length;\n                        let numTrial = remainClassAnnotation[j].length;\n                        let numSuccess = intersection.length;\n                        let testStat = hyperCDF(\n                          numSuccess,\n                          ontologySize,\n                          totalSuccess,\n                          numTrial\n                        );\n                        // If testStat is larger than matchCutOff, we consider it a match\n                        if (testStat > matchCutOff) {\n                          // We need to update the colMapping and unionScore\n                          colMapping[curSearchIndex] = remainCols[j];\n                          unionScore += 1 / originCols.length;\n                          // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\n                          remainCols.splice(j, 1);\n                          remainClassAnnotation.splice(j, 1);\n                          // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\n                          // j to go back to the correct posiition\n                          --j;\n                          // Also we need to call break to prevent further looping: we are done with this search column\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          // console.log(\"Remain columns are \"+)\n          // console.log(\"Here is table HTML\");\n          // console.log(tableHTML);\n          // console.log(\"Here are the class annotations for columns that still need mapping\");\n          // for (let i=0;i<searchCols.length;++i) {\n          //   console.log(selectedClassAnnotation[searchCols[i]]);\n          // }\n          // console.log(\"The remain columns are \"+remainCols);\n          // console.log(\"Here are the class annotations for the remaining columns\");\n          // console.log(values);\n          // console.log(\"This is column mapping \"+colMapping);\n          // console.log(\"Union score is \"+unionScore);\n\n          // We need to loop through the searchCols\n\n          // We push on tables with unionScore > unionCutOff\n          if (unionScore >= unionCutOff) {\n            // console.log(\"This table is unionable!\");\n            // console.log(\"Table is \"+tableHTML);\n            // console.log(\"Union Score is \"+unionScore);\n            // console.log(\"Column mapping is \"+colMapping);\n            // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\n            // console.log(colMapping);\n            return Promise.resolve({\n              isOpen: false,\n              unionScore: unionScore,\n              colMapping: colMapping,\n              data: tableHTML,\n              title: newCols,\n            });\n          } else {\n            return Promise.resolve(-1);\n          }\n        }\n      });\n    }\n\n    // Case 2: semantic mapping is disabled.\n    // In this case we check if the unionScore is high enough directly, without going through the semantic mapping process\n    else {\n      // We push on tables with unionScore > unionCutOff\n      if (unionScore >= unionCutOff) {\n        // console.log(\"This table is unionable!\");\n        // console.log(\"Table is \"+tableHTML);\n        // console.log(\"Union Score is \"+unionScore);\n        // console.log(\"Column mapping is \"+colMapping);\n        // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\n        // console.log(colMapping);\n        return Promise.resolve({\n          isOpen: false,\n          unionScore: unionScore,\n          colMapping: colMapping,\n          data: tableHTML,\n          title: newCols,\n        });\n      } else {\n        return Promise.resolve(-1);\n      }\n    }\n  }\n  // This else clause means that this table does not even have enough number of columns.\n  // So we know right away it cannot be a match. So we return -1 (failure)\n  else {\n    return Promise.resolve(-1);\n  }\n}\n\n// This function takes in the HTML of a table, and returns a Promise that resolves to the class annotation for all the columns of the table\nfunction findClassAnnotation(tableHTML, remainCols, pageName) {\n  // console.log(\"Page Name is: \"+pageName);\n  // console.log(\"Table HTML is: \");\n  // console.log(tableHTML);\n  // console.log(remainCols);\n  let selectedTable = tableHTML;\n  let tempTable = [];\n\n  // We first fetch the plain, unprocessed version of the table.\n  // Note: this function potentially needs to be modified.\n  // Instead of using innerText for cell data, if its href exists, we should use its href instead\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\n\n      // Note: We want to use the href as data for the first column (if such href exists) instead of its innerText.\n      if (i === 1) {\n        // We get all the links from this current cell (there may be more than one)\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\n          \"a\"\n        );\n        // we want to use the first valid link as the search element for this cell\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\n        //                            and it is not a citation (so [0] is not \"[\")\n        for (let k = 0; k < anchorArray.length; ++k) {\n          if (\n            anchorArray[k].innerText !== \"\" &&\n            anchorArray[k].innerText[0] !== \"[\"\n          ) {\n            let hrefArray = anchorArray[k].href.split(\"/\");\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\n            curCellText = hrefArray[hrefArray.length - 1];\n            // if (curCellText.includes(\"UEFA\")) {\n            // console.log(curCellText);\n            // }\n          }\n        }\n      }\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\n      // console.log(curColSpan);\n      tempRow.push({\n        data: curCellText,\n        rowSpan: curRowSpan,\n        colSpan: curColSpan,\n      });\n    }\n    tempTable.push(tempRow);\n  }\n\n  // We first deal with colspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].colSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\n          tempTable[i].splice(j + 1, 0, {\n            data: curCellText,\n            rowSpan: 1,\n            colSpan: 1,\n          });\n        }\n      }\n    }\n  }\n\n  // We now deal with rowspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].rowSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\n          if (i + k < tempTable.length) {\n            tempTable[i + k].splice(j, 0, {\n              data: curCellText,\n              rowSpan: 1,\n              colSpan: 1,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // console.log(\"Table data is: \");\n  // console.log(tempTable);\n\n  // Now tempTable contains the clean data we can use\n  let promiseArray = [];\n  // We take the minimum of (1, tempTable.length-1) number of values from each column to determine its class annotation\n  // Note!! This -1 here is important. It excludes the row corresponding to the column headers\n  let remainEntries = Math.min(1, tempTable.length - 1);\n\n  // This is a placeholder array to solve the 2D problem. It's a 1D array containing remainEntries number of -1's\n  // let placeHolderArray = [];\n  // let notFoundArray = [];\n  // for (let i=0;i<remainEntries;++i) {\n  //   placeHolderArray.push(-1);\n  //   notFoundArray.push(\"null\");\n  // }\n\n  // Let's loop through the table to ask our queries.\n  // If remainCols are undefined, we take every columns from the tempTable;\n  if (remainCols === undefined) {\n    remainCols = [];\n    for (let j = 0; j < tempTable[0].length; ++j) {\n      remainCols.push(j);\n    }\n  }\n\n  // console.log(\"Remain columns are: \"+remainCols);\n  for (let j = 0; j < remainCols.length; ++j) {\n    // console.log(\"We are taking this number of entries from this table: \"+remainEntries);\n    // Find the current column index\n    let curColIndex = remainCols[j];\n    // console.log(\"Current column index is: \"+curColIndex);\n\n    // Loop through the first three (or one) entries from this column\n    for (let i = 1; i <= remainEntries; ++i) {\n      // Here we make the query\n      let prefixURL =\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let suffixURL =\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      // console.log(tempTable[i][j].data);\n      // console.log(regexReplace(tempTable[i][j].data));\n      // console.log(tempTable[i][curColIndex]);\n      let curEntry =\n        tempTable[i][curColIndex] === undefined\n          ? \"NONEXISTING\"\n          : regexReplace(tempTable[i][curColIndex].data);\n      // console.log(curEntry);\n      // console.log(regexReplace(tempTable[i][curColIndex].data));\n      // console.log(!isNaN(Number(curEntry)));\n      // console.log(\"Replaced data is \"+curEntry);\n      // console.log(curEntry === \"\");\n\n      // If we found out that the current entry is a number, we do not want to send a query.\n      // Note: Number(\"\") will show up as a number!! This was one of the bugs that we fixed\n      if (!isNaN(Number(curEntry)) && curEntry !== \"\") {\n        promiseArray.push(Promise.resolve([\"Number\"]));\n      }\n      // Else if we find the curEntry is too long, it will likely not exist in DBPedia\n      else if (curEntry.length > 40) {\n        promiseArray.push(Promise.resolve([\"Null\"]));\n      }\n      // Else we construct the query\n      else {\n        // console.log(\"Cur Entry is \"+curEntry);\n        if (curEntry === undefined || curEntry === \"\") {\n          curEntry = \"NONEXISTING\";\n        }\n        // if (curEntry === \"Sergio_Agüero\") {\n        //   console.log(\"We have another problem here\");\n        // }\n        // console.log(curEntry);\n        // console.log(tempTable[i][curColIndex].data);\n        // console.log(regexReplace(tempTable[i][curColIndex].data));\n        let queryBody =\n          \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n          curEntry +\n          \"+rdf%3Atype+%3Fo.%0D%0A++++++BIND%28STR%28%3Fo%29+AS+%3FoString+%29.%0D%0A++++++FILTER%28regex%28%3FoString%2C%22dbpedia.org%2Fontology%2F%22%2C%22i%22%29%29%0D%0A%7D%0D%0A&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        // if (curEntry === \"Bangor_City_F%5Cu002EC%5Cu002E\") {\n        //   console.log(\"There is something wrong with this entry\")\n        //   console.log(queryURL);\n        // }\n        // console.log(\"Query is constructed!\");\n        // if (queryURL === \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\") {\n        //   console.log(\"Here is where the problem occurs\");\n        // }\n        // console.log(queryURL);\n        promiseArray.push(fetchJSON(queryURL));\n        // console.log(\"Query pushed successfully. This is queryBody: \");\n        // console.log(queryBody);\n      }\n    }\n  }\n  return allPromiseReady(promiseArray).then((values) => {\n    // console.log(values);\n    // for (let i=0;i<values.length;++i) {\n    //   console.log(values[i]);\n    // }\n    // console.log(\"Query results from Virtuoso are:\");\n    // console.log(values);\n    let classAnnotation = [];\n    for (let j = 0; j < remainCols.length; ++j) {\n      // console.log(\"Number of remain cols is \"+remainCols.length);\n      let curColumnClass = [];\n      // If we are dealing with number results, we just want to push on an array with one element \"Number\"\n      if (values[remainEntries * j] !== undefined) {\n        if (values[remainEntries * j][0] !== undefined) {\n          if (values[remainEntries * j][0] === \"Number\") {\n            classAnnotation.push([\"Number\"]);\n          }\n          // If we are dealing with invalid results, we just want to push on an empty array\n          else if (values[remainEntries * j][0] === \"Null\") {\n            classAnnotation.push([]);\n          }\n        }\n        // if (values[remainEntries*j][0] === -1) {\n        //   classAnnotation.push([\"Number\"]);\n        // }\n        // // If we are dealing with invalid results, we just want to push on an empty array\n        // else if (values[remainEntries*j][0] === \"null\") {\n        //   classAnnotation.push([]);\n        // }\n        // Else, we find its class annotation from query results\n        else {\n          for (let i = 0; i < remainEntries; ++i) {\n            let curCellClass = [];\n            // console.log(remainEntries*j+i);\n            let bindingArray = values[remainEntries * j + i].results.bindings;\n            for (let k = 0; k < bindingArray.length; ++k) {\n              curCellClass.push(bindingArray[k].o.value.slice(28));\n            }\n            curColumnClass = [...new Set([...curColumnClass, ...curCellClass])];\n          }\n          classAnnotation.push(curColumnClass);\n        }\n      }\n    }\n    // return classAnnotation;\n    // console.log(\"Current class annotation is \");\n    // if (classAnnotation.length === 5 && pageName === \"2008–09_Premier_League\") {\n      // console.log(classAnnotation);\n    // }\n    // console.log(classAnnotation);\n    return Promise.resolve(classAnnotation);\n  });\n}\n\n// This function returns a 2D array of objects representing the data for tableDataExplore.\n\n// It taks two parameters:\n//  1) HTML \"selectedTableHTML\" storing the HTML of a table\n//  2) string \"urlOrigin\", storing which page this table is from\n\n// It returns a 2D array of objects representing the data for tableDataExplore.\nfunction setTableFromHTML(selecteTableHTML, urlOrigin) {\n  let selectedTable = selecteTableHTML;\n  let tempTable = [];\n\n  // We first fetch the plain, unprocessed version of the table.\n  // This is the part where we make the modification: use links instead of cell literals\n\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\n      // Note: We want to use the href as data (if such href exists) instead of its innerText.\n      if (i > 0) {\n        // We get all the links from this current cell (there may be more than one)\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\n          \"a\"\n        );\n        // we want to use the first valid link as the search element for this cell\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\n        //                            and it is not a citation (so [0] is not \"[\")\n        for (let k = 0; k < anchorArray.length; ++k) {\n          if (\n            anchorArray[k].innerText !== \"\" &&\n            anchorArray[k].innerText[0] !== \"[\"\n          ) {\n            let hrefArray = anchorArray[k].href.split(\"/\");\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\n            curCellText = decodeURIComponent(hrefArray[hrefArray.length - 1]);\n            // if (curCellText.includes(\"UEFA\")) {\n            // console.log(curCellText);\n            // }\n          }\n        }\n      }\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\n      // console.log(curColSpan);\n      tempRow.push({\n        data: curCellText,\n        origin: urlOrigin,\n        rowSpan: curRowSpan,\n        colSpan: curColSpan,\n      });\n    }\n    tempTable.push(tempRow);\n  }\n\n  // We first deal with colspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].colSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\n          tempTable[i].splice(j + 1, 0, {\n            data: curCellText,\n            origin: urlOrigin,\n            rowSpan: 1,\n            colSpan: 1,\n          });\n        }\n      }\n    }\n  }\n\n  // We now deal with rowspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].rowSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\n          if (i + k < tempTable.length) {\n            tempTable[i + k].splice(j, 0, {\n              data: curCellText,\n              origin: urlOrigin,\n              rowSpan: 1,\n              colSpan: 1,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // We now add in an additional column: the originURL of the page\n  tempTable[0].splice(0, 0, {\n    data: \"OriginURL\",\n    origin: urlOrigin,\n    rowSpan: 1,\n    colSpan: 1,\n  });\n  for (let i = 1; i < tempTable.length; ++i) {\n    tempTable[i].splice(0, 0, {\n      data: urlOrigin,\n      origin: \"null\",\n      rowSpan: 1,\n      colSpan: 1,\n    });\n  }\n  return tempTable; // tempTable is a 2D array of objects storing the table data. Object has two fields: data(string) and origin(string).\n}\n\n// This function takes in 1 parameter\n// 1) tableDataExplore, returned from setTableFromHTML.\n\n// And returns tableData (with no header rows) that can be unioned with the selected table.\n\nfunction setUnionData(tableDataExplore) {\n\n  // We first need to set the tableHeader, so that cells have the correct origins\n  let tableHeader = [];\n  for (let j=0;j<tableDataExplore[0].length;++j) {\n    tableHeader.push(\n      {\"value\":tableDataExplore[0][j].data\n      ,\"label\":tableDataExplore[0][j].data}\n    )\n  }\n  // We then need to handle both data and origin.\n  let tableData = [];\n  // console.log(tableDataExplore);\n  // This starts the loop for rows\n  for (let i=1;i<tableDataExplore.length;++i) {\n    let tempRow = [];\n    // This starts the loop for columns\n    for (let j=0;j<tableDataExplore[i].length;++j) {\n      // First set the data\n      let data = tableDataExplore[i][j].data;\n      // Then set the origin\n      let origin = [];\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\n      origin.push(originText);\n      tempRow.push({\"data\":data,\"origin\":origin});\n    }\n    tableData.push(tempRow);\n  }\n  return tableData;\n}\n\n// This function takes in four parameters and return the CDF for hypergeometric distribution, for x\n// N: total number of elements (780 in our case)\n// K: total number of successful elements (length of selected column's class annotation)\n// n: number of trials (length of test column's class annotation)\n// x: (length of intersection of selected column and test column)\n\nfunction hyperCDF(x, N, K, n) {\n  let count = 0;\n  // console.log(combinations(5,2));\n  let denom = combinations(N, n);\n  for (let i = 0; i <= x; ++i) {\n    count += (combinations(K, i) * combinations(N - K, n - i)) / denom;\n  }\n  return count;\n}\n\n// This function takes in 2 parameters:\n// 1) tableDataExplore\n// 2) selectedClassAnnotation\n\n// It returns a Promise of an object with 5 properties:\n// 1) keyColIndex\n// 2) tableHeader\n// 3) tableData\n// 4) keyColNeighbours\n// 5) optionsMap.\n\n// This object contains all the information we needed for the Excel-style table\n\nfunction getTableStates(tableDataExplore, selectedClassAnnotation) {\n  // We need to take care of keyColIndex, tableHeader, tableData, optionsMap, and keyColNeighbours\n\n  // tableDataExplore contains all the information we need to set the five states listed above\n  // We just need to make use of the \"data\" and \"origin\" attributes. rowSpan and colSpan have no impact here.\n  // Also, since we are not modifying tableDataExplore, we do not need to make a copy of it.\n\n  // First, let's deal with keyColIndex. \n  // We will use the first column such that it's class annotation is not [] or [\"Number\"]\n  // If no such column exists, we default it to the first column\n\n  let keyColIndex = -1;\n  for (let i=0;i<selectedClassAnnotation.length;++i) {\n    if (selectedClassAnnotation[i].length > 0 \n        && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"Number\")) {\n      // Note: we have to include the plus 1 here, because selectedClassAnnotation's length is 1 smaller than the number of columns \n      // Since OriginURL column does not have class annotation\n      keyColIndex = i+1; \n      break;\n    }\n  }\n  if (keyColIndex === -1) {\n    keyColIndex = 0;\n  }\n  // console.log(\"Key Column Index is: \");\n  // console.log(keyColIndex);\n\n  // Now, let's deal with tableHeader. Note: these tableHeaders only have value and label, no range or type\n  let tableHeader = [];\n  for (let j=0;j<tableDataExplore[0].length;++j) {\n    tableHeader.push(\n      {\"value\":tableDataExplore[0][j].data\n      ,\"label\":tableDataExplore[0][j].data}\n    )\n  }\n  // console.log(\"Table header is: \");\n  // console.log(tableHeader);\n\n  // Now, let's deal with tableData. Wee need to handle both data and origin.\n  let tableData = [];\n  // console.log(tableDataExplore);\n  // This starts the loop for rows\n  for (let i=1;i<tableDataExplore.length;++i) {\n    let tempRow = [];\n    // This starts the loop for columns\n    for (let j=0;j<tableDataExplore[i].length;++j) {\n      // First set the data\n      let data = tableDataExplore[i][j].data;\n      // Then set the origin\n      let origin = [];\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\n      origin.push(originText);\n      tempRow.push({\"data\":data,\"origin\":origin});\n    }\n    tableData.push(tempRow);\n  }\n  // console.log(\"Table data is: \");\n  // console.log(tableData);\n\n  // Now, let's deal with keyColNeighbours and optionsMap\n  // Note: the following part is really similar to what we have in contextSetCell\n  let promiseArray = [];\n\n  // Below is the first query we will make.\n  // This query fetches the neighbours for tableData[0][keyColIndex], so the first cell in column with index keyColIndex\n  // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\n\n  let prefixURLOne =\n    \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n  let suffixURLOne =\n    \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n  let queryBodyOne =\n    \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\n    regexReplace(tableData[0][keyColIndex].data) +\n    \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\n  let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n  let otherColPromiseSubject = fetchJSON(queryURLOne);\n  promiseArray.push(otherColPromiseSubject);\n\n  // Below is the second query we will make.\n  // Difference with the previous query is that we are using tableData[0][colIndex] as OBJECT\n  let prefixURLTwo =\n    \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n  let suffixURLTwo =\n    \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n  let queryBodyTwo =\n    \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\n    regexReplace(tableData[0][keyColIndex].data) +\n    \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\n  let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n  let otherColPromiseObject = fetchJSON(queryURLTwo);\n  promiseArray.push(otherColPromiseObject);\n\n  return allPromiseReady(promiseArray).then((values) => {\n    // Now we finalize the keyColNeighbours\n    let keyColNeighbours = [];\n    keyColNeighbours = updateKeyColNeighbours(\n      keyColNeighbours,\n      values[0].results.bindings,\n      \"subject\"\n    );\n    keyColNeighbours = updateKeyColNeighbours(\n      keyColNeighbours,\n      values[1].results.bindings,\n      \"object\"\n    );\n    // console.log(\"Key Column Neighbours are: \");\n    // console.log(keyColNeighbours);\n\n    // Now, we handle the optionsMaps\n    // We can just put on empty options.\n    let optionsMap = [];\n    for (let j=0;j<tableHeader.length;++j) {\n      optionsMap.push([]);\n    }\n    // console.log(\"Options Map are: \");\n    // console.log(optionsMap);\n\n    // Lastly, let's put all the information together in a single object, and return it as a Promise\n    return Promise.resolve(\n      {\n        \"keyColIndex\":keyColIndex,\n        \"tableHeader\":tableHeader,\n        \"tableData\":tableData,\n        \"keyColNeighbours\":keyColNeighbours,\n        \"optionsMap\":optionsMap\n      }\n    )\n  })\n}\n","// import { Route, Switch, Link } from \"react-router-dom\";\nimport React, { Component } from \"react\";\n// import Header from \"../components/Header\";\n// import Footer from \"../components/Footer\";\nimport MainBody from \"../components/MainBody\";\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"wrapper \">\n        <div className=\"font-body\">\n          {/* <div className=\"header\">\n            <Header />\n          </div> */}\n          <div>\n            <MainBody />\n          </div>\n          {/* <div className=\"footer\">\n            <Footer />\n          </div> */}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n\n\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"./assets/custom.css\";\nimport \"./assets/layout.css\";\nimport App from \"./layouts/App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}