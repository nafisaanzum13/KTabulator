{"version":3,"sources":["components/Header.jsx","components/Footer.jsx","components/SettingModal.jsx","components/FilterModal.jsx","components/JoinModal.jsx","components/UnionModal.jsx","components/URLForm.jsx","components/LandingPage.jsx","components/TablePanel.jsx","components/TableSelection.jsx","components/TaskMenu.jsx","components/FirstColSelection.jsx","components/OtherColSelection.jsx","components/PreviewOrigin.jsx","components/ActionPanel.jsx","components/PagePanel.jsx","components/MainBody.jsx","layouts/App.jsx","index.js"],"names":["Header","state","className","href","class","encodeURIComponent","JSON","stringify","this","props","fullState","title","download","onClick","copyTable","openModal","undoPreviousStep","Component","Footer","SettingModal","isOpen","showSetting","onChange","e","toggleSemantic","type","value","checked","semanticEnabled","unionCutOff","unionCutOffChange","min","max","step","closeModal","FilterModal","optionsEle","i","push","dataAndChecked","toggleChecked","data","replace","length","rangeEle","showFilter","numericCol","tableData","curFilterIndex","isNaN","Number","placeholder","filterMin","handleRangeFilter","filterMax","checkAll","toggleAll","Button","applyFilter","cancelFilter","JoinModal","joinPairEle","joinPairArray","joinPairRecord","originIndex","joinIndex","buttonText","originColOptions","label","joinColOptions","runJoin","showJoin","originJoinIndex","selectJoinColumn","options","isMulti","joinJoinIndex","cancelJoin","UnionModal","showUnionModal","hardcodeUnion","cancelUnionAlign","URLForm","handleURLPaste","bind","preventDefault","urlPasted","clipboardData","window","getData","onPaste","LandingPage","TablePanel","showFullTitle","createSuperTable","createSelectedTableView","showPartialTitle","setState","colIndex","tableHeader","textLiteral","niceRender","firstColHeaderInfo","curText","j","onMouseEnter","onMouseLeave","textToAdd","rowNum","colNum","table","tempRow","tempHeader","buttonsEle","textEle","firstColFilled","columnHeaderGen","handlePlusClick","contextSetColumn","contextAddColumn","showFilterMethods","keyColIndex","buttonEle","getOtherOptions","contextDeleteColumn","rows","previewColIndex","style","backgroundColor","previewData","readOnly","cellColor","curTitle","onCellChange","onDoubleClick","originPreviewPage","tableDataExplore","tableHeaderRow","tableRows","tableEle","border","str","TableSelection","createButtonArray","originTableArray","buttonArray","headerCells","cells","headerData","removeNewLine","innerText","slice","tableContent","dangerouslySetInnerHTML","__html","outerHTML","selectButton","tableOpenList","listType","buttonFunction","toggleTable","Collapse","originTableArrayEle","TaskMenu","subject","resultStr","bracketIndex","indexOf","handleStartSubject","decodeURIComponent","toggleTableSelection","showTableSelection","CardBody","Card","handleStartTable","FirstColSelection","createFirstColSelection","keyCheckedIndex","firstColSelection","firstColChecked","selectedNeighbours","alert","populateEle","populateText","pDataset","oValue","pValue","populateKeyColumn","confirmAddFirstCol","returnEle","typeEle","firstColText","firstColTextChange","toUpperCase","includes","toggleFirstNeighbour","selectionEle","OtherColSelection","createOtherColSelection","otherColSelection","otherColChecked","otherCheckedIndex","console","log","populateOtherColumn","otherColText","otherColTextChange","toggleOtherNeighbour","PreviewOrigin","createPreviewEle","createOriginEle","previewInfoExpanded","previewInfoArray","previewEle","key","togglePreviewElement","brEle","selectedCell","originEle","origin","ActionPanel","createPropertyArray","createSiblingArray","createTableArray","createRecommendArray","createStartRecommend","createCustomizedUnion","firstIndex","secondIndex","tableArray","propertyNeighbours","siblingArray","tableElement","thirdIndex","tableTitleText","toggleOtherTable","unionTable","colMapping","siblingElement","zeroDividerSet","tooltipText","name","listClassSib","toggleSibling","unionPage","propertyElement","predicate","object","propertyText","listClass","togglePropertyNeighbours","recommendArray","recommendEle","neighbourArray","recommendText","populateRecommendation","recommendationText","createNeighbourText","actionInfo","neighbourArrayText","sameNeighbourOneRow","sameNeighbourDiffRow","curActionInfo","populateStartRecommend","unionURL","formEle","handleUnionPaste","tableListEle","unionTableArray","unionOpenList","toggleUnionTable","unionCustomized","actionEle","wrapperEle","titleEle","usecaseSelected","selectedTableIndex","task","addToFirstCol","createSameNeighbour","sameNeighbourEle","contextSortColumn","openFilter","contextDedupColumn","curIndex","tabIndex","selectedIndex","onSelect","index","handleTabSwitch","toggleUnionJoin","showUnionTables","showJoinTables","handleJoinTable","PagePanel","pageEle","wikiPageClass","iframeURL","buttonhideShow","toggleWikiPage","aria-hidden","pageHidden","id","src","MainBody","optionsMap","semanticTree","typeRecord","tablePasted","lastAction","prevState","keyColNeighbours","firstDegNeighbours","selectedClassAnnotation","showJoinModal","joinTableIndex","joinTableData","cellChange","selectColHeader","getKeyOptions","getNeighbourPromise","getOtherColPromise","addAllNeighbour","getTableStates","unionProperty","showUnionAlign","handleFileChange","document","body","classList","add","promiseArray","fetchText","allPromiseReady","then","values","htmlText","wikiTableArray","DOMParser","parseFromString","getElementsByClassName","tagName","undefined","remove","textArea","createElement","copiedText","appendChild","select","execCommand","removeChild","taskSelected","_","cloneDeep","fetchJSON","regexReplace","resultsBinding","processedBinding","filter","a","p","sort","b","splice","dctArray","dbopArray","o","count","getPCount","prevNeighbour","curNeighbour","datatype","concat","removePrefix","updateFirstColSelection","results","bindings","target","neighbourIndex","curColumnArray","curNeighbourData","otherColCheckedIndex","firstColCheckedUpdated","allSubject","queryBody","queryURL","myJson","keyColOptions","curValue","somevar","tempObj","neighbour","colEmpty","colFilled","nonEmptyInfo","tempSelection","scrollTo","selectedOptions","keyColLabel","ownLabel","cellValue","curPromise","keyQueryGen","updatedRowCount","Math","rowsToAdd","emptyEntryCount","startingIndex","tempOrigin","uniqBy","x","setFirstColumnData","promiseArrayOne","promiseArrayTwo","sampleRows","sampleSize","promiseArrayThree","getRDFType","valuesOne","valuesTwo","valuesThree","selectionInfo","updateUnionSelection","updatedNeighbours","updateNeighbourInfo","curColumnRecord","buildTypeRecord","autoFillInfo","getAutofillInfo","numNewRows","fillStartIndex","columnInfo","autoPromise","autofillFarPromise","valuesAuto","farArray","processAutoInfo","farIndex","curColumn","autofillFirstDeg","autofillFarDeg","longHopWarning","hasMultiple","originToAdd","keyOrigin","lastIndex","dataArray","recommendNeighbours","relation","differenceBy","filledPercent","numCols","fillRecommendation","keyColIndexUpdated","tableDataUpdated","k","newTableHeader","tableHeaderUpdated","selectedClassAnnotationUpdated","optionsMapUpdated","curCol","requiredLength","subjectNeighbours","objectNeighbours","curRow","rowToAdd","firstDegNeighboursUpdated","curData","curRecommendation","sliceIndex","numRecommend","order","aValue","bValue","rowIndex","otherColPromiseSubject","otherColPromiseObject","subjectInfoArray","updatePreviewInfo","objectInfoArray","minLength","originText","Promise","resolve","tableIndex","queryPromise","queryOne","urlReplace","queryTwo","findClassAnnotation","queryResults","propertyNeighboursPO","bindingArray","urlOrigin","curSiblingArray","siblingName","s","setTableFromHTML","stateInfo","siblingNameArray","tableArrayPromise","pageHTML","findTableFromHTML","tableArrayValues","aTableLength","bTableLength","aName","bName","selectedSibling","selectedTable","otherTableHTML","tableTreePromise","treeValues","tableTree","buildTableTree","otherTableOrigin","otherTableData","setUnionData","otherTypeRecord","otherTreeValues","otherTableTree","newMapping","originCols","newCols","curHeaderCells","headerName","HTMLCleanCell","originColName","newColName","semMatchingIndex","findSemanticUnion","newMappingCopy","tableConcat","refInfo","autoArray","autoIndex","removeNAfromNotes","headerRow","sameTable","diffColFound","m","tempMapping","Set","checkIndex","allFalse","NEGATIVE_INFINITY","POSITIVE_INFINITY","curNumData","valuesToKeep","originTableHeader","joinTableHeader","originTableData","originColumns","curColData","joinColumns","allPairsRecord","numFound","curVal","indexAddOne","joinScore","computeJoinableColumn","method","joinTableDataUpdated","curJoinEntry","curEntryFound","dataToUnion","tempData","uploadedFile","files","reader","FileReader","readAsText","onload","result","parse","content","firstColIndex","bodyEle","bottomContentClass","topContentClass","url","fetch","response","ok","Error","json","catch","error","text","all","updateKeyColNeighbours","subPropertyOf","neighbourCount","neighbourToAdd","valuesToAdd","neighbourRange","range","neighbourSubPropertyOf","objLabel","categoryPreviewInfoArray","categoryBinding","dataToAdd","colInNew","trim","split","pageName","wikiTablesFound","tablesFound","tablePromise","findTableFromTable","unionScore","tableHTML","remainCols","searchCols","sameStructure","remainClassAnnotation","curSearchIndex","intersection","totalSuccess","numTrial","hyperCDF","tempTable","curCellText","anchorArray","getElementsByTagName","hrefArray","curRowSpan","rowSpan","curColSpan","colSpan","remainEntries","curColIndex","curEntry","classAnnotation","curColumnClass","curCellClass","selecteTableHTML","N","K","n","denom","combinations","processAllNeighbours","allNeighboursArray","allNeighboursArrayCopy","prevEntry","filledCount","round","storeFirstDeg","neighbourArrayCopy","dedupedData","uniq","addRecommendNeighbours","processedNeighboursCopy","processedNeighbours","upperStrOne","upperStrTwo","myArray","oType","subjectNeighbourArray","temp","processedSubjectNeighbours","objectNeighbourArray","processedObjectNeighbours","unionSelection","unionChecked","firstRecord","oneDegInfo","twoDegInfo","threeDegInfo","curOrigin","firstOrigin","curRef","curInfo","curString","curType","substring","tableDataPassed","firstDegNeighboursPassed","firstDegNeighboursPassedCopy","degLimit","numVar","selectClause","optionClause","optionIndex","curClause","refColIndex","returnClause","returnArray","curBinding","curVarName","valueToAdd","valueArray","totalNeighbourText","sampleData","startingType","prefixURL","suffixURL","typeArray","curTypeArray","tableDataArray","tableTypeArray","curCounter","tableTypeRecord","curTypeRecord","originURLTypeRecord","curColumnPromise","columnTreePromise","columnRecord","curColumnType","bodyClause","semTree","buildColumnTree","columnType","columnTree","fullColumnTree","columnTypeCopy","countMap","highestCount","Object","keys","highestTypes","tempTree","curTypeTree","tree","curHighType","cellTree","typeUsed","curLevel","counter","combinedTree","maxDepth","totalCount","curLevelMap","originColIndex","otherColIndex","otherColScore","curColScore","calcColumnScore","treeOne","treeTwo","returnScore","originTypes","curOriginType","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.b3c01940.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport { FaCopy, FaUndo, FaDownload } from \"react-icons/fa\";\r\nimport { FiSettings } from \"react-icons/fi\";\r\n\r\nclass Header extends Component {\r\n  state = {};\r\n  render() {\r\n    // console.log(this.props.fullState);\r\n    return (\r\n      <>\r\n        <div className=\"row header-body\">\r\n          <div className=\"col-md-8\">\r\n            <a href=\"index.html\" class=\"logo\">\r\n              <b>\r\n                <span>K</span>Tabulator\r\n              </b>\r\n            </a>\r\n          </div>\r\n          <div className=\"offset-md-2 col-md-2 row\">\r\n            <div className=\"col-md-3\">\r\n              <a\r\n                href={`data:text/json;charset=utf-8,\r\n                      ${encodeURIComponent(JSON.stringify(this.props.fullState))}`}\r\n                title=\"download table\"\r\n                download=\"shareTable.json\"\r\n              >\r\n                <FaDownload className=\"json-link\"/>\r\n              </a>\r\n            </div>\r\n            <div className=\"col-md-3\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"export table\"\r\n                onClick={() => this.props.copyTable()}\r\n              >\r\n                <FaCopy className=\"logo-left-color\" />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-3\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"Union Table Settings\"\r\n              >\r\n                <FiSettings\r\n                  className=\"logo-left-color\"\r\n                  onClick={() => this.props.openModal()}\r\n                />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-3\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"undo previous action\"\r\n                onClick={() => this.props.undoPreviousStep()}\r\n              >\r\n                <FaUndo className=\"color-wrangler\" />\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <hr class=\"header-hr\"></hr>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","import React, { Component } from \"react\";\r\nclass Footer extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        {/* <hr className=\"m-0\"></hr> */}\r\n        <div className=\"text-center text-sm\">\r\n          {/* <small>University of Waterloo, 2020</small> */}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Footer;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\n// The two following lines are for range sliders\r\nimport RangeSlider from \"react-bootstrap-range-slider\";\r\nimport \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\n\r\nclass SettingModal extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showSetting}\r\n          className=\"setting-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div className=\"row\">\r\n              <div className=\"col-md-6 offset-md-3\">\r\n                <h4>Table Union Search Settings</h4>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Semantic Mapping:</div>\r\n              <div className=\"col-md-6\">\r\n                <div onChange={(e) => this.props.toggleSemantic(e)}>\r\n                  <input\r\n                  type=\"radio\"\r\n                  value=\"enabled\"\r\n                  checked={this.props.semanticEnabled === \"enabled\"}\r\n                  />{\" \"}\r\n                  Enabled\r\n                  <input\r\n                    type=\"radio\"\r\n                    value=\"disabled\"\r\n                    checked={this.props.semanticEnabled === \"disabled\"}\r\n                  />{\" \"}\r\n                  Disabled\r\n                </div>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Percentage of Columns to Union:</div>\r\n              <div className=\"col-md-6\">\r\n                <RangeSlider\r\n                  value={this.props.unionCutOff}\r\n                  onChange={(e) => this.props.unionCutOffChange(e)}\r\n                  min={0}\r\n                  max={1}\r\n                  step={0.05}\r\n                />\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4 offset-md-4\">\r\n                <button onClick={() => this.props.closeModal()}>Confirm Settings</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SettingModal;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\nimport { Button } from \"reactstrap\";\r\n\r\nclass FilterModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    let optionsEle = [];\r\n    for (let i=0;i<this.props.dataAndChecked.length;++i) {\r\n      optionsEle.push(\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            checked={this.props.dataAndChecked[i].checked}\r\n            onChange={(e) => this.props.toggleChecked(e, i)}\r\n          />\r\n          {niceRender(this.props.dataAndChecked[i].data)}\r\n        </div>\r\n      )\r\n    }\r\n    // console.log(optionsEle);\r\n\r\n    // Support for range filter starts here:\r\n    // If we have detected that this is a numeric column, we need to display an additional element here\r\n    // We first loop through this column to determine if it's a numeric column or a string column\r\n    let rangeEle = null;\r\n\r\n    if (this.props.showFilter === true) {\r\n      let numericCol = true;\r\n      for (let i = 0; i < this.props.tableData.length; ++i) {\r\n        // We only care about entries that are not N/A\r\n        if (this.props.tableData[i][this.props.curFilterIndex].data !== \"N/A\") {\r\n          if (isNaN(Number(this.props.tableData[i][this.props.curFilterIndex].data))) {\r\n            numericCol = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      // console.log(\"a numeric column? \"+numericCol);\r\n      \r\n      // If this is a numeric column, we need to allow users to input two fields:\r\n      // min and max\r\n      if (numericCol) {\r\n        rangeEle = \r\n          <div>\r\n            <p>\r\n              <input\r\n                placeholder=\"min\"\r\n                value={this.props.filterMin}\r\n                onChange={(e) => this.props.handleRangeFilter(e, \"min\")}\r\n              ></input>\r\n              to\r\n              <input\r\n                placeholder=\"max\"\r\n                value={this.props.filterMax}\r\n                onChange={(e) => this.props.handleRangeFilter(e, \"max\")}\r\n              ></input>\r\n            </p>\r\n          </div>\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showFilter}\r\n          className=\"filter-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div>\r\n              Here is the list of data to filter.\r\n            </div>\r\n            <br />\r\n            <div className=\"checkbox-list\">\r\n              <div>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={this.props.checkAll}\r\n                  onChange={(e) => this.props.toggleAll(e)}\r\n                />\r\n                Check/Uncheck all\r\n              </div>\r\n              <br />\r\n              {rangeEle}\r\n              {optionsEle}\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-1 offset-md-9\">\r\n                <Button onClick={(e) => this.props.applyFilter(e)}>OK</Button>\r\n              </div>\r\n              <div className=\"col-md-2\">\r\n                <Button onClick={(e) => this.props.cancelFilter(e)}>Cancel</Button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FilterModal;\r\n\r\n// This function renders data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\nimport Select from \"react-select\";\r\nimport { Button } from \"reactstrap\";\r\n\r\nclass JoinModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    // Support for join recommendation: in addition to letting users choose the join columns\r\n    // we also want to make three suggestions or the three most joinable pairs, using a value-based approach\r\n\r\n    // console.log(this.props.originColOptions);\r\n    // console.log(this.props.joinColOptions);\r\n\r\n    let joinPairEle = null;\r\n    let joinPairArray = []\r\n    if (this.props.joinPairRecord.length > 0) {\r\n      for (let i = 0; i < this.props.joinPairRecord.length; ++i) {\r\n        let originIndex = this.props.joinPairRecord[i][\"indices\"][0];\r\n        let joinIndex = this.props.joinPairRecord[i][\"indices\"][1];\r\n        let originCol = this.props.originColOptions[originIndex].label;\r\n        let joinCol = this.props.joinColOptions[joinIndex].label;\r\n        let buttonText = originCol + \" with \" + joinCol;\r\n        joinPairArray.push(\r\n          <p>\r\n            <Button\r\n              onClick={(e) => this.props.runJoin(e, \"suggest\", originIndex, joinIndex)}\r\n            >\r\n              {buttonText}\r\n            </Button>\r\n          </p>\r\n        )\r\n      }\r\n      joinPairEle = \r\n        <div>\r\n          <p>\r\n            Here are the suggested columns to join on.\r\n          </p>\r\n          {joinPairArray}\r\n        </div>\r\n    }\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showJoin}\r\n          className=\"join-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            {joinPairEle}\r\n            <div className=\"row\"> \r\n              <div className=\"col-md-5\">\r\n                Choose join column from table panel\r\n              </div>\r\n              <div className=\"offset-md-1 col-md-5\">\r\n                Choose join column from selected table\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <Select\r\n                className=\"col-md-5\"\r\n                value={this.props.originColOptions[this.props.originJoinIndex]}\r\n                onChange={(e) => this.props.selectJoinColumn(e, \"originTable\")}\r\n                placeholder={\"Choose Join Column\"}\r\n                options={this.props.originColOptions}\r\n                isMulti={false}\r\n              />\r\n              <Select\r\n                className=\"offset-md-1 col-md-5\"\r\n                value={this.props.joinColOptions[this.props.joinJoinIndex]}\r\n                onChange={(e) => this.props.selectJoinColumn(e, \"joinTable\")}\r\n                placeholder={\"Choose Join Column\"}\r\n                options={this.props.joinColOptions}\r\n                isMulti={false}\r\n              />\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-1 offset-md-9\">\r\n                <Button onClick={(e) => this.props.runJoin(e, \"custom\")}>OK</Button>\r\n              </div>\r\n              <div className=\"col-md-2\">\r\n                <Button onClick={(e) => this.props.cancelJoin(e)}>Cancel</Button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default JoinModal;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\nimport { Button } from \"reactstrap\";\r\n\r\n// Note: this component is hard-coded and should be fixed.\r\n\r\nclass UnionModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showUnionModal}\r\n          className=\"union-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div className=\"row\"> \r\n              <div className=\"col-md-5\">\r\n                Choose one of the following alignments:\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"modal-body\">\r\n              <div>\r\n                <Button onClick={(e) => this.props.hardcodeUnion(e)}>Suggested Alignment</Button>\r\n                <p>First Column---English title; director---Director(s); country---Country</p>\r\n              </div>\r\n              <div>\r\n                <Button>Create Manual Alignment</Button>\r\n              </div>\r\n            </div>\r\n            <div className=\"row\">\r\n              <div className=\"col-md-2 offset-md-10\">\r\n                <Button onClick={() => this.props.cancelUnionAlign()}>Cancel</Button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default UnionModal;\r\n","import React, { Component } from \"react\";\r\n\r\nclass URLForm extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n  }\r\n\r\n  handleURLPaste(e) {\r\n    e.preventDefault();\r\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\r\n    this.props.handleURLPaste(urlPasted);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"row text-center\">\r\n          <div className=\"col-md-6 offset-md-3\">\r\n            <input\r\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\r\n              onPaste={this.handleURLPaste}\r\n              className=\" form-control\"\r\n            ></input>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default URLForm;\r\n","import React, { Component } from \"react\";\r\nimport URLForm from \"../components/URLForm\";\r\n\r\nclass LandingPage extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  // In here we need to support both pasting of a URL and selection of a JSON file downloaded from website\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"landing-page\">\r\n          <div className=\"row\">\r\n            <div className=\"white-form col-md-5\">\r\n              <h1 className=\"text-center\"> \r\n                Welcome!\r\n              </h1>\r\n              <hr className=\"header-hr\"></hr>\r\n              <h4 className=\"text-center\">\r\n                Enter the URL of a Wikipedia page to get started\r\n              </h4>\r\n              <URLForm \r\n                handleURLPaste={this.props.handleURLPaste} \r\n              />\r\n              {/* <br />\r\n              <h4 className=\"offset-md-1\">\r\n                Or upload a downloaded table\r\n              </h4>\r\n              <div className=\"offset-md-4\">\r\n                <input \r\n                  type=\"file\" \r\n                  onChange={this.props.handleFileChange}\r\n                />\r\n              </div> */}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default LandingPage;\r\n","import React, { Component } from \"react\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// import Tooltip from '@atlaskit/tooltip';\r\n// import Select from \"react-select\";\r\n// import { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\r\nimport { FaSearch, FaEdit, FaPlus, FaMinus, FaFilter, FaArrowDown, FaEllipsisH} from \"react-icons/fa\";\r\n\r\nclass TablePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      showFullTitle: false, // boolean storing whether we want to display the full title for the first column, in the startSubject case\r\n    };\r\n    this.createSuperTable = this.createSuperTable.bind(this);\r\n    this.createSelectedTableView = this.createSelectedTableView.bind(this);\r\n    // The following functions are for first column's display in the startSubject case. They are helpers for columnHeaderGen\r\n    this.showFullTitle = this.showFullTitle.bind(this);\r\n    this.showPartialTitle = this.showPartialTitle.bind(this);\r\n  }\r\n\r\n  showFullTitle() {\r\n    this.setState({\r\n      showFullTitle: true,\r\n    })\r\n  }\r\n\r\n  showPartialTitle() {\r\n    this.setState({\r\n      showFullTitle: false,\r\n    })\r\n  }\r\n\r\n  // This function creates the i-th column header from this.props.tableHeader[i]\r\n  // It is a helper function for createSuperTable\r\n\r\n  columnHeaderGen(colIndex) {\r\n    // console.log(colIndex);\r\n    // console.log(this.props.tableHeader);\r\n\r\n    // In this case we deal with the first column header\r\n    // We want to divide it into two subcases: \"start table\" vs. \"start subject\"\r\n    if (colIndex === 0) {\r\n      // First subcase is start table\r\n      if (this.props.tableHeader.length > 0 && \r\n          this.props.tableHeader[0].length === 1 && \r\n          this.props.tableHeader[0][0].label === \"OriginURL\") {\r\n        let textLiteral = \"\";\r\n        for (let i = 0; i < this.props.tableHeader[0].length; ++i) {\r\n          let textToAdd = i > 0 ? \"\\nAND \" + niceRender(this.props.tableHeader[0][i].label) : niceRender(this.props.tableHeader[0][i].label);\r\n          textLiteral+=textToAdd;\r\n        }\r\n        let textEle = \r\n          <div>\r\n            {textLiteral}\r\n          </div>\r\n        return textEle;\r\n      }\r\n      // Second subcase is start subject\r\n      else {\r\n        // In this subcase, we first check if firstColHeaderInfo has length < 2\r\n        let firstColHeaderInfo = this.props.firstColHeaderInfo;\r\n\r\n        // If yes, we simply display it\r\n        if (firstColHeaderInfo.length < 2) {\r\n          let textLiteral = [];\r\n          for (let i = 0; i < firstColHeaderInfo.length; ++i) {\r\n            let curText = \"\";\r\n            for (let j = 0; j < firstColHeaderInfo[i].length; ++j) {\r\n              let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[i][j].label) : niceRender(firstColHeaderInfo[i][j].label);\r\n              curText+=textToAdd;\r\n            }\r\n            textLiteral.push(\r\n              <p>\r\n                {curText}\r\n              </p>\r\n            )\r\n          }\r\n          let textEle = \r\n            <div>\r\n              {textLiteral}\r\n            </div>\r\n          return textEle;\r\n        }\r\n\r\n        // Else, firstColHeaderInfo has length longer than 1, so we have to check this.state.showFullTitle\r\n        // what we render depends on whether this.state.showFullTitle is true or not\r\n        else {\r\n          let showFullTitle = this.state.showFullTitle;\r\n\r\n          // If showFullTitle is false, we display the first element from firstColHeaderInfo\r\n          // As well as an icon that, on hover, sets showFullTitle to true\r\n          if (showFullTitle === false) {\r\n            let textLiteral = [];\r\n            let curText = \"\";\r\n            for (let j = 0; j < firstColHeaderInfo[0].length; ++j) {\r\n              let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[0][j].label) : niceRender(firstColHeaderInfo[0][j].label);\r\n              curText+=textToAdd;\r\n            }\r\n            textLiteral.push(\r\n              <p>\r\n                {curText}\r\n                {\"\\u00A0\"}\r\n                <FaEllipsisH \r\n                  onMouseEnter={() => this.showFullTitle()}\r\n                  onMouseLeave={() => this.showPartialTitle()}\r\n                />\r\n              </p>\r\n            )\r\n            let textEle = \r\n              <div>\r\n                {textLiteral}\r\n              </div>\r\n            return textEle;\r\n          }\r\n          // If showFullTitle is true, we display the full table header for the first column\r\n          else {\r\n            let textLiteral = [];\r\n            for (let i = 0; i < firstColHeaderInfo.length; ++i) {\r\n              let curText = \"\";\r\n              for (let j = 0; j < firstColHeaderInfo[i].length; ++j) {\r\n                let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[i][j].label) : niceRender(firstColHeaderInfo[i][j].label);\r\n                curText+=textToAdd;\r\n              }\r\n              if (i === 0) {\r\n                textLiteral.push(\r\n                  <p>\r\n                    {curText}\r\n                    {\"\\u00A0\"}\r\n                    <FaEllipsisH \r\n                      onMouseEnter={() => this.showFullTitle()}\r\n                      onMouseLeave={() => this.showPartialTitle()}\r\n                    />\r\n                  </p>\r\n                )\r\n              }\r\n              else {\r\n                textLiteral.push(\r\n                  <p>\r\n                    {curText}\r\n                  </p>\r\n                )\r\n              }\r\n            }\r\n            let textEle = \r\n              <div>\r\n                {textLiteral}\r\n              </div>\r\n            return textEle;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // In this case we deal with non-first column headers\r\n    else {\r\n      let textLiteral = \"\";\r\n      for (let i = 0; i < this.props.tableHeader[colIndex].length; ++i) {\r\n        let textToAdd = \r\n          this.props.tableHeader[colIndex][i].type === \"object\" ? \"is \" + this.props.tableHeader[colIndex][i].value + \" of\" \r\n          : this.props.tableHeader[colIndex][i].value;\r\n        textToAdd = i > 0 ? \"\\nOR \" + textToAdd : textToAdd;\r\n        textLiteral+=textToAdd;\r\n      }\r\n      let textEle = \r\n        <div>\r\n          {textLiteral}\r\n        </div>\r\n      return textEle;\r\n    }\r\n  }\r\n\r\n  // This function takes the states tableData, keyColIndex, tableHeader, optionsMap\r\n  // And convert them into HTML for the super table\r\n\r\n  createSuperTable() {\r\n\r\n    // console.log(this.props.firstColHeaderInfo);\r\n    // console.log(\"Has first column been filled? \" + this.props.firstColFilled);\r\n    // console.log(this.props.tableData);\r\n    // console.log(\"The current previewColIndex is \"+this.props.previewColIndex);\r\n    \r\n    const rowNum = this.props.tableData.length;\r\n    const colNum = this.props.tableData[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n\r\n    let tempRow = [];\r\n    for (let colIndex = 0; colIndex < colNum; ++colIndex) {\r\n      let tempHeader;\r\n      // This part deals with the column 0 \r\n      if (colIndex === 0) {\r\n        let buttonsEle = null;\r\n        let textEle = <div><br /></div>;\r\n        if (this.props.firstColFilled === true) {\r\n          // If we have filled in the first column already, then we can generate its header text\r\n          textEle = this.columnHeaderGen(colIndex);\r\n          // Moreover, if the first column head is not [\"OriginURL\"], then we can create the button element\r\n          if (this.props.tableHeader[0][0].value !== \"OriginURL\") {\r\n            buttonsEle = \r\n              <div>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add entities\"\r\n                  onClick={() => this.props.handlePlusClick()}\r\n                >\r\n                  <FaArrowDown />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Set as key column\"\r\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\r\n                >\r\n                  <FaSearch />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n              </div>\r\n          }\r\n          else {\r\n            buttonsEle =\r\n              <div>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n              </div>\r\n          }\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            <div\r\n              className=\"super-header-div\"\r\n            >\r\n            </div>\r\n            {buttonsEle}\r\n            {textEle}\r\n          </th>\r\n        )\r\n      }\r\n      // This part deals with key columns that are not column 0\r\n      else if (colIndex === this.props.keyColIndex) {\r\n        let textEle = this.columnHeaderGen(colIndex);\r\n        let buttonEle = <div><br /></div>;\r\n        if (this.props.firstColFilled === true) {\r\n          buttonEle = \r\n            <div>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n            </div>\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            {buttonEle}\r\n            {textEle}\r\n          </th>\r\n        );\r\n      }\r\n      // This part deals with the non-key, non-first column headers\r\n      else {\r\n        let textEle = this.columnHeaderGen(colIndex);\r\n        let buttonEle = <div><br /></div>;;\r\n        if (this.props.firstColFilled === true) {\r\n          buttonEle = \r\n            <div>\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"Add entities\"\r\n                onClick={(e) => this.props.getOtherOptions(e, colIndex)}\r\n              >\r\n                <FaEdit />\r\n              </button>\r\n              <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Set as key column\"\r\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\r\n                >\r\n                  <FaSearch />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Add column to the right\"\r\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\r\n                >\r\n                  <FaPlus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Delete this column\"\r\n                  onClick={(e) => this.props.contextDeleteColumn(e, colIndex)}\r\n                >\r\n                  <FaMinus />\r\n                </button>\r\n                <button\r\n                  className=\"btn btn-default\"\r\n                  title=\"Filter this column\"\r\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\r\n                >\r\n                  <FaFilter />\r\n                </button>\r\n            </div>\r\n        }\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            {buttonEle}\r\n            {textEle}\r\n          </th>\r\n        );\r\n      }\r\n      tempRow.push(tempHeader);\r\n    }\r\n    table.push(\r\n      <thead className=\"table-head\">\r\n        <tr>{tempRow}</tr>\r\n      </thead>\r\n    );\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n\r\n    // We are adding an ID for each cell for contextmenu\r\n    let rows = [];\r\n    for (let i = 0; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      // Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // We want to treat preview columns and other columns differently\r\n\r\n        // First we deal with preview column\r\n        if (j === this.props.previewColIndex) {\r\n          let cellColor = {backgroundColor: \"LightGray\"};\r\n          tempRow.push(\r\n            <td style={cellColor}>\r\n              <input\r\n                className=\"twenty-vw column-preview-color\"\r\n                type=\"text\"\r\n                value={niceRender(this.props.tableData[i][j].previewData)}\r\n                readOnly\r\n              />\r\n            </td>\r\n          );\r\n        }\r\n        // Else we are dealing with a regular column\r\n        else {\r\n          let cellColor;\r\n          // We use light blue to represent search column\r\n          if (j === this.props.keyColIndex) {\r\n            cellColor = { backgroundColor: \"LightBlue\" };\r\n          }\r\n          // We use white to represent other columns\r\n          else {\r\n            cellColor = { backgroundColor: \"White\" };\r\n          }\r\n          // We include a small modification here to deal with the cell titles\r\n          let curTitle = niceRender(this.props.tableData[i][j].data).replace(/;/g, \"\\n\");\r\n          tempRow.push(\r\n            <td style={cellColor}>\r\n              <input\r\n                className=\"twenty-vw\"\r\n                type=\"text\"\r\n                value={niceRender(this.props.tableData[i][j].data)}\r\n                title={curTitle}\r\n                onChange={(e) => this.props.onCellChange(e, i, j)}\r\n                onDoubleClick={(e) => this.props.originPreviewPage(e, i, j)}\r\n              />\r\n            </td>\r\n          );\r\n        }\r\n      }\r\n      //Create the parent and add the children\r\n      rows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{rows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  // This function makes no modification of the data at all.\r\n  // It takes all the data from this.props.tableDataExplore, and convert them into HTML\r\n  createSelectedTableView() {\r\n    // console.log(rowNum);\r\n    // console.log(colNum);\r\n    // console.log(this.props.tableDataExplore[0][0].data);\r\n    // console.log(this.props.tableDataExplore[0][0].origin);\r\n    const rowNum = this.props.tableDataExplore.length;\r\n    const colNum = this.props.tableDataExplore[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n    let tempRow = [];\r\n    for (let j = 0; j < colNum; ++j) {\r\n      let tempHeader = (\r\n        <th className=\"table-head table-col\">\r\n          {this.props.tableDataExplore[0][j].data}\r\n        </th>\r\n      );\r\n      tempRow.push(tempHeader);\r\n    }\r\n    let tableHeaderRow = <tr className=\"table-head table-col\">{tempRow}</tr>;\r\n    table.push(<thead>{tableHeaderRow}</thead>);\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n    let tableRows = [];\r\n    for (let i = 1; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      //Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // Create the each cell\r\n        tempRow.push(\r\n          <td className=\"table-col\">\r\n            {this.props.tableDataExplore[i][j].data}\r\n          </td>\r\n        );\r\n      }\r\n      //Create the parent and add the children\r\n      tableRows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{tableRows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  render() {\r\n    let tableEle = null;\r\n\r\n    // In all cases, once we have pasted the URL. We want to display the super table in the table panel.\r\n    tableEle = (\r\n      // class table-fixed helps with sticky column headers\r\n      <div>\r\n        <table class border=\"1\" className=\"table table-sm table-bordered\">\r\n          {this.createSuperTable()}\r\n        </table>\r\n        {/* {menuArray} */}\r\n      </div>\r\n    );\r\n    return <div>{tableEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TablePanel;\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n\r\n","// This component takes in 5 props:\r\n\r\n// 1) originTableArray: 1D array storing all tables found on pasted URL\r\n// 2) tableOpenList:    1D array storing whether each table in originTableArray has been toggled open or not\r\n// 3) toggleTable:      function that handles the toggling on/off of a table\r\n// 4) listType:         string. Has value \"select\" when we are using TableSelection to select the starting table.\r\n//                              Has value \"join\" when we are using TableSelection in the join tables setting.\r\n// 5) buttonFunction:   function corresponding to the listType.\r\n\r\nimport React, { Component } from \"react\";\r\nimport { Button, Collapse } from \"reactstrap\";\r\nimport { FaTable } from \"react-icons/fa\";\r\n\r\nclass TableSelection extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createButtonArray = this.createButtonArray.bind(this);\r\n  }\r\n\r\n  createButtonArray() {\r\n    // this.props.originTableArray is a list of tables passed into this component \r\n    const originTableArray = this.props.originTableArray;\r\n\r\n    let buttonArray = [];\r\n    for (let i = 0; i < originTableArray.length; ++i) {\r\n      // This first part create the buttons with text: table index plus column names\r\n      // It also removes some newline characters\r\n      let buttonText = \"Table \" + i + \": \";\r\n      // console.log(originTableArray[i]);\r\n      let headerCells = originTableArray[i].rows[0].cells;\r\n      for (let j = 0; j < headerCells.length; ++j) {\r\n        let headerData = removeNewLine(headerCells[j].innerText);\r\n        if (headerData[headerData.length - 1] === \"\\n\") {\r\n          headerData = headerData.slice(0, -1);\r\n        }\r\n        buttonText = buttonText + headerData + \"| \";\r\n      }\r\n      // Now let's update the table content\r\n      let tableContent = (\r\n        <div\r\n          dangerouslySetInnerHTML={{\r\n            __html: this.props.originTableArray[i].outerHTML,\r\n          }}\r\n        />\r\n      );\r\n      let selectButton;\r\n      if (this.props.tableOpenList[i] === true) {\r\n        let buttonText = \"\";\r\n        if (this.props.listType === \"select\") {\r\n          buttonText = \"Select\";\r\n        }\r\n        else if (this.props.listType === \"join\"){\r\n          buttonText = \"Join\"\r\n        }\r\n        else {\r\n          buttonText = \"Union\"\r\n        }\r\n        selectButton = \r\n          <Button\r\n            onClick={(e) => this.props.buttonFunction(e, i)}\r\n          >\r\n            {buttonText}\r\n          </Button>\r\n      }\r\n      buttonArray.push(\r\n        <li\r\n          className=\"list-group-item\"\r\n        >\r\n        <span \r\n          onClick={(e) => this.props.toggleTable(e, i)}\r\n        >\r\n          {buttonText} {}\r\n          <FaTable />\r\n        </span>\r\n        {selectButton}\r\n          <Collapse isOpen={this.props.tableOpenList[i]}>\r\n            <div>{tableContent}</div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">{buttonArray}</ul>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const numTables = this.props.originTableArray.length;\r\n    let originTableArrayEle = null;\r\n    if (numTables !== 0) {\r\n      originTableArrayEle = <div>{this.createButtonArray()}</div>;\r\n    }\r\n    return <div>{originTableArrayEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TableSelection;\r\n\r\nfunction removeNewLine(str) {\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1);\r\n  } else {\r\n    return str;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Collapse, CardBody, Card } from \"reactstrap\";\r\nimport { FaList } from \"react-icons/fa\";\r\nimport TableSelection from \"../components/TableSelection\";\r\n\r\nclass TaskMenu extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const subject = niceRender(reverseReplace(this.props.urlPasted.slice(30)));\r\n    return (\r\n      <div className=\"action-scrollable\">\r\n        <ul class=\"list-group list-css list-group-flush\">\r\n          <hr className=\"m-0\"></hr>\r\n          <li\r\n            className=\"list-group-item\"\r\n            onClick={(e) => this.props.handleStartSubject(e, \"startSubject\")}\r\n          >\r\n            Start creating a table about {decodeURIComponent(subject)}\r\n          </li>\r\n          <li className=\"list-group-item\">\r\n            <span onClick={() => this.props.toggleTableSelection()}>\r\n              Start with an existing table from page <FaList />\r\n            </span>\r\n\r\n            <Collapse isOpen={this.props.showTableSelection}>\r\n              <CardBody>\r\n                <Card>\r\n                  <div>\r\n                    <TableSelection\r\n                      originTableArray={this.props.originTableArray}\r\n                      tableOpenList={this.props.tableOpenList}\r\n                      toggleTable={this.props.toggleTable}\r\n                      buttonFunction={this.props.handleStartTable}\r\n                      listType={\"select\"}\r\n                    />\r\n                  </div>\r\n                </Card>\r\n              </CardBody>\r\n            </Collapse>\r\n          </li>\r\n          <hr className=\"m-0\"></hr>\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TaskMenu;\r\n\r\n// This function changes the copied text \"%E2%80%93\" to \"-\" when we copy a URL from google.\r\n\r\nfunction reverseReplace(str) {\r\n  return str.replace(/%E2%80%93/, \"\");\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way.\r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\nfunction niceRender(str) {\r\n  let resultStr = str;\r\n  let bracketIndex = str.indexOf(\"(\");\r\n  // If ( is present in a string, we want to remove it\r\n  // We include the -1 because usually ( is preceeded by _\r\n  if (bracketIndex !== -1) {\r\n    resultStr = resultStr.slice(0, bracketIndex - 1);\r\n  }\r\n  // now we turn all \"_\" into \" \"\r\n  return resultStr.replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Button } from \"reactstrap\";\r\n\r\nclass FirstColSelection extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createFirstColSelection = this.createFirstColSelection.bind(this);\r\n  }\r\n\r\n  createFirstColSelection() {\r\n    let keyCheckedIndex = this.props.keyCheckedIndex;\r\n    let firstColSelection = this.props.firstColSelection;\r\n    let firstColChecked = this.props.firstColChecked;\r\n\r\n    let selectedNeighbours = [];\r\n    // We will create the selectedNeighbours array from this.props.firstColSelection and this.props.firstColChecked\r\n    if (firstColChecked.length !== firstColSelection.length) {\r\n      alert(\"Some error exists\");\r\n    }\r\n    for (let i = 0; i < firstColChecked.length; ++i) {\r\n      if (firstColChecked[i] === true) {\r\n        selectedNeighbours.push(firstColSelection[i]);\r\n      }\r\n    }\r\n\r\n    // console.log(selectedNeighbours);\r\n\r\n    // We initialize the populateEle as text telling users they should select from the attribute list\r\n    let populateEle = (\r\n      <div className=\"fixed-populateEle\">\r\n        <b>Choose from attributes below</b> to determine the content for the\r\n        first column\r\n        {/* <br /> */}\r\n      </div>\r\n    );\r\n    \r\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\r\n    if (keyCheckedIndex !== -1 && selectedNeighbours.length > 0) {\r\n      let populateText =\r\n        this.props.firstColFilled === false\r\n          ? \"Populate first column with entities that\"\r\n          : \"Add to first column with entities that\";\r\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\r\n        let curText = i > 0 ? \", and\" : \"\";\r\n        if (selectedNeighbours[i].pDataset === \"dct\") {\r\n          curText =\r\n            curText + \" are \" + niceRender(selectedNeighbours[i].oValue);\r\n        } else {\r\n          curText =\r\n            curText +\r\n            \" have \" +\r\n            selectedNeighbours[i].pValue +\r\n            \"=\" +\r\n            niceRender(selectedNeighbours[i].oValue);\r\n        }\r\n        populateText += curText;\r\n      }\r\n      populateText += \"?\";\r\n      // We conditionally create the button element\r\n      // If firstColFilled is false, we want to run populateKeyColumn\r\n      // Otherwise, we want to run addKeyColumn\r\n      let buttonEle =\r\n        this.props.firstColFilled === false ? (\r\n          <Button\r\n            className=\"btn-sm\"\r\n            onClick={(e) =>\r\n              this.props.populateKeyColumn(e, 0, selectedNeighbours)\r\n            }\r\n          >\r\n            OK\r\n          </Button>\r\n        ) : (\r\n          <Button\r\n            className=\"btn-sm\"\r\n            onClick={(e) =>\r\n              this.props.confirmAddFirstCol(e, selectedNeighbours)\r\n            }\r\n          >\r\n            OK\r\n          </Button>\r\n        );\r\n      populateEle = (\r\n        <div className=\"fixed-populateEle\">\r\n          <b>{populateText}</b>\r\n          {\"\\u00A0\"}\r\n          {buttonEle}\r\n          <br />\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // We now create the returnEle. First, we push on the populateEle\r\n    let returnEle = [];\r\n    // returnEle.push(populateEle);\r\n\r\n    // Modified on August 26th: we want to add an input search bar that acts as a type-ahead\r\n    let typeEle = (\r\n      <div>\r\n        <div>\r\n          <p>\r\n            Search for attributes:\r\n            {\"\\u00A0\"}\r\n            <input\r\n              value={this.props.firstColText}\r\n              onChange={(e) => this.props.firstColTextChange(e)}\r\n              placeholder={\"Type here\"}\r\n            />\r\n          </p>\r\n        </div>\r\n      </div>\r\n    )\r\n    returnEle.push(typeEle);\r\n\r\n    // We loop over the firstColSelection array, and push on the needed radio checkbox and textual information\r\n    for (let i = 0; i < firstColSelection.length; ++i) {\r\n      if (firstColSelection[i].pValue === \"category\") {\r\n        // Addition condition added here:\r\n        // before pushing a neighbour on, we need to check either of the following two conditions meets\r\n        // 1) this.props.firstColText is empty (\"\")\r\n        // 2) niceRender(firstColSelection[i].oValue) includes this.props.firstColText\r\n        if (this.props.firstColText === \"\"\r\n            ||\r\n            niceRender(firstColSelection[i].oValue).toUpperCase().includes(this.props.firstColText.toUpperCase())) {\r\n          returnEle.push(\r\n            <div>\r\n              <div>\r\n                <p>\r\n                  <input\r\n                    type=\"checkbox\"\r\n                    checked={firstColChecked[i]}\r\n                    onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\r\n                  />\r\n                  {\"\\u00A0\"}\r\n                  {\"\\u00A0\"}\r\n                  {niceRender(firstColSelection[i].oValue)}\r\n                </p>\r\n              </div>\r\n            </div>\r\n          );\r\n        }\r\n      } \r\n      else {\r\n        // Addition condition added here:\r\n        // before pushing a neighbour on, we need to check either of the following three conditions meets\r\n        // 1) this.props.firstColText is empty (\"\")\r\n        // 2) firstColSelection[i].pValue includes this.props.firstColText\r\n        // 2) niceRender(firstColSelection[i].oValue) includes this.props.firstColText\r\n        if (this.props.firstColText === \"\"\r\n            ||\r\n            firstColSelection[i].pValue.toUpperCase().includes(this.props.firstColText.toUpperCase())\r\n            ||\r\n            niceRender(firstColSelection[i].oValue).toUpperCase().includes(this.props.firstColText.toUpperCase())) {\r\n          returnEle.push(\r\n            <div>\r\n              <p>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={firstColChecked[i]}\r\n                  onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\r\n                />\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {firstColSelection[i].pValue}\r\n                {\":\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {niceRender(firstColSelection[i].oValue)}\r\n              </p>\r\n            </div>\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return (\r\n      <div>\r\n        {populateEle}\r\n        <div className=\"padding-top-8vh\">{returnEle}</div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    let selectionEle = this.createFirstColSelection();\r\n\r\n    return <div>{selectionEle}</div>;\r\n  }\r\n}\r\n\r\nexport default FirstColSelection;\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way.\r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\").replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Button } from \"reactstrap\";\r\n\r\nclass OtherColSelection extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createOtherColSelection = this.createOtherColSelection.bind(this);\r\n  }\r\n\r\n  createOtherColSelection() {\r\n    let otherColSelection = this.props.otherColSelection;\r\n    let otherColChecked = this.props.otherColChecked;\r\n    let otherCheckedIndex = this.props.otherCheckedIndex;\r\n\r\n    // console.log(otherColSelection);\r\n    // console.log(otherColChecked);\r\n    // console.log(otherCheckedIndex);\r\n\r\n    // First do some basic error checking\r\n    if (otherColChecked.length !== otherColSelection.length) {\r\n      console.log(\"Some error exists\");\r\n    }\r\n\r\n    // Now, we will create the selectedNeighbours array from otherColSelection and otherColChecked\r\n    let selectedNeighbours = [];\r\n    for (let i = 0; i < otherColChecked.length; ++i) {\r\n      if (otherColChecked[i] === true) {\r\n        selectedNeighbours.push(otherColSelection[i]);\r\n      }\r\n    }\r\n\r\n    // We initialize the populateEle as text telling users they should select from the attribute list\r\n    let populateEle = (\r\n      <div className=\"fixed-populateEle\">\r\n        <b>Choose from attributes below</b> to determine the content for this\r\n        column\r\n        <br />\r\n      </div>\r\n    );\r\n\r\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\r\n    if (otherCheckedIndex !== -1 && selectedNeighbours.length > 0) {\r\n      let populateText = \"Populate this column with attributes \";\r\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\r\n        let curText =\r\n          selectedNeighbours[i].type === \"object\"\r\n            ? \"is \" + selectedNeighbours[i].value + \" of\"\r\n            : selectedNeighbours[i].value;\r\n        curText = i > 0 ? \" OR \" + curText : curText;\r\n        populateText += curText;\r\n      }\r\n      populateText += \"?\";\r\n      populateEle = (\r\n        <div className=\"fixed-populateEle\">\r\n          <b>{populateText}</b>\r\n          {\"\\u00A0\"}\r\n          <Button\r\n            className=\"btn-sm\"\r\n            onClick={(e) =>\r\n              this.props.populateOtherColumn(\r\n                e,\r\n                this.props.colIndex,\r\n                selectedNeighbours\r\n              )\r\n            }\r\n          >\r\n            OK\r\n          </Button>\r\n          <br />\r\n        </div>\r\n      );\r\n    }\r\n\r\n    let returnEle = [];\r\n    // Modified on August 23rd: We want to display the textual information separately (not right next to any attribute)\r\n    // We also want to make this div fixed\r\n    returnEle.push(populateEle);\r\n\r\n    // Modified on August 26th: we want to add an input search bar that acts as a type-ahead\r\n    let typeEle = (\r\n      <div>\r\n        <div>\r\n          <p>\r\n            <br />\r\n          </p>\r\n        </div>\r\n        <div>\r\n          <p>\r\n            Search for attributes:\r\n            {\"\\u00A0\"}\r\n            <input\r\n              value={this.props.otherColText}\r\n              onChange={(e) => this.props.otherColTextChange(e)}\r\n              placeholder={\"Type here\"}\r\n            />\r\n          </p>\r\n        </div>\r\n      </div>\r\n    )\r\n    returnEle.push(typeEle);\r\n\r\n    // We loop through the otherColSelection array, and push on the needed radio checkbox\r\n    for (let i = 0; i < otherColSelection.length; ++i) {\r\n      // Modified on August 26th: before pushing a neighbour on, we need to check either of the following two conditions meets\r\n      // 1) this.props.otherColText is empty (\"\")\r\n      // 2) otherColSelection[i].label includes this.props.otherColText\r\n      if (this.props.otherColText === \"\" \r\n          || \r\n          otherColSelection[i].label.toUpperCase().includes(this.props.otherColText.toUpperCase())) {\r\n        returnEle.push(\r\n          <div>\r\n            <div>\r\n              <p>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={otherColChecked[i]}\r\n                  onChange={(e) =>\r\n                    this.props.toggleOtherNeighbour(e, i, this.props.colIndex)\r\n                  }\r\n                />\r\n                {\"\\u00A0\"}\r\n                {\"\\u00A0\"}\r\n                {otherColSelection[i].label}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        );\r\n      }\r\n    }\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n    let selectionEle = this.createOtherColSelection();\r\n\r\n    return <div>{selectionEle}</div>;\r\n  }\r\n}\r\n\r\nexport default OtherColSelection;\r\n","import React, { Component } from \"react\";\r\nimport { FaPlus, FaMinus } from \"react-icons/fa\";\r\n\r\nclass PreviewOrigin extends Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createPreviewEle = this.createPreviewEle.bind(this);\r\n    this.createOriginEle = this.createOriginEle.bind(this);\r\n  }\r\n\r\n  createPreviewEle() {\r\n    let previewInfoExpanded = this.props.previewInfoExpanded;\r\n    let previewInfoArray = this.props.previewInfoArray;\r\n    // We do some preliminary error checking\r\n    if (previewInfoExpanded.length !== previewInfoArray.length) {\r\n      alert(\"Some error exists!\");\r\n    }\r\n\r\n    // Move on to actual body of the function\r\n    let previewEle = [];\r\n    for (let i = 0; i < previewInfoArray.length; ++i) {\r\n      // First case: the current previewInfoArray element's value array only has one element. We just want to show some text.\r\n      if (previewInfoArray[i].value.length === 1) {\r\n        previewEle.push(\r\n          <div>\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">\r\n                <b>{previewInfoArray[i].key}:</b>\r\n              </div>\r\n              <div className=\"col-md-7\">\r\n                {niceRender(previewInfoArray[i].value[0])}\r\n              </div>\r\n            </div>\r\n            <br />\r\n          </div>\r\n        )\r\n      } \r\n      // Second case: the current previewInfoArray element's value array has more than one element.\r\n      // In this case we have to check for the previewInfoExpanded's variable.\r\n      else {\r\n        // Subcase one: previewInfoExpanded[i] is false, which means we want to push on one element only, and show a plus button\r\n        if (previewInfoExpanded[i] === false) {\r\n          previewEle.push(\r\n            <div>\r\n              <div className=\"row\">\r\n                <div className=\"col-md-4\">\r\n                  <b>{previewInfoArray[i].key}:</b>\r\n                </div>\r\n                <div className=\"col-md-7\">\r\n                  {niceRender(previewInfoArray[i].value[0])}\r\n                </div>\r\n                <div className=\"col-md-1\">\r\n                  <button\r\n                    className=\"btn btn-default\"\r\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\r\n                  >\r\n                    <FaPlus />\r\n                  </button>\r\n                </div>\r\n              </div>\r\n              <br />\r\n            </div>\r\n          )\r\n        }\r\n        // Subcase one: previewInfoExpanded[i] is true, which means we want to push on value.length number of elements.\r\n        // In this case we want to give a minus, or collapse icon\r\n        else {\r\n          // We first push on the first element(or row), which will include the minus icon\r\n          previewEle.push(\r\n            <div>\r\n              <div className=\"row\">\r\n                <div className=\"col-md-4\">\r\n                  <b>{previewInfoArray[i].key}:</b>\r\n                </div>\r\n                <div className=\"col-md-7\">\r\n                  {niceRender(previewInfoArray[i].value[0])}\r\n                </div>\r\n                <div className=\"col-md-1\">\r\n                  <button\r\n                    className=\"btn btn-default\"\r\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\r\n                  >\r\n                    <FaMinus />\r\n                  </button>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )\r\n          // We then push on the subsequent values\r\n          for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\r\n            let brEle = j === previewInfoArray[i].value.length - 1 ? <br /> : null;\r\n            previewEle.push(\r\n              <div>\r\n                <div className=\"row\">\r\n                  <div className=\"offset-md-4 col-md-7\">\r\n                    {\"- \" + niceRender(previewInfoArray[i].value[j])}\r\n                  </div>\r\n                </div>\r\n                {brEle}\r\n              </div>\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n    let returnEle = (\r\n      <div>\r\n        <p>Preview of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\r\n        {previewEle}\r\n      </div>\r\n    )\r\n    return returnEle;\r\n  }\r\n\r\n  createOriginEle() {\r\n    let originEle = [];\r\n    for (let i = 0; i < this.props.selectedCell.origin.length; ++i) {\r\n      originEle.push(\r\n        <p>\r\n          {niceRender(this.props.selectedCell.origin[i])}\r\n        </p>\r\n      );\r\n    }\r\n    let returnEle = (\r\n      <div>\r\n        <p>Origin of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\r\n        {originEle}\r\n      </div>\r\n    )\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n    // console.log(this.props.previewInfoArray);\r\n    // console.log(this.props.previewInfoExpanded);\r\n    // console.log(this.props.selectedCell);\r\n    let previewEle = this.createPreviewEle();\r\n    let originEle = this.createOriginEle();\r\n    return (\r\n      <div>\r\n        {previewEle}\r\n        <hr className=\"preview-origin-divider\"/>\r\n        {originEle}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PreviewOrigin;\r\n\r\n// This function renders strings in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport TaskMenu from \"../components/TaskMenu\";\r\nimport { Collapse, Button, CardBody, Card } from \"reactstrap\";\r\nimport { FaList, FaTable } from \"react-icons/fa\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// The two following lines are for tabs\r\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\r\nimport \"react-tabs/style/react-tabs.css\";\r\nimport TableSelection from \"./TableSelection\";\r\n// The two following lines are for range sliders\r\n// import RangeSlider from \"react-bootstrap-range-slider\";\r\n// import \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\nimport FirstColSelection from \"./FirstColSelection\";\r\nimport OtherColSelection from \"./OtherColSelection\";\r\nimport PreviewOrigin from \"./PreviewOrigin\";\r\n\r\nclass ActionPanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createPropertyArray = this.createPropertyArray.bind(this);\r\n    this.createSiblingArray = this.createSiblingArray.bind(this);\r\n    this.createTableArray = this.createTableArray.bind(this);\r\n    this.createRecommendArray = this.createRecommendArray.bind(this);\r\n    this.createStartRecommend = this.createStartRecommend.bind(this);\r\n    this.createCustomizedUnion = this.createCustomizedUnion.bind(this); // updated 9/13\r\n  }\r\n\r\n  createTableArray(firstIndex, secondIndex) {\r\n    const tableArray = this.props.propertyNeighbours[firstIndex].siblingArray[\r\n      secondIndex\r\n    ].tableArray;\r\n    let tableElement = [];\r\n    for (let thirdIndex = 0; thirdIndex < tableArray.length; ++thirdIndex) {\r\n      // console.log(\"Hello\");\r\n      // console.log(tableArray[thirdIndex].title);\r\n      let tableTitleText = \"Table \" + thirdIndex + \": \";\r\n      for (let i = 0; i < tableArray[thirdIndex].title.length; ++i) {\r\n        tableTitleText = tableTitleText + tableArray[thirdIndex].title[i] + \"|\";\r\n      }\r\n      tableElement.push(\r\n        <div>\r\n          <Button\r\n            onClick={(e) =>\r\n              this.props.toggleOtherTable(\r\n                e,\r\n                firstIndex,\r\n                secondIndex,\r\n                thirdIndex\r\n              )\r\n            }\r\n          >\r\n            {tableTitleText}\r\n            <FaTable />\r\n          </Button>\r\n          <Collapse isOpen={tableArray[thirdIndex].isOpen}>\r\n            <Card>\r\n              <CardBody>\r\n                <div>\r\n                  <ul className=\"list-group list-css\">\r\n                    <li\r\n                      className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                      onClick={(e) =>\r\n                        this.props.unionTable(\r\n                          firstIndex,\r\n                          secondIndex,\r\n                          tableArray[thirdIndex].data,\r\n                          tableArray[thirdIndex].colMapping\r\n                        )\r\n                      }\r\n                    >\r\n                      Union table\r\n                    </li>\r\n                  </ul>\r\n                  <div\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: tableArray[thirdIndex].data.outerHTML,\r\n                    }}\r\n                  ></div>\r\n                </div>\r\n              </CardBody>\r\n            </Card>\r\n          </Collapse>\r\n        </div>\r\n      );\r\n    }\r\n    return tableElement;\r\n  }\r\n\r\n  createSiblingArray(firstIndex) {\r\n    const siblingArray = this.props.propertyNeighbours[firstIndex].siblingArray;\r\n    let siblingElement = [];\r\n    let zeroDividerSet = false;\r\n    for (\r\n      let secondIndex = 0;\r\n      secondIndex < siblingArray.length;\r\n      ++secondIndex\r\n    ) {\r\n      let tooltipText =\r\n        \"Examine tables on page \" + siblingArray[secondIndex].name;\r\n      // let divider = null;\r\n      let listClassSib = \"list-group-item\";\r\n      if (siblingArray[secondIndex].isOpen) {\r\n        listClassSib = \"list-group-item list-with-background\";\r\n      }\r\n      if (\r\n        zeroDividerSet === false &&\r\n        siblingArray[secondIndex].tableArray.length === 0\r\n      ) {\r\n        zeroDividerSet = true;\r\n        // divider = (\r\n        //   <li>\r\n        //     <h5>\r\n        //       Below are sibling pages on which no similar tables are found:\r\n        //     </h5>\r\n        //     <hr />\r\n        //   </li>\r\n        // );\r\n        siblingElement.push(\r\n          <li className=\"list-group-item\">\r\n            <hr />\r\n            <h5>\r\n              Below are sibling pages on which no similar tables are found:\r\n            </h5>\r\n            <hr />\r\n          </li>\r\n        );\r\n      }\r\n\r\n      siblingElement.push(\r\n        <li\r\n          className={listClassSib}\r\n          title={tooltipText}\r\n          // onClick={(e) =>\r\n          //   this.props.toggleSibling(e, firstIndex, secondIndex)\r\n          // }\r\n        >\r\n          <span\r\n            onClick={(e) =>\r\n              this.props.toggleSibling(e, firstIndex, secondIndex)\r\n            }\r\n          >\r\n            {niceRender(siblingArray[secondIndex].name) + \" \"}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={siblingArray[secondIndex].isOpen}>\r\n            <div>\r\n              <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button\"\r\n                  onClick={(e) => this.props.unionPage(firstIndex, secondIndex)}\r\n                >\r\n                  Union from page\r\n                </li>\r\n              </ul>\r\n              {this.createTableArray(firstIndex, secondIndex)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {\" \"}\r\n        {siblingElement}{\" \"}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  createPropertyArray() {\r\n    // console.log(\"Getting here meaning we are recreating the property array\");\r\n    const propertyNeighbours = this.props.propertyNeighbours;\r\n    // console.log(propertyNeighbours);\r\n    let propertyElement = [];\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      // We create the text for property buttons: table index plus column names\r\n      const predicate = propertyNeighbours[i].predicate;\r\n      const object = propertyNeighbours[i].object;\r\n      let propertyText =\r\n        predicate !== \"subject\"\r\n          ? predicate + \": \" + object + \" \"\r\n          : object + \" \";\r\n      let tooltipText = \"Show other pages with \" + predicate + \": \" + object;\r\n\r\n      let listClass = \"list-group-item\";\r\n      if (this.props.propertyNeighbours[i].isOpen) {\r\n        listClass = \"list-group-item list-with-background\";\r\n      }\r\n\r\n      propertyElement.push(\r\n        <li class={listClass} title={tooltipText}>\r\n          <span onClick={(e) => this.props.togglePropertyNeighbours(e, i)}>\r\n            {niceRender(propertyText)}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={this.props.propertyNeighbours[i].isOpen}>\r\n            <div>\r\n              <hr />\r\n              {/* <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                  onClick={(e) => this.props.unionProperty(i)}\r\n                >\r\n                  Union from all pages\r\n                </li>\r\n              </ul> */}\r\n              {this.createSiblingArray(i)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {propertyElement}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  // This function creates the HTML element for recommend array\r\n\r\n  createRecommendArray(colIndex, recommendArray) {\r\n    // console.log(recommendArray);\r\n    let recommendEle = [];\r\n    // stringRecommend and semanticRecommend are both HTML elements that should be constructed from recommend array\r\n    for (let i = 0; i < recommendArray.length; ++i) {\r\n      let neighbourArray = [\r\n        {\r\n          value: recommendArray[i].value,\r\n          type: recommendArray[i].type,\r\n        },\r\n      ];\r\n      let recommendText = recommendArray[i].label;\r\n      recommendEle.push(\r\n        <div>\r\n          <p>\r\n            <Button\r\n              onClick={(e) =>\r\n                this.props.populateRecommendation(e, colIndex, neighbourArray)\r\n              }\r\n            >\r\n              {recommendText}\r\n            </Button>\r\n          </p>\r\n        </div>\r\n      );\r\n    }\r\n    // Now, we also want to tell user they are adding attributes with respect to which column.\r\n    let recommendationText = \"\";\r\n    if (this.props.keyColIndex !== -1) {\r\n      let neighbourArray = this.props.tableHeader[this.props.keyColIndex];\r\n      recommendationText =\r\n        this.props.keyColIndex !== 0\r\n          ? createNeighbourText(neighbourArray)\r\n          : \"First Column\";\r\n    }\r\n    let returnEle = (\r\n      <div className=\"container\">\r\n        <p>Attribute recommendations:</p>\r\n        <p>\r\n          Current Search Column: <b>{recommendationText}</b>\r\n        </p>\r\n        {recommendEle}\r\n      </div>\r\n    );\r\n    return returnEle;\r\n  }\r\n\r\n  // This function creates the HTML element for populateSameNeighbour\r\n  createSameNeighbour(actionInfo) {\r\n    let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\r\n    let returnEle = (\r\n      <div className=\"container\">\r\n        <p>Some cells in this column contain multiple values.</p>\r\n        <p>Expand all other values that are also</p>\r\n        <p>\r\n          <b>{neighbourArrayText}</b> ?\r\n        </p>\r\n        <div className=\"row\">\r\n          <Button\r\n            className=\"col-md-4\"\r\n            onClick={(e) =>\r\n              this.props.sameNeighbourOneRow(\r\n                e,\r\n                actionInfo.colIndex,\r\n                actionInfo.neighbourArray\r\n              )\r\n            }\r\n          >\r\n            In One Row\r\n          </Button>\r\n          <Button\r\n            className=\"offset-md-1 col-md-4\"\r\n            onClick={(e) =>\r\n              this.props.sameNeighbourDiffRow(\r\n                e,\r\n                actionInfo.colIndex,\r\n                actionInfo.neighbourArray\r\n              )\r\n            }\r\n          >\r\n            In Separate Rows\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n    return returnEle;\r\n  }\r\n\r\n  // This function creates the starting recommendations, when actionInfo.task is showStartRecommend\r\n  createStartRecommend() {\r\n    // console.log(this.props.curActionInfo);\r\n    let recommendEle = [];\r\n    let recommendArray = this.props.curActionInfo.recommendArray;\r\n    for (let i = 0; i < recommendArray.length; ++i) {\r\n      let neighbourArray = [\r\n        {\r\n          value: recommendArray[i].value,\r\n          type: recommendArray[i].type,\r\n        },\r\n      ];\r\n      let recommendText = recommendArray[i].label;\r\n      recommendEle.push(\r\n        <div>\r\n          <p>\r\n            <Button\r\n              onClick={(e) =>\r\n                this.props.populateStartRecommend(\r\n                  e,\r\n                  this.props.curActionInfo.colIndex,\r\n                  neighbourArray\r\n                )\r\n              }\r\n            >\r\n              {recommendText}\r\n            </Button>\r\n          </p>\r\n        </div>\r\n      );\r\n    }\r\n    // Now, we also want to tell user they are adding attributes with respect to which column.\r\n    let recommendationText = \"\";\r\n    if (this.props.keyColIndex !== -1) {\r\n      let neighbourArray = this.props.tableHeader[this.props.keyColIndex];\r\n      recommendationText =\r\n        this.props.keyColIndex !== 0\r\n          ? createNeighbourText(neighbourArray)\r\n          : \"First Column\";\r\n    }\r\n    let returnEle = (\r\n      <div className=\"container\">\r\n        <p>Attribute recommendations:</p>\r\n        <p>\r\n          Current Search Column: <b>{recommendationText}</b>\r\n        </p>\r\n        {recommendEle}\r\n      </div>\r\n    );\r\n    return returnEle;\r\n  }\r\n\r\n  // The following function creates the HTML element for table union, in the startSubject case.\r\n  createCustomizedUnion() {\r\n\r\n    // First element to create: the title (text) element\r\n    let textEle;\r\n    if (this.props.unionURL === \"\") {\r\n      textEle = \r\n        <div>\r\n          <p>\r\n            For customized table, please paste URL below to look for tables.\r\n          </p>\r\n        </div>\r\n    }\r\n    else {\r\n      textEle = \r\n        <div>\r\n          <p>\r\n            The following tables are from page:{\" \"}\r\n            <b>\r\n              {decodeURIComponent(this.props.unionURL.slice(30))}\r\n            </b>\r\n          </p>\r\n        </div>\r\n    }\r\n\r\n    // Second element to create: input element to support the URL pasting.\r\n    let formEle = \r\n      <div>\r\n        <div className=\"row text-center\">\r\n          <div className=\"col-md-9 offset-md-1\">\r\n            <input\r\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\r\n              onPaste={(e) => this.props.handleUnionPaste(e)}\r\n              className=\" form-control\"\r\n            ></input>\r\n          </div>\r\n        </div>\r\n        <br />\r\n      </div>\r\n    \r\n    // Third element to create: TableCreation component\r\n    let tableListEle = \r\n      <div>\r\n        <TableSelection\r\n          originTableArray={this.props.unionTableArray}\r\n          tableOpenList={this.props.unionOpenList}\r\n          toggleTable={this.props.toggleUnionTable}\r\n          listType={\"union\"}\r\n          // buttonFunction={this.props.showUnionAlign}\r\n          buttonFunction={this.props.unionCustomized} \r\n        />\r\n      </div>\r\n\r\n    // Finally, we create the return element.\r\n    let returnEle = \r\n      <div>\r\n        {textEle}\r\n        {formEle}\r\n        {tableListEle}\r\n      </div>\r\n    return returnEle;\r\n  }\r\n\r\n  render() {\r\n    let actionEle; // contains either wrangling actions or unionable tables for the action panel\r\n    let wrapperEle; // wrapper element for actionEle. This is what we will render in the HTML.\r\n    let titleEle; // contains what we will display as the title for the action panel\r\n\r\n    // We first decide the content for the titleElement\r\n    if (\r\n      this.props.usecaseSelected === \"\"\r\n      // ||\r\n      // (this.props.usecaseSelected === \"startTable\" &&\r\n      //   this.props.selectedTableIndex === -1)\r\n    ) {\r\n      titleEle = (\r\n        <div className=\"row\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              Insert Data\r\n              <span> </span>\r\n              {/* <span className=\"logo-right-color xsmall\">\r\n                Select your starting action\r\n              </span> */}\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    } else {\r\n      titleEle = (\r\n        <div className=\"row action-header\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              Insert Data\r\n              <span> </span>\r\n              {/* <span className=\"logo-right-color xsmall\">\r\n                Select your next action\r\n              </span> */}\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // We now decide the content for the actionElement\r\n    // Case 1: URL has been pasted, but task has not been selected. User needs to select task.\r\n    if (this.props.usecaseSelected === \"\") {\r\n      wrapperEle = (\r\n        <TaskMenu\r\n          handleStartSubject={this.props.handleStartSubject}\r\n          urlPasted={this.props.urlPasted}\r\n          showTableSelection={this.props.showTableSelection}\r\n          toggleTableSelection={this.props.toggleTableSelection}\r\n          originTableArray={this.props.originTableArray}\r\n          tableOpenList={this.props.tableOpenList}\r\n          toggleTable={this.props.toggleTable}\r\n          selectedTableIndex={this.props.selectedTableIndex}\r\n          handleStartTable={this.props.handleStartTable}\r\n        />\r\n      );\r\n    }\r\n    // Case 2: Task has been selected. curActionInfo is not null, meaning we have to display some task in ActionPanel\r\n    else if (this.props.curActionInfo !== null) {\r\n      const actionInfo = this.props.curActionInfo;\r\n      // Case 2.1: Users have selected \"Create Table from subject\".\r\n      // We ask users to select a column header for the first column.\r\n      if (actionInfo.task === \"afterStartSubject\") {\r\n        actionEle = (\r\n          <FirstColSelection\r\n            firstColSelection={this.props.firstColSelection}\r\n            firstColChecked={this.props.firstColChecked}\r\n            firstColText={this.props.firstColText}\r\n            firstColFilled={this.props.firstColFilled}\r\n            toggleFirstNeighbour={this.props.toggleFirstNeighbour}\r\n            firstColTextChange={this.props.firstColTextChange}\r\n            tableHeader={this.props.tableHeader}\r\n            keyCheckedIndex={this.props.keyCheckedIndex}\r\n            populateKeyColumn={this.props.populateKeyColumn}\r\n            confirmAddFirstCol={this.props.confirmAddFirstCol}\r\n          />\r\n        );\r\n      }\r\n      // Case 2.2: Users have clicked on the down arrow for non-first columns.\r\n      // We ask users to select a column header for this column.\r\n      else if (actionInfo.task === \"showOtherColSelection\") {\r\n        actionEle = (\r\n          <OtherColSelection\r\n            otherColSelection={this.props.otherColSelection}\r\n            otherColChecked={this.props.otherColChecked}\r\n            otherColText={this.props.otherColText}\r\n            otherCheckedIndex={this.props.otherCheckedIndex}\r\n            toggleOtherNeighbour={this.props.toggleOtherNeighbour}\r\n            otherColTextChange={this.props.otherColTextChange}\r\n            populateOtherColumn={this.props.populateOtherColumn}\r\n            colIndex={actionInfo.colIndex}\r\n          />\r\n        );\r\n      }\r\n      // Case 2.2: Users have click on the PLUS icon on first column's header.\r\n      // We ask users if they want to add more entities to the first column.\r\n      else if (actionInfo.task === \"plusClicked\") {\r\n        // We want to do an error check here: if the first column is not the current search column, we disable adding more entities to it.\r\n        if (this.props.keyColIndex !== 0) {\r\n          actionEle = (\r\n            <div>\r\n              <p>\r\n                <b>\r\n                  Please set the first column as the search column before adding\r\n                  more entities to it.\r\n                </b>\r\n              </p>\r\n            </div>\r\n          );\r\n        } else {\r\n          actionEle = (\r\n            <div>\r\n              <p>Add more entities to the first column?</p>\r\n              <Button onClick={() => this.props.addToFirstCol()}>OK</Button>\r\n            </div>\r\n          );\r\n        }\r\n      }\r\n      // In this case, we tell users they can keep wrangling by selecting column header for empty columns\r\n      else if (actionInfo.task === \"afterPopulateColumn\") {\r\n        actionEle = (\r\n          <div>\r\n            <p>\r\n              <b>Fill an empty column</b> by clicking on its <b>edit icon</b>\r\n            </p>\r\n            <p>OR</p>\r\n            <p>\r\n              <b>Add a new column</b> by clicking on a column's <b>plus icon</b>\r\n            </p>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we give user a button to allow the population of first column\r\n      else if (actionInfo.task === \"populateKeyColumn\") {\r\n        let neighbourArrayText = \"\";\r\n        for (let i = 0; i < actionInfo.neighbourArray.length; ++i) {\r\n          if (i > 0) {\r\n            neighbourArrayText += \" & \";\r\n          }\r\n          neighbourArrayText += actionInfo.neighbourArray[i].label;\r\n        }\r\n        if (neighbourArrayText !== \"\") {\r\n          actionEle = (\r\n            <div>\r\n              <p>Fill this column with:</p>\r\n              <p>\r\n                <b>{neighbourArrayText}</b> ?\r\n              </p>\r\n              <Button\r\n                onClick={(e) =>\r\n                  this.props.populateKeyColumn(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    actionInfo.neighbourArray\r\n                  )\r\n                }\r\n              >\r\n                OK\r\n              </Button>\r\n            </div>\r\n          );\r\n        } else {\r\n          actionEle = (\r\n            <div>\r\n              <p className=\"suggestion-text\">\r\n                Fill the <b>first column header</b> by choosing from its{\" \"}\r\n                <b>down arrow</b>\r\n              </p>\r\n            </div>\r\n          );\r\n        }\r\n      }\r\n      // In this case we give user a button to allow the population of a new column\r\n      else if (actionInfo.task === \"populateOtherColumn\") {\r\n        let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\r\n        actionEle = (\r\n          <div>\r\n            <p>Fill this column with:</p>\r\n            <p>\r\n              <b>{neighbourArrayText}</b> ?\r\n            </p>\r\n            <Button\r\n              onClick={(e) =>\r\n                this.props.populateOtherColumn(\r\n                  e,\r\n                  actionInfo.colIndex,\r\n                  actionInfo.neighbourArray\r\n                )\r\n              }\r\n            >\r\n              OK\r\n            </Button>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we give user a button to allow the population of same neighbour\r\n      else if (actionInfo.task === \"populateSameNeighbour\") {\r\n        actionEle = this.createSameNeighbour(actionInfo);\r\n      }\r\n      // In this case we give users an array of recommended neighbours to add to the table\r\n      else if (actionInfo.task === \"populateRecommendation\") {\r\n        let recommendArray = this.createRecommendArray(\r\n          actionInfo.colIndex,\r\n          actionInfo.recommendArray\r\n        );\r\n        actionEle = <div>{recommendArray}</div>;\r\n      }\r\n      // In this case we have to include both populateSameNeighbour and populateRecommendation\r\n      else if (actionInfo.task === \"sameNeighbourAndRecommendation\") {\r\n        let sameNeighbourEle = this.createSameNeighbour(actionInfo);\r\n        let recommendEle = this.createRecommendArray(\r\n          actionInfo.colIndex,\r\n          actionInfo.recommendArray\r\n        );\r\n        actionEle = (\r\n          <div>\r\n            <Card className=\"action-panel-card\">{recommendEle}</Card>\r\n            <br />\r\n            <Card className=\"action-panel-card\">{sameNeighbourEle}</Card>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we give user four column filter methods: sort asc, sort des, filter, and dedup\r\n      else if (actionInfo.task === \"showFilterMethods\") {\r\n        let textEle = null;\r\n        if (actionInfo.colIndex === 0) {\r\n          textEle = (\r\n            <p>\r\n              <b>How would you like to process the first column?</b>\r\n            </p>\r\n          );\r\n        } else {\r\n          textEle = (\r\n            <p>\r\n              <b>\r\n                How would you like to process column{\" \"}\r\n                {createNeighbourText(\r\n                  this.props.tableHeader[actionInfo.colIndex]\r\n                )}{\" \"}\r\n                ?\r\n              </b>\r\n            </p>\r\n          );\r\n        }\r\n        // console.log(textEle);\r\n        actionEle = (\r\n          <div>\r\n            <div>{textEle}</div>\r\n            <div>\r\n              <Button\r\n                onClick={(e) =>\r\n                  this.props.contextSortColumn(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    \"ascending\"\r\n                  )\r\n                }\r\n              >\r\n                Sort ascending\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) =>\r\n                  this.props.contextSortColumn(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    \"descending\"\r\n                  )\r\n                }\r\n              >\r\n                Sort descending\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) => this.props.openFilter(e, actionInfo.colIndex)}\r\n              >\r\n                Filter this column\r\n              </Button>\r\n            </div>\r\n            <br />\r\n            <div>\r\n              <Button\r\n                onClick={(e) =>\r\n                  this.props.contextDedupColumn(e, actionInfo.colIndex)\r\n                }\r\n              >\r\n                Dedup this column\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"contextCellOrigin\") {\r\n        actionEle = (\r\n          <div>\r\n            <p>Origin of selected cell is:</p>\r\n            <div>{actionInfo.origin}</div>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"originPreviewPage\") {\r\n        actionEle = (\r\n          // <div>\r\n          //   <div>\r\n          //     <p>Preview of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\r\n          //     <div>\r\n          //       {renderPreview(actionInfo.preview)}\r\n          //     </div>\r\n          //   </div>\r\n          //   <hr className=\"preview-origin-divider\"/>\r\n          //   <div>\r\n          //     <p>Origin of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\r\n          //     <div>{actionInfo.origin}</div>\r\n          //   </div>\r\n          // </div>\r\n          <PreviewOrigin\r\n            previewInfoArray={this.props.previewInfoArray}\r\n            previewInfoExpanded={this.props.previewInfoExpanded}\r\n            selectedCell={this.props.selectedCell}\r\n            togglePreviewElement={this.props.togglePreviewElement}\r\n          />\r\n        );\r\n      }\r\n      // In this case we display the starting recommendations\r\n      else if (actionInfo.task === \"showStartRecommend\") {\r\n        let recommendEle = this.createStartRecommend();\r\n        actionEle = <div>{recommendEle}</div>;\r\n      }\r\n      // In this case we have to include both populateSameNeighbour and populateStartRecommend\r\n      else if (actionInfo.task === \"sameNeighbourAndStartRecommend\") {\r\n        let sameNeighbourEle = this.createSameNeighbour(actionInfo);\r\n        let recommendEle = this.createStartRecommend();\r\n        actionEle = (\r\n          <div>\r\n            <Card className=\"action-panel-card\">{recommendEle}</Card>\r\n            <br />\r\n            <Card className=\"action-panel-card\">{sameNeighbourEle}</Card>\r\n          </div>\r\n        );\r\n      }\r\n    }\r\n    // This is an empty else clause\r\n    else {\r\n    }\r\n\r\n    // Now we have to determine whether we are rendering one tab or two tabs.\r\n    // One tab for startSubject. Two tabs for startTable.\r\n    // console.log(this.props.usecaseSelected);\r\n\r\n    // Modified after JOIN has been added in:\r\n    // In the startSubject case, we will have two tab: wrangling actions, and table actions.\r\n    // Wrangling Actions: same as before.\r\n    // Table Actions: Union will be empty, JOIN will use the pasted URL from the beginning.\r\n\r\n    if (this.props.usecaseSelected === \"startSubject\") {\r\n      let curIndex = this.props.tabIndex;\r\n\r\n      // updated on 9/13: let's check with this.props.unionURL to decide what we want to show in the union table section\r\n\r\n\r\n\r\n      wrapperEle = (\r\n        <div className=\"height-inherit\">\r\n          <Tabs\r\n            selectedIndex={curIndex}\r\n            onSelect={(index) => this.props.handleTabSwitch(index)}\r\n          >\r\n            <TabList>\r\n              <Tab>From DBpedia</Tab>\r\n              <Tab>From Wiki Tables</Tab>\r\n            </TabList>\r\n            <div className=\"action-scrollable\">\r\n              <TabPanel>{actionEle}</TabPanel>\r\n              <TabPanel>\r\n                <div>\r\n                  <ul class=\"list-group list-css list-group-flush\">\r\n                    <hr className=\"m-0\"></hr>\r\n                    <li className=\"list-group-item\">\r\n                      <span\r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"union\")}\r\n                      >\r\n                        Union Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showUnionTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                            {this.createCustomizedUnion()}\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <li className=\"list-group-item\">\r\n                      <span\r\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\r\n                      >\r\n                        Join Tables from Wikipedia\r\n                      </span>\r\n\r\n                      <Collapse isOpen={this.props.showJoinTables}>\r\n                        <CardBody>\r\n                          <Card>\r\n                            <p>\r\n                              The following tables are from page:{\" \"}\r\n                              <b>\r\n                                {decodeURIComponent(\r\n                                  this.props.urlPasted.slice(30)\r\n                                )}\r\n                              </b>\r\n                            </p>\r\n                            <TableSelection\r\n                              originTableArray={this.props.originTableArray}\r\n                              tableOpenList={this.props.tableOpenList}\r\n                              toggleTable={this.props.toggleTable}\r\n                              buttonFunction={this.props.handleJoinTable}\r\n                              listType={\"join\"}\r\n                            />\r\n                          </Card>\r\n                        </CardBody>\r\n                      </Collapse>\r\n                    </li>\r\n                    <hr className=\"m-0\"></hr>\r\n                  </ul>\r\n                </div>\r\n              </TabPanel>\r\n            </div>\r\n          </Tabs>\r\n        </div>\r\n      );\r\n    } \r\n    else if (this.props.usecaseSelected === \"startTable\") {\r\n      // If we have not selected a table, we show both tabs, as we are fully ready.\r\n      if (this.props.selectedTableIndex !== -1) {\r\n        let curIndex = this.props.tabIndex;\r\n        wrapperEle = (\r\n          <div className=\"height-inherit\">\r\n            <Tabs\r\n              selectedIndex={curIndex}\r\n              onSelect={(index) => this.props.handleTabSwitch(index)}\r\n              className=\"height-inherit\"\r\n            >\r\n              <TabList>\r\n                <Tab>From DBpedia</Tab>\r\n                <Tab>From Wiki Tables</Tab>\r\n              </TabList>\r\n              <div className=\"action-scrollable\">\r\n                <TabPanel>{actionEle}</TabPanel>\r\n                <TabPanel>\r\n                  <div>\r\n                    <ul class=\"list-group list-css list-group-flush\">\r\n                      <hr className=\"m-0\"></hr>\r\n                      <li className=\"list-group-item\">\r\n                        <span\r\n                          onClick={(e) =>\r\n                            this.props.toggleUnionJoin(e, \"union\")\r\n                          }\r\n                        >\r\n                          Union Tables from Wikipedia\r\n                        </span>\r\n\r\n                        <Collapse isOpen={this.props.showUnionTables}>\r\n                          <CardBody>\r\n                            <Card>\r\n                              Expand relations below to look at other pages with\r\n                              similar tables:\r\n                              <br />\r\n                              {this.createPropertyArray()}\r\n                            </Card>\r\n                          </CardBody>\r\n                        </Collapse>\r\n                      </li>\r\n                      <li className=\"list-group-item\">\r\n                        <span\r\n                          onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\r\n                        >\r\n                          Join Tables from Wikipedia\r\n                        </span>\r\n\r\n                        <Collapse isOpen={this.props.showJoinTables}>\r\n                          <CardBody>\r\n                            <Card>\r\n                              <p>\r\n                                The following tables are from page:{\" \"}\r\n                                <b>\r\n                                  {decodeURIComponent(\r\n                                    this.props.urlPasted.slice(30)\r\n                                  )}\r\n                                </b>\r\n                              </p>\r\n                              <TableSelection\r\n                                originTableArray={this.props.originTableArray}\r\n                                tableOpenList={this.props.tableOpenList}\r\n                                toggleTable={this.props.toggleTable}\r\n                                buttonFunction={this.props.handleJoinTable}\r\n                                listType={\"join\"}\r\n                              />\r\n                            </Card>\r\n                          </CardBody>\r\n                        </Collapse>\r\n                      </li>\r\n                      <hr className=\"m-0\"></hr>\r\n                    </ul>\r\n                  </div>\r\n                </TabPanel>\r\n              </div>\r\n            </Tabs>\r\n          </div>\r\n        );\r\n      }\r\n      // Else, we have not selected a table yet. In this case, wrapperEle should be equal to actionEle\r\n      else {\r\n        wrapperEle = actionEle;\r\n      }\r\n    }\r\n    return (\r\n      <div className=\"height-inherit\">\r\n        <div>{titleEle}</div>\r\n        <div className=\"height-inherit\">{wrapperEle}</div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ActionPanel;\r\n\r\n// // The following helper function creates HTML elements from previewInfoArray,\r\n// // an array of key-val pairs containing the info for a cell's preview.\r\n\r\n// // It also makes use of niceRender, so that preview looks clean.\r\n\r\n// function renderPreview(previewInfoArray) {\r\n//   // console.log(previewInfoArray);\r\n//   let infoEle = [];\r\n//   for (let i = 0; i < previewInfoArray.length; ++i) {\r\n//     let keyLiteral = previewInfoArray[i].key;\r\n//     // We get the first element from value Array\r\n//     let valLiteral = niceRender(previewInfoArray[i].value[0]);\r\n//     // Since we have already included thte first element, we start the index from 1\r\n//     for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\r\n//       valLiteral = valLiteral + \"; \"+niceRender(previewInfoArray[i].value[j]);\r\n//     }\r\n//     infoEle.push(\r\n//       <p><b>{keyLiteral}</b>{\":\"}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{valLiteral}</p>\r\n//     )\r\n//   }\r\n//   return infoEle;\r\n// }\r\n\r\n// // This function renders this.props.tableData[i][j].data in a nicer way.\r\n// // It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\n// function niceRender(str) {\r\n//   return str.replace(/_\\(.*?\\)/g, \"\")\r\n//             .replace(/_/g, \" \");\r\n// }\r\n\r\n// This function creates neighbourArrayText from neighbourArray\r\n\r\nfunction createNeighbourText(neighbourArray) {\r\n  let neighbourArrayText = \"\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    if (i > 0) {\r\n      neighbourArrayText += \" OR \";\r\n    }\r\n    let curNeighbourText =\r\n      neighbourArray[i].type === \"object\"\r\n        ? \"is \" + neighbourArray[i].value + \" of\"\r\n        : neighbourArray[i].value;\r\n    neighbourArrayText += curNeighbourText;\r\n  }\r\n  return neighbourArrayText;\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way.\r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\").replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nclass PagePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    let pageEle = null;\r\n    let wikiPageClass = \"small-padding wiki-page-hidden\";\r\n    let buttonClass = \"btn btn-sm btn-info toggle-button\";\r\n    if (this.props.iframeURL !== \"\") {\r\n      let buttonhideShow = (\r\n        <button\r\n          className={buttonClass}\r\n          onClick={() => this.props.toggleWikiPage()}\r\n        >\r\n          <i class=\"fa fa-chevron-up\" aria-hidden=\"true\"></i>\r\n          Show\r\n        </button>\r\n      );\r\n      if (!this.props.pageHidden) {\r\n        wikiPageClass = \"small-padding wiki-page\";\r\n        buttonhideShow = (\r\n          <div>\r\n            <hr className=\"m-1\"></hr>\r\n            <button\r\n              className={buttonClass}\r\n              onClick={() => this.props.toggleWikiPage()}\r\n            >\r\n              <i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i>\r\n              Hide\r\n            </button>\r\n          </div>\r\n        );\r\n      }\r\n      pageEle = (\r\n        <div className=\"page-panel text-right\">\r\n          {buttonhideShow}\r\n          <div className={wikiPageClass}>\r\n            <iframe\r\n              id=\"iframe\"\r\n              title=\"URLPage\"\r\n              src={this.props.iframeURL}\r\n              className=\"iframe-cls\"\r\n            ></iframe>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n    return <div>{pageEle}</div>;\r\n  }\r\n}\r\n\r\nexport default PagePanel;\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\nimport { combinations } from \"mathjs\";\r\nimport Header from \"../components/Header\";\r\nimport Footer from \"../components/Footer\";\r\nimport SettingModal from \"../components/SettingModal\";\r\nimport FilterModal from \"../components/FilterModal\";\r\nimport JoinModal from \"../components/JoinModal\";\r\nimport UnionModal from \"../components/UnionModal\";\r\nimport LandingPage from \"../components/LandingPage\";\r\nimport TablePanel from \"../components/TablePanel\";\r\nimport ActionPanel from \"../components/ActionPanel\";\r\nimport PagePanel from \"../components/PagePanel\";\r\nimport _ from \"lodash\";\r\n\r\nconst maxNeighbourCount = 10;\r\nconst maxFetchCount = 30;\r\nconst initialColNum = 4;   // initial number of columns\r\nconst initialRowNum = 20;  // initial number of rows\r\nconst numForTree = 3;      // how many entries(rows) we want to use to construct the semantic tree\r\n\r\nclass MainBody extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    let tableData = [];\r\n    let tableHeader = [];\r\n    let optionsMap = [];\r\n    let semanticTree = [];\r\n    let typeRecord = [];\r\n    // The following double loop initializes tableData\r\n    for (let i = 0; i < initialRowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < initialColNum; ++j) {\r\n        // Initially, cell has no data or origin\r\n        // data field is a string\r\n        // origin field is an array of strings\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    // The following loop initializes semanticTree\r\n    for (let j = 0; j < initialColNum; ++j) {\r\n      semanticTree.push([]);\r\n      typeRecord.push([]);\r\n    }\r\n    for (let j = 0; j < initialColNum; ++j) {\r\n      let emptyOptions = [];\r\n      optionsMap.push(emptyOptions);\r\n      tableHeader.push([]);\r\n    }\r\n    this.state = {\r\n      // states below are general states used throughout the app\r\n      urlPasted: \"\",  \r\n      tablePasted: \"\",\r\n      usecaseSelected: \"\",\r\n      pageHidden: false,\r\n      iframeURL: \"\",\r\n      curActionInfo: null, // object storing the current action that should be displayed in ActionPanel. Initially null.\r\n      lastAction: \"\",      // string storing the last action that has modified the result table in the table panel\r\n      prevState: \"\",       // objects storing the information needed to undo the last step. Information stored depends on lastAction\r\n      showSetting: false,    // boolean storing whether setting modal is shown or not. Default to false.\r\n      showTableSelection: false,    // boolean storing whether the list of tables from page is shown. Default to false.\r\n      tabIndex: 1,         // integer storing the index of the tab currently displaying. Default to 1.\r\n      showUnionTables: false,  // boolean storing whether all the unionable pages and tables is shown. Default to false.\r\n      showJoinTables: false,   // boolean storing whether the page storing joinable tables is shown. Default to false.\r\n\r\n      // states below are useful for startSubject\r\n      keyColIndex: 0,   // number storing the index of the search column. initially the key column is the first column\r\n      // 1D array of objects with four properties storing the table headers. This array is used to create the column headers in table panel\r\n      // 1) label:  string storing the label of an option (ex: spouse)\r\n      // 2) value:  string storing the value of an option (ex: spouse)\r\n      // 3) type:   string that's either \"subject\" or \"object\". Storing whether the current option is ?s or ?o with respect to key column. Can be empty.\r\n      // 4) range:  string storing the rdfs:range of the current option.\r\n      tableHeader: tableHeader,\r\n      tableData: tableData, // 2D array of objects storing the table data (not including the table headers).\r\n      optionsMap: optionsMap, // 2D array storing the options map\r\n      keyColNeighbours: [], // 1D array storing the neighbours of the key column\r\n      // An object with two attributes: subject and object\r\n      // Subject and Object are both 1D arrays \r\n      // - Length tableData.length\r\n      // - Each element is an object with multiple attributes. Ex: {birthdate:[1998-01-01], almaMater:[a, b, c]}\r\n      firstDegNeighbours: [],\r\n\r\n      // states below are useful for first column header selection\r\n      firstColSelection: [],   // 1D array of objects storing information about the starting subject's neighbours\r\n      firstColChecked: [],     // 1D array of booleans storing whether a neighbour of the starting subject is selected or not\r\n      firstColFilled: false,   // boolean indicating whether the first column has been filled. \r\n                               // Will be set to true and remain that way after calling populateKeyColumn, or handleStartTable\r\n      firstColText: \"\",        // string storing the type-ahead text that users have typed in for first column's selection. Initially empty.\r\n      keyCheckedIndex: -1,     // index storing the most recent index that has just been toggled for the first column. Initially -1.\r\n      firstColHeaderInfo: [],  // 2D array of objects storing information needed to create the first column's header. (since both AND and OR need to be considered)\r\n\r\n      // states below are useful for other column header selection\r\n      otherColSelection: [],    // 1D array of objects storing information about the search column's neighbours\r\n      otherColChecked: [],      // 1D array of booleans storing whether a neighbour of the search column is selected or not\r\n      otherCheckedIndex: -1,    // index storing the most recent index that has just been toggled for a non-first column. Initially -1.\r\n      otherColText: \"\",         // string storing the type-ahead text that users have typed in for other column's selection. Initially empty.\r\n\r\n      // states below are useful for startTable\r\n      originTableArray: [], // 1D array storing all tables found on pasted URL\r\n      tableOpenList: [], // 1D array storing whether each table in originTableArray has been toggled open or not\r\n      selectedTableIndex: -1, // index of table selected by user. If it's -1, take user to table selection. Else, show the table in Table Panel.\r\n      selectedClassAnnotation: [], // semantic class annotation for each column of selected table\r\n      // 2D arary of objects with three properties, which store the table data from explore table task. Similar to tableData above. \r\n      // Three properties: data, origin, rowSpan, colSpan.\r\n      tableDataExplore: [], \r\n      // array of objects with four properties storing the status/content for each property neighbour\r\n      // 1) predicate: string storing the predicate (ex. dbp:league)\r\n      // 2) object: string storing the object (ex. dbo:NBA)\r\n      // 3) isOpen: boolean storing whether the current property neighbour is toggled on or not\r\n      // 4) siblingArary: array of objects with two properties storing the staus/content for each sibling URL\r\n      //    4.1) isOpen:      boolean storing whether the current sibling is toggled on or not\r\n      //    4.2) tableArray:  array of objects storing the status/content for each \"same\" table on the sibling URL\r\n      //         4.2.1) isOepn:        boolean storing whether the current table is toggled on or not\r\n      //         4.2.2) unionScore:    number storing teh union score of the current table (how \"similar\" it is to the original table)\r\n      //         4.2.3) colMapping:    array of numbers storing the column mapping between the current table and the selected table\r\n      //         4.2.4) data:          HTML of a table\r\n      //         4.2.5) title:         array of strings storing the column headers of the current table\r\n      propertyNeighbours: [],\r\n      semanticEnabled: \"disabled\", // boolean value indicating whether semantic mapping is enabled or not. Default to true\r\n      unionCutOff: 0.5, // number representing the union percentage a table must have to be considered unionable (>=)\r\n\r\n      // states below are for column filter\r\n      showFilter: false,        // boolean storing whether we want to show column filter or not. Initially false.\r\n      checkAll: true,           // boolean that when toggled to true, all dataAndChecked will be set to true, \r\n                                // and when false, all dataAndChecked will be set to false.\r\n      curFilterIndex: -1,       // number storing the index of the column on which we apply the filter. Initially -1 (no filter.)\r\n      dataAndChecked: [],       // array of [data, checked] pairs storing which data are in the filter column, and whether we should keep them.\r\n      filterMin: null,          // number storing min value of filter. \r\n      filterMax: null,          // number storing max value of filter.\r\n    \r\n      // states below are for table join\r\n      showJoinModal: false,    // boolean storing whether the join option modal is show or not. Default to false.\r\n      joinTableIndex: -1,      // number storing the index of the table we want to join from originTableArray.\r\n      joinTableData: [],       // 2D array storing the data of the table we want to join from originTableArray. Initially empty.\r\n      originColOptions: [],    // 1D array storing the selection options for the original table.\r\n      joinColOptions: [],      // 1D array storing the selection options for the newly selected table.\r\n      originJoinIndex: -1,     // number storing the index of the column of the original table that we are joining.\r\n      joinJoinIndex: -1,       // number storing the index of the column of the newly selected table that we are joining.\r\n      joinPairRecord: [],    // 1D array (max len 3) storing the indices of recommended join column index and join scores\r\n\r\n      // states below are for column preview\r\n      previewColIndex: -1,     // number storing the index of the column that we want to show preview for. \r\n                               // When -1, we do not want to show any preview. This state needs to be passed to TablePanel\r\n                               // It should only be set to non -1 when we have toggled some selections on, but haven't confirmed on selections yet. \r\n      \r\n      // states below are useful for cell preview and origin\r\n      selectedCell: null,      // data in the format of tableData[i][j] (has both data and origin attribute). \r\n                               // (origin element can be determined from this)\r\n      previewInfoArray: [],    // array storing the information used to create the preview element. \r\n                               // It contains categories, subject, object first degree neighbours.\r\n      previewInfoExpanded: [], // array of booleans storing whether each element from previewInfoArray is expanded or not.\r\n                               // This can only be set to true for previewInfoArray elements that have value length longer than 1.\r\n\r\n      // states below are for customized table union\r\n      unionURL: \"\",            // user-pasted URL, so that they can union table with customized table. If \"\", nothing has ever been pasted yet.\r\n      unionTableArray: [],     // 1D array storing all tables found on union URL.\r\n      unionOpenList: [],       // 1D array of bools storing whether each table in unionTableArray has been toggled open or not.\r\n      showUnionModal: false,   // boolean storing whether the union modal should be shown or not.\r\n\r\n      // states below are for the semantic tree\r\n      semanticTree: semanticTree,   // array (length = num of columns) storing the semantic tree for each column in the table\r\n      typeRecord: typeRecord,       // array (length = num of columns) storing the rdf:type for (3 entities from) each column in the table\r\n                                    // Each element has two fields: data, type.\r\n    };\r\n\r\n    // functions below are useful during start up\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n    this.handleStartSubject = this.handleStartSubject.bind(this);\r\n    this.handleStartTable = this.handleStartTable.bind(this);\r\n\r\n    // functions below are useful for startSubject\r\n    this.cellChange = this.cellChange.bind(this);\r\n    this.selectColHeader = this.selectColHeader.bind(this);\r\n    this.getKeyOptions = this.getKeyOptions.bind(this);\r\n    this.getOtherOptions = this.getOtherOptions.bind(this);\r\n    this.getNeighbourPromise = this.getNeighbourPromise.bind(this);\r\n    this.populateKeyColumn = this.populateKeyColumn.bind(this);\r\n    this.getOtherColPromise = this.getOtherColPromise.bind(this);\r\n    // this.getOtherColPromiseTwo = this.getOtherColPromiseTwo.bind(this);\r\n    this.populateOtherColumn = this.populateOtherColumn.bind(this);\r\n    this.addAllNeighbour = this.addAllNeighbour.bind(this);\r\n    this.getTableStates = this.getTableStates.bind(this);\r\n    this.sameNeighbourDiffRow = this.sameNeighbourDiffRow.bind(this);\r\n    this.sameNeighbourOneRow = this.sameNeighbourOneRow.bind(this);\r\n\r\n    // functions below are for column processing\r\n    this.contextAddColumn = this.contextAddColumn.bind(this);\r\n    this.contextDeleteColumn = this.contextDeleteColumn.bind(this);\r\n    this.contextSetColumn = this.contextSetColumn.bind(this);\r\n    this.originPreviewPage = this.originPreviewPage.bind(this);\r\n    this.contextSortColumn = this.contextSortColumn.bind(this);\r\n    this.contextDedupColumn = this.contextDedupColumn.bind(this);\r\n    this.showFilterMethods = this.showFilterMethods.bind(this);\r\n\r\n    // functions below are useful for startTable\r\n    this.toggleTable = this.toggleTable.bind(this);\r\n    this.togglePropertyNeighbours = this.togglePropertyNeighbours.bind(this);\r\n    this.toggleSibling = this.toggleSibling.bind(this);\r\n    this.toggleOtherTable = this.toggleOtherTable.bind(this);\r\n    this.unionTable = this.unionTable.bind(this);\r\n    this.unionPage = this.unionPage.bind(this);\r\n    this.unionProperty = this.unionProperty.bind(this);\r\n    this.toggleSemantic = this.toggleSemantic.bind(this);\r\n    this.unionCutOffChange = this.unionCutOffChange.bind(this);\r\n\r\n    // functions below are generally usefull\r\n    this.copyTable = this.copyTable.bind(this);\r\n    this.toggleWikiPage = this.toggleWikiPage.bind(this);\r\n    this.undoPreviousStep = this.undoPreviousStep.bind(this);\r\n    this.handleTabSwitch = this.handleTabSwitch.bind(this);\r\n    this.openModal = this.openModal.bind(this);\r\n    this.closeModal = this.closeModal.bind(this);\r\n    this.toggleTableSelection = this.toggleTableSelection.bind(this);\r\n    this.toggleUnionJoin = this.toggleUnionJoin.bind(this);\r\n\r\n    // functions below are for column filter\r\n    this.openFilter = this.openFilter.bind(this);\r\n    this.cancelFilter = this.cancelFilter.bind(this);\r\n    this.toggleChecked = this.toggleChecked.bind(this);\r\n    this.toggleAll = this.toggleAll.bind(this);\r\n    this.applyFilter = this.applyFilter.bind(this);\r\n    this.handleRangeFilter = this.handleRangeFilter.bind(this);\r\n\r\n    // functions below are for join feature\r\n    this.handleJoinTable = this.handleJoinTable.bind(this);\r\n    this.cancelJoin = this.cancelJoin.bind(this);\r\n    this.selectJoinColumn = this.selectJoinColumn.bind(this);\r\n    this.runJoin = this.runJoin.bind(this);\r\n\r\n    // functions below are for first column selection\r\n    this.toggleFirstNeighbour = this.toggleFirstNeighbour.bind(this);\r\n    this.handlePlusClick = this.handlePlusClick.bind(this);\r\n    this.addToFirstCol = this.addToFirstCol.bind(this);\r\n    this.confirmAddFirstCol = this.confirmAddFirstCol.bind(this); \r\n    this.firstColTextChange = this.firstColTextChange.bind(this);\r\n\r\n    // functions below are for other column selection\r\n    this.toggleOtherNeighbour = this.toggleOtherNeighbour.bind(this);\r\n    this.otherColTextChange = this.otherColTextChange.bind(this);\r\n\r\n    // functions below are for cell preview and origin\r\n    this.togglePreviewElement = this.togglePreviewElement.bind(this);\r\n\r\n    // functions below are for recommendations\r\n    this.populateRecommendation = this.populateRecommendation.bind(this);\r\n    this.createStartRecommend = this.createStartRecommend.bind(this);\r\n    this.populateStartRecommend = this.populateStartRecommend.bind(this);\r\n\r\n    // functions below are for table union in startSubject case\r\n    this.handleUnionPaste = this.handleUnionPaste.bind(this);\r\n    this.toggleUnionTable = this.toggleUnionTable.bind(this);\r\n    this.showUnionAlign = this.showUnionAlign.bind(this);\r\n    this.cancelUnionAlign = this.cancelUnionAlign.bind(this);\r\n    this.hardcodeUnion = this.hardcodeUnion.bind(this);\r\n\r\n    // functions below are for file uploading/sharing\r\n    this.handleFileChange = this.handleFileChange.bind(this);\r\n\r\n    // functions below are for unioning customized tables\r\n    this.unionCustomized = this.unionCustomized.bind(this);\r\n  }\r\n\r\n  // As soon as the URL has been pasted, we want to fetch all tables from the pasted URL.\r\n  // We then update the originTableArray, which stores all the tables found on the pasted URL\r\n  // We also initialize tableOpenList to all false\r\n  handleURLPaste(urlPasted) {\r\n    document.body.classList.add('waiting');\r\n\r\n    // We first check if user has pasted a valid wikipedia page.\r\n\r\n    if (!urlPasted.includes(\"https://en.wikipedia.org/wiki/\")) {\r\n      document.body.classList.remove('waiting');\r\n      alert(\"Please paste a valid Wikipedia link.\");\r\n    }\r\n\r\n    // If yes, we fetch the tables from the pasted Wikipedia page\r\n    else {\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchText(urlPasted));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // We first parse the pasted URL and store the list of tables from the pasted URL\r\n        let htmlText = values[0];\r\n        let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\r\n        let wikiTableArray = doc.getElementsByClassName(\"wikitable\");\r\n        let originTableArray = [];\r\n        for (let i = 0; i < wikiTableArray.length; ++i) {\r\n          // console.log(wikiTableArray[i].rows);\r\n          if (wikiTableArray[i].tagName === \"TABLE\" && wikiTableArray[i].rows !== undefined) {\r\n            originTableArray.push(wikiTableArray[i]);\r\n          }\r\n        }\r\n        console.log(originTableArray);\r\n        let tableOpenList = [];\r\n        for (let i = 0; i < originTableArray.length; ++i) {\r\n          tableOpenList.push(false);\r\n        }\r\n\r\n        // Adding support for undo:\r\n        document.body.classList.remove('waiting');\r\n\r\n        let lastAction = \"handleURLPaste\";\r\n        let prevState = \r\n          {\r\n            \"urlPasted\":\"\",\r\n            \"iframeURL\":\"\",\r\n            \"originTableArray\":[],\r\n            \"tableOpenList\":[],\r\n          };\r\n\r\n        this.setState({\r\n          originTableArray: originTableArray,\r\n          tableOpenList: tableOpenList,\r\n          urlPasted: urlPasted,\r\n          iframeURL: urlPasted,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function copies the table content to clipboard\r\n\r\n  copyTable() {\r\n    const textArea = document.createElement(\"textarea\"); // this line allows the use of select() function\r\n    let copiedText = \"\";\r\n\r\n    // This case handles the copy table for start subject\r\n    if (this.state.usecaseSelected === \"startSubject\" || this.state.usecaseSelected === \"startTable\") {\r\n      // We first push on the text for column headers (using the labels)\r\n      let tableHeader = this.state.tableHeader;\r\n      for (let i = 0; i < tableHeader.length; ++i) {\r\n        // console.log(tableHeader[i]);\r\n        let curText = \"\";\r\n        // This first condition deals with first column's header text\r\n        if (i === 0) {\r\n          // First subcase: starting table\r\n          if (this.state.usecaseSelected === \"startTable\") {\r\n            curText = \"OriginURL\";\r\n          }\r\n          // Second subcase: starting entity\r\n          else {\r\n            for (let j = 0; j < tableHeader[i].length; ++j) {\r\n              if (j > 0) {\r\n                curText += \" AND \"; \r\n              }\r\n              curText += niceRender(tableHeader[i][j].oValue);\r\n            }\r\n          }\r\n        }\r\n        // This condition deals with other column's header text\r\n        else {\r\n          for (let j = 0; j < tableHeader[i].length; ++j) {\r\n            if (j > 0) {\r\n              curText += \" OR \";\r\n            }\r\n            let textToAdd = tableHeader[i][j].type === \"object\" ? \"is \" + tableHeader[i][j].value + \" of\" : tableHeader[i][j].value;\r\n            curText += textToAdd;\r\n          }\r\n        }\r\n        copiedText = copiedText + curText + \"\\t\";\r\n      }\r\n      copiedText += \"\\n\";\r\n      // Now we need to fetch the rows that are not column headers\r\n      let tableData = this.state.tableData;\r\n      const rowNum = tableData.length;\r\n      const colNum = tableData[0].length;\r\n      for (let i = 0; i < rowNum; ++i) {\r\n        for (let j = 0; j < colNum; ++j) {\r\n          let curText = niceRender(tableData[i][j].data);\r\n          if (curText !== undefined) {\r\n            copiedText = copiedText + curText + \"\\t\";\r\n          }\r\n        }\r\n        copiedText += \"\\n\";\r\n      }\r\n    }\r\n    textArea.value = copiedText;\r\n    document.body.appendChild(textArea);\r\n    textArea.select();\r\n    document.execCommand(\"copy\");\r\n    document.body.removeChild(textArea);\r\n    alert(\"Table content has been exported!\");\r\n  }\r\n\r\n  // This function handles the toggling of the WikiPage at bottom\r\n\r\n  toggleWikiPage() {\r\n    let pageHidden = this.state.pageHidden;\r\n    this.setState({\r\n      pageHidden: !pageHidden,\r\n    });\r\n  }\r\n\r\n  // This function handles the selection of the starting task \"startSubject\"\r\n\r\n  handleStartSubject(e, taskSelected) {\r\n\r\n    if (taskSelected === \"startSubject\") {\r\n      \r\n      // Change the cursor since we are making a fetch request\r\n      document.body.classList.add('waiting');\r\n\r\n      // Since the starting task is \"startSubject\", we set the URL to be the first cell in the table\r\n      const subject = decodeURIComponent(this.state.urlPasted.slice(30)); \r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      tableData[0][0].data = subject;\r\n\r\n      // Let's run some queries here to fetch some first degree properties \r\n\r\n      // The query we will run is simply as follows\r\n      // select ?p ?o\r\n      // where {\r\n      // dbr:Barack_Obama ?p ?o.\r\n      // }\r\n\r\n      // Note: we are not taking account of the object neighbours. Subject neighbours only.\r\n\r\n      let prefixURL = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL = \r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBody = \r\n        \"select+%3Fp+%3Fo%0D%0Awhere+%7B%0D%0Adbr%3A\" + \r\n        regexReplace(subject) +\r\n        \"+%3Fp+%3Fo.%0D%0A%7D&\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      \r\n      let promiseArray = [fetchJSON(queryURL)]\r\n      \r\n      allPromiseReady(promiseArray).then((values) => {\r\n\r\n        // We set up the firstColSelection and firstColChecked states here\r\n        let firstColSelection = updateFirstColSelection(values[0].results.bindings);\r\n        let firstColChecked = [];\r\n        // Initially, firstColChecked is all false\r\n        for (let i = 0; i < firstColSelection.length; ++i) {\r\n          firstColChecked.push(false);\r\n        }\r\n\r\n        // console.log(firstColSelection);\r\n        // console.log(firstColChecked);\r\n\r\n        // We create the InfoObject needed for Action Panel\r\n        let tempObj = {\r\n          \"task\":\"afterStartSubject\",\r\n        };\r\n\r\n        // Adding support for undo:\r\n        let lastAction = \"handleStartSubject\";\r\n        let prevState = \r\n          {\r\n            \"usecaseSelected\":this.state.usecaseSelected,\r\n            \"tableData\":this.state.tableData,\r\n            \"tabIndex\":this.state.tabIndex,\r\n            \"curActionInfo\":this.state.curActionInfo,\r\n            \"firstColSelection\":this.state.firstColSelection,\r\n            \"firstColChecked\":this.state.firstColChecked,\r\n          };\r\n        \r\n        // Check the cursor back because we are done with the function\r\n        document.body.classList.remove('waiting');\r\n\r\n        this.setState({\r\n          usecaseSelected: taskSelected,\r\n          tableData: tableData,\r\n          firstColSelection: firstColSelection,\r\n          firstColChecked: firstColChecked,\r\n          curActionInfo: tempObj,\r\n          tabIndex: 0,\r\n          firstColText: \"\", // updated on August 26th\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      })\r\n    } \r\n  }\r\n\r\n  // This function handles the toggling of the starting subject's neighbours\r\n  // Also, we store this toggledIndex, so that we can display the suggestion text at the right location.\r\n  // Obviously, we need to update this.state.firstColChecked array.\r\n\r\n  toggleFirstNeighbour(e, index) {\r\n    // console.log(\"Toggled index is \"+index);\r\n    \r\n    // We first create a copy of firstColChecked\r\n    let firstColChecked = this.state.firstColChecked.slice();\r\n\r\n    // Now we deal with keyCheckedIndex\r\n    let keyCheckedIndex = index;\r\n  \r\n    // We handle the toggling here\r\n    firstColChecked[index] = !firstColChecked[index];\r\n\r\n    // Lastly, we make the state changes\r\n    this.setState({\r\n      firstColChecked:firstColChecked,\r\n      keyCheckedIndex:keyCheckedIndex,\r\n      firstColText: \"\",\r\n    })\r\n  }\r\n\r\n  // This function handles users typing into the type aheader for first column's neighbour selections\r\n  firstColTextChange(e) {\r\n    e.preventDefault();\r\n    let firstColText = e.target.value;\r\n    this.setState({\r\n      firstColText: firstColText,\r\n    })\r\n  }\r\n\r\n  // This function handles the toggling of a non-first column's attribute selection\r\n  // Note: since the preview feature is being addded, this function needs to handle preview as well.\r\n  // It will handle the preview similarly to how it handles populateOtherColumn, \r\n  // Except it sets previewData attribute, instead of data attribute.\r\n  toggleOtherNeighbour(e, neighbourIndex, colIndex) {\r\n    // We first get all the variables we needed\r\n    let previewColIndex;\r\n    let tableData = _.cloneDeep(this.state.tableData); \r\n    let otherColChecked = _.cloneDeep(this.state.otherColChecked);\r\n\r\n    // We first deal with the toggling of otherCheckedIndex and otherColChecked\r\n    let otherCheckedIndex = neighbourIndex;\r\n    otherColChecked[neighbourIndex] = !otherColChecked[neighbourIndex];\r\n\r\n    // We then deal with column preview.\r\n\r\n    // First step is to create a selectedNeighbours array for preview, similar to OtherColSelection.\r\n    // We will create the selectedNeighbours array from otherColSelection and otherColChecked\r\n    let selectedNeighbours = [];\r\n    for (let i = 0; i < otherColChecked.length; ++i) {\r\n      if (otherColChecked[i] === true) {\r\n        selectedNeighbours.push(this.state.otherColSelection[i]);\r\n      }\r\n    }\r\n    // console.log(selectedNeighbours);\r\n    // console.log(colIndex);\r\n    \r\n    // If selectedNeighbours is non-empty, we need to set previewColIndex to colIndex, and set tableData's previewData attribute\r\n    if (selectedNeighbours.length > 0) {\r\n      // We first set tableData, based on selectedNeighbours and colIndex. The following part will be similar to populateOtherColumn.\r\n      for (let i = 0; i < tableData.length; ++i) {\r\n        // curColumnArray is the previewData array, for each entry in search column, for all neighbours in selectedNeighbours\r\n        let curColumnArray = [];\r\n        // We loop through selectedNeighbours\r\n        for (let j = 0; j < selectedNeighbours.length; ++j) {\r\n          let curNeighbour = selectedNeighbours[j];\r\n          let firstDegNeighbours = \r\n            curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n          let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n          if (curNeighbourData !== undefined) {\r\n            curColumnArray = curColumnArray.concat(curNeighbourData);\r\n          }\r\n        }\r\n        // If curColumnArray is empty, that means this entry in search column do not have any of the attributes from selectedNeighbours\r\n        // We want to set previewData to N/A\r\n        if (curColumnArray.length === 0) {\r\n          tableData[i][colIndex].previewData = \"N/A\";\r\n        }\r\n        // Else, we have found at least one value. We want to set previewData to curColumnArray[0]\r\n        else {\r\n          tableData[i][colIndex].previewData = curColumnArray[0];\r\n        }\r\n      }\r\n\r\n      // Now that we are done with setting tableData, we set previewColIndex.\r\n      previewColIndex = colIndex;\r\n    }\r\n    // In this case, selectedNeighbours is empty, we want to set previewColIndex back to -1.\r\n    else {\r\n      previewColIndex = -1;\r\n    }\r\n\r\n    // Support for undo:\r\n    let lastAction = \"toggleOtherNeighbour\";\r\n    let prevState = \r\n    {\r\n      otherColChecked: this.state.otherColChecked,\r\n      otherColCheckedIndex: this.state.otherCheckedIndex,\r\n      tableData: this.state.tableData,\r\n      previewColIndex: this.state.previewColIndex,\r\n    }\r\n\r\n    this.setState({\r\n      otherColChecked: otherColChecked,\r\n      otherCheckedIndex: otherCheckedIndex,\r\n      tableData: tableData,\r\n      previewColIndex: previewColIndex,\r\n      otherColText: \"\",\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // This function handles user typing into the type-ahead for other column's neighbour selection\r\n\r\n  otherColTextChange(e) {\r\n    e.preventDefault();\r\n    let otherColText = e.target.value;\r\n    this.setState({\r\n      otherColText: otherColText,\r\n    })\r\n  }\r\n\r\n\r\n  // This function is a simple function that creates an object and passes to Action Panel\r\n  handlePlusClick() {\r\n    this.setState({\r\n      curActionInfo:{\"task\":\"plusClicked\"},\r\n      previewColIndex: -1, // we also want to set preview column index to -1 (clear previews)\r\n      tabIndex: 0,\r\n    })\r\n  }\r\n\r\n  // This function handles when users want to add more entities to the first column\r\n  addToFirstCol() {\r\n    // We need to make the Action Panel display FirstColSelection component again.\r\n    // Before doing so, we need to first clear out this.state.firstColChecked, and this.state.keyCheckedIndex\r\n    // So that we do not have information carried over from the previous first column selection.\r\n\r\n    // First we update firstColChecked\r\n    let firstColCheckedUpdated = [];\r\n    for (let i = 0; i < this.state.firstColChecked.length; ++i) {\r\n      firstColCheckedUpdated.push(false);\r\n    }\r\n\r\n    // Then we reset keyCheckedIndex\r\n    let keyCheckedIndexUpdated = -1;\r\n\r\n    // We now set up tempObj for Action Panel\r\n    let tempObj = {\r\n      \"task\":\"afterStartSubject\",\r\n    };\r\n\r\n    // Finallym we set the states.\r\n    this.setState({\r\n      firstColChecked:firstColCheckedUpdated,\r\n      keyCheckedIndex:keyCheckedIndexUpdated,\r\n      curActionInfo:tempObj,\r\n      firstColText: \"\", // updated on August 26th\r\n    })\r\n  }\r\n\r\n  // This function handles manually changing cell in a table.\r\n  // Other than manipulating the data, it does one check: \r\n  // If this.state.tableHeader[j] is empty ([]), we set tableHeader[j] as [{\"value\":\"Notes\", \"type\":\"Subject\"}]\r\n  cellChange(e, i, j) {\r\n    e.preventDefault();\r\n    let tableData = this.state.tableData.slice();\r\n    tableData[i][j].data = e.target.value;\r\n\r\n    // Below is added on August 25th:\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n    if (tableHeader[j].length === 0) {\r\n      tableHeader[j] = [\r\n        {\r\n          \"value\":\"Notes\",\r\n          \"label\":\"Notes\",\r\n          \"type\":\"subject\",\r\n        }\r\n      ]\r\n    }\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n    });\r\n  }\r\n\r\n  // This function updates the options for selections when we click on selection for a key column\r\n  // based on cells already filled in this column\r\n\r\n  getKeyOptions(e, colIndex) {\r\n    if (colIndex === this.state.keyColIndex) {\r\n      \r\n      // We first get all the non-empty values from the key column\r\n      let allSubject = [];\r\n      for (let i = 0; i < this.state.tableData.length; ++i) {\r\n        if (this.state.tableData[i][colIndex].data === \"\") {\r\n          break;\r\n        } else {\r\n          allSubject.push(regexReplace(this.state.tableData[i][colIndex].data));\r\n        }\r\n      }\r\n\r\n      // In here we fetch the options for first column's selection\r\n      // It uses the common dct:subject of all cells entered in the key column\r\n\r\n      // Modification: let's also find the common rdf:type dbo:xxx of cells filled.\r\n\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n      for (let i = 0; i < allSubject.length; ++i) {\r\n        queryBody +=\r\n          \"%0D%0A++++++++dbr%3A\" + allSubject[i] + \"+%28dct%3Asubject%7Crdf%3Atype%29+%3Fsomevar.\";\r\n      }\r\n      let suffixURL =\r\n        \"%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchJSON(queryURL));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let myJson = values[0];\r\n        let keyColOptions = [];\r\n        // We loop through the result bindings. \r\n        // If it's from dct:subject, or rdf:type dbo:xxxx, we push it onto keyColOptions\r\n        for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n          let curValue = myJson.results.bindings[i].somevar.value;\r\n          // This clause deals with dct:subject\r\n          if (curValue.includes(\"dbpedia.org/resource/Category:\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(37);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"dct\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n          // This clause deals with rdf:type dbo:xxxx\r\n          else if (curValue.includes(\"dbpedia.org/ontology/\") && !curValue.includes(\"Wikidata\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(28);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"rdf\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n        }\r\n        // Take a look at keyColOptions\r\n        // console.log(keyColOptions);\r\n        // We create a copy of the optionsMap.\r\n        // Then change the entry in the optionsMap corresponding to the key column to what we have just fetched: keyColOptions.\r\n        let optionsMap = this.state.optionsMap.slice();\r\n        optionsMap[this.state.keyColIndex] = keyColOptions;\r\n        this.setState({\r\n          optionsMap: optionsMap,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function updates the options for selections when we want to open selection for non-key column\r\n  // based on cells already filled in this column, and the cells in the key column\r\n  // aka: Michelle Obama is Barack Obama' wife\r\n\r\n  // It needs to update Action Panel to display the correct content.\r\n\r\n  // If this column is empty or completely filled, it will just pass keyColNeighbours to Action Panel.\r\n\r\n  getOtherOptions(e, colIndex) {\r\n\r\n    // console.log(\"Column index clicked is \"+colIndex);\r\n\r\n    // console.log(this.state.keyColNeighbours);\r\n\r\n    // The first thing we need to do is to determine the content for otherColSelection\r\n    let otherColSelection = [];\r\n\r\n    // We check if this column is all-empty, or all filled\r\n    let colEmpty = true;\r\n    let colFilled = true;\r\n    let nonEmptyInfo = [];\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      // If some data is not \"\", that means this column is not empty\r\n      if (this.state.tableData[i][colIndex].data !== \"\") {\r\n        colEmpty = false;\r\n        nonEmptyInfo.push([i, this.state.tableData[i][colIndex].data]);\r\n      }\r\n      // If some data is \"\", that means this column is not filled\r\n      else {\r\n        colFilled = false;\r\n      }\r\n    }\r\n\r\n    // Case 1:\r\n    // If this column is non-empty, and not completely filled, we want to deal with special otherColSelection\r\n    if (colEmpty === false && colFilled === false) {\r\n      document.body.classList.add('waiting');\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL =\r\n        \"%0D%0A%7D%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n      // Bugfix added on August 17th: instead of using every entry from nonEmptyInfo to determine the relation, we will use the first one\r\n      // for (let i = 0; i < nonEmptyInfo.length; ++i) {\r\n      for (let i = 0; i < 1; ++i) {\r\n        let curKeySubject = regexReplace(\r\n          this.state.tableData[nonEmptyInfo[i][0]][this.state.keyColIndex].data\r\n        );\r\n        let curEnteredSubject = regexReplace(nonEmptyInfo[i][1]);\r\n        queryBody +=\r\n          \"%0D%0A++++++++dbr%3A\" +\r\n          curKeySubject +\r\n          \"+%3Fsomevar+dbr%3A\" +\r\n          curEnteredSubject +\r\n          \".\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchJSON(queryURL));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n      let myJson = values[0];\r\n      // we create a temporary variable to hold results from myJson.results.bindings\r\n      let tempSelection = [];\r\n      for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n        let tempObj = {};\r\n        let neighbour = myJson.results.bindings[i].somevar.value.slice(28);\r\n        tempObj[\"label\"] = neighbour;\r\n        tempObj[\"value\"] = neighbour;\r\n        tempObj[\"type\"] = \"subject\"; // for now we only allow the subject search\r\n        tempSelection.push(tempObj);\r\n      }\r\n      // We push onto otherColSelection the right elements from keyColNeighbours, based on tempSelection\r\n      // console.log(this.state.keyColNeighbours);\r\n      // console.log(tempSelection);\r\n      for (let i = 0; i < tempSelection.length; ++i) {\r\n        for (let j = 0; j < this.state.keyColNeighbours.length; ++j) {\r\n          if (tempSelection[i].value === this.state.keyColNeighbours[j].value \r\n              && tempSelection[i].type === this.state.keyColNeighbours[j].type) {\r\n            otherColSelection.push(this.state.keyColNeighbours[j]);\r\n            break; \r\n          }\r\n        }\r\n      }\r\n      // Now, we do not want to have an empty otherColSelection.\r\n      // Thus, if it is, we just want to set it as this.state.keyColNeighbours\r\n      if (otherColSelection.length === 0) {\r\n        otherColSelection = this.state.keyColNeighbours;\r\n      }\r\n      // Take a look at otherColSelection\r\n      // console.log(otherColSelection);\r\n\r\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\r\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\r\n\r\n      let otherColChecked = [];\r\n      for (let i = 0; i < otherColSelection.length; ++i) {\r\n        otherColChecked.push(false);\r\n      }\r\n      let otherCheckedIndex = -1;\r\n\r\n      let tempObj = \r\n        {\r\n          \"task\":\"showOtherColSelection\",\r\n          \"colIndex\":colIndex,\r\n        }\r\n\r\n      document.body.classList.remove('waiting');\r\n      this.setState({\r\n        otherColSelection:otherColSelection,\r\n        otherColChecked:otherColChecked,\r\n        otherColText: \"\",  // Modified on August 26th: every time we click on this edit icon, we want to reset otherColText\r\n        otherCheckedIndex:otherCheckedIndex,\r\n        curActionInfo:tempObj,\r\n        previewColIndex: -1,\r\n      })\r\n      })\r\n    }\r\n\r\n    // Case 2:\r\n    // If this column is empty or completely filled, we just set otherColSelection to be keyColNeighbours\r\n    else {\r\n      otherColSelection = this.state.keyColNeighbours;\r\n      // Take a look at otherColSelection\r\n      // console.log(otherColSelection);\r\n\r\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\r\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\r\n\r\n      // Maybe some modifications need to be done here when colFilled === true\r\n      let otherColChecked = [];\r\n      for (let i = 0; i < otherColSelection.length; ++i) {\r\n        otherColChecked.push(false);\r\n      }\r\n      let otherCheckedIndex = -1;\r\n\r\n      let tempObj = \r\n        {\r\n          \"task\":\"showOtherColSelection\",\r\n          \"colIndex\":colIndex,\r\n        }\r\n\r\n      window.scrollTo(0, 0);\r\n      this.setState({\r\n        otherColSelection:otherColSelection,\r\n        otherColChecked:otherColChecked,\r\n        otherColText: \"\",  // Modified on August 26th: every time we click on this edit icon, we want to reset otherColText\r\n        otherCheckedIndex:otherCheckedIndex,\r\n        curActionInfo:tempObj,\r\n        previewColIndex: -1,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function handles the the selection of a column header.\r\n  // Note: we want to deal with the selection of key column header vs non key column header differently\r\n\r\n  selectColHeader(e, colIndex) {\r\n\r\n    let tableHeader = this.state.tableHeader.slice();\r\n\r\n    if (e !== null) {\r\n\r\n      // We first get the selectedOptions\r\n      let selectedOptions = _.cloneDeep(e);\r\n      // console.log(selectedOptions);\r\n      tableHeader[colIndex] = selectedOptions;\r\n\r\n      // This part deals with the selection of a key column header\r\n      if (colIndex === this.state.keyColIndex) {\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"populateKeyColumn\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbourArray\"] = [];\r\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          tempObj.neighbourArray.push(selectedOptions[i]);\r\n        }\r\n        // console.log(tempObj);\r\n        this.setState({\r\n          tableHeader: tableHeader,\r\n          curActionInfo: tempObj,\r\n        })\r\n      }\r\n\r\n      // This part deals with the selection of a non key column header\r\n      else {\r\n        // We want to change the label of non-key column headers with respect to the label of key column\r\n        // First step: set up the label text for the key column\r\n        let keyColLabel = \"\";\r\n        for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\r\n          let labelToAdd = i > 0 ? \"&\" + tableHeader[this.state.keyColIndex][i].label : tableHeader[this.state.keyColIndex][i].label;\r\n          keyColLabel+=labelToAdd;\r\n        }\r\n        // Then, since tableHeader[colIndex] is an array, we update all element's label from the array\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          let ownLabel = tableHeader[colIndex][i].type === \"subject\" ? tableHeader[colIndex][i].value : \"is \" + tableHeader[colIndex][i].value + \" of\";\r\n          tableHeader[colIndex][i].label = ownLabel + \"--\" + keyColLabel;\r\n        }\r\n        // console.log(tableHeader);\r\n\r\n        // Now, we want to ask in ActionPanel whether user wants to populate the column based on the chosen column names\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"populateOtherColumn\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbourArray\"] = [];\r\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          tempObj.neighbourArray.push(selectedOptions[i]);\r\n        }\r\n        // Because we are allowing multi-selects now, type and range are no long two single strings.\r\n        // Rather, their values can be figured out from neighbourArray\r\n        // console.log(tempObj);\r\n        this.setState({\r\n          tableHeader: tableHeader,\r\n          curActionInfo: tempObj,\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  // This function is a helper function for populateKeyColumn. It is similar to getOtherColPromise.\r\n  // It makes an array of queries to find the union of neighbours for the first column (key column).\r\n\r\n  // Some modification needs to be made to the queries\r\n  // So that ?o in the first query and ?s in the second query have to be included as well.\r\n\r\n  // It takes in three parameters\r\n  // 1) tableData: tableData (with updated values in the first column)\r\n  // 2) type: either \"subject\" or \"object\"\r\n  // 3) colIndex:  integer representing which column's neighbours we are fetching\r\n\r\n  getNeighbourPromise(tableData, type, colIndex) {\r\n    // console.log(tableData);\r\n    // console.log(type);\r\n\r\n    // Query we make if type is subject\r\n\r\n    // select ?p ?o ?range ?subPropertyOf\r\n    // where {\r\n    // dbr:Barack_Obama ?p ?o.\r\n    // OPTIONAL {?p rdfs:range ?range}.\r\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\r\n    // }\r\n\r\n    // Query we make if type is object\r\n\r\n    // select ?s ?p ?range ?subPropertyOf\r\n    // where {\r\n    // ?s ?p dbr:Barack_Obama.\r\n    // OPTIONAL {?p rdfs:range ?range}.\r\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\r\n    // }\r\n\r\n    // BUGFIX August 17th: The query below may need to be used for performance issues\r\n\r\n    // select ?s ?p ?range ?subPropertyOf\r\n    // where {\r\n    // ?s ?p dbr:Barack_Obama.\r\n    // OPTIONAL {?p rdfs:range ?range}.\r\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\r\n    // {\r\n    // select ?p (count(?s) as ?count) \r\n    // where {\r\n    // ?s ?p dbr:Barack_Obama\r\n    // }\r\n    // group by ?p\r\n    // having (count(?s) <= maxFetchCount)\r\n    // }\r\n    // }\r\n\r\n    let promiseArray = [];\r\n    let prefixURL =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURL =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      let cellValue = tableData[i][colIndex].data === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(tableData[i][colIndex].data);\r\n      // console.log(cellValue);\r\n      let queryBody;\r\n      if (type === \"subject\") {\r\n        queryBody =\r\n          \"select+%3Fp+%3Fo+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0Adbr%3A\" +\r\n          cellValue +\r\n          \"+%3Fp+%3Fo.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\r\n      }\r\n      else {\r\n        // queryBody = \r\n        //   \"select+%3Fs+%3Fp+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" +\r\n        //   cellValue +\r\n        //   \".%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\r\n\r\n        // Above code is the query before bugfix on August 17th. Below is the fixed version of the code\r\n        queryBody = \r\n          \"select+%3Fs+%3Fp+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" + \r\n          cellValue + \r\n          \".%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7B%0D%0Aselect+%3Fp+%28count%28%3Fs%29+as+%3Fcount%29+%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" +\r\n          cellValue + \r\n          \"%0D%0A%7D%0D%0Agroup+by+%3Fp%0D%0Ahaving+%28count%28%3Fs%29+%3C%3D+\" + \r\n          maxFetchCount +\r\n          \"%29%0D%0A%7D%0D%0A%7D%0D%0A&\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n    return promiseArray;\r\n  }\r\n\r\n  // This function populates the key column\r\n  // It also fetches the neighbours of the key column (based on the first cell in the table)\r\n  // as well as setting the origins of cells in the key column\r\n\r\n  // Instead of having a fixed number of entries in the key column,\r\n  // We have made it more flexible. (but also pose a limit, so we don't get way too many entries)\r\n\r\n  populateKeyColumn(e, colIndex, neighbourArray) {\r\n    // Let's first take a look at parameters passed in\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n\r\n    // Let's create a helper function to generate the query text.\r\n    let queryURL = keyQueryGen(neighbourArray)\r\n    // console.log(queryURL);\r\n\r\n    // If queryURL is error, we have encountered some previously unseen datatypes. In this case we just print an error.\r\n    if (queryURL === \"ERROR\") {\r\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\")\r\n    }\r\n\r\n    // Else we run the body of the funnction\r\n\r\n    else {\r\n      document.body.classList.add('waiting');\r\n\r\n      let promiseArray = [fetchJSON(queryURL)];\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // let's first work with the first promise result: fill in table data with the entities we have fetched\r\n  \r\n        // console.log(values[0].results.bindings);\r\n\r\n        // We set the tableHeader[0] here, from a deep copy of tableHeader\r\n        // tableHeader[0] should be set as neighbourArray\r\n        let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n        tableHeader[0] = neighbourArray;\r\n\r\n        // Addition: we want to display the first column's header correctly. Let's add support for that\r\n        let firstColHeaderInfo = [];\r\n        firstColHeaderInfo.push(neighbourArray);\r\n  \r\n        // This part sets the data for each cell\r\n        let tableData = _.cloneDeep(this.state.tableData);\r\n  \r\n        if (this.state.tableHeader[0].length === 0) {\r\n          tableData = setFirstColumnData(\r\n            values[0].results.bindings,\r\n            tableData,\r\n            tableHeader,\r\n            colIndex\r\n          )\r\n        }\r\n  \r\n        // console.log(tableData);\r\n  \r\n        // We need to make modification here: find neighbours of a column, instead of neighbours of a cell\r\n        // To do this, we need to use this tableData to ask more queries (number of queires is equal to tableData.length)\r\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\r\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\r\n\r\n        // Now we construct the semantic tree for the first column\r\n        // We first randomly get a number of (Math.min(tableData.length, numForTree)) samples from tableData\r\n        let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n        let promiseArrayThree = getRDFType(sampleRows, 0);\r\n\r\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n        allPromiseReady(promiseArrayThree).then((valuesThree) => {\r\n          // console.log(typeRecord);\r\n\r\n          // console.log(valuesOne);\r\n          // console.log(valuesTwo);\r\n          // console.log(valuesThree);\r\n\r\n          // Support for semantic tree: we write a helper function here to \r\n\r\n          // Modified on Sept 13th: whenever updateNeighbourInfo is called, updateUnionSelection should also be called\r\n          // updateUnionSelection should basically be a looped version for updateFirstColSelection\r\n          let selectionInfo = updateUnionSelection(valuesOne);\r\n          // console.log(selectionInfo);\r\n\r\n          // We call updateNeighbourInfo here because we are changing the rows\r\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n          // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n          // to support semantic tree\r\n          let curColumnRecord = buildTypeRecord(sampleRows, 0, valuesThree)\r\n          let typeRecord = _.cloneDeep(this.state.typeRecord);\r\n          typeRecord[0] = curColumnRecord;\r\n\r\n          // Lastly, we set up the information for the action panel\r\n          let tempObj = {};\r\n          tempObj[\"task\"] = \"showStartRecommend\";\r\n          tempObj[\"colIndex\"] = colIndex;\r\n          tempObj[\"recommendArray\"] = this.createStartRecommend(keyColNeighbours);\r\n  \r\n          // Support for undo: \r\n          // Let's save the previous state in an object\r\n          let lastAction = \"populateKeyColumn\";\r\n          let prevState = \r\n            {\r\n              \"keyColIndex\":this.state.keyColIndex,\r\n              \"keyColNeighbours\":this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n              \"curActionInfo\":this.state.curActionInfo,\r\n              \"tableData\":this.state.tableData,\r\n              \"tableHeader\":this.state.tableHeader,\r\n              \"firstColFilled\":this.state.firstColFilled,\r\n              \"firstColHeaderInfo\":this.state.firstColHeaderInfo,\r\n              \"firstColSelection\":this.state.firstColSelection, // updated on Sept 13th\r\n              \"firstColChecked\":this.state.firstColChecked, // updated on Sept 13th\r\n              \"typeRecord\":this.state.typeRecord,\r\n            };\r\n\r\n          document.body.classList.remove('waiting');\r\n  \r\n          this.setState({\r\n            keyColIndex: colIndex,\r\n            keyColNeighbours: keyColNeighbours,\r\n            firstDegNeighbours: firstDegNeighbours,\r\n            curActionInfo: tempObj, // Changed on Aug 20th\r\n            tableData: tableData,\r\n            tableHeader: tableHeader,\r\n            firstColFilled: true,\r\n            firstColHeaderInfo: firstColHeaderInfo,\r\n            firstColText: \"\", // updated on August 26th\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n            firstColSelection: selectionInfo.firstColSelection,\r\n            firstColChecked: selectionInfo.firstColChecked,\r\n            typeRecord: typeRecord,\r\n          });\r\n        })\r\n        })\r\n        })\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function adds more entities to the first column.\r\n  // It should be similar to populateKeyColumn, with some differences\r\n\r\n  confirmAddFirstCol(e, neighbourArray) {\r\n\r\n    // Support for autofill starts here\r\n    // Let's figure out what's currently in the table first.\r\n    // console.log(this.state.tableHeader);\r\n    let autoFillInfo = getAutofillInfo(this.state.tableData);\r\n    // console.log(autoFillInfo);\r\n\r\n    // console.log(neighbourArray);\r\n    let queryURL = keyQueryGen(neighbourArray);\r\n\r\n    // Let's first make sure that the neighbourArray do not contain attributes of unknown datatypes.\r\n    if (queryURL === \"ERROR\") {\r\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\");\r\n    }\r\n\r\n    else {\r\n      document.body.classList.add(\"waiting\");\r\n\r\n      let promiseArray = [fetchJSON(queryURL)];\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // console.log(values[0].results.bindings);\r\n        // Now we append the new query results to tableData\r\n        let numNewRows = Math.min(values[0].results.bindings.length, initialRowNum);\r\n        let tableData = [];\r\n        // We first push on numNewRows number of rows, while setting up data and origin\r\n        for (let i = 0; i < numNewRows; ++i) {\r\n          let tempRow = [];\r\n          for (let j = 0; j < this.state.tableHeader.length; ++j) {\r\n            if (j === 0) {\r\n              tempRow.push({\r\n                data: values[0].results.bindings[i].somevar.value.slice(28),\r\n                origin: [values[0].results.bindings[i].somevar.value.slice(28)]\r\n              })\r\n            }\r\n            else {\r\n              // We do not have support for autofill at this step yet.\r\n              tempRow.push({ data: \"\", origin: []});\r\n            }\r\n          }\r\n          tableData.push(tempRow);\r\n        }\r\n\r\n        // To support autofill, let's also store the starting index of the newly appended data\r\n        let fillStartIndex = this.state.tableData.length;\r\n        // We concat this.state.tableData and tableData together, and dedup by first column's data\r\n        tableData = _.cloneDeep(this.state.tableData).concat(tableData);\r\n        tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\r\n        // console.log(tableData);\r\n\r\n        // Now, we move on to update firstDegNeighbours and keyColNeighbours\r\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", 0);\r\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", 0);\r\n\r\n        // In here we add support for auto-fill information:\r\n        // We make use of the autofillFarPromise helper function to get the 2nd and 3rd deg neighbours\r\n        let columnInfo = autoFillInfo.columnInfo;\r\n        let autoPromise = autofillFarPromise(tableData, columnInfo, fillStartIndex, \"startSubject\", -1);\r\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n        allPromiseReady(autoPromise).then((valuesAuto) => {\r\n\r\n          // console.log(valuesAuto)\r\n\r\n          let selectionInfo = updateUnionSelection(valuesOne); // Sept 13 update\r\n  \r\n          // We call updateNeighbourInfo here because we are changing the rows\r\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n          // This is where we can start working on the auto-fill\r\n          // Let's first look at fillStartIndex, tableData, and autoFillInfo\r\n          // console.log(\"New entries' starting index is \"+fillStartIndex);\r\n          // console.log(tableData);\r\n          // console.log(autoFillInfo);\r\n          // console.log(firstDegNeighbours);\r\n\r\n          // console.log(valuesAuto);\r\n\r\n          // Now we call a helper function to process valuesAuto\r\n          // Specifically, we want to get an array of arrays of string, as data for the 2nd/3rd deg neighbour columns\r\n          let farArray = processAutoInfo(columnInfo, valuesAuto, \"startSubject\");\r\n          // This farArray contains all the information we needed. We set a starting index\r\n          let farIndex = 0;\r\n\r\n          // Stepone: Call helper function autofillFirstDeg to fill in the one-deg neighbours first\r\n          // This information should already exists in firstDegNeighbours\r\n          for (let i = 0; i < columnInfo.length; ++i) {\r\n            // We are currently dealing with curColumn_th column in the table\r\n            let curColumn = i + 1;\r\n            // If it is a one-deg neighbour, we call the autofillFirstDeg to update tableData\r\n            if (columnInfo[i].length === 1) {\r\n              tableData = \r\n                autofillFirstDeg(tableData, \r\n                                 columnInfo[i], \r\n                                 curColumn, \r\n                                 fillStartIndex, \r\n                                 firstDegNeighbours, \r\n                                 this.state.keyColIndex);\r\n            }\r\n            // It it is a 2nd/3rd deg neighbour, we call autofillFarDeg to update tableData\r\n            if (columnInfo[i].length === 2 || columnInfo[i].length === 3) {\r\n              tableData = \r\n                autofillFarDeg(tableData,\r\n                               columnInfo[i],\r\n                               farArray[farIndex],\r\n                               curColumn,\r\n                               fillStartIndex);\r\n              // We also need to update farIndex\r\n              ++farIndex;\r\n            }\r\n          }\r\n          // console.log(tableData);\r\n\r\n          document.body.classList.remove('waiting');\r\n\r\n          // Lastly, we display a warning if autoFillInfo.longHopWarning is true\r\n          if (autoFillInfo.longHopWarning) {\r\n            alert(\"Neighbours more than 3 hops away is not autofilled.\");\r\n          }\r\n\r\n          let firstColHeaderInfo = _.cloneDeep(this.state.firstColHeaderInfo);\r\n          firstColHeaderInfo.push(neighbourArray);\r\n\r\n          // Support for undo\r\n          let lastAction = \"confirmAddFirstCol\";\r\n          let prevState = \r\n            {\r\n              \"tableData\": this.state.tableData,\r\n              \"keyColNeighbours\": this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n              \"firstColHeaderInfo\": this.state.firstColHeaderInfo,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n              \"firstColSelection\": this.state.firstColSelection, // updated on 9/13\r\n              \"firstColChecked\": this.state.firstColChecked, // updated on 9/13\r\n            }\r\n  \r\n          this.setState({\r\n            tableData: tableData,\r\n            keyColNeighbours: keyColNeighbours,\r\n            firstDegNeighbours: firstDegNeighbours,\r\n            firstColHeaderInfo: firstColHeaderInfo,\r\n            curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n            previewColIndex: -1,\r\n            firstColText: \"\", // updated on August 26th\r\n            firstColSelection: selectionInfo.firstColSelection,\r\n            firstColChecked: selectionInfo.firstColChecked,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n          });\r\n        })\r\n        })\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  // // TEST FUNCTION----------------------------------------------------\r\n\r\n  // getOtherColPromiseTwo(neighbour, type) {\r\n  //   let promiseArray = [];\r\n  //   // The following is the query we will make\r\n\r\n  //   // SELECT ?key ?val\r\n  //   // WHERE{\r\n  //   //       ?key (dbo:spouse|dbp:spouse) ?val.\r\n  //   //       VALUES ?key {dbr:Barack_Obama dbr:Ronald_Reagan dbr:Donald_Trump }\r\n  //   // }\r\n\r\n\r\n  //   let prefixURL = \r\n  //     \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  //   let suffixURL = \r\n  //     \"%7D%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=300000&debug=on&run=+Run+Query+\";\r\n  //   let queryBody;\r\n  //   // This clause handles the case of \"Obama -> property -> object\"\r\n  //   if (type === \"subject\") {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fkey+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fval.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   } \r\n  //   // This clause handles the case of \"subject -> property -> Obama\"\r\n  //   else {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fval+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fkey.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   }\r\n  //   for (let i = 0; i < this.state.tableData.length; ++i) {\r\n  //     let cellValue = regexReplace(\r\n  //       this.state.tableData[i][this.state.keyColIndex].data\r\n  //     );\r\n  //     // N/A's will block the search, let's replace it with some string that does not block the search\r\n  //     if (cellValue === \"N/A\") {\r\n  //       cellValue = \"NONEXISTINGSTRING\";\r\n  //     }\r\n  //     let curQueryText = \"dbr%3A\"+cellValue+\"+\";\r\n  //     queryBody+=curQueryText;\r\n  //   }\r\n  //   let queryURL = prefixURL + queryBody + suffixURL;\r\n  //   // console.log(queryURL);\r\n  //   promiseArray.push(fetchJSON(queryURL));\r\n  //   return promiseArray;\r\n  // }\r\n\r\n  // The following function serves as a helper function for \"populateOtherColumn\" and \"populateSameNeighbour\"\r\n  // It makes an array of queries, which may affect the performance of our system. Let's change it now.\r\n\r\n  getOtherColPromise(neighbour, type) {\r\n    let promiseArray = [];\r\n    let prefixURL =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURL =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      let cellValue = regexReplace(\r\n        this.state.tableData[i][this.state.keyColIndex].data\r\n      );\r\n      // N/A's will block the search, let's replace it with some string that does not block the search\r\n      if (cellValue === \"N/A\") {\r\n        cellValue = \"NONEXISTINGSTRING\";\r\n      }\r\n      let queryBody;\r\n      if (type === \"subject\") {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\" +\r\n          cellValue +\r\n          \"+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+%3Fsomevar.%0D%0A%7D%0D%0A%0D%0A&\";\r\n      } else {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A++++++++%3Fsomevar+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+dbr%3A\" +\r\n          cellValue +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n    return promiseArray;\r\n  }\r\n\r\n  // document.body.classList.add('waiting');\r\n\r\n  // console.log(neighbourIndex);\r\n\r\n  // Support for \"populateSameRange\":\r\n\r\n  // When the range is not equal to undefined, we want to ask user if they want to populate all other attributes from this range\r\n  // console.log(range);\r\n\r\n  // we need to make a number of queries in the form of: dbr:somekeycolumnentry dbp:neighbour|dbo:neighbour somevar\r\n  // let promiseArrayTwo = this.getOtherColPromiseTwo(neighbour, type); // this is for testing\r\n  // let promiseArray = this.getOtherColPromise(neighbour, type);\r\n\r\n  // allPromiseReady(promiseArray).then((values) => {\r\n  // // allPromiseReady(promiseArrayTwo).then((testValues) => {\r\n\r\n  // //   // Let's compare the different values we get from getOtherColPromise and getOtherColPromiseTwo\r\n  // //   console.log(values);\r\n  // //   console.log(testValues);\r\n\r\n  // //   // Now we need to process the testValues\r\n\r\n  // //   let pairArray = [];\r\n\r\n  // //   // First we removed the prefixes from resultArray\r\n  // //   for (let i=0; i<testValues[0].results.bindings.length; ++i) {\r\n  // //     pairArray.push(\r\n  // //       {\r\n  // //         \"key\":removePrefix(testValues[0].results.bindings[i].key.value),\r\n  // //         \"value\":removePrefix(testValues[0].results.bindings[i].val.value)\r\n  // //       }\r\n  // //     )\r\n  // //   }\r\n  // //   console.log(pairArray);\r\n\r\n  // //   // Then we create a keyArray\r\n  // //   let keyArray = [];\r\n\r\n  // //   for (let i=0; i<this.state.tableData.length; ++i) {\r\n  // //     keyArray.push(this.state.tableData[i][this.state.keyColIndex].data);\r\n  // //   }\r\n  // //   console.log(keyArray);\r\n  populateOtherColumn(e, colIndex, neighbourArray) {\r\n\r\n    document.body.classList.add('waiting');\r\n\r\n    // console.log(this.state.typeRecord);\r\n\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // We use a boolean to keep track of if any cell contains multiple values\r\n    let hasMultiple = false;\r\n\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\r\n      let curColumnArray = [];\r\n      // We loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours = \r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        // console.log(firstDegNeighbours);\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // console.log(neighbourArray);\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        // we set the data to N/A\r\n        let curData = \"N/A\";\r\n        tableData[i][colIndex].data = curData;\r\n        // Note that we still want to set origin to support autofill\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        // console.log(\"Current data point is: \");\r\n        // console.log(i);\r\n        // console.log(this.state.keyColIndex);\r\n        // console.log(tableData[i][this.state.keyColIndex]);\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n      // Otherwise, we have found at least one value.\r\n      else {\r\n        // we first set the data for the cell using curColumnArray[0]\r\n        tableData[i][colIndex].data = curColumnArray[0];\r\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n        // console.log(keyOrigin)\r\n\r\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\r\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\r\n        if (curColumnArray.length > 1) {\r\n          hasMultiple = true;\r\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\r\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\r\n        } \r\n      }\r\n    }\r\n    // Now, we are done with updating tableData.\r\n    // We want to update tableHeader as well.\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n    tableHeader[colIndex] = neighbourArray;\r\n\r\n    // We start setting up the content for the Action Panel.\r\n\r\n    let recommendArray = createRecommendArray(neighbourArray, this.state.keyColNeighbours);\r\n    // console.log(recommendArray);\r\n\r\n    // tempObj stores the information passed to ActionPanel\r\n    let tempObj = {};\r\n\r\n    // Case 1: hasMultiple is true, and there are recommendations\r\n    if (hasMultiple === true && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"sameNeighbourAndRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    // Case 2: only hasMultiple is true\r\n    else if (hasMultiple === true) {\r\n      tempObj[\"task\"] = \"populateSameNeighbour\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n    }\r\n    // Case 3: only hasRecommendation is true\r\n    else if (recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray; \r\n    }\r\n    // Case 4: neither hasMultiple or hasRecommendation is true. In which case we just tell users that they can fill more columns.\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Now we construct the semantic tree for the this column\r\n    // We first randomly get a number of (Math.min(tableData.length, numForTree)) samples from tableData\r\n    let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, colIndex);\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n    // to support semantic tree\r\n    let curColumnRecord = buildTypeRecord(sampleRows, colIndex, values)\r\n    let typeRecord = _.cloneDeep(this.state.typeRecord);\r\n    typeRecord[colIndex] = curColumnRecord;\r\n    // console.log(typeRecord);\r\n\r\n    document.body.classList.remove('waiting');\r\n\r\n    // Support for undo: \r\n    // Let's save the previous state in an object\r\n    let lastAction = \"populateOtherColumn\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n        \"tableHeader\":this.state.tableHeader,\r\n        \"previewColIndex\":this.state.previewColIndex,\r\n        \"otherColText\": this.state.otherColText,\r\n        \"typeRecord\": this.state.typeRecord,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      previewColIndex: -1,\r\n      otherColText: \"\",\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n      typeRecord: typeRecord,\r\n    });\r\n    })\r\n\r\n\r\n    // let tableData = _.cloneDeep(this.state.tableData);\r\n    // let firstDegNeighbours = type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n    // let longestDataArray = [];\r\n    // for (let i = 0; i < tableData.length; ++i) {\r\n    //   let dataArray = firstDegNeighbours[i][neighbour];\r\n    //   // console.log(dataArray);\r\n    //   // If dataArray is empty, this current entry in search column does not have this neighbour at all.\r\n    //   if (dataArray === undefined) {\r\n    //     tableData[i][colIndex].data = \"N/A\";\r\n    //   } \r\n    //   // Otherwise, we have found at least one value. Let's use dataArray[0]\r\n    //   else {\r\n    //     // we first set data for the cell\r\n    //     tableData[i][colIndex].data = dataArray[0];\r\n    //     // we then set origin for the cell. The origin depends on whether type is \"subject\" or \"object\"\r\n    //     let originToAdd = type === \"subject\" ? neighbour + \":\" + dataArray[0] : \"is \" + neighbour + \" of:\" + dataArray[0];\r\n    //     let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n    //     keyOrigin.push(originToAdd);\r\n    //     tableData[i][colIndex].origin = keyOrigin;\r\n    //     // If dataArray's length is longer than longestDataArray's length, we want to update it\r\n    //     if (dataArray.length > longestDataArray.length) {\r\n    //       longestDataArray = dataArray;\r\n    //     }\r\n    //   }\r\n    // }\r\n    // // console.log(longestDataArray);\r\n    // let maxCount = Math.min(longestDataArray.length, maxNeighbourCount);\r\n    // let remainNeighbourCount = maxCount - 1;\r\n\r\n    // console.log(remainNeighbourCount);\r\n    \r\n    // // Now we set up the content for ActionPanel\r\n    // let tempObj = {};\r\n\r\n    // // In this case, we give users option to populate duplicate neighbours\r\n    // if (remainNeighbourCount > 0) {\r\n    //   tempObj[\"task\"] = \"populateSameNeighbour\";\r\n    //   tempObj[\"colIndex\"] = colIndex;\r\n    //   tempObj[\"neighbour\"] = neighbour;\r\n    //   tempObj[\"type\"] = type;\r\n    //   tempObj[\"numCols\"] = remainNeighbourCount;\r\n    //   if (range !== undefined) {\r\n    //     tempObj[\"range\"] = range;\r\n    //   }\r\n    // }\r\n    // // In this case, users are not populating column with duplicate names, but it has a range.\r\n    // // We may need to ask user if they want to populate other columns from the same range\r\n    // else if (range !== undefined) {\r\n    //   let siblingNeighbour = [];\r\n    //   // console.log(\"Range is \"+range);\r\n    //   // console.log(this.state.keyColNeighbours);\r\n    //   for (let i = 0; i < this.state.keyColNeighbours.length; ++i) {\r\n    //     if (\r\n    //       this.state.keyColNeighbours[i].range === range &&\r\n    //       this.state.keyColNeighbours[i].value !== neighbour\r\n    //     ) {\r\n    //       siblingNeighbour.push(this.state.keyColNeighbours[i]);\r\n    //     }\r\n    //   }\r\n    //   // If we have found columns from the same range (other than the current neighbour),\r\n    //   console.log(siblingNeighbour);\r\n    //   // If sibling neighbour is non-empty, we give user the option to populate other columns from the same range.\r\n    //   if (siblingNeighbour.length > 0) {\r\n    //     // Let's do some string processing to improve UI clarity\r\n    //     let rangeLiteral = \"\";\r\n    //     if (range.includes(\"http://dbpedia.org/ontology/\")) {\r\n    //       rangeLiteral = range.slice(28);\r\n    //     } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\r\n    //       rangeLiteral = range.slice(33);\r\n    //     } else {\r\n    //       rangeLiteral = range;\r\n    //     }\r\n    //     tempObj[\"task\"] = \"populateSameRange\";\r\n    //     tempObj[\"colIndex\"] = colIndex;\r\n    //     tempObj[\"range\"] = rangeLiteral;\r\n    //     // console.log(siblingNeighbour);\r\n    //     tempObj[\"siblingNeighbour\"] = siblingNeighbour;\r\n    //   }\r\n    //   // Else, if we have NOT found anything from the same range, we tell user that they can populate more columns\r\n    //   else {\r\n    //     tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    //   }\r\n    // }\r\n    // // In this case, we tell users that they can populate more columns\r\n    // else {\r\n    //   tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    // }\r\n    // // Support for undo: \r\n    // // Let's save the previous state in an object\r\n    // let lastAction = \"populateOtherColumn\";\r\n    // let prevState = \r\n    //   {\r\n    //     \"curActionInfo\":this.state.curActionInfo,\r\n    //     \"tableData\":this.state.tableData,\r\n    //   };\r\n\r\n    // this.setState({\r\n    //   curActionInfo: tempObj,\r\n    //   tableData: tableData,\r\n    //   lastAction: lastAction,\r\n    //   prevState: prevState,\r\n    // });\r\n  }\r\n\r\n  // This function is a helper function that takes in 9 parameters:\r\n  // Note: this function does not make any fetch requests, thus does NOT involve promises.\r\n\r\n  // 1) colIndex:          index of the column that we just filled (ex. 1, if we just filled in column 1)\r\n  // 2) neighbourArray:    an array of neighbour objects (two important attributes: value, type)\r\n  // 3) numCols:           number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\r\n  \r\n  // 4) keyColIndex:                 original key column index\r\n  // 5) tableHeader:                 original tableHeader\r\n  // 6) tableData:                   original tableData\r\n  // 7) optionsMap:                  original optionsMap\r\n  // 8) selectedClassAnnotation:     original selectedClassAnnotation\r\n\r\n  // 9) fillRecommendation:              When true, decrement requiredLength in code by 1.\r\n\r\n  // and returns an object with 5 values:\r\n  // 1) tableHeader:                tableHeader after modification\r\n  // 2) tableData:                  tableData after modification\r\n  // 3) optionsMap:                 optionsMap after modification\r\n  // 4) selectedClassAnnotation:    selectedClassAnnotation after modification\r\n  // 5) keyColIndex:                keyColIndex after modification\r\n\r\n  addAllNeighbour(\r\n    colIndex,\r\n    neighbourArray,\r\n    numCols,\r\n    keyColIndex,\r\n    tableHeader,\r\n    tableData,\r\n    optionsMap,\r\n    selectedClassAnnotation,\r\n    fillRecommendation\r\n  ) {\r\n    // Let's first check if all the variables are as expected\r\n\r\n    // console.log(\"Column index is: \"+colIndex);\r\n    // console.log(\"NeighbourArray is: \");\r\n    // console.log(neighbourArray);\r\n    // console.log(\"Number of columns to fill is: \"+numCols);\r\n    // console.log(\"Key column index \"+keyColIndex);\r\n    // console.log(\"Table header is: \");\r\n    // console.log(tableHeader);\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Options map is: \");\r\n    // console.log(optionsMap);\r\n    // console.log(\"selected class annotation is \");\r\n    // console.log(selectedClassAnnotation);\r\n    // console.log(\"End of attributes check\\n\\n\\n\\n\");\r\n\r\n    // First thing should be to insert \"numCols\" number of empty columns right after column with index \"colIndex\"\r\n    const rowNum = tableData.length;\r\n    const colNum = tableData[0].length;\r\n\r\n    // Let's check if we need to modify keyColIndex:\r\n    // if colIndex < keyColIndex, we need to increase keyColIndex by numCols\r\n    let keyColIndexUpdated = keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      keyColIndexUpdated+=numCols;\r\n    }\r\n    // console.log(\"Updated key column index is \"+keyColIndexUpdated);\r\n\r\n    // We first take care of table data's (empty) additions\r\n    let tableDataUpdated = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(tableData[i][j]);\r\n      }\r\n      // we add in numCols number of empty columns\r\n      for (let j = 0; j < numCols; ++j) {\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(tableData[i][k]);\r\n      }\r\n      tableDataUpdated.push(tempRow);\r\n    }\r\n    // console.log(\"Updated table data is \");\r\n    // console.log(tableDataUpdated);\r\n\r\n    // we now take care of table header's addition.\r\n    let tableHeaderUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeaderUpdated.push(tableHeader[j]);\r\n    }\r\n    // Now we decide what the newly pushed tableHeader should look like\r\n    let newTableHeader;\r\n    // If we are not populating new suggestions, we simply use tableHeader[colIndex]\r\n    if (fillRecommendation === false) {\r\n      newTableHeader = tableHeader[colIndex];\r\n    }\r\n    // else, it is an length one array of object. Object has 2 properties: value and label\r\n    else {\r\n      // We need to figure out what this label is\r\n      let keyColLabel = \"\";\r\n      for (let i = 0; i < tableHeader[keyColIndex].length; ++i) {\r\n        let labelToAdd = i > 0 ? \"&\" + tableHeader[keyColIndex][i].label : tableHeader[keyColIndex][i].label;\r\n        keyColLabel+=labelToAdd;\r\n      }\r\n      let ownLabel = neighbourArray[0].type === \"subject\" ? neighbourArray[0].value : \"is \" + neighbourArray[0].value + \" of\";\r\n      newTableHeader = [\r\n        {\r\n          \"value\" : neighbourArray[0].value,\r\n          \"label\" : ownLabel + \"--\" + keyColLabel,\r\n          \"type\"  : neighbourArray[0].type,\r\n        }\r\n      ]\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      tableHeaderUpdated.push(newTableHeader);\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeaderUpdated.push(tableHeader[k]);\r\n    }\r\n    // console.log(\"Updated table header is \");\r\n    // console.log(tableHeaderUpdated);\r\n\r\n    // We now take care of selectedClassAnnotation. For now, we just add some empty arrays to it\r\n    let selectedClassAnnotationUpdated = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      selectedClassAnnotationUpdated.push([]);\r\n    }\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[k]);\r\n    }\r\n    // console.log(\"Updated class annotation is \");\r\n    // console.log(selectedClassAnnotationUpdated);\r\n\r\n    // we now take care of optionMap's addition. We just need to add some empty arrays to it\r\n    let optionsMapUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      optionsMapUpdated.push(optionsMap[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      optionsMapUpdated.push([]);\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      optionsMapUpdated.push(optionsMap[k]);\r\n    }\r\n    // console.log(\"Updated options map is \");\r\n    // console.log(optionsMapUpdated);\r\n\r\n    // Finally, we fill in the actual data for tableData. We need to take care of both data and origin\r\n\r\n    // Outer loop loops over all rows in the table\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray corresponds to the dataArray for each entry from the search column\r\n      let curColumnArray = [];\r\n      // we loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours =\r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // console.log(curColumnArray);\r\n      for (let curCol = colIndex + 1; curCol < colIndex + 1 + numCols; ++curCol) {\r\n        // Starting value for requiredLength is 2\r\n        let requiredLength = fillRecommendation === true ? curCol - colIndex : curCol - colIndex + 1;\r\n        // If curColumnArray's length does not meet the required length, we simply set data to N/A\r\n        if (curColumnArray.length < requiredLength) {\r\n          let curData = \"N/A\";\r\n          tableDataUpdated[i][curCol].data = curData;\r\n          // Note that we still want to set origin to support autofill\r\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n          keyOrigin.push(originToAdd);\r\n          tableData[i][colIndex].origin = keyOrigin;\r\n        }\r\n        else {\r\n          // We first set the data of the cell\r\n          let value = curColumnArray[requiredLength - 1];\r\n          tableDataUpdated[i][curCol].data = value;\r\n          // We then set the origin of the cell\r\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + value;\r\n          let keyOrigin = tableDataUpdated[i][keyColIndexUpdated].origin.slice();\r\n          keyOrigin.push(originToAdd);\r\n          tableDataUpdated[i][curCol].origin = keyOrigin;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      tableHeader: tableHeaderUpdated,\r\n      tableData: tableDataUpdated,\r\n      optionsMap: optionsMapUpdated,\r\n      selectedClassAnnotation: selectedClassAnnotationUpdated,\r\n      keyColIndex: keyColIndexUpdated,\r\n    };\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in different rows, if that neighbour has multiple occurences.\r\n  // It should modify both tableData and firstDegNeighbours, but not keyColNeighbours.\r\n  // This is because we are not removing, or adding anything new, to the search column.\r\n\r\n  sameNeighbourDiffRow(e,colIndex,neighbourArray) {\r\n\r\n    // First we take a look at the parameters passed in\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n    // console.log(this.state.tableData);\r\n\r\n    let tableDataUpdated = [];\r\n    let subjectNeighbours = [];\r\n    let objectNeighbours = [];\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    let firstDegNeighbours = _.cloneDeep(this.state.firstDegNeighbours);\r\n\r\n    // The first loop deals with tableData's additions \r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We first create a deep copy of the current row\r\n      let curRow = _.cloneDeep(tableData[i]);\r\n      // If the current cell in the selected column does NOT have dataArray attribute, we push it onto tableData as it is\r\n      if (curRow[colIndex].dataArray === undefined) {\r\n        tableDataUpdated.push(curRow);\r\n      }\r\n      // Else, we have to push on dataArray.length number of new rows onto tableData.\r\n      // We need to take care of the new cell's data, origin, and dataArray\r\n      else {\r\n        // First, we still need to push on curRow\r\n        tableDataUpdated.push(curRow);\r\n        // Then, we deal with rows that are not in the original table\r\n        for (let j = 0; j < curRow[colIndex].dataArray.length; ++j) {\r\n          let rowToAdd = _.cloneDeep(curRow);\r\n          // We set data\r\n          rowToAdd[colIndex].data = curRow[colIndex].dataArray[j];\r\n          // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + curRow[colIndex].dataArray[j];\r\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n          keyOrigin.push(originToAdd);\r\n          rowToAdd[colIndex].origin = keyOrigin;\r\n          // Lastly, we remove the dataArray attribute from rowToAdd\r\n          delete rowToAdd[colIndex].dataArray;\r\n          tableDataUpdated.push(rowToAdd);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The second loop deals with firstDegNeighbours's additions\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We first create a deep copy of the current row\r\n      let curRow = _.cloneDeep(tableData[i]);\r\n      // If the current cell in the selected column does NOT have dataArray attribute\r\n      // We push onto subjectNeighbours and objectNeighbours once\r\n      if (curRow[colIndex].dataArray === undefined) {\r\n        subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\r\n        objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\r\n      }\r\n      // Else, we have to push onto subject/objectNeighbours 1 + dataArray.length times.\r\n      else {\r\n        for (let j = 0; j < 1 + curRow[colIndex].dataArray.length; ++j) {\r\n          subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\r\n          objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\r\n        }\r\n      }\r\n    }\r\n    let firstDegNeighboursUpdated = \r\n      {\r\n        \"subject\":subjectNeighbours,\r\n        \"object\":objectNeighbours,\r\n      }\r\n    // We take a look at updated tableData and firstDegNeighbours\r\n    // console.log(tableDataUpdated);\r\n    // console.log(firstDegNeighboursUpdated);\r\n\r\n    // Now we set up the obj for Action Panel\r\n    // We check if the curActionInfo's task is sameNeighbourAndRecommendation or populateSameNeighbour\r\n    let tempObj = {};\r\n    let curActionInfo = _.cloneDeep(this.state.curActionInfo);\r\n\r\n    // If it is sameNeighbourAndRecommendation, we will turn it to populateRecommendation\r\n    if (curActionInfo.task === \"sameNeighbourAndRecommendation\") {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\r\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \r\n    }\r\n    // Else, if it is sameNeighbourAndStartRecommend, we will turn it to showStartRecommend\r\n    else if (curActionInfo.task === \"sameNeighbourAndStartRecommend\") {\r\n      tempObj[\"task\"] = \"showStartRecommend\";\r\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\r\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \r\n    }\r\n    // Else, we turn the current action into afterPopulateColumn\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for undo: \r\n    // Let's save the previous state in an object\r\n    let lastAction = \"sameNeighbourDiffRow\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n        \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableDataUpdated,\r\n      firstDegNeighbours: firstDegNeighboursUpdated,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in the same columns, if that neighbour has multiple occurences.\r\n\r\n  sameNeighbourOneRow(e, colIndex, neighbourArray) {\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n    // console.log(numCols);\r\n\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // Outer loop loops over all rows in the table\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray corresponds to the dataArray for each entry from the search column\r\n      let curColumnArray = [];\r\n      // we loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        // console.log(curNeighbour.value);\r\n        let firstDegNeighbours =\r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(firstDegNeighbours);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          // console.log(curNeighbourData);\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // console.log(curColumnArray);\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        let curData = \"N/A\"\r\n        tableData[i][colIndex].data = curData;\r\n        // we still need to set the origin for the cell\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n      // Otherwise, we have found at least one value. And we want to set up the data and origin. \r\n      else {\r\n        // we first set the data for the cell using all values from curColumnArray (this is different from populateOtherColumn)\r\n        let curData = \"\";\r\n        for (let k = 0; k < curColumnArray.length; ++k) {\r\n          let dataToAdd = k > 0 ? \";\" + curColumnArray[k] : curColumnArray[k];\r\n          curData+=dataToAdd;\r\n          // console.log(\"Data to add is \"+dataToAdd);\r\n          // console.log(\"Current data is \"+curData);\r\n        }\r\n        tableData[i][colIndex].data = curData;\r\n        // we then set the origin for the cell\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n    }\r\n\r\n    // Now we set up the obj for Action Panel\r\n    // We check if the curActionInfo's task is sameNeighbourAndRecommendation or populateSameNeighbour\r\n    let tempObj = {};\r\n    let curActionInfo = _.cloneDeep(this.state.curActionInfo);\r\n\r\n    // If it is sameNeighbourAndRecommendation, we will turn it to populateRecommendation\r\n    if (curActionInfo.task === \"sameNeighbourAndRecommendation\") {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\r\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \r\n    }\r\n    // Else, if it is sameNeighbourAndStartRecommend, we will turn it to showStartRecommend\r\n    else if (curActionInfo.task === \"sameNeighbourAndStartRecommend\") {\r\n      tempObj[\"task\"] = \"showStartRecommend\";\r\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\r\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \r\n    }\r\n    // Else, we turn the current action into afterPopulateColumn\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for undo: \r\n    let lastAction = \"sameNeighbourOneRow\";\r\n    let prevState = \r\n      {\r\n        \"curActionInfo\":this.state.curActionInfo,\r\n        \"tableData\":this.state.tableData,\r\n      };\r\n\r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following function populates one recommendation neighbour\r\n  // This function should be very similar to populateStartRecommend\r\n  populateRecommendation(e, colIndex, neighbourArray) {\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n\r\n    document.body.classList.add('waiting');\r\n\r\n    // First thing we need to do should be the same as contextAddColumn\r\n    const rowNum = this.state.tableData.length;\r\n    const colNum = this.state.tableData[0].length;\r\n\r\n    // we first take care of table data's addition\r\n    let tableData = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(this.state.tableData[i][j]);\r\n      }\r\n      // we add in one column of empty data\r\n      tempRow.push({ data: \"\", origin: [] });\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(this.state.tableData[i][k]);\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    // console.log(tableData);\r\n\r\n    // we now take care of tabler header, and selectedClassAnnotation's addition\r\n    let tableHeader = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeader.push(this.state.tableHeader[j]);\r\n    }\r\n    tableHeader.push([]);\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeader.push(this.state.tableHeader[k]);\r\n    }\r\n    // console.log(tableHeader);\r\n\r\n    // we now take care of selectedClassAnnotation\r\n    let selectedClassAnnotation = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\r\n    }\r\n    selectedClassAnnotation.push([]);\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\r\n    }\r\n    // console.log(selectedClassAnnotation);\r\n\r\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\r\n    let keyColIndex = this.state.keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      ++keyColIndex;\r\n    }\r\n    // console.log(keyColIndex);\r\n\r\n    // Now, the part that's the same as contextAddColumn is over.\r\n    // The part below will be largely the same as populateOtherColumn.\r\n\r\n    // An important things for us to do how is to increment colIndex\r\n    ++colIndex;\r\n\r\n    // We use a boolean to keep track of if any cell contains multiple values\r\n    let hasMultiple = false;\r\n\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\r\n      let curColumnArray = [];\r\n      // We loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours = \r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        // console.log(firstDegNeighbours);\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        let curData = \"N/A\";\r\n        tableData[i][colIndex].data = curData;\r\n        // we still need to set origin for the data to support auto-fill\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n      // Otherwise, we have found at least one value.\r\n      else {\r\n        // we first set the data for the cell using curColumnArray[0]\r\n        tableData[i][colIndex].data = curColumnArray[0];\r\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\r\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n        // console.log(keyOrigin)\r\n\r\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\r\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\r\n        if (curColumnArray.length > 1) {\r\n          hasMultiple = true;\r\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\r\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\r\n        } \r\n      }\r\n    }\r\n    // Now, we are done with updating tableData.\r\n    // We want to update tableHeader as well.\r\n    tableHeader[colIndex] = neighbourArray;\r\n\r\n    // In the third part of the code, We start setting up the content for the Action Panel.\r\n\r\n    // First thing we want to do is to update the recommendArray: \r\n    // We want to remove the recommendation just added from the recommendArray\r\n    let recommendArray = _.cloneDeep(this.state.curActionInfo.recommendArray)\r\n    let curRecommendation = neighbourArray[0];\r\n    let sliceIndex = -1;\r\n\r\n    // This for loop checks which index we want to remove\r\n    for (let i = 0; i < recommendArray.length; ++i) {\r\n      if (recommendArray[i].value === curRecommendation.value && recommendArray[i].type === curRecommendation.type) {\r\n        sliceIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // console.log(sliceIndex);\r\n    // console.log(curRecommendation);\r\n    // console.log(recommendArray);\r\n    \r\n    // This if condition removes the found element\r\n    if (sliceIndex !== -1) {\r\n      recommendArray.splice(sliceIndex, 1);\r\n    }\r\n\r\n    // tempObj stores the information passed to ActionPanel\r\n    let tempObj = {};\r\n    // console.log(this.state.curActionInfo);\r\n    if (hasMultiple === true && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"sameNeighbourAndRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    else if (hasMultiple === false && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"populateRecommendation\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    else if (hasMultiple === true) {\r\n      tempObj[\"task\"] = \"populateSameNeighbour\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n    }\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\"\r\n    }\r\n\r\n    // console.log(tableData);\r\n    // console.log(tableHeader);\r\n    // console.log(selectedClassAnnotation);\r\n    // console.log(keyColIndex);\r\n    // console.log(tempObj);\r\n\r\n    // Support for updating typeRecord. To do this, we have to first get the typeRecord for the column just added.\r\n    // We first randomly get a number of (Math.min(tableData.length, numForTree)) samples from tableData\r\n    let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, colIndex);\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n    // to support semantic tree\r\n    let curColumnRecord = buildTypeRecord(sampleRows, colIndex, values)\r\n    // we now add the curColumnRecord to typeRecord\r\n    let typeRecord = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      typeRecord.push(this.state.typeRecord[j]);\r\n    }\r\n    typeRecord.push(curColumnRecord);\r\n    for (let k = colIndex; k < colNum; ++k) {\r\n      typeRecord.push(this.state.typeRecord[k]);\r\n    }\r\n\r\n    // console.log(typeRecord);\r\n\r\n    document.body.classList.remove('waiting');\r\n\r\n    // Lastly, we add support for undo, and set the states\r\n    let lastAction = \"populateRecommendation\";\r\n    let prevState =\r\n      {\r\n        \"tableData\": this.state.tableData,\r\n        \"tableHeader\": this.state.tableHeader,\r\n        \"curActionInfo\": this.state.curActionInfo,\r\n        \"keyColIndex\": this.state.keyColIndex,\r\n        \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n        \"tabIndex\": this.state.tabIndex,\r\n        \"previewColIndex\": this.state.previewColIndex,\r\n        \"typeRecord\": this.state.typeRecord,\r\n      } \r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      selectedClassAnnotation: selectedClassAnnotation,\r\n      keyColIndex: keyColIndex,\r\n      curActionInfo: tempObj,\r\n      tabIndex: 0,\r\n      previewColIndex: -1,\r\n      prevState: prevState,\r\n      lastAction: lastAction,\r\n      typeRecord: typeRecord,\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function\r\n\r\n  createStartRecommend(keyColNeighbours) {\r\n    let recommendArray = [];\r\n    let numRecommend = Math.min(5, keyColNeighbours.length);\r\n    for (let i = 0; i < numRecommend; ++i) {\r\n      recommendArray.push(keyColNeighbours[i]);\r\n    }\r\n    return recommendArray;\r\n  }\r\n\r\n  // This function below should mostly be similar to populateRecommendation, with some small differences. \r\n\r\n  populateStartRecommend(e, colIndex, neighbourArray) {\r\n    // console.log(colIndex);\r\n    // console.log(neighbourArray);\r\n    // console.log(this.state.curActionInfo);\r\n\r\n    document.body.classList.add('waiting');\r\n\r\n    // First thing we need to do should be the same as contextAddColumn\r\n    const rowNum = this.state.tableData.length;\r\n    const colNum = this.state.tableData[0].length;\r\n\r\n    // we first take care of table data's addition\r\n    let tableData = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(this.state.tableData[i][j]);\r\n      }\r\n      // we add in one column of empty data\r\n      tempRow.push({ data: \"\", origin: [] });\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(this.state.tableData[i][k]);\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    // console.log(tableData);\r\n\r\n    // we now take care of tabler header, and selectedClassAnnotation's addition\r\n    let tableHeader = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeader.push(this.state.tableHeader[j]);\r\n    }\r\n    tableHeader.push([]);\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeader.push(this.state.tableHeader[k]);\r\n    }\r\n    // console.log(tableHeader);\r\n\r\n    // we now take care of selectedClassAnnotation\r\n    let selectedClassAnnotation = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\r\n    }\r\n    selectedClassAnnotation.push([]);\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\r\n    }\r\n    // console.log(selectedClassAnnotation);\r\n\r\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\r\n    let keyColIndex = this.state.keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      ++keyColIndex;\r\n    }\r\n    // console.log(keyColIndex);\r\n\r\n    // Now, the part that's the same as contextAddColumn is over.\r\n    // The part below will be largely the same as populateOtherColumn.\r\n\r\n    // An important things for us to do how is to increment colIndex\r\n    ++colIndex;\r\n\r\n    // We use a boolean to keep track of if any cell contains multiple values\r\n    let hasMultiple = false;\r\n\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\r\n      let curColumnArray = [];\r\n      // We loop through the neighbourArray\r\n      for (let j = 0; j < neighbourArray.length; ++j) {\r\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\r\n        let curNeighbour = neighbourArray[j];\r\n        let firstDegNeighbours = \r\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\r\n        // console.log(firstDegNeighbours);\r\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\r\n        // If yes, we want to concat those values with curColumnArray\r\n        if (curNeighbourData !== undefined) {\r\n          curColumnArray = curColumnArray.concat(curNeighbourData);\r\n        }\r\n      }\r\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\r\n      if (curColumnArray.length === 0) {\r\n        let curData = \"N/A\";\r\n        tableData[i][colIndex].data = curData;\r\n        // we still need to set origin so that we can support autofill\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\r\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n      }\r\n      // Otherwise, we have found at least one value.\r\n      else {\r\n        // we first set the data for the cell using curColumnArray[0]\r\n        tableData[i][colIndex].data = curColumnArray[0];\r\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\r\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n        keyOrigin.push(originToAdd);\r\n        tableData[i][colIndex].origin = keyOrigin;\r\n        // console.log(keyOrigin)\r\n\r\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\r\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\r\n        if (curColumnArray.length > 1) {\r\n          hasMultiple = true;\r\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\r\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\r\n        } \r\n      }\r\n    }\r\n    // Now, we are done with updating tableData.\r\n    // We want to update tableHeader as well.\r\n    tableHeader[colIndex] = neighbourArray;\r\n\r\n    // In the third part of the code, We start setting up the content for the Action Panel.\r\n\r\n    // First thing we want to do is to update the recommendArray: \r\n    // We want to remove the recommendation just added from the recommendArray\r\n    let recommendArray = _.cloneDeep(this.state.curActionInfo.recommendArray)\r\n    let curRecommendation = neighbourArray[0];\r\n    let sliceIndex = -1;\r\n\r\n    // This for loop checks which index we want to remove\r\n    for (let i = 0; i < recommendArray.length; ++i) {\r\n      if (recommendArray[i].value === curRecommendation.value && recommendArray[i].type === curRecommendation.type) {\r\n        sliceIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // console.log(sliceIndex);\r\n    // console.log(curRecommendation);\r\n    // console.log(recommendArray);\r\n    \r\n    // This if condition removes the found element\r\n    if (sliceIndex !== -1) {\r\n      recommendArray.splice(sliceIndex, 1);\r\n    }\r\n\r\n    // tempObj stores the information passed to ActionPanel\r\n    let tempObj = {};\r\n    // console.log(this.state.curActionInfo);\r\n    if (hasMultiple === true && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"sameNeighbourAndStartRecommend\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    else if (hasMultiple === false && recommendArray.length > 0) {\r\n      tempObj[\"task\"] = \"showStartRecommend\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"recommendArray\"] = recommendArray;\r\n    }\r\n    else if (hasMultiple === true) {\r\n      tempObj[\"task\"] = \"populateSameNeighbour\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbourArray\"] = neighbourArray;\r\n    }\r\n    else {\r\n      tempObj[\"task\"] = \"afterPopulateColumn\";\r\n    }\r\n\r\n    // Support for updating typeRecord. To do this, we have to first get the typeRecord for the column just added.\r\n    // We first randomly get a number of (Math.min(tableData.length, numForTree)) samples from tableData\r\n    let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, colIndex);\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n    // to support semantic tree\r\n    let curColumnRecord = buildTypeRecord(sampleRows, colIndex, values)\r\n    // we now add the curColumnRecord to typeRecord\r\n    let typeRecord = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      typeRecord.push(this.state.typeRecord[j]);\r\n    }\r\n    typeRecord.push(curColumnRecord);\r\n    for (let k = colIndex; k < colNum; ++k) {\r\n      typeRecord.push(this.state.typeRecord[k]);\r\n    }\r\n\r\n    // console.log(tableData);\r\n    // console.log(tableHeader);\r\n    // console.log(selectedClassAnnotation);\r\n    // console.log(keyColIndex);\r\n    // console.log(tempObj);\r\n    // console.log(typeRecord);\r\n\r\n    // Lastly, we add support for undo, and set the states\r\n\r\n    document.body.classList.remove('waiting');\r\n\r\n    let lastAction = \"populateStartRecommend\";\r\n    let prevState =\r\n      {\r\n        \"tableData\": this.state.tableData,\r\n        \"tableHeader\": this.state.tableHeader,\r\n        \"curActionInfo\": this.state.curActionInfo,\r\n        \"keyColIndex\": this.state.keyColIndex,\r\n        \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n        \"tabIndex\": this.state.tabIndex,\r\n        \"previewColIndex\": this.state.previewColIndex,\r\n        \"typeRecord\": this.state.typeRecord,\r\n      } \r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      selectedClassAnnotation: selectedClassAnnotation,\r\n      keyColIndex: keyColIndex,\r\n      curActionInfo: tempObj,\r\n      tabIndex: 0,\r\n      previewColIndex: -1,\r\n      prevState: prevState,\r\n      lastAction: lastAction,\r\n      typeRecord: typeRecord,\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function adds a new column to the table, to the right of the selected column.\r\n  // In here, let's also set tabIndex to 0.\r\n\r\n  contextAddColumn(e, colIndex) {\r\n    const rowNum = this.state.tableData.length;\r\n    const colNum = this.state.tableData[0].length;\r\n\r\n    // we first take care of table data's addition\r\n    let tableData = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(this.state.tableData[i][j]);\r\n      }\r\n      // we add in one column of empty data\r\n      tempRow.push({ data: \"\", origin: [] });\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(this.state.tableData[i][k]);\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n\r\n    // we now take care of tabler header, and selectedClassAnnotation's addition\r\n    let tableHeader = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeader.push(this.state.tableHeader[j]);\r\n    }\r\n    tableHeader.push([]);\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeader.push(this.state.tableHeader[k]);\r\n    }\r\n\r\n    // we now take care of selectedClassAnnotation\r\n    let selectedClassAnnotation = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\r\n    }\r\n    selectedClassAnnotation.push([]);\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\r\n    }\r\n\r\n    // we now take care of typeRecord\r\n    let typeRecord = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      typeRecord.push(this.state.typeRecord[j]);\r\n    }\r\n    typeRecord.push([]);\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      typeRecord.push(this.state.typeRecord[k]);\r\n    }\r\n    // console.log(typeRecord);\r\n\r\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\r\n    let keyColIndex = this.state.keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      ++keyColIndex;\r\n    }\r\n\r\n    // console.log(this.state.selectedClassAnnotation);\r\n    // console.log(tableHeader);\r\n\r\n    // Support for undo: \r\n    let lastAction = \"contextAddColumn\";\r\n    let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"tableHeader\": this.state.tableHeader,\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n          \"keyColIndex\": this.state.keyColIndex,\r\n          \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n          \"tabIndex\": this.state.tabIndex,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n          \"typeRecord\": this.state.typeRecord,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n      keyColIndex: keyColIndex,\r\n      selectedClassAnnotation: selectedClassAnnotation,\r\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n      previewColIndex: -1, // we want to set the preview column index to -1\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n      typeRecord: typeRecord,\r\n    });\r\n  }\r\n  \r\n  // The following function handles the deletion of a selected column.\r\n  // This function should be largely similar to contextAddColumn\r\n\r\n  contextDeleteColumn(e, colIndex) {\r\n    // console.log(\"This is the column we are trying to delete \"+colIndex);\r\n\r\n    // We disable the deletion of the search column\r\n    if (colIndex === this.state.keyColIndex) {\r\n      alert(\"The current column is the search column.\\n\\nPlease set another search column before deleting the current column.\");\r\n    }\r\n\r\n    // We also disable the deletion of the first column\r\n    else if (colIndex === 0) {\r\n      alert(\"Deleting the first column causes unexpected behavior.\\n\\nPlease do not delete the first column.\");\r\n    }\r\n\r\n    // Else, we can proceed to deletion.\r\n    else {\r\n      // We handle tableData, tableHeader, optionsMap, selectedClassAnnotation, and typeRecord's deletion\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      let tableHeader = this.state.tableHeader.slice();\r\n      let optionsMap = this.state.optionsMap.slice();\r\n      let selectedClassAnnotation = this.state.selectedClassAnnotation.slice();\r\n      let typeRecord = _.cloneDeep(this.state.typeRecord);\r\n\r\n      // tableData\r\n      for (let i = 0; i < tableData.length; ++i) {\r\n        tableData[i].splice(colIndex, 1);\r\n      }\r\n      // tableHeader, optionsMap, selectedClassAnnotation, and typeRecord\r\n      tableHeader.splice(colIndex, 1);\r\n      optionsMap.splice(colIndex, 1);\r\n      if (colIndex > 0) {\r\n        selectedClassAnnotation.splice(colIndex-1, 1);\r\n      }\r\n      typeRecord.splice(colIndex, 1);\r\n      // console.log(typeRecord);\r\n\r\n      // If colIndex is less than keyColIndex, we need to decrease keyColIndex by 1, if keyColIndex > 0\r\n      let keyColIndex = this.state.keyColIndex;\r\n      if (colIndex < keyColIndex) {\r\n        --keyColIndex;\r\n      }\r\n\r\n      // When we are deleting a column, we do not necessarily want to go to tab 0.\r\n      // However, if we are in tab 1, we want to toggle off all property neighbours\r\n      let propertyNeighbours = _.cloneDeep(this.state.propertyNeighbours);\r\n      if (this.state.tabIndex === 1) {\r\n        for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n          propertyNeighbours[i].isOpen = false;\r\n        }\r\n      }\r\n\r\n      // Support for undo: \r\n      let lastAction = \"contextDeleteColumn\";\r\n      let prevState = \r\n          {\r\n            \"tableData\": this.state.tableData,\r\n            \"tableHeader\": this.state.tableHeader,\r\n            \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n            \"keyColIndex\": this.state.keyColIndex,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n            \"propertyNeighbours\": this.state.propertyNeighbours,\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n            \"typeRecord\": this.state.typeRecord,\r\n          };\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        tableHeader: tableHeader,\r\n        selectedClassAnnotation: selectedClassAnnotation,\r\n        typeRecord: typeRecord,\r\n        keyColIndex: keyColIndex,\r\n        previewColIndex: -1, // we want to set the preview column index to -1\r\n        propertyNeighbours: propertyNeighbours,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the sorting of a column from context menu.\r\n  // It is a prototype. Needs to be refined in the future.\r\n\r\n  contextSortColumn(e, colIndex, order) {\r\n    // console.log(\"The column we are sorting is \"+colIndex);\r\n    document.body.classList.add('waiting');\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // We first loop through this column to determine if it's a numeric column or a string column\r\n    let numericCol = true;\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We only care about entries that are not N/A\r\n      if (tableData[i][colIndex].data !== \"N/A\") {\r\n        if (isNaN(Number(tableData[i][colIndex].data))) {\r\n          numericCol = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // In this case we are sorting a numerical column\r\n    if (numericCol) {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return Number(aValue) - Number(bValue);\r\n          }\r\n          else {\r\n            return Number(bValue) - Number(aValue);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // In this case we are sorting a string-based column\r\n    else {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return aValue < bValue ? -1 : 1;\r\n          }\r\n          else {\r\n            return aValue < bValue ? 1 : -1;\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n\r\n    // We need a bugfix here: since tableData is reordered, firstColSelection now do not have the correct data anymore.\r\n    // We have to update firstColSelection to include the correct data.\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo: \r\n      let lastAction = \"contextSortColumn\";\r\n      let prevState = \r\n          {\r\n            \"tableData\": this.state.tableData,\r\n            \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function dedups the selected column.\r\n  // Note: this function has to make modifications to both firstDegNeighbours and keyColNeighbours\r\n\r\n  contextDedupColumn(e, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(colIndex);\r\n    // console.log(tableData);\r\n\r\n    // We simply dedup this column by calling the uniqBy function from the lodash library\r\n    tableData = _.uniqBy(tableData, function(x) {return x[colIndex].data;});\r\n    // console.log(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Now we deal with firstDegNeighbours and keyColNeighbours' updates\r\n    // Since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo:\r\n      let lastAction = \"contextDedupColumn\";\r\n      let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"keyColNeighbours\": this.state.keyColNeighbours,\r\n          \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n          \"tabIndex\": this.state.tabIndex,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n        }\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        tabIndex: 0,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function handles click event on the filter icon.\r\n  // We want to let the Action Panel display 4 different filtering methods:\r\n  // 1) Sort ascending\r\n  // 2) Sort descending\r\n  // 3) Filter\r\n  // 4) Dedup\r\n\r\n  showFilterMethods(e, colIndex) {\r\n    // console.log(\"Selected column is \"+colIndex);\r\n\r\n    // We just need to pass on the colIndex\r\n    let tempObj = {};\r\n    tempObj[\"task\"] = \"showFilterMethods\";\r\n    tempObj[\"colIndex\"] = colIndex;\r\n    \r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tabIndex: 0, // we also want to set the currentlly active tab index to 0\r\n      previewColIndex: -1, // we also want to set preview column index to -1 (clear previews)\r\n    })\r\n  }\r\n\r\n  // The following functions sets the selected column to be the search column.\r\n\r\n  contextSetColumn(e, colIndex) {\r\n\r\n    // console.log(\"Col index of search cell is \"+colIndex);\r\n\r\n    // Let's do a preliminary check here to make sure that users do not set empty columns as search columns\r\n    let colEmpty = true;\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      if (this.state.tableData[i][colIndex].data !== \"\") {\r\n        colEmpty = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // We give users an alert if they try to set an empty columns as the search column\r\n    if (colEmpty === true) {\r\n      alert(\"This column is currently empty. Try set the data for this column before setting it as the search column.\");\r\n    }\r\n    else {\r\n      document.body.classList.add('waiting');\r\n\r\n      // Code here should largely be similar to what we have in populateKeyColumn\r\n\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n      // We need to find neighbours of a column.\r\n      // We need to use tableData to ask more queries (number of queries is equal to tableData.length)\r\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\r\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\r\n\r\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n        // We call updateNeighbourInfo here because we are changing the rows\r\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n        // Lastly, we set up the information for the action panel\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"showStartRecommend\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"recommendArray\"] = this.createStartRecommend(keyColNeighbours);\r\n\r\n        document.body.classList.remove('waiting');\r\n\r\n        // Support for undo: \r\n        let lastAction = \"contextSetColumn\";\r\n        let prevState = \r\n            {\r\n              \"keyColIndex\": this.state.keyColIndex,\r\n              \"keyColNeighbours\": this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n              \"curActionInfo\": this.state.curActionInfo,\r\n              \"tabIndex\": this.state.tabIndex,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n            };\r\n\r\n        this.setState({\r\n          keyColIndex: colIndex,\r\n          keyColNeighbours: keyColNeighbours,\r\n          firstDegNeighbours: firstDegNeighbours,\r\n          curActionInfo: tempObj,\r\n          tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n          previewColIndex: -1,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      })\r\n      })\r\n    }\r\n  }\r\n\r\n  // // The following function displays the origin of a cell in the Action Panel.\r\n\r\n  // contextCellOrigin(e, rowIndex, colIndex) {\r\n  //   // To get the origin of a cell, we simply returns its \"origin field\"\r\n  //   // The trick is to set the origin field correctly in previous functions\r\n  //   // The place to do that should be in the two populating columns\r\n\r\n  //   let cellSelected = this.state.tableData[rowIndex][colIndex];\r\n\r\n  //   let originElement = [];\r\n  //   for (let i = 0; i < cellSelected.origin.length; ++i) {\r\n  //     originElement.push(<p>{niceRender(cellSelected.origin[i])}</p>);\r\n  //   }\r\n\r\n  //   // This origin literal correctly contains the cell Origin we want to display\r\n  //   // Now we just need to show it in the ActionPanel\r\n  //   let tempObj = {};\r\n  //   tempObj[\"task\"] = \"contextCellOrigin\";\r\n  //   tempObj[\"origin\"] = originElement;\r\n\r\n  //   // Support for undo: \r\n  //   let lastAction = \"contextCellOrigin\";\r\n  //   let prevState = \r\n  //       {\r\n  //         \"curActionInfo\": this.state.curActionInfo,\r\n  //         \"tabIndex\": this.state.tabIndex,\r\n  //       };\r\n    \r\n  //   this.setState({\r\n  //     curActionInfo: tempObj,\r\n  //     tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n  //     lastAction: lastAction,\r\n  //     prevState: prevState,\r\n  //   });\r\n  // }\r\n\r\n  // This function has three functionalities: \r\n  // Show the selected cell's origin, show the selected cell's preview, and update the bottom iframe's URL\r\n\r\n  originPreviewPage(e, rowIndex, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    // console.log(\"Row index is \"+rowIndex);\r\n    // console.log(\"Col index is \"+colIndex);\r\n\r\n    // This first part deals with preview\r\n\r\n    // Let's first run queries to fetch the dbp neighbours and dbo neighbours for the selected cell (withe some filtering)\r\n    // In here, we need both the ?p and ?o. This is different from before.\r\n\r\n    let promiseArray = [];\r\n\r\n    // Below is the first query we will make. In here we are using the tableCell as SUBJECT\r\n\r\n    // select ?p ?o\r\n    // where {\r\n    // dbr:Barack_Obama ?p ?o.\r\n    // }\r\n\r\n    let prefixURLOne = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne = \r\n      \"select+%3Fp+%3Fo%0D%0Awhere+%7B%0D%0Adbr%3A\" + \r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \"+%3Fp+%3Fo.%0D%0A%7D&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let otherColPromiseSubject = fetchJSON(queryURLOne);\r\n    promiseArray.push(otherColPromiseSubject);\r\n\r\n    // Below is the second query we will make. In here we are using the tableCell as OBJECT.\r\n\r\n    // select ?p ?o\r\n    // where {\r\n    // ?o ?p dbr:Barack_Obama.\r\n    // }\r\n\r\n    let prefixURLTwo = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"select+%3Fp+%3Fo%0D%0Awhere+%7B%0D%0A%3Fo+%3Fp+dbr%3A\" +\r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \".%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    let otherColPromiseObject = fetchJSON(queryURLTwo);\r\n    promiseArray.push(otherColPromiseObject);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      // console.log(values[0]);\r\n      // console.log(values[1]);\r\n      // let previewInfoArray = [];\r\n      let subjectInfoArray = \r\n        updatePreviewInfo(\r\n          values[0].results.bindings,\r\n          \"subject\"\r\n        );\r\n      let objectInfoArray = \r\n        updatePreviewInfo(\r\n          values[1].results.bindings,\r\n          \"object\"\r\n        );\r\n      // console.log(subjectInfoArray);\r\n      // console.log(objectInfoArray);\r\n\r\n      // // Modified on August 28th: when we double click a cell in the first column, and the first column is the current search column\r\n      // // We want to update firstColSelection and firstColChecked as well\r\n      // let firstColSelection = _.cloneDeep(this.state.firstColSelection);\r\n      // let firstColChecked = _.cloneDeep(this.state.firstColChecked);\r\n\r\n      // if (this.state.keyColIndex === 0 && colIndex === 0) {\r\n      //   // We first update firstColSelection\r\n      //   console.log(values[0].results.bindings);\r\n      //   firstColSelection = updateFirstColSelection(values[0].results.bindings);\r\n      //   // We then update firstColChecked\r\n      //   firstColChecked = [];\r\n      //   for (let i = 0; i < firstColSelection.length; ++i) {\r\n      //     firstColChecked.push(false);\r\n      //   }\r\n      // }\r\n      \r\n      // Here is where we make the modifications: instead of passing information to Action Panel, let's store them as states\r\n      let previewInfoArray = subjectInfoArray.concat(objectInfoArray);\r\n      let previewInfoExpanded = [];\r\n      for (let i = 0; i < previewInfoArray.length; ++i) {\r\n        previewInfoExpanded.push(false);\r\n      }\r\n      let selectedCell = _.cloneDeep(this.state.tableData[rowIndex][colIndex]);\r\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\r\n\r\n      let tempObj = {};\r\n      tempObj[\"task\"] = \"originPreviewPage\";\r\n\r\n      // Support for undo: \r\n      document.body.classList.remove('waiting');\r\n      let lastAction = \"originPreviewPage\";\r\n      let prevState = \r\n          {\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n            \"tabIndex\": this.state.tabIndex,\r\n            \"pageHidden\": this.state.pageHidden,\r\n            \"iframeURL\": this.state.iframeURL,\r\n            \"previewInfoArray\": this.state.previewInfoArray,\r\n            \"previewInfoExpanded\": this.state.previewInfoExpanded,\r\n            \"selectedCell\": this.state.selectedCell,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n            // \"firstColSelection\": this.state.firstColSelection,\r\n            // \"firstColChecked\": this.state.firstColChecked,\r\n          };\r\n      \r\n      this.setState({\r\n        curActionInfo: tempObj,\r\n        tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n        previewColIndex: -1,\r\n        pageHidden: false,\r\n        iframeURL: iframeURL,\r\n        previewInfoArray: previewInfoArray,\r\n        previewInfoExpanded: previewInfoExpanded,\r\n        selectedCell: selectedCell,\r\n        // firstColSelection: firstColSelection, // updated on 9/13\r\n        // firstColChecked: firstColChecked, // updated on 9/13\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n  }\r\n\r\n  toggleTable(e, index) {\r\n    let tableOpenList = this.state.tableOpenList.slice();\r\n    tableOpenList[index] = !tableOpenList[index];\r\n    // When we toggle on one table, we want to close all other tables\r\n    for (let i = 0; i < tableOpenList.length; ++i) {\r\n      if (i !== index) {\r\n        tableOpenList[i] = false;\r\n      }\r\n    }\r\n    this.setState({\r\n      tableOpenList: tableOpenList,\r\n    });\r\n  }\r\n\r\n  // The following function is a helper function for handleStartTable.\r\n\r\n  // It takes in 2 parameters:\r\n  // 1) tableDataExplore\r\n  // 2) selectedClassAnnotation\r\n\r\n  // It returns a Promise of an object with 5 properties:\r\n  // 1) keyColIndex\r\n  // 2) tableHeader\r\n  // 3) tableData\r\n  // 4) keyColNeighbours\r\n  // 5) optionsMap.\r\n\r\n  // This object contains all the information we needed for the Excel-style table.\r\n\r\n  getTableStates(tableDataExplore, selectedClassAnnotation) {\r\n    // We need to take care of keyColIndex, tableHeader, tableData, optionsMap, and keyColNeighbours\r\n\r\n    // tableDataExplore contains all the information we need to set the five states listed above\r\n    // We just need to make use of the \"data\" and \"origin\" attributes. rowSpan and colSpan have no impact here.\r\n    // Also, since we are not modifying tableDataExplore, we do not need to make a copy of it.\r\n\r\n    // First, let's deal with keyColIndex. \r\n    // We will use the first column such that it's class annotation is not [] or [\"Number\"] or [\"originURL\"]\r\n    // If no such column exists, we default it to the first column\r\n\r\n    // console.log(selectedClassAnnotation);\r\n\r\n    let keyColIndex = -1;\r\n    for (let i=0;i<selectedClassAnnotation.length;++i) {\r\n      if (selectedClassAnnotation[i].length > 0 \r\n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"Number\")\r\n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"originURL\")\r\n        ) {\r\n        keyColIndex = i+1; \r\n        break;\r\n      }\r\n    }\r\n    if (keyColIndex === -1) {\r\n      keyColIndex = 0;\r\n    }\r\n    // console.log(\"Key Column Index is: \");\r\n    // console.log(keyColIndex);\r\n\r\n    // Now, let's deal with tableHeader. Note: these tableHeaders only have value and label, no range or type\r\n    // Also note that since table headers can be multi-selects, each tableHeader element is in the form of a length one array\r\n    let tableHeader = [];\r\n    for (let j=0;j<tableDataExplore[0].length;++j) {\r\n      tableHeader.push(\r\n        [\r\n          {\"value\":tableDataExplore[0][j].data\r\n          ,\"label\":tableDataExplore[0][j].data}\r\n        ]\r\n      )\r\n    }\r\n    // console.log(\"Table header is: \");\r\n    // console.log(tableHeader);\r\n\r\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\r\n    let tableData = [];\r\n    // console.log(tableDataExplore);\r\n    // This starts the loop for rows\r\n    for (let i=1;i<tableDataExplore.length;++i) {\r\n      let tempRow = [];\r\n      // This starts the loop for columns\r\n      let minLength = Math.min(tableDataExplore[i].length, tableHeader.length);\r\n      for (let j=0;j<minLength;++j) {\r\n        // First set the data\r\n        let data = tableDataExplore[i][j].data;\r\n        // Then set the origin\r\n        let origin = [];\r\n        // let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j][0].value+\": \"+tableDataExplore[i][j].data;\r\n        let originText = tableHeader[j][0].value+\": \"+tableDataExplore[i][j].data;\r\n        origin.push(originText);\r\n        tempRow.push({\"data\":data,\"origin\":origin});\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    // console.log(\"Table data is: \");\r\n    // console.log(tableData);\r\n\r\n    // Now, let's deal with keyColNeighbours and optionsMap\r\n    // Note: the following part should be similar to what we have in contextSetColumn\r\n\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", keyColIndex);\r\n    return allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    return allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n      \r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      return Promise.resolve(\r\n        {\r\n          \"keyColIndex\":keyColIndex,\r\n          \"tableHeader\":tableHeader,\r\n          \"tableData\":tableData,\r\n          \"keyColNeighbours\":keyColNeighbours,\r\n          \"firstDegNeighbours\":firstDegNeighbours,\r\n        }\r\n      )\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function handles the selection of table.\r\n\r\n  handleStartTable(e, tableIndex) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // We need to let table panel display the selected table\r\n    // And we need to update the Action Panel to display the first degree properties of the original page\r\n    // We do a fetch request here (Sixth Query). It gets the property neighbours of the original page that are links, as well as dct:subject\r\n    // Lastly, we need to set usecaseSelected to \"startSubject\"\r\n\r\n    // First query gets the property neighbours\r\n    let queryPromise = [];\r\n    let prefixURLOne =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne =\r\n      \"SELECT+%3Fp+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(decodeURIComponent(this.state.urlPasted.slice(30))) +\r\n      \"+%3Fp+%3Fo.%0D%0A++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++FILTER%28isIRI%28%3Fo%29+%26%26+regex%28%3FpString%2C%22property%22%2C%22i%22%29+%26%26+%28%21regex%28%3FpString%2C%22text%22%2C%22i%22%29%29%29.%0D%0A%7D%0D%0A&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let queryOne = fetchJSON(queryURLOne);\r\n    queryPromise.push(queryOne);\r\n\r\n    // Second query gets the dct:subject neighbours\r\n    let prefixURLTwo =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(decodeURIComponent(this.state.urlPasted.slice(30))) +\r\n      \"+dct%3Asubject+%3Fo%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    let queryTwo = fetchJSON(queryURLTwo);\r\n    queryPromise.push(queryTwo);\r\n\r\n    // Third query here should get the class annotations\r\n    queryPromise.push(\r\n      findClassAnnotation(this.state.originTableArray[tableIndex])\r\n    );\r\n\r\n    // now we process the query results\r\n    allPromiseReady(queryPromise).then((queryResults) => {\r\n      // console.log(queryResults[0].results.bindings);\r\n      // console.log(queryResults[1].results.bindings);\r\n      // console.log(queryResults[2]);\r\n      let selectedClassAnnotation = queryResults[2];\r\n      // console.log(selectedClassAnnotation);\r\n\r\n      // First we fetch the property neighbours\r\n      // Let's also do some prefetching at this stage: let's remove the propertyNeighbours with too many siblings (150)\r\n      // and remove the propertyNeighbours with only one child (aka the originally pasted page)\r\n\r\n      let propertyNeighboursPO = [];\r\n      let promiseArray = [];\r\n      let bindingArray = [];\r\n\r\n      // The part below deals with the property neighbours\r\n      bindingArray = queryResults[0].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let predicate = bindingArray[i].p.value.slice(28);\r\n        // console.log(\"Predicate is \"+predicate);\r\n        let object = bindingArray[i].o.value.slice(28);\r\n        // console.log(\"Object is \"+object);\r\n        // If object includes some weird literal values, we replace it with \"NONEXISTING\"\r\n        if (object.includes(\"/\")) {\r\n          object = \"NONEXISTING\";\r\n        }\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs+%0D%0AWHERE+%7B%0D%0A%09%3Fs+dbp%3A\" +\r\n          regexReplace(predicate) +\r\n          \"+dbr%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: predicate, object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below deals with the dct:subject neighbours\r\n      bindingArray = queryResults[1].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let object = bindingArray[i].o.value.slice(37);\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs%0D%0AWHERE+%7B%0D%0A++++++%3Fs+dct%3Asubject+dbc%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: \"subject\", object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below processes all the siblings and remove neighbours with too many or too few siblings\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let propertyNeighbours = [];\r\n        let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\r\n        // console.log(urlOrigin);\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let curSiblingArray = values[i].results.bindings;\r\n          // Note, this 150 below should also be adjustable by users\r\n          if (curSiblingArray.length > 1 && curSiblingArray.length < 150) {\r\n            let siblingArray = [];\r\n            for (let i = 0; i < curSiblingArray.length; ++i) {\r\n              let siblingName = curSiblingArray[i].s.value.slice(28);\r\n              siblingArray.push({\r\n                isOpen: false,\r\n                name: siblingName,\r\n                tableArray: [],\r\n              });\r\n            }\r\n            // console.log(siblingArray);\r\n            propertyNeighbours.push({\r\n              predicate: propertyNeighboursPO[i].predicate,\r\n              object: propertyNeighboursPO[i].object,\r\n              isOpen: false,\r\n              siblingArray: siblingArray,\r\n            });\r\n          }\r\n        }\r\n        // we do a rudimentary ranking here: sort the property neighbours by the length of siblingArray\r\n        propertyNeighbours.sort((a, b) =>\r\n          a.siblingArray.length < b.siblingArray.length ? 1 : -1\r\n        );\r\n        // Then we call the parse table helper function to update the tableDataExplore\r\n        let selectedTableHTML = this.state.originTableArray[tableIndex];\r\n        // setTableFromHTML is the function that prepares the data for tableDataExplore\r\n        let tableDataExplore = setTableFromHTML(selectedTableHTML, urlOrigin);\r\n\r\n        // Modeless Change: We need to call the helper function this.getTableStates.\r\n        // By processing the tableDataExplore to get the right states for the Excel-style table.\r\n\r\n        // To do this, we need to call this.getTableStates here. We just need to pass in tableDataExplore and selectedClassAnnotation \r\n        let statePromise = [this.getTableStates(tableDataExplore, selectedClassAnnotation)];\r\n        allPromiseReady(statePromise).then((values) => {\r\n          let stateInfo = values[0];\r\n          // console.log(stateInfo);\r\n          \r\n          // Now we add support for the semantic trees\r\n          // First take a look at tableData\r\n          // console.log(stateInfo.tableData);\r\n\r\n          // We sample rows from the table. Note that we need a semantic tree for every column\r\n          // Except the first (since the first column is OriginURL)\r\n          let sampleRows = _.sampleSize(stateInfo.tableData, Math.min(stateInfo.tableData.length, numForTree));\r\n          let promiseArray = getRDFType(sampleRows, -1, \"startTable\");\r\n\r\n          allPromiseReady(promiseArray).then((values) => {\r\n\r\n          // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n          // to support semantic tree\r\n          let typeRecord = buildTypeRecord(sampleRows, -1, values, \"startTable\");\r\n          // console.log(typeRecord);\r\n\r\n          // Lastly, we set up the information for the action panel\r\n          let tempObj = {};\r\n          tempObj[\"task\"] = \"showStartRecommend\";\r\n          tempObj[\"colIndex\"] = stateInfo.keyColIndex;\r\n          tempObj[\"recommendArray\"] = this.createStartRecommend(stateInfo.keyColNeighbours);\r\n\r\n          document.body.classList.remove('waiting');\r\n          // Support for undo: \r\n          let lastAction = \"handleStartTable\";\r\n          let prevState = \r\n              {\r\n                \"firstColFilled\": this.state.firstColFilled,\r\n                \"selectedTableIndex\": this.state.selectedTableIndex,\r\n                \"propertyNeighbours\": this.state.propertyNeighbours,\r\n                \"curActionInfo\": this.state.curActionInfo,\r\n                \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n                \"keyColIndex\": this.state.keyColIndex,\r\n                \"keyColNeighbours\": this.state.keyColNeighbours,\r\n                \"firstDegNeighbours\": this.state.firstDegNeighbours,\r\n                \"tableData\": this.state.tableData,\r\n                \"tableHeader\": this.state.tableHeader,\r\n                \"usecaseSelected\": this.state.usecaseSelected,\r\n                \"tabIndex\": this.state.tabIndex,\r\n                \"typeRecord\": this.state.typeRecord,\r\n              };\r\n\r\n          this.setState({\r\n            firstColFilled: true,\r\n            selectedTableIndex: tableIndex,\r\n            propertyNeighbours: propertyNeighbours,\r\n            // curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n            curActionInfo: tempObj, // Changed on Aug 20th\r\n            selectedClassAnnotation: selectedClassAnnotation,\r\n            keyColIndex: stateInfo.keyColIndex,\r\n            keyColNeighbours: stateInfo.keyColNeighbours,\r\n            firstDegNeighbours: stateInfo.firstDegNeighbours,\r\n            tableData: stateInfo.tableData,\r\n            tableHeader: stateInfo.tableHeader,\r\n            usecaseSelected: \"startTable\",\r\n            tabIndex: 1,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n            typeRecord: typeRecord,\r\n          });\r\n          });\r\n        })\r\n      });\r\n    });\r\n  }\r\n\r\n  togglePropertyNeighbours(e, index) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // First let's do the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    propertyNeighbours[index].isOpen = !propertyNeighbours[index].isOpen;\r\n\r\n    // we want to loop through all siblings if we are toggling a propertyNeighbour on\r\n    if (propertyNeighbours[index].isOpen === true) {\r\n      let bindingArray = propertyNeighbours[index].siblingArray;\r\n      let siblingArray = [];\r\n      let siblingNameArray = []; // this array keeps track of the sibling names\r\n      let promiseArray = [];\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let siblingName = bindingArray[i].name;\r\n        let siblingURL = \"https://en.wikipedia.org/wiki/\" + siblingName;\r\n        let curPromise = fetchText(siblingURL);\r\n        promiseArray.push(curPromise);\r\n        siblingNameArray.push(siblingName);\r\n      }\r\n\r\n      // Since we only want to display siblings with useful tables, we do some checking here\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // tableArrayPromise stores an array of promises that resolve to tableArray\r\n        let tableArrayPromise = [];\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let pageHTML = values[i];\r\n          // This is a helper function that fetches useful tables from pageHTML\r\n          // console.log(\"The class annotation for the selected table is: \");\r\n          // console.log(this.state.selectedClassAnnotation);\r\n          tableArrayPromise.push(\r\n            findTableFromHTML(\r\n              this.state.tableHeader,\r\n              pageHTML,\r\n              this.state.selectedClassAnnotation,\r\n              this.state.semanticEnabled,\r\n              this.state.unionCutOff,\r\n              siblingNameArray[i]\r\n            )\r\n          );\r\n          // we potentially want to do something different here if urlOrigin === siblingNameArray[i]\r\n          // We only want to keep siblings that do have useful tables\r\n          // if (tableArray.length !== 0) {\r\n          // siblingArray.push({\"isOpen\":false,\"name\":siblingNameArray[i],\"tableArray\":tableArray});\r\n          // }\r\n        }\r\n        allPromiseReady(tableArrayPromise).then((tableArrayValues) => {\r\n          for (let i = 0; i < tableArrayValues.length; ++i) {\r\n            siblingArray.push({\r\n              isOpen: false,\r\n              name: siblingNameArray[i],\r\n              tableArray: tableArrayValues[i],\r\n            });\r\n          }\r\n          // This following line sorts the siblingArray\r\n          siblingArray.sort(function (a, b) {\r\n            let aTableLength = a.tableArray.length;\r\n            let bTableLength = b.tableArray.length;\r\n            let aName = a.name;\r\n            let bName = b.name;\r\n            if (aTableLength === bTableLength) {\r\n              return aName < bName ? -1 : aName > bName ? 1 : 0;\r\n            } else {\r\n              return aTableLength > bTableLength ? -1 : 1;\r\n            }\r\n          });\r\n          propertyNeighbours[index].siblingArray = siblingArray;\r\n          document.body.classList.remove('waiting');\r\n          this.setState({\r\n            propertyNeighbours: propertyNeighbours,\r\n          });\r\n        });\r\n      });\r\n    } else {\r\n      document.body.classList.remove('waiting');\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of a sibling URL\r\n\r\n  toggleSibling(e, firstIndex, secondIndex) {\r\n    // Handle the toggling task\r\n    // console.log(\"Here we start the sibling toggle\");\r\n    // console.log(\"The current property neighbour is \");\r\n    // console.log(\r\n    //   \"The current property neighbour is \",\r\n    //   this.state.propertyNeighbours.slice()\r\n    // );\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    // console.log(propertyNeighbours);\r\n    let selectedSibling =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex];\r\n\r\n    // Note that if this sibling's tableArray is empty, we probably do not want to toggle it.\r\n    if (selectedSibling.tableArray.length === 0) {\r\n      // console.log(\"Selected sibling has no tables: \" + selectedSibling.name);\r\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n      this.setState({\r\n        pageHidden: false,\r\n        iframeURL: iframeURL,\r\n      });\r\n    } else {\r\n      // if the sibling's tableArray is not empty, we want to toggle it\r\n      selectedSibling.isOpen = !selectedSibling.isOpen;\r\n      // console.log(\"Let's take a look at the current property neighbour\");\r\n      // console.log(propertyNeighbours[firstIndex]);\r\n      // if (propertyNeighbours[firstIndex].isOpen === false) {\r\n      // propertyNeighbours[firstIndex].isOpen = true;\r\n      // console.log(\"In here we should have fixed the problem.\");\r\n      // console.log(propertyNeighbours);\r\n      // }\r\n      // We also want to change the iframe displayed at the bottom if we are toggling a sibling open\r\n      if (selectedSibling.isOpen === true) {\r\n        // console.log(\"If we get here, then sibling page should be opened\");\r\n        let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        propertyNeighbours[firstIndex].isOpen = true;\r\n        // console.log(propertyNeighbours[firstIndex]);\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        // console.log(\"First index is: \" + firstIndex);\r\n        // console.log(\"In here we should have fixed the problem.\");\r\n        // console.log(\"This is the property neighbour we will pass in\");\r\n        // console.log(propertyNeighbours);\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n          iframeURL: iframeURL,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of other table (that's the same as the selected table)\r\n\r\n  toggleOtherTable(e, firstIndex, secondIndex, thirdIndex) {\r\n    // First handle the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    const selectedTable =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray[\r\n        thirdIndex\r\n      ];\r\n    // console.log(selectedTable.data);\r\n    selectedTable.isOpen = !selectedTable.isOpen;\r\n    this.setState({\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // The following funcion unions the table that user has selected to the table in the TablePanel\r\n\r\n  unionTable(firstIndex, secondIndex, otherTableHTML, colMapping) {\r\n    document.body.classList.add('waiting');\r\n\r\n    // First we create a copy of the current tableData\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Let's also get the length of tableData, which will be used in autofilling\r\n    let fillStartIndex = tableData.length;\r\n\r\n    // Starting here, let's build the semantic tree from type record.\r\n    // Let's write a helper function to get the type lineage for each column in the table\r\n    // Note that we have to put tableTreePromise in an array here so that allPromiseReady can work\r\n    // console.log(this.state.typeRecord);\r\n    let tablePromise = [tableTreePromise(this.state.typeRecord)];\r\n    // console.log(tablePromise);\r\n    allPromiseReady(tablePromise).then((treeValues) => {\r\n    let tableTree = buildTableTree(treeValues[0], this.state.typeRecord);\r\n    // console.log(tableTree);\r\n\r\n    // Then we get the clean data and set the origin for the other table.\r\n    // We do so by calling setTableFromHTML, and setUnionData.\r\n    let otherTableOrigin = this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\r\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\r\n    otherTableData = setUnionData(otherTableData);\r\n    // console.log(otherTableData);\r\n\r\n    // Note that we also need to build a semantic tree for the table being unioned\r\n    // To do that, we first get its typeRecord\r\n\r\n    // We sample rows from the otherTableData. \r\n    // Note that we skip the first column in otherTableData (since the first column is OriginURL)\r\n    let sampleRows = _.sampleSize(otherTableData, Math.min(otherTableData.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, -1, \"startTable\");\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // We call helper function to store the ontology rdf:type of the sampleRows to support semantic tree\r\n    let otherTypeRecord = buildTypeRecord(sampleRows, -1, values, \"startTable\");\r\n    // Now we build the semantic tree for the other table from otherTypeRecord\r\n    let otherTablePromise = [tableTreePromise(otherTypeRecord)];\r\n    // console.log(tablePromise);\r\n    allPromiseReady(otherTablePromise).then((otherTreeValues) => {\r\n    let otherTableTree = buildTableTree(otherTreeValues[0], otherTypeRecord);\r\n\r\n    // We now take a look at both tableTree and otherTableTree\r\n    // console.log(tableTree);\r\n    // console.log(otherTableTree);\r\n\r\n    // We start creating column mappings\r\n    let newMapping = [];\r\n\r\n    // We first union by row names, then union by semTree\r\n    \r\n    // Step One: get the column names of the table in the table panel, using this.state.tableHeader.\r\n    let originCols = [];\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n\r\n    for (let j = 0; j < this.state.tableHeader.length; ++j) {\r\n      let curValue = \"\";\r\n      for (let k = 0; k < tableHeader[j].length; ++k) {\r\n        curValue+=tableHeader[j][k].value;\r\n      }\r\n      originCols.push(curValue);\r\n      newMapping.push(-1);\r\n    }\r\n    // console.log(originCols);\r\n\r\n    // Step Two: get the column names of the othe table, based on otherTableHTML\r\n    let newCols = [\"OriginURL\"];\r\n    let curHeaderCells = otherTableHTML.rows[0].cells;\r\n  \r\n    for (let j = 0; j < curHeaderCells.length; ++j) {\r\n      let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\r\n      newCols.push(headerName);\r\n    }\r\n    // console.log(newCols);\r\n\r\n    // Step three: check which names are matched already\r\n    // Let's use string containment, ignored upper/lower cases\r\n    // for (let j = 0; j < newMapping.length; ++j) {\r\n    //   let curIndex = newCols.indexOf(originCols[j]);\r\n    //   if (curIndex !== -1) {\r\n    //     // This means the new table also contains column j from the selected table\r\n    //     // Thus we have found a mapping. We updated colMapping.\r\n    //     newMapping[j] = curIndex;\r\n    //   }\r\n    // }\r\n\r\n    for (let j = 0; j < newMapping.length; ++j) {\r\n      let originColName = originCols[j].toUpperCase();\r\n      for (let k = 0; k < newCols.length; ++k) {\r\n        let newColName = newCols[k].toUpperCase();\r\n        if (originColName.includes(newColName) || newColName.includes(originColName)) {\r\n          newMapping[j] = k;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    // console.log(newMapping);\r\n\r\n    // Step four: for those columns in original table whose names cannot be matched, look into semantic tree\r\n\r\n    for (let j = 0; j < newMapping.length; ++j) {\r\n      if (newMapping[j] === -1) {\r\n        let semMatchingIndex = findSemanticUnion(j, tableTree, otherTableTree);\r\n        // We include an additional check here that this column is not used already\r\n        if (semMatchingIndex !== -1 && newMapping.indexOf(semMatchingIndex) === -1) {\r\n          newMapping[j] = semMatchingIndex;\r\n        }\r\n      }\r\n    }\r\n    // console.log(newMapping);\r\n\r\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\r\n    let newMappingCopy = newMapping.slice();\r\n\r\n    // Before we go into autofill, let's update the tableData first\r\n    tableData = tableConcat(\r\n      tableData,\r\n      otherTableData,\r\n      otherTableOrigin,\r\n      newMappingCopy\r\n    )\r\n    // console.log(otherTableData);\r\n    // console.log(tableData);\r\n\r\n    // Step five: for those columns in original table whose names are still not matched, look into column autofill\r\n    // In here we have to make use of what we have done previously with autofill\r\n\r\n    // Note that one change we have to make is passing in originCols, since in startTable case we don't know reference column\r\n    let autoFillInfo = getAutofillInfo(tableData, originCols);\r\n    // console.log(autoFillInfo);\r\n    // console.log(fillStartIndex);\r\n\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    // In here we add support for auto-fill information:\r\n    // We make use of the autofillFarPromise helper function to get the 2nd and 3rd deg neighbours\r\n    let columnInfo = autoFillInfo.columnInfo;\r\n    let refInfo = autoFillInfo.refInfo;\r\n    // console.log(columnInfo);\r\n\r\n    // Start from here: next we need to modify autofillFarPromise function to accomodate startTable\r\n    // We should no longer differentiate between 1st def neighbours and 2/3 deg neighbours\r\n    let autoPromise = autofillFarPromise(tableData, columnInfo, fillStartIndex, \"startTable\", refInfo);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n    allPromiseReady(autoPromise).then((valuesAuto) => {\r\n\r\n      let selectionInfo = updateUnionSelection(valuesOne); // Sept 13 update\r\n\r\n      // console.log(valuesAuto);\r\n\r\n      // We call helper \"processAutoInfo\" to process valuesAuto\r\n      // Specifically, we want to get an array of arrays of string, as data for the 1/2/3 deg neighbour columns\r\n      let autoArray = processAutoInfo(columnInfo, valuesAuto, \"startTable\");\r\n      let autoIndex = 0;\r\n      console.log(autoArray);\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      for (let i = 0; i < columnInfo.length; ++i) {\r\n        // We are currently dealing with curColumn_th column in the table\r\n        let curColumn = i + 1;\r\n\r\n        //  We call autofillFarDeg to update tableData\r\n        if (columnInfo[i].length > 0 && columnInfo[i].length < 4) {\r\n          tableData = \r\n            autofillFarDeg(tableData,\r\n                           columnInfo[i],\r\n                           autoArray[autoIndex],\r\n                           curColumn,\r\n                           fillStartIndex);\r\n          // We also need to update autoIndex\r\n          ++autoIndex;\r\n        }\r\n      }\r\n      console.log(tableData);\r\n\r\n      document.body.classList.remove('waiting');\r\n      // Suppport for undo.\r\n      let lastAction = \"unionTable\";\r\n      let prevState = \r\n          {\r\n            \"tableData\":this.state.tableData,\r\n            \"keyColNeighbours\":this.state.keyColNeighbours,\r\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n            \"firstColSelection\": this.state.firstColSelection, \r\n            \"firstColChecked\": this.state.firstColChecked, \r\n          };\r\n      \r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n        firstColSelection: selectionInfo.firstColSelection,\r\n        firstColChecked: selectionInfo.firstColChecked,\r\n      })\r\n    })\r\n    })\r\n    })\r\n    })\r\n    })\r\n    })\r\n  }\r\n\r\n  // Start here\r\n  unionCustomized(e, index) {\r\n    document.body.classList.add('waiting');\r\n    // console.log(this.state.unionURL);\r\n    // console.log(this.state.unionTableArray);\r\n    // console.log(this.state.unionOpenList);\r\n    // console.log(index);\r\n\r\n    // First we create a copy of the current tableData\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Let's also get the length of tableData, which will be used in autofilling\r\n    let fillStartIndex = tableData.length;\r\n\r\n    // Starting here, let's build the semantic tree from type record.\r\n    // console.log(this.state.typeRecord);\r\n    let tablePromise = [tableTreePromise(this.state.typeRecord)];\r\n    // console.log(tablePromise);\r\n    allPromiseReady(tablePromise).then((treeValues) => {\r\n    let tableTree = buildTableTree(treeValues[0], this.state.typeRecord);\r\n\r\n    // Now we work with otherTable's data\r\n    let otherTableOrigin = decodeURIComponent(this.state.unionURL.slice(30));\r\n    let otherTableHTML = this.state.unionTableArray[index];\r\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\r\n    otherTableData = setUnionData(otherTableData);\r\n    // console.log(otherTableData);\r\n\r\n    // We now build a semantic tree for the table being unioned\r\n    let sampleRows = _.sampleSize(otherTableData, Math.min(otherTableData.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, -1, \"startTable\");\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // We call helper function to store the ontology rdf:type of the sampleRows to support semantic tree\r\n    let otherTypeRecord = buildTypeRecord(sampleRows, -1, values, \"startTable\");\r\n    // Now we build the semantic tree for the other table from otherTypeRecord\r\n    let otherTablePromise = [tableTreePromise(otherTypeRecord)];\r\n    // console.log(tablePromise);\r\n    allPromiseReady(otherTablePromise).then((otherTreeValues) => {\r\n    let otherTableTree = buildTableTree(otherTreeValues[0], otherTypeRecord);\r\n\r\n    // We take a look at both tableTree and otherTableTree\r\n    // console.log(tableTree);\r\n    // console.log(otherTableTree);\r\n\r\n    // We start creating column mappings\r\n    let newMapping = [];\r\n\r\n    // We first union by row names, then union by semTree\r\n    \r\n    // Step One: get the column names of the table in the table panel, using this.state.tableHeader.\r\n    let originCols = [];\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n\r\n    for (let j = 0; j < this.state.tableHeader.length; ++j) {\r\n      let curValue = \"\";\r\n      for (let k = 0; k < tableHeader[j].length; ++k) {\r\n        curValue+=tableHeader[j][k].value;\r\n      }\r\n      originCols.push(curValue);\r\n      newMapping.push(-1);\r\n    }\r\n    // console.log(originCols);\r\n\r\n    // Step Two: get the column names of the othe table, based on otherTableHTML\r\n    let newCols = [\"OriginURL\"];\r\n    let curHeaderCells = otherTableHTML.rows[0].cells;\r\n  \r\n    for (let j = 0; j < curHeaderCells.length; ++j) {\r\n      let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\r\n      newCols.push(headerName);\r\n    }\r\n    // console.log(newCols);\r\n\r\n    // Step three: check which names are matched already. Using string containment, ignoring cases.\r\n    for (let j = 1; j < newMapping.length; ++j) {\r\n      let originColName = originCols[j].toUpperCase();\r\n      for (let k = 0; k < newCols.length; ++k) {\r\n        let newColName = newCols[k].toUpperCase();\r\n        if (originColName.includes(newColName) || newColName.includes(originColName)) {\r\n          newMapping[j] = k;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    // console.log(newMapping);\r\n\r\n    // Step four: for those columns in original table whose names cannot be matched, look into semantic tree\r\n\r\n    for (let j = 0; j < newMapping.length; ++j) {\r\n      if (newMapping[j] === -1) {\r\n        let semMatchingIndex = findSemanticUnion(j, tableTree, otherTableTree);\r\n        // We include an additional check here that this column is not used already\r\n        if (semMatchingIndex !== -1 && newMapping.indexOf(semMatchingIndex) === -1) {\r\n          newMapping[j] = semMatchingIndex;\r\n        }\r\n      }\r\n    }\r\n    // console.log(newMapping);\r\n\r\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\r\n    let newMappingCopy = newMapping.slice();\r\n\r\n    // Before we go into autofill, let's update the tableData first\r\n    tableData = tableConcat(\r\n      tableData,\r\n      otherTableData,\r\n      otherTableOrigin,\r\n      newMappingCopy\r\n    )\r\n    // console.log(tableData);\r\n\r\n    // Step five: for those columns in original table whose names are still not matched, look into column autofill\r\n\r\n    // Note that one change we have to make is passing in originCols, since in startTable case we don't know reference column\r\n    let autoFillInfo = getAutofillInfo(tableData, false, newMapping);\r\n    // console.log(autoFillInfo);\r\n    // console.log(fillStartIndex);\r\n\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    // In here we add support for auto-fill information:\r\n    // We make use of the autofillFarPromise helper function \r\n    let columnInfo = autoFillInfo.columnInfo;\r\n    // let refInfo = autoFillInfo.refInfo;\r\n    // console.log(columnInfo);\r\n\r\n    // Start from here: next we need to modify autofillFarPromise function to accomodate startTable\r\n    // We should no longer differentiate between 1st def neighbours and 2/3 deg neighbours\r\n    let autoPromise = autofillFarPromise(tableData, columnInfo, fillStartIndex, \"startSubject\", -1);\r\n    // console.log(autoPromise);\r\n\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n    allPromiseReady(autoPromise).then((valuesAuto) => {\r\n\r\n    // console.log(valuesAuto);\r\n\r\n    let selectionInfo = updateUnionSelection(valuesOne); // Sept 13 update\r\n  \r\n    // We call updateNeighbourInfo here because we are changing the rows\r\n    let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n    let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n    let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n    // We call helper \"processAutoInfo\" to process valuesAuto to handle the 2nd/3rd deg neighbours\r\n    let farArray = processAutoInfo(columnInfo, valuesAuto, \"startSubject\");\r\n    // console.log(farArray);\r\n    // This farArray contains all the information we needed. We set a starting index\r\n    let farIndex = 0;\r\n\r\n    // Stepone: Call helper function autofillFirstDeg to fill in the one-deg neighbours first\r\n    // This information should already exists in firstDegNeighbours\r\n    for (let i = 0; i < columnInfo.length; ++i) {\r\n      // We are currently dealing with curColumn_th column in the table\r\n      let curColumn = i + 1;\r\n      // If it is a one-deg neighbour, we call the autofillFirstDeg to update tableData\r\n      if (columnInfo[i].length === 1) {\r\n        tableData = \r\n          autofillFirstDeg(tableData, \r\n                            columnInfo[i], \r\n                            curColumn, \r\n                            fillStartIndex, \r\n                            firstDegNeighbours, \r\n                            this.state.keyColIndex);\r\n      }\r\n      // It it is a 2nd/3rd deg neighbour, we call autofillFarDeg to update tableData\r\n      if (columnInfo[i].length === 2 || columnInfo[i].length === 3) {\r\n        tableData = \r\n          autofillFarDeg(tableData,\r\n                          columnInfo[i],\r\n                          farArray[farIndex],\r\n                          curColumn,\r\n                          fillStartIndex);\r\n        // We also need to update farIndex\r\n        ++farIndex;\r\n      }\r\n    }\r\n\r\n    // Lastly we remove NA from Notes column.\r\n    tableData = removeNAfromNotes(tableData, originCols)\r\n\r\n    document.body.classList.remove('waiting');\r\n\r\n    // Suppport for undo.\r\n    let lastAction = \"unionCustomized\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n          \"keyColNeighbours\":this.state.keyColNeighbours,\r\n          \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n          \"firstColSelection\": this.state.firstColSelection, \r\n          \"firstColChecked\": this.state.firstColChecked, \r\n        };\r\n    \r\n    this.setState({\r\n      tableData: tableData,\r\n      keyColNeighbours: keyColNeighbours,\r\n      firstDegNeighbours: firstDegNeighbours,\r\n      previewColIndex: -1,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n      firstColSelection: selectionInfo.firstColSelection,\r\n      firstColChecked: selectionInfo.firstColChecked,\r\n    })\r\n    })\r\n    })\r\n    })\r\n    })\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function unions all similar tables found under a sibling page with the selected table\r\n  unionPage(firstIndex, secondIndex) {\r\n    document.body.classList.add('waiting');\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // We get the tableArray and name of the current sibling page\r\n    let tableArray = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray;\r\n    let otherTableOrigin = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\r\n\r\n    for (let i = 0; i < tableArray.length; ++i) {\r\n      // We get the clean data for the current \"other table\"\r\n      let otherTableData = setTableFromHTML(\r\n        tableArray[i].data,\r\n        otherTableOrigin\r\n      );\r\n      // We fetch the header row now\r\n      let headerRow = otherTableData[0];\r\n      otherTableData = setUnionData(otherTableData);\r\n      // console.log(headerRow);\r\n      // console.log(this.state.tableHeader);\r\n\r\n      // Let's do some checking here: we do not want to union the same table with itself\r\n      let sameTable = false;\r\n      if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n        let diffColFound = false;\r\n        for (let m=0; m<headerRow.length; ++m) {\r\n          if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n            diffColFound = true;\r\n            break;\r\n          }\r\n        }\r\n        if (diffColFound === false) {\r\n          sameTable = true;\r\n        }\r\n      }\r\n      // We create a copy of the colMapping of the current \"other table\"\r\n      let tempMapping = tableArray[i].colMapping.slice();\r\n\r\n      // if sameTable is false, we can safely union the data\r\n      if (sameTable === false) {\r\n        tableData = tableConcat(\r\n          tableData,\r\n          otherTableData,\r\n          tempMapping\r\n        );\r\n      }\r\n    }\r\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      document.body.classList.remove('waiting');\r\n      // Suppport for undo.\r\n      let lastAction = \"unionPage\";\r\n      let prevState = \r\n          {\r\n            \"tableData\":this.state.tableData,\r\n            \"keyColNeighbours\":this.state.keyColNeighbours,\r\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n            \"previewColIndex\": this.state.previewColIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        tableData: tableData,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n    })\r\n  }\r\n\r\n  // The following function unions all similar tables found under a property(parent) neighbour with the selected table\r\n  // This is the highest level of union.\r\n\r\n  unionProperty(firstIndex) {\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // we get the siblingArray of the current property neighbour\r\n    let siblingArray = this.state.propertyNeighbours[firstIndex].siblingArray;\r\n\r\n    for (let i = 0; i < siblingArray.length; ++i) {\r\n      // We get the tableArray and name of the current sibling page\r\n      let tableArray = siblingArray[i].tableArray;\r\n      let otherTableOrigin = siblingArray[i].name;\r\n      // console.log(otherTableOrigin);\r\n      // If the current sibling has no tables that are unionable, we break out of the loop.\r\n      // Because siblingArray is sorted by the length of their tableArray\r\n      if (tableArray.length === 0) {\r\n        break;\r\n      }\r\n      // Else, we want to union all unionable tables from the current sibling page\r\n      else {\r\n        for (let j = 0; j < tableArray.length; ++j) {\r\n          // We get the clean data for the current \"other table\"\r\n          let otherTableData = setTableFromHTML(\r\n            tableArray[j].data,\r\n            otherTableOrigin\r\n          );\r\n          // We fetch the column header row\r\n          let headerRow = otherTableData[0];\r\n          otherTableData = setUnionData(otherTableData);\r\n          // Let's do some checking here: we do not want to union the same table with itself\r\n          let sameTable = false;\r\n          if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n            let diffColFound = false;\r\n            for (let m=0; m<headerRow.length; ++m) {\r\n              if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n                diffColFound = true;\r\n                break;\r\n              }\r\n            }\r\n            if (diffColFound === false) {\r\n              sameTable = true;\r\n            }\r\n          }\r\n          // We create a copy of the colMapping of the current \"oother table\"\r\n          let tempMapping = tableArray[j].colMapping.slice();\r\n\r\n          // if sameTable is false, we can safely union the data\r\n          if (sameTable === false) {\r\n            tableData = tableConcat(\r\n              tableData,\r\n              otherTableData,\r\n              tempMapping\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Support for undo: \r\n    let lastAction = \"unionProperty\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of \"semanticEnabled\" setting\r\n\r\n  toggleSemantic(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing semanticEnabled changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n\r\n    this.setState({\r\n      semanticEnabled: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of the unionCutoff percentage\r\n\r\n  unionCutOffChange(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing union cutoff changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n    this.setState({\r\n      unionCutOff: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles opening the filter for a particular column\r\n\r\n  openFilter(e, colIndex) {\r\n    // In this function, we want to set showFilter to true, and update dataAndChecked based on colIndex\r\n\r\n    let dataArray = [];\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      dataArray.push(this.state.tableData[i][colIndex].data);\r\n    }\r\n    dataArray = [...new Set(dataArray)];\r\n    // Let's sort this dataArray a bit: we put N/A at the beginning of the array\r\n    dataArray.sort(\r\n      function(a,b) { \r\n        return a === \"N/A\" ? -1 : b === \"N/A\" ? 1 : 0; \r\n      }\r\n    );\r\n\r\n    let dataAndChecked = [];\r\n    for (let i=0;i<dataArray.length;++i) {\r\n      dataAndChecked.push(\r\n        {\r\n          \"data\":dataArray[i],\r\n          \"checked\":true\r\n        }\r\n      )\r\n    }\r\n    // console.log(dataAndChecked);\r\n\r\n    this.setState({\r\n      dataAndChecked: dataAndChecked,\r\n      showFilter: true,\r\n      checkAll: true,   // we want to set checkAll to true whenever we open the filter modal\r\n      curFilterIndex: colIndex,\r\n    })\r\n  }\r\n\r\n  // This function handles cancelling the filter (so we close it).\r\n  // In here, we will clean every state related to filtering\r\n\r\n  cancelFilter(e) {\r\n    this.setState({\r\n      dataAndChecked: [],\r\n      showFilter: false,\r\n      curFilterIndex: -1,\r\n      filterMin: null,\r\n      filterMax: null,\r\n    })\r\n  }\r\n  \r\n\r\n  // This function handles toggling the data checkboxes in filter modal.\r\n\r\n  toggleChecked(e, checkIndex) {\r\n    let dataAndChecked = this.state.dataAndChecked;\r\n    dataAndChecked[checkIndex].checked = !dataAndChecked[checkIndex].checked;\r\n    this.setState({\r\n      dataAndChecked:dataAndChecked,\r\n    })\r\n  }\r\n\r\n  // This function handles toggling the Check/Uncheck all checkbox in filter modal.\r\n\r\n  toggleAll(e) {\r\n    let checkAll = this.state.checkAll;\r\n    let dataAndChecked = this.state.dataAndChecked;\r\n    checkAll = !checkAll;\r\n    // Now we loop through dataAndChecked to set all the checked attribute\r\n    for (let i = 0; i < dataAndChecked.length; ++i) {\r\n      dataAndChecked[i].checked = checkAll;\r\n    }\r\n    this.setState({\r\n      checkAll: checkAll,\r\n      dataAndChecked: dataAndChecked,\r\n    })\r\n  }\r\n\r\n  // This function handles applying the filter to tableData, based on dataAndChecked\r\n\r\n  applyFilter(e) {\r\n    // console.log(this.state.dataAndChecked);\r\n    // console.log(this.state.curFilterIndex);\r\n    // console.log(\"Column to filter is \"+this.state.curFilterIndex);\r\n\r\n    // The following part are added for debugging purposes\r\n    let allFalse = true;\r\n    for (let i = 0; i < this.state.dataAndChecked.length; ++i) {\r\n      if (this.state.dataAndChecked[i].checked === true) {\r\n        allFalse = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // console.log(this.state.filterMin);\r\n    // console.log(this.state.filterMax);\r\n\r\n    // We do not want users to toggle every value off\r\n    if (allFalse === true) {\r\n      alert(\"Please do not remove every value from the table!\");\r\n    }\r\n    // In here we check if user has inputted some kidn of range filter values \r\n    else if (this.state.filterMin !== null || this.state.filterMax !== null) {\r\n      // We first get the min and max values \r\n      let filterMin;\r\n      let filterMax;\r\n      if (this.state.filterMin === null) {\r\n        filterMin = Number.NEGATIVE_INFINITY;\r\n        filterMax = Number(this.state.filterMax);\r\n      }\r\n      else if (this.state.filterMax === null) {\r\n        filterMin = Number(this.state.filterMin);\r\n        filterMax = Number.POSITIVE_INFINITY;\r\n      }\r\n      else {\r\n        filterMin = Number(this.state.filterMin);\r\n        filterMax = Number(this.state.filterMax);\r\n      }\r\n      // Now we begin the filtering\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      for (let i=0;i<tableData.length;++i) {\r\n        let curNumData = Number(tableData[i][this.state.curFilterIndex].data);\r\n        if (isNaN(curNumData) || curNumData > filterMax || curNumData < filterMin) {\r\n          tableData.splice(i,1);\r\n          --i;\r\n        }\r\n      }\r\n\r\n      // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n      // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n\r\n      // Now we add support for the semantic trees\r\n      // First take a look at tableData\r\n      // console.log(tableData);\r\n\r\n      // We sample rows from the table. Note that we need a semantic tree for every column\r\n      // Except the first (since the first column is OriginURL)\r\n      let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n      let promiseArray = getRDFType(sampleRows, -1, this.state.usecaseSelected);\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n      \r\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n        // We call updateNeighbourInfo here because we are changing the rows\r\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n        // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n        // to support semantic tree\r\n        let typeRecord = buildTypeRecord(sampleRows, -1, values, this.state.usecaseSelected);\r\n        // console.log(typeRecord);\r\n\r\n        // Suppport for undo.\r\n        let lastAction = \"applyFilter\";\r\n        let prevState = \r\n            {\r\n              \"tableData\":this.state.tableData,\r\n              \"curActionInfo\":this.state.curActionInfo,\r\n              \"keyColNeighbours\":this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n              \"typeRecord\": this.state.typeRecord,\r\n            };\r\n        \r\n        this.setState({\r\n          dataAndChecked: [],\r\n          showFilter: false,\r\n          curFilterIndex: -1,\r\n          filterMin: null,\r\n          filterMax: null,\r\n          tableData: tableData,\r\n          keyColNeighbours: keyColNeighbours,\r\n          firstDegNeighbours: firstDegNeighbours,\r\n          previewColIndex: -1,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n          typeRecord: typeRecord,\r\n        })\r\n      })\r\n      })\r\n      })\r\n    }\r\n    // This else clause contains the original function body (filter by checking boxes)\r\n    else {\r\n      let valuesToKeep = [];\r\n      for (let i=0;i<this.state.dataAndChecked.length;++i) {\r\n        if (this.state.dataAndChecked[i].checked === true) {\r\n          valuesToKeep.push(this.state.dataAndChecked[i].data);\r\n        }\r\n      }\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      for (let i=0;i<tableData.length;++i) {\r\n        if (!valuesToKeep.includes(tableData[i][this.state.curFilterIndex].data)) {\r\n          tableData.splice(i,1);\r\n          --i;\r\n        }\r\n      }\r\n\r\n      // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\r\n      // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\r\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\r\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\r\n\r\n      // Now we add support for the semantic trees\r\n      // First take a look at tableData\r\n      // console.log(tableData);\r\n\r\n      // We sample rows from the table. Note that we need a semantic tree for every column\r\n      // Except the first (since the first column is OriginURL)\r\n      let sampleRows = _.sampleSize(tableData, Math.min(tableData.length, numForTree));\r\n      let promiseArray = getRDFType(sampleRows, -1, this.state.usecaseSelected);\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n        // We call updateNeighbourInfo here because we are changing the rows\r\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n        // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n        // to support semantic tree\r\n        let typeRecord = buildTypeRecord(sampleRows, -1, values, this.state.usecaseSelected);\r\n        // console.log(typeRecord);\r\n\r\n        // Suppport for undo.\r\n        let lastAction = \"applyFilter\";\r\n        let prevState = \r\n            {\r\n              \"tableData\":this.state.tableData,\r\n              \"curActionInfo\":this.state.curActionInfo,\r\n              \"keyColNeighbours\":this.state.keyColNeighbours,\r\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n              \"previewColIndex\": this.state.previewColIndex,\r\n              \"typeRecord\": this.state.typeRecord,\r\n            };\r\n        \r\n        this.setState({\r\n          dataAndChecked: [],\r\n          showFilter: false,\r\n          curFilterIndex: -1,\r\n          filterMin: null,\r\n          filterMax: null,\r\n          tableData: tableData,\r\n          keyColNeighbours: keyColNeighbours,\r\n          firstDegNeighbours: firstDegNeighbours,\r\n          previewColIndex: -1,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n          typeRecord: typeRecord,\r\n        })\r\n      })\r\n      })\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function hanles switching tabs\r\n\r\n  handleTabSwitch(index) {\r\n    // If we are switching to \"Union Table\" tab from \"Wrangling Actions\" tab, we want to toggle off all the property neighbours.\r\n    // Since we might have potentially changed the table in table panel, thus changed the search criteria as well\r\n    if (index === 1) {\r\n      let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n      for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n        propertyNeighbours[i].isOpen = false;\r\n      }\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n        tabIndex: index,\r\n      });\r\n    }\r\n    else {\r\n      this.setState({\r\n        tabIndex: index,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function handles user changing min/max values for range filters\r\n  handleRangeFilter(e, type) {\r\n    e.preventDefault();\r\n    if (type === \"min\") {\r\n      this.setState({\r\n        filterMin: e.target.value,\r\n      })\r\n    } else {\r\n      this.setState({\r\n        filterMax: e.target.value,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function undos the previous change that user has made to the result table in table panel\r\n\r\n  undoPreviousStep() {\r\n    // We first get which action we need to undo\r\n    let lastAction = this.state.lastAction;\r\n    // Then we fetch the previous state\r\n    let prevState = this.state.prevState;\r\n    // console.log(lastAction);\r\n    // console.log(prevState);\r\n\r\n    // Note, since we are allowing one step undo only, we set lastAction to \"\" everytime we run this function\r\n\r\n    // Case 1: Undo the ULR Paste. \r\n    // In this case we need to restore urlPasted, iframeURL, originTableArray, and tableOpenList\r\n    if (lastAction === \"handleURLPaste\") {\r\n      this.setState({\r\n        urlPasted: prevState.urlPasted,\r\n        iframeURL: prevState.iframeURL,\r\n        originTableArray: prevState.originTableArray,\r\n        tableOpenList: prevState.tableOpenList,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 2: Undo the selection of the task: startSubject.\r\n    // In this case we need to restore usecaseSelected, tableData, firstColSelection, firstColChecked, tabIndex, and curActionInfo\r\n\r\n    else if (lastAction === \"handleStartSubject\") {\r\n      this.setState({\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tableData: prevState.tableData,\r\n        firstColSelection: prevState.firstColSelection,\r\n        firstColChecked: prevState.firstColChecked,\r\n        tabIndex: prevState.tabIndex,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 3: Undo the selection of the task: startTable.\r\n    // In this case we need to restore many states. See code below.\r\n\r\n    else if (lastAction === \"handleStartTable\") {\r\n      this.setState({\r\n        firstColFilled: prevState.firstColFilled,\r\n        selectedTableIndex: prevState.selectedTableIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 4: Undo the population of key column.\r\n    // In this case we need to restore keyColIndex, keyColNeighbours, firstDegNeighbours, firstColFilled, \r\n    //                                 curActionInfo, tableData, tableHeader\r\n\r\n    else if (lastAction === \"populateKeyColumn\") {\r\n      this.setState({\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        firstColFilled: prevState.firstColFilled,\r\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\r\n        firstColSelection: prevState.firstColSelection,\r\n        firstColChecked: prevState.firstColChecked,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 5: Undo the population of a new column.\r\n    // In this case we need to restore curActionInfo, tableData.\r\n    else if (lastAction === \"populateOtherColumn\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        previewColIndex: prevState.previewColIndex,\r\n        otherColText: prevState.otherColText,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 6: Undo the population of same neighbour in different columns.\r\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap.\r\n    else if (lastAction === \"sameNeighbourDiffRow\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 7: Undo the population of same neighbour in the same column.\r\n    // In this case we need to restore the curActionInfo, tableData.\r\n    else if (lastAction === \"sameNeighbourOneRow\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 9: Undo the union of tables.\r\n    // In this case we need to restore tableData\r\n    else if (lastAction === \"unionTable\" || lastAction === \"unionPage\" || lastAction === \"unionProperty\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 10: Undo the addition of a new column\r\n    else if (lastAction === \"contextAddColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        curActionInfo: prevState.curActionInfo,\r\n        keyColIndex: prevState.keyColIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 11: Undo the set of search cell.\r\n    else if (lastAction === \"contextSetColumn\") {\r\n      this.setState({\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // // Case 12: Undo the showing of cell origin.\r\n    // else if (lastAction === \"contextCellOrigin\") {\r\n    //   this.setState({\r\n    //     curActionInfo: prevState.curActionInfo,\r\n    //     tabIndex: prevState.tabIndex,\r\n    //     lastAction: \"\",\r\n    //   })\r\n    // }\r\n\r\n    // Case 12: Undo the showing of cell preview.\r\n    else if (lastAction === \"originPreviewPage\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        pageHidden: prevState.pageHidden,\r\n        iframeURL: prevState.iframeURL,\r\n        previewInfoArray: prevState.previewInfoArray,\r\n        previewInfoExpanded: prevState.previewInfoExpanded,\r\n        selectedCell: prevState.selectedCell,\r\n        previewColIndex: prevState.previewColIndex,\r\n        // firstColSelection: prevState.firstColSelection,\r\n        // firstColChecked: prevState.firstColChecked,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 13: Undo the deletion of column.\r\n    else if (lastAction === \"contextDeleteColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 14: Undo the sorting of a column.\r\n    else if (lastAction === \"contextSortColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 14: Undo the deduping of a column.\r\n    else if (lastAction === \"contextDedupColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 15: Undo the row filtering based on column filters.\r\n    else if (lastAction === \"applyFilter\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 16: Undo the joining of two tables.\r\n    else if (lastAction === \"runJoin\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        previewColIndex: prevState.previewColIndex,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"confirmAddFirstCol\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        firstDegNeighbours: prevState.firstDegNeighbours,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\r\n        previewColIndex: prevState.previewColIndex,\r\n        firstColSelection: prevState.firstColSelection, // updated on 9/13\r\n        firstColChecked: prevState.firstColChecked,  // updated on 9/13\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"toggleOtherNeighbour\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        previewColIndex: prevState.previewColIndex,\r\n        otherColChecked: prevState.otherColChecked,\r\n        otherColCheckedIndex: prevState.otherColCheckedIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"populateRecommendation\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        keyColIndex: prevState.keyColIndex,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    else if (lastAction === \"populateStartRecommend\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        keyColIndex: prevState.keyColIndex,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        previewColIndex: prevState.previewColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // This is an empty else clause.\r\n    else {\r\n\r\n    }\r\n  }\r\n\r\n  // The two following functions opens/closes the modal for union table settings.\r\n\r\n  openModal() {\r\n    this.setState({\r\n      showSetting: true,\r\n    })\r\n  }\r\n\r\n  closeModal() {\r\n    this.setState({\r\n      showSetting: false,\r\n    })\r\n  }\r\n\r\n  // The following function toggles this.state.showTableSelection.\r\n\r\n  toggleTableSelection() {\r\n    let showTableSelection = !this.state.showTableSelection;\r\n    this.setState({\r\n      showTableSelection: showTableSelection,\r\n    })\r\n  }\r\n\r\n  // The following function handles the toggling of \"show unionable tables\" and \"show joinable tables\".\r\n  // based on whether the string passed in is \"union\" or \"join\"\r\n\r\n  toggleUnionJoin(e, str) {\r\n    // In this case we are toggling on/off unionable tables \r\n    if (str === \"union\") {\r\n      this.setState({\r\n        showUnionTables: !this.state.showUnionTables,\r\n        showJoinTables: false,\r\n      })\r\n    }\r\n    // In this case we are toggling on/off joinable tables \r\n    else {\r\n      // Note: every time before we toggle on joinable tables, let's set all this.state.tableOpenList to false\r\n      let tableOpenList = this.state.tableOpenList.slice();\r\n      for (let i = 0; i < tableOpenList.length; ++i) {\r\n        tableOpenList[i] = false;\r\n      }\r\n      this.setState({\r\n        showUnionTables: false,\r\n        showJoinTables: !this.state.showJoinTables,\r\n        tableOpenList: tableOpenList,\r\n      })\r\n    }\r\n  }\r\n\r\n  // The following function handles the join of a selected table with the table in tablePanel.\r\n\r\n  handleJoinTable(e, i) {\r\n    // We need to get two arrays of column headers. One for the table panel table, one for the selected table to join.\r\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\r\n    let originTableHeader = [];\r\n    let joinTableHeader = [];\r\n\r\n    // Note: both originTableHeader and joinTableHeader are array of objects with three properties: label, value, and index\r\n\r\n    // First we get the header for the origin table\r\n    // console.log(tableHeader);\r\n    // Let's loop through this tableHeader to fill the originTableHeader\r\n    for (let i = 0; i < tableHeader.length; ++i) {\r\n      // If the current element in table header has length of 0, it means it's empty\r\n      if (tableHeader[i].length === 0) {\r\n        break;\r\n      }\r\n      else {\r\n        // We loop through the tableHeader[i]\r\n        let value = \"\";\r\n        for (let j = 0; j < tableHeader[i].length; ++j) {\r\n          let valueToAdd = j > 0 ? \"&\" + tableHeader[i][j].value : tableHeader[i][j].value;\r\n          value+=valueToAdd;\r\n        }\r\n        originTableHeader.push(\r\n          {\r\n            \"value\":value,\r\n            \"label\":value,\r\n            \"index\":i\r\n          }\r\n        )\r\n      }\r\n    }\r\n    // console.log(originTableHeader);\r\n\r\n    // Now that we have originTableHeader working correctly, let's get the joinTableHeader\r\n    let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\r\n    let joinTableData = setTableFromHTML(this.state.originTableArray[i], urlOrigin);\r\n    // console.log(joinTable);\r\n\r\n    // We start the index from 1, because 0 index corresponds to OriginURL\r\n    for (let i = 0; i < joinTableData[0].length; ++i) {\r\n      joinTableHeader.push(\r\n        {\r\n          \"value\":joinTableData[0][i].data,\r\n          \"label\":joinTableData[0][i].data,\r\n          \"index\":i\r\n        }\r\n      )\r\n    }\r\n\r\n    // Now we take a look at originTableHeader, joinTableHeader, and joinTable\r\n    // console.log(originTableHeader);\r\n    // console.log(joinTableHeader);\r\n    // console.log(joinTableData);\r\n\r\n    // It seems like we have fetched the right values. \r\n    // Now we use these to update states, so that join modal can display the right content.\r\n\r\n    // Bugfix here: if either tableHeader is empty, we want to show an alert message\r\n    if (originTableHeader.length === 0 || joinTableHeader.length === 0) {\r\n      alert(\"One of the join tables have no data. Join cannot be performed.\");\r\n    }\r\n    else {\r\n      // Support for join suggestions starts here: \r\n      // we compute the three most joinable column pairs based on column data\r\n      // console.log(this.state.tableData);\r\n      // console.log(joinTableData);\r\n\r\n      // We call the helper function computeJoinableColumn that takes in the table data and headers\r\n\r\n      let joinPairRecord = computeJoinableColumn(this.state.tableData, joinTableData, originTableHeader, joinTableHeader);\r\n\r\n      this.setState({\r\n        showJoinModal: true,\r\n        joinTableIndex: i,\r\n        joinTableData: joinTableData,\r\n        originColOptions: originTableHeader,\r\n        joinColOptions: joinTableHeader,\r\n        joinPairRecord: joinPairRecord,\r\n      })\r\n    }\r\n  }\r\n\r\n  // The following function handles cancelling the join operation.\r\n\r\n  cancelJoin(e) {\r\n    this.setState({\r\n      showJoinModal: false,\r\n    })\r\n  }\r\n\r\n  // The following function handles the selection of join columns.\r\n  // It updates either originJoinIndex, or joinJoinIndex, based on the second parameter passed in\r\n\r\n  selectJoinColumn(e, table) {\r\n    // console.log(e.index);\r\n    if (table === \"originTable\") {\r\n      this.setState({\r\n        originJoinIndex: e.index,\r\n      })\r\n    }\r\n    else {\r\n      this.setState({\r\n        joinJoinIndex: e.index,\r\n      })\r\n    }\r\n  }\r\n\r\n  // The function handles the actual join of two selected tables. \r\n  // Currently, the only join type supported is left join\r\n\r\n  // Since join is equal to column addition, we need to update tableData, tableHeader, optionsMap, and selectedClassAnnotation\r\n\r\n  // Note: it also supports users directly clicks on one of the join suggestions\r\n  runJoin(e, method, originIndex, joinIndex) {\r\n    // First check all the info that we needed\r\n    let joinTableData = this.state.joinTableData.slice();\r\n    let originJoinIndex = \"\";\r\n    let joinJoinIndex = \"\";\r\n    if (method === \"custom\") {\r\n      originJoinIndex = this.state.originJoinIndex;\r\n      joinJoinIndex = this.state.joinJoinIndex;\r\n    }\r\n    else {\r\n      originJoinIndex = originIndex;\r\n      joinJoinIndex = joinIndex;\r\n    }\r\n    // console.log(joinTableData);\r\n    // console.log(\"Column to join from original table is \"+originJoinIndex);\r\n    // console.log(\"Column to join from new tabel is \"+joinJoinIndex);\r\n    \r\n    // If the join table has n columns, then we are adding n-1 new columns to the table in table panel.\r\n    // Since we only allow join of one column from each table.\r\n\r\n    // Let's deal with tableHeader, optionsMap, and selectedCalssAnnotation, before we move on to tableData.\r\n    let tableHeaderUpdated = this.state.tableHeader.slice();\r\n    let optionsMapUpdated = this.state.optionsMap.slice();\r\n    let selectedClassAnnotationUpdated = this.state.selectedClassAnnotation.slice();\r\n\r\n    // First we handle tableHeader's addition.\r\n    // We first loop through tableHeader to remove all the empty ones\r\n    for (let i = 0; i < tableHeaderUpdated.length; ++i) {\r\n      if (tableHeaderUpdated[i] === \"\") {\r\n        tableHeaderUpdated.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n    // Now we push on the new columns. Note that it has to be in the form of an array\r\n    for (let i = 0; i < joinTableData[0].length; ++i) {\r\n      if (i !== joinJoinIndex) {\r\n        tableHeaderUpdated.push(\r\n          [\r\n            {\r\n              \"value\":joinTableData[0][i].data,\r\n              \"label\":joinTableData[0][i].data\r\n            }\r\n          ]\r\n        )\r\n      }\r\n    }\r\n    // console.log(tableHeaderUpdated); \r\n\r\n    // Then we handle optionsMap's addition. We do not need to do much here.\r\n    // We start the index from 1, because we only add in n-1 new columns.\r\n    for (let i = 1; i < joinTableData[0].length; ++i) {\r\n      optionsMapUpdated.push([]);\r\n    }\r\n    // console.log(optionsMapUpdated);\r\n\r\n    // Then we handle selectedClassAnnotation's addition.\r\n    let queryPromise = [findClassAnnotation(this.state.originTableArray[this.state.joinTableIndex])];\r\n    allPromiseReady(queryPromise).then((values) => {\r\n    // Note, we need to push on an empty [] to values here, corresponding to the originURL column's class annotation\r\n    values[0].splice(0, 0, []);\r\n    for (let i = 0; i < values[0].length; ++i) {\r\n      if (i !== joinJoinIndex) {\r\n        selectedClassAnnotationUpdated.push(values[0][i]);\r\n      }\r\n    }\r\n    console.log(selectedClassAnnotationUpdated);\r\n    \r\n    // Lastly, and most importantly, we want to handle tableData's change.\r\n    // Let's start with an empty tableDataUpdated. Loop through tableData. \r\n    // Use a bool to keep track of if tableData[i][originJoinIndex] is in join table. For every yes, we push one element onto tableDataUpdated.\r\n    // If at the end, the bool is still no, we push on tableData[i] with a bunch of N/A's at the position of the newly added columns.\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    let tableDataUpdated = [];\r\n    // Let's first run some code to process joinTableData, so that it shares the same format as tableData\r\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\r\n    let joinTableHeader = [];\r\n    for (let j=0;j<joinTableData[0].length;++j) {\r\n      joinTableHeader.push(\r\n        {\"value\":joinTableData[0][j].data\r\n        ,\"label\":joinTableData[0][j].data}\r\n      )\r\n    }\r\n    let joinTableDataUpdated = [];\r\n    // console.log(tableDataExplore);\r\n    // This starts the loop for rows\r\n    for (let i=1;i<joinTableData.length;++i) {\r\n      let tempRow = [];\r\n      // This starts the loop for columns\r\n      for (let j=0;j<joinTableData[i].length;++j) {\r\n        // First set the data\r\n        let data = joinTableData[i][j].data;\r\n        // Then set the origin\r\n        let origin = [];\r\n        let originText = joinTableData[i][j].origin+\": \"+joinTableHeader[j].value+\": \"+joinTableData[i][j].data;\r\n        origin.push(originText);\r\n        tempRow.push({\"data\":data,\"origin\":origin});\r\n      }\r\n      joinTableDataUpdated.push(tempRow);\r\n    }\r\n\r\n    // Take a look at tableData, and joinTableDataUpdated\r\n    // console.log(tableData);\r\n    // console.log(joinTableDataUpdated);\r\n\r\n    // Now we can finally start the join operator\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      let curJoinEntry = tableData[i][originJoinIndex].data;\r\n      // console.log(\"Current entry to join is \"+curJoinEntry);\r\n      let curEntryFound = false;\r\n      // We start the index from 1 because the first column in joinTableData is the header\r\n      for (let j = 0; j < joinTableDataUpdated.length; ++j) {\r\n        if (joinTableDataUpdated[j][joinJoinIndex].data === curJoinEntry) {\r\n          // console.log(\"A match has been found at index \"+j);\r\n          // Let's create the tempRow that we want to push onto tableDataUpdated\r\n\r\n          let tempRow = _.cloneDeep(tableData[i]);\r\n          for (let k = 0; k < joinTableDataUpdated[j].length; ++k) {\r\n            if (k !== joinJoinIndex) {\r\n              tempRow.push(joinTableDataUpdated[j][k]);\r\n            }\r\n          }\r\n          tableDataUpdated.push(tempRow);\r\n          curEntryFound = true;\r\n        }\r\n      }\r\n      // If this current entry does NOT have a corresponding entry in the join table,\r\n      // We push it directly onto tableDataUpdated, with the addtion of some N/A's.\r\n      if (curEntryFound === false) {\r\n        // Let's create the tempRow that we want to push onto tableDataUpdated\r\n\r\n        // Code Placeholder\r\n        let tempRow = _.cloneDeep(tableData[i]);\r\n        for (let k = 0; k < joinTableDataUpdated[0].length; ++k) {\r\n          if (k !== joinJoinIndex) {\r\n            tempRow.push(\r\n              {\r\n                \"data\":\"N/A\",\r\n                \"origin\":[]\r\n              }\r\n            );\r\n          }\r\n        }\r\n        tableDataUpdated.push(tempRow);\r\n      }\r\n    }\r\n    // console.log(tableDataUpdated);\r\n\r\n    // Now, we have correctly got everything we needed: tableDataUpdated, tableHeaderUpdated, optionsMapUpdated, selectedClassAnnotationUpdated\r\n    // Let's add some support for undo, and do not forget to close the joinModal\r\n\r\n    let promiseArrayOne = this.getNeighbourPromise(tableDataUpdated, \"subject\", this.state.keyColIndex);\r\n    let promiseArrayTwo = this.getNeighbourPromise(tableDataUpdated, \"object\", this.state.keyColIndex);\r\n\r\n    // Now we add support for the semantic trees\r\n    // First take a look at tableDataUpdated\r\n    // console.log(tableDataUpdated);\r\n\r\n    // We sample rows from the table. Note that we need a semantic tree for every column\r\n    // Except the first (since the first column is OriginURL)\r\n    let sampleRows = _.sampleSize(tableDataUpdated, Math.min(tableDataUpdated.length, numForTree));\r\n    let promiseArray = getRDFType(sampleRows, -1, this.state.usecaseSelected);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\r\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\r\n\r\n      // We call updateNeighbourInfo here because we are changing the rows\r\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\r\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\r\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\r\n\r\n      // In here we call another helper function to store the ontology rdf:type of the sampleRows\r\n      // to support semantic tree\r\n      let typeRecord = buildTypeRecord(sampleRows, -1, values, this.state.usecaseSelected);\r\n      // console.log(typeRecord);\r\n\r\n      // Support for undo: \r\n      let lastAction = \"runJoin\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n          \"tableHeader\":this.state.tableHeader,\r\n          \"keyColNeighbours\":this.state.keyColNeighbours,\r\n          \"firstDegNeighbours\":this.state.firstDegNeighbours,\r\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\r\n          \"previewColIndex\": this.state.previewColIndex,\r\n          \"typeRecord\": this.state.typeRecord,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        tableData: tableDataUpdated,\r\n        tableHeader: tableHeaderUpdated,\r\n        keyColNeighbours: keyColNeighbours,\r\n        firstDegNeighbours: firstDegNeighbours,\r\n        selectedClassAnnotation: selectedClassAnnotationUpdated,\r\n        showJoinModal: false,\r\n        previewColIndex: -1,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n        typeRecord: typeRecord,\r\n      })\r\n    })\r\n    })\r\n    })\r\n    })\r\n  }\r\n\r\n  // This function handles the expansion/collapse of an attribute in cell preview and origin\r\n  togglePreviewElement(e, i) {\r\n    let previewInfoExpanded = this.state.previewInfoExpanded.slice();\r\n    previewInfoExpanded[i] = !previewInfoExpanded[i];\r\n    this.setState({\r\n      previewInfoExpanded: previewInfoExpanded,\r\n    })\r\n  }\r\n\r\n  // This function handles the URL paste for table union. It should very similar to handleURLPaste\r\n  handleUnionPaste(e) {\r\n\r\n    document.body.classList.add('waiting');\r\n\r\n    // We first get the urlPasted\r\n    e.preventDefault();\r\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\r\n\r\n    // We first check if user has pasted a valid wikipedia page.\r\n    if (!urlPasted.includes(\"https://en.wikipedia.org/wiki/\")) {\r\n      document.body.classList.remove('waiting');\r\n      alert(\"Please paste a valid Wikipedia link.\");\r\n    }\r\n\r\n    // If yes, we need to fetch the tables from the pasted Wikipedia page\r\n    else {\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchText(urlPasted));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // We first parse the pasted URL and store the list of tables from the pasted URL\r\n        let htmlText = values[0];\r\n        let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\r\n        let wikiTableArray = doc.getElementsByClassName(\"wikitable\");\r\n        let unionTableArray = [];\r\n        for (let i = 0; i < wikiTableArray.length; ++i) {\r\n          if (wikiTableArray[i].tagName === \"TABLE\" && wikiTableArray[i].rows !== undefined) {\r\n            unionTableArray.push(wikiTableArray[i]);\r\n          }\r\n        }\r\n        let unionOpenList = [];\r\n        for (let i = 0; i < unionTableArray.length; ++i) {\r\n          unionOpenList.push(false);\r\n        }\r\n\r\n        document.body.classList.remove('waiting');\r\n\r\n        // Need to add support for undo later. Skip for now\r\n        this.setState({\r\n          unionURL: urlPasted,\r\n          unionTableArray: unionTableArray,\r\n          unionOpenList: unionOpenList,\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function handles the toggle on/off for tables in unionTableArray\r\n  toggleUnionTable(e, index) {\r\n    let unionOpenList = this.state.unionOpenList.slice();\r\n    unionOpenList[index] = !unionOpenList[index];\r\n    // When we toggle on one table (to union), we want to close all other tables\r\n    for (let i = 0; i < unionOpenList.length; ++i) {\r\n      if (i !== index) {\r\n        unionOpenList[i] = false;\r\n      }\r\n    }\r\n    this.setState({\r\n      unionOpenList: unionOpenList,\r\n    })\r\n  }\r\n\r\n  // The function handles user clicking the \"union\" button for a table from unionTableArray\r\n  // For now, it simply sets showUnionModal to true.\r\n  showUnionAlign(e, index) {\r\n    this.setState({\r\n      showUnionModal: true,\r\n    })\r\n  }\r\n\r\n  // The function handles cancel of union operation. For now, it just sets showUnionModal to false.\r\n  cancelUnionAlign() {\r\n    this.setState({\r\n      showUnionModal: false,\r\n    })\r\n  } \r\n\r\n  // The following function is completely hardcoded: it performs the table union\r\n  hardcodeUnion(e) {\r\n    document.body.classList.add('waiting');\r\n\r\n    let dataToUnion = setTableFromHTML(this.state.unionTableArray[0],\"\");\r\n    // console.log(dataToUnion);\r\n\r\n    // Now we should have a for loop to loop over dataToUnion.length\r\n    // We also need to run a loop to queries to specifically fetch the dbo:starring attribute\r\n\r\n    // Let's first take a look of all the movies (all entries from col index 2). \r\n    // Then we will ask the queries. Then, when we get our results back (the starring), \r\n    // we construct the new table data row by row. One cell at a time.\r\n    // and concat the new table data with the existing table data.\r\n\r\n    let promiseArray = [];\r\n\r\n    for (let i = 0; i < dataToUnion.length; ++i) {\r\n      let cellValue = dataToUnion[i][2].data === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(dataToUnion[i][2].data);\r\n      let prefixURL = \r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL = \r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBody =\r\n        \"select+%3Fo%0D%0Awhere+%7B%0D%0Adbr%3A\" + cellValue + \"+dbo%3Astarring+%3Fo.%0D%0A%7D&\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n\r\n      // for (let i = 0; i < values.length; ++i) {\r\n      //   console.log(values[i].results.bindings);\r\n      // }\r\n\r\n      // We have gotten all the data we need. Let's now put them together\r\n\r\n      let otherTableData = [];\r\n\r\n      for (let i = 0; i < dataToUnion.length; ++i) {\r\n        let tempRow = [];\r\n        // We push on the movies, directors, notes (which will be blank), starring (using the query results), and country in order\r\n        // First movies\r\n        tempRow.push(dataToUnion[i][2]);\r\n        // Then directors\r\n        tempRow.push(dataToUnion[i][4]);\r\n        // Then notes. It will have blank data and origin\r\n        tempRow.push({\r\n          \"data\": \"\",\r\n          \"origin\": \"\",\r\n        })\r\n        // Then starring. We need to use query results.\r\n        if (values[i].results.bindings.length === 0) {\r\n          tempRow.push({\r\n            \"data\": \"N/A\",\r\n          })\r\n        }\r\n        else {\r\n          let tempData = \"\";\r\n          for (let j = 0; j < values[i].results.bindings.length; ++j) {\r\n            if (j > 0) {\r\n              tempData+=\";\";\r\n            }\r\n            tempData+=removePrefix(values[i].results.bindings[j].o.value);\r\n          }\r\n          tempRow.push({\r\n            \"data\": tempData,\r\n            \"origin\":\"\",\r\n          })\r\n        }\r\n        // Lastly, country.\r\n        tempRow.push(dataToUnion[i][5]);\r\n\r\n        // After the row has been set, we push the row onto otherTableData\r\n        otherTableData.push(tempRow);\r\n      }\r\n      // console.log(otherTableData);\r\n\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      tableData = tableData.concat(otherTableData);\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      this.setState({\r\n        showUnionModal: false,\r\n        tableData: tableData,\r\n      })\r\n    })\r\n  }\r\n\r\n  // The following function handles users uploading a json table downloaded from website\r\n  handleFileChange(e) {\r\n\r\n    document.body.classList.add('waiting');\r\n\r\n    console.log(\"File just uploaded\");\r\n    let uploadedFile = e.target.files[0];\r\n    let reader = new FileReader();\r\n    reader.readAsText(uploadedFile);\r\n    console.log(\"Reading file is done\");\r\n    reader.onload = async(e) => {\r\n      let result = e.target.result;\r\n      let content = await JSON.parse(result);\r\n      // In here we have parsed the file read in\r\n      console.log(content);\r\n\r\n      // Note that originTableArray cannot be copied into the JSON file, we need to fetch it again here\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchText(content.urlPasted));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n      // We first parse the pasted URL and store the list of tables from the pasted URL\r\n      let htmlText = values[0];\r\n      let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\r\n      let wikiTableArray = doc.getElementsByClassName(\"wikitable\");\r\n      let originTableArray = [];\r\n      for (let i = 0; i < wikiTableArray.length; ++i) {\r\n        // console.log(wikiTableArray[i].rows);\r\n        if (wikiTableArray[i].tagName === \"TABLE\" && wikiTableArray[i].rows !== undefined) {\r\n          originTableArray.push(wikiTableArray[i]);\r\n        }\r\n      }\r\n      originTableArray = content.usecaseSelected === \"startTable\" ? originTableArray : content.originTableArray;\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Let's set state based on content\r\n      this.setState({\r\n        urlPasted: content.urlPasted,\r\n        tablePasted: content.tablePasted,\r\n        usecaseSelected: content.usecaseSelected,\r\n        pageHidden: content.pageHidden,\r\n        iframeURL: content.iframeURL,\r\n        curActionInfo: content.curActionInfo,\r\n        lastAction: content.lastAction,\r\n        prevState: content.prevState,\r\n        showSetting: false,\r\n        showTableSelection: content.showTableSelection,\r\n        tabIndex: content.tabIndex,\r\n        showUnionTables: content.showUnionTables,\r\n        showJoinTables: content.showJoinTables,\r\n\r\n        keyColIndex: content.keyColIndex,\r\n        tableHeader: content.tableHeader,\r\n        tableData: content.tableData,\r\n        optionsMap: content.optionsMap,\r\n        keyColNeighbours: content.keyColNeighbours,\r\n        firstDegNeighbours: content.firstDegNeighbours,\r\n        firstColSelection: content.firstColSelection,\r\n        firstColChecked: content.firstColChecked,\r\n        firstColFilled: content.firstColFilled,\r\n        firstColText: content.firstColIndex,\r\n        keyCheckedIndex: content.keyCheckedIndex,\r\n        firstColHeaderInfo: content.firstColHeaderInfo,\r\n        otherColSelection: content.otherColSelection,\r\n        otherColChecked: content.otherColChecked,\r\n        otherCheckedIndex: content.otherCheckedIndex,\r\n        otherColText: content.otherColText,\r\n\r\n        originTableArray: originTableArray,\r\n        tableOpenList: content.tableOpenList,\r\n        selectedTableIndex: content.selectedTableIndex,\r\n        selectedClassAnnotation: content.selectedClassAnnotation,\r\n        tableDataExplore: content.tableDataExplore,\r\n        propertyNeighbours: content.propertyNeighbours,\r\n        semanticEnabled: content.semanticEnabled,\r\n        unionCutOff: content.unionCutOff,\r\n\r\n        showFilter: false,\r\n        checkAll: true,\r\n        curFilterIndex: -1,\r\n        dataAndChecked: [],\r\n        filterMin: null,\r\n        filterMax: null,\r\n\r\n        showJoinModal: false,\r\n        joinTableIndex: -1,\r\n        joinTableData: [],\r\n        originColOptions: [],\r\n        joinColOptions: [],\r\n        originJoinIndex: -1,\r\n        joinJoinIndex: -1,\r\n        joinPairRecord: [],\r\n\r\n        previewColIndex: content.previewColIndex,\r\n\r\n        selectedCell: content.selectedCell,\r\n        previewInfoArray: content.previewInfoArray,\r\n        previewInfoExpanded: content.previewInfoExpanded,\r\n\r\n        unionURL: content.unionURL,\r\n        unionTableArray: content.unionTableArray,\r\n        unionOpenList: content.unionOpenList,\r\n        showUnionModal: false,\r\n\r\n        semanticTree: content.semanticTree,\r\n        typeRecord: content.typeRecord,\r\n      })\r\n    })\r\n    }\r\n  }\r\n\r\n  render() {\r\n    let bodyEle;\r\n    let bottomContentClass = \" bottom-content\";\r\n    let topContentClass = \"row top-content\";\r\n    if (this.state.pageHidden) {\r\n      bottomContentClass = \" bottom-content-hidden\";\r\n      topContentClass = \"row top-content-large\";\r\n    }\r\n    // If user has not pasted the URL, we want to display the landing page\r\n    if (this.state.urlPasted === \"\") {\r\n      bodyEle = \r\n        <LandingPage \r\n          handleURLPaste={this.handleURLPaste} \r\n          handleFileChange={this.handleFileChange}\r\n        />;\r\n    }\r\n    // Else, we show the three panels: TablePanel, ActionPanel, and PagePanel\r\n    else {\r\n      bodyEle = (\r\n        <div>\r\n          <div className=\"header\">\r\n            <Header \r\n              // Following states are passed for general purposes\r\n              copyTable={this.copyTable}\r\n              undoPreviousStep={this.undoPreviousStep}\r\n              openModal = {this.openModal}\r\n              fullState = {this.state}\r\n            />\r\n          </div> \r\n          <div className=\"mainbody\">\r\n            <div className=\"\">\r\n              <div className={topContentClass}>\r\n                <div className=\"col-md-7 small-padding table-panel\">\r\n                  <TablePanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    // Following states are passed to \"startSubject\"\r\n                    tableHeader={this.state.tableHeader}\r\n                    tableData={this.state.tableData}\r\n                    keyColIndex={this.state.keyColIndex}\r\n                    onCellChange={this.cellChange}\r\n                    selectColHeader={this.selectColHeader}\r\n                    getKeyOptions={this.getKeyOptions}\r\n                    optionsMap={this.state.optionsMap}\r\n                    contextAddColumn={this.contextAddColumn}\r\n                    contextDeleteColumn={this.contextDeleteColumn}\r\n                    contextSetColumn={this.contextSetColumn}\r\n                    originPreviewPage={this.originPreviewPage}\r\n                    showFilterMethods={this.showFilterMethods}\r\n                    // Following states control the render of first column header\r\n                    firstColFilled={this.state.firstColFilled}\r\n                    handlePlusClick={this.handlePlusClick}\r\n                    firstColHeaderInfo={this.state.firstColHeaderInfo}\r\n                    // Following states control the render of other column header\r\n                    getOtherOptions={this.getOtherOptions}\r\n                    // Following states control the render of column preview\r\n                    previewColIndex={this.state.previewColIndex}\r\n                  />\r\n                </div>\r\n                <div className=\"col-md-5 small-padding action-panel\">\r\n                  <ActionPanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    curActionInfo={this.state.curActionInfo}\r\n                    handleStartSubject={this.handleStartSubject}\r\n                    populateKeyColumn={this.populateKeyColumn}\r\n                    populateOtherColumn={this.populateOtherColumn}\r\n                    sameNeighbourDiffRow={this.sameNeighbourDiffRow}\r\n                    sameNeighbourOneRow={this.sameNeighbourOneRow}\r\n                    populateRecommendation={this.populateRecommendation}\r\n                    populateStartRecommend={this.populateStartRecommend}\r\n                    // Folloiwng states are passed to \"startTable\"\r\n                    handleStartTable={this.handleStartTable}\r\n                    propertyNeighbours={this.state.propertyNeighbours}\r\n                    togglePropertyNeighbours={this.togglePropertyNeighbours}\r\n                    toggleSibling={this.toggleSibling}\r\n                    toggleOtherTable={this.toggleOtherTable}\r\n                    unionTable={this.unionTable}\r\n                    unionPage={this.unionPage}\r\n                    unionProperty={this.unionProperty}\r\n                    // Follow state handles tab switch\r\n                    tabIndex={this.state.tabIndex}\r\n                    handleTabSwitch={this.handleTabSwitch}\r\n                    // Following states are passed during start up\r\n                    showTableSelection={this.state.showTableSelection}\r\n                    toggleTableSelection={this.toggleTableSelection}\r\n                    originTableArray={this.state.originTableArray}\r\n                    tableOpenList={this.state.tableOpenList}\r\n                    toggleTable={this.toggleTable}\r\n                    selectedTableIndex={this.state.selectedTableIndex}\r\n                    // Following states are for union/join tables\r\n                    showUnionTables={this.state.showUnionTables}\r\n                    showJoinTables={this.state.showJoinTables}\r\n                    toggleUnionJoin={this.toggleUnionJoin}\r\n                    handleJoinTable={this.handleJoinTable}\r\n                    // Following states are for first column's header selection\r\n                    firstColSelection={this.state.firstColSelection}\r\n                    firstColChecked={this.state.firstColChecked}\r\n                    firstColText={this.state.firstColText}\r\n                    firstColFilled={this.state.firstColFilled}\r\n                    keyColIndex={this.state.keyColIndex}\r\n                    toggleFirstNeighbour={this.toggleFirstNeighbour}\r\n                    firstColTextChange={this.firstColTextChange}\r\n                    tableHeader={this.state.tableHeader}\r\n                    keyCheckedIndex={this.state.keyCheckedIndex}\r\n                    addToFirstCol={this.addToFirstCol}\r\n                    confirmAddFirstCol={this.confirmAddFirstCol}\r\n                    // Following states are for other column's header selection\r\n                    otherColSelection={this.state.otherColSelection}\r\n                    otherColChecked={this.state.otherColChecked}\r\n                    otherColText={this.state.otherColText}\r\n                    otherCheckedIndex={this.state.otherCheckedIndex}\r\n                    toggleOtherNeighbour={this.toggleOtherNeighbour}\r\n                    otherColTextChange={this.otherColTextChange}\r\n                    // Following states are for column's processing methods\r\n                    contextSortColumn={this.contextSortColumn}\r\n                    contextDedupColumn={this.contextDedupColumn}\r\n                    openFilter={this.openFilter}\r\n                    // Following states are for displaying cell's preview and origin\r\n                    previewInfoArray={this.state.previewInfoArray}\r\n                    previewInfoExpanded={this.state.previewInfoExpanded}\r\n                    selectedCell={this.state.selectedCell}\r\n                    togglePreviewElement={this.togglePreviewElement}\r\n                    // Following states are for showStartRecommend\r\n                    keyColNeighbours={this.state.keyColNeighbours}\r\n                    // Following states are for customized table union\r\n                    unionURL={this.state.unionURL}\r\n                    handleUnionPaste={this.handleUnionPaste}\r\n                    unionTableArray={this.state.unionTableArray}\r\n                    unionOpenList={this.state.unionOpenList}\r\n                    toggleUnionTable={this.toggleUnionTable}\r\n                    showUnionAlign={this.showUnionAlign}\r\n                    unionCustomized={this.unionCustomized}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div className={bottomContentClass}>\r\n                <div>\r\n                  <PagePanel\r\n                    pageHidden={this.state.pageHidden}\r\n                    iframeURL={this.state.iframeURL}\r\n                    toggleWikiPage={this.toggleWikiPage}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div>\r\n                <SettingModal \r\n                  showSetting={this.state.showSetting}\r\n                  closeModal={this.closeModal}\r\n                  semanticEnabled={this.state.semanticEnabled}\r\n                  toggleSemantic={this.toggleSemantic}\r\n                  unionCutOff={this.state.unionCutOff}\r\n                  unionCutOffChange={this.unionCutOffChange}\r\n                />\r\n              </div>\r\n              <div>\r\n                <FilterModal\r\n                  showFilter={this.state.showFilter}\r\n                  dataAndChecked={this.state.dataAndChecked}\r\n                  checkAll={this.state.checkAll}\r\n                  applyFilter={this.applyFilter}\r\n                  cancelFilter={this.cancelFilter}\r\n                  toggleChecked={this.toggleChecked}\r\n                  toggleAll={this.toggleAll}\r\n                  // Support for range filter\r\n                  tableData={this.state.tableData}\r\n                  curFilterIndex={this.state.curFilterIndex}\r\n                  filterMin={this.state.filterMin}\r\n                  filterMax={this.state.filterMax}\r\n                  handleRangeFilter={this.handleRangeFilter}\r\n                />\r\n              </div>\r\n              <div>\r\n                <JoinModal \r\n                  showJoin={this.state.showJoinModal}\r\n                  cancelJoin={this.cancelJoin}\r\n                  originColOptions={this.state.originColOptions}\r\n                  joinColOptions={this.state.joinColOptions}\r\n                  originJoinIndex={this.state.originJoinIndex}\r\n                  joinJoinIndex={this.state.joinJoinIndex}\r\n                  selectJoinColumn={this.selectJoinColumn}\r\n                  runJoin={this.runJoin}\r\n                  // support for suggested join\r\n                  joinPairRecord={this.state.joinPairRecord}\r\n                />\r\n              </div>\r\n              <div>\r\n                <UnionModal\r\n                  showUnionModal={this.state.showUnionModal}\r\n                  cancelUnionAlign={this.cancelUnionAlign}\r\n                  hardcodeUnion={this.hardcodeUnion}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"footer\">\r\n            <Footer />\r\n          </div> \r\n        </div>\r\n      );\r\n    }\r\n    return <div>{bodyEle}</div>;\r\n  }\r\n}\r\n\r\nexport default MainBody;\r\n\r\n// This function takes in a queryURL and returns its JSON format\r\nfunction fetchJSON(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS)\r\n        .then(function (response) {\r\n          if (!response.ok) {\r\n            throw Error(1);\r\n          }\r\n          return response;\r\n        })\r\n        .then(function (response) {\r\n          return response.json();\r\n        })\r\n        .catch(function (error) {\r\n          document.body.classList.remove('waiting');\r\n          // alert(\"Some error occured when accessing SPARQL public endpoint. If semantic mapping is enabled, disable it and try again.\");\r\n          return 1;\r\n        })\r\n}\r\n\r\n// This function takes in a queryURL and returns its Text format\r\nfunction fetchText(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS)\r\n         .then((response) => response.text())\r\n         .catch(function (error) {\r\n           document.body.classList.remove(\"waiting\");\r\n           return 1;\r\n         });\r\n}\r\n\r\n// This function ensures that all promises in promiseArray are ready\r\nfunction allPromiseReady(promiseArray) {\r\n  return Promise.all(promiseArray);\r\n}\r\n\r\n// This function replaces string so that the result can be used in queryURL.\r\n// It currently replaces \"(\", \")\", \"'\", \"-\", \" \", \"&\", \".\", \"\"\",and \"/\"\r\nfunction regexReplace(str) {\r\n  return str\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/%/g, \"%5Cu0025\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/</g, \"%5Cu003C\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/>/g, \"%5Cu003E\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\")\r\n    .replace(/@/g, \"%5Cu0040\")\r\n    .replace(/\\^/g, \"%5Cu005E\")\r\n    .replace(/~/g, \"%5Cu007E\")\r\n    .replace(/`/g, \"%5Cu0060\")\r\n    .replace(/\\|/g, \"%5Cu007C\")\r\n    .replace(/\\[/g, \"%5Cu005B\")\r\n    .replace(/\\\\/g, \"%5Cu005C\")\r\n    .replace(/\\]/g, \"%5Cu005D\")\r\n    .replace(/\\{/g, \"%5Cu007B\")\r\n    .replace(/\\}/g, \"%5Cu007D\");\r\n}\r\n\r\n// This function replaces the URL pasted\r\nfunction urlReplace(str) {\r\n  return str\r\n    .replace(/%E2%80%93/g, \"%5Cu2013\")\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/</g, \"%5Cu003C\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/>/g, \"%5Cu003E\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\")\r\n    .replace(/@/g, \"%5Cu0040\")\r\n    .replace(/\\^/g, \"%5Cu005E\")\r\n    .replace(/~/g, \"%5Cu007E\")\r\n    .replace(/`/g, \"%5Cu0060\")\r\n    .replace(/\\|/g, \"%5Cu007C\")\r\n    .replace(/\\[/g, \"%5Cu005B\")\r\n    .replace(/\\\\/g, \"%5Cu005C\")\r\n    .replace(/\\]/g, \"%5Cu005D\")\r\n    .replace(/\\{/g, \"%5Cu007B\")\r\n    .replace(/\\}/g, \"%5Cu007D\");\r\n}\r\n\r\n// This function removes the prefix \"http://dbpedia.org/resource/\" from query results, if it includes one\r\n\r\nfunction removePrefix(str) {\r\n  let prefixToRemove = \"http://dbpedia.org/resource/\";\r\n  // If dbResult contains prefix of \"http://dbpedia.org/resource/\", we want to remove it\r\n  if (str.includes(prefixToRemove) === true) {\r\n     str = str.slice(28);\r\n  }\r\n  return str;\r\n}\r\n\r\n// This function updates the key column's neighbours for ONE entry from the search column.\r\n\r\n// It taks three parameters:\r\n//  1) array \"keyColNeighbour\" storing list of neighbours for the key column\r\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  3) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns the updated keyColNeighbours\r\nfunction updateKeyColNeighbours(keyColNeighbours, resultsBinding, type) {\r\n\r\n  // console.log(resultsBinding);\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 &&\r\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         || a.p.value === \"http://dbpedia.org/property/nba\"\r\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\r\n         )\r\n  );\r\n\r\n  // We remove predicate in dbp that appear in both dbo and dbp: \r\n  // ex: dbo:spouse and dbp:spouse\r\n  processedBinding = processedBinding.sort(function (a, b) {\r\n    if (a.p.value.slice(28) > b.p.value.slice(28)) {\r\n      return 1;\r\n    }\r\n    else if (a.p.value.slice(28) < b.p.value.slice(28)) {\r\n      return -1;\r\n    }\r\n    else {\r\n      if (a.p.value.includes(\"ontology\") && b.p.value.includes(\"property\")) {\r\n        return -1;\r\n      }\r\n      return 1;\r\n    }\r\n  })\r\n  \r\n  for (let i = 1; i < processedBinding.length; ++i) {\r\n    if (processedBinding[i].p.value.includes(\"property\") && processedBinding[i-1].p.value.includes(\"ontology\") &&\r\n        processedBinding[i].p.value.slice(28) === processedBinding[i-1].p.value.slice(28)) {\r\n      processedBinding.splice(i,1);\r\n      --i;\r\n    }\r\n  }\r\n\r\n  // We then do some filtering based on subPropertyOf.\r\n  // Because of our observation, we only want to keep entries whose subPropertyOf attribute is from the DUL dataset.\r\n  // processedBinding = processedBinding.filter(a => a.subPropertyOf === undefined || a.subPropertyOf.value.includes(\"DUL.owl\"));\r\n  processedBinding = processedBinding.filter(function(a) {\r\n    if (a.subPropertyOf !== undefined) {\r\n      return a.subPropertyOf.value.includes(\"DUL.owl\");\r\n    }\r\n    return true;\r\n  })\r\n\r\n  // we then sort the resultsBinding by p.value.slice(28)\r\n  processedBinding = processedBinding.sort((a, b) =>\r\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n  );\r\n\r\n  // we take a look at processedBinding at this stage\r\n  // console.log(processedBinding);\r\n\r\n  // Let's only start the loop is processedBinding is non-empty\r\n  if (processedBinding.length > 0) {\r\n    // We set count of neighbour ready to be added\r\n    let neighbourCount = 1;  \r\n\r\n    // We set literal of neighbour ready to be added.\r\n    // Morever, we get the value of the neighbour ready to be added, depending on type.\r\n    // Initialized with the first neighbour.\r\n\r\n    let neighbourToAdd = processedBinding[0].p.value.slice(28); \r\n    let valuesToAdd = [];\r\n    valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[0].o.value) : removePrefix(processedBinding[0].s.value))\r\n\r\n    // we set range of neighbour ready to be added. \"\" if doesn't exist.\r\n    let neighbourRange = processedBinding[0].range !== undefined ? processedBinding[0].range.value : \"\";\r\n\r\n    // we the subPropertyOf of neighbour ready to be added. \"\" if doesn't exist.\r\n    let neighbourSubPropertyOf = processedBinding[0].subPropertyOf !== undefined ? processedBinding[0].subPropertyOf.value : \"\";\r\n    \r\n    // We loop over processedBinding\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      // If the current neighbour is equal to neighbourToAdd, we increment the count, and push onto valuesToAdd\r\n      if (curNeighbour === neighbourToAdd) {\r\n        ++neighbourCount;\r\n        valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value))\r\n      }\r\n      // else, we push neighbourToAdd to keyColNeighbours. \r\n      else {\r\n        // set value.\r\n        let objValue = neighbourToAdd;\r\n        // set label. We want to change the neighbour label if type === \"object\".\r\n        let objLabel = neighbourToAdd;\r\n        if (type === \"object\") {\r\n          objLabel = \"is \" + objLabel + \" of\";\r\n        }\r\n        // set type\r\n        let objType = type;\r\n        // set count\r\n        let objCount = neighbourCount;\r\n        // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\r\n        let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\r\n        // set range\r\n        let objRange = neighbourRange;\r\n        // set subPropertyOf\r\n        let objSubPropertyOf = neighbourSubPropertyOf;\r\n        // set dataset\r\n\r\n\r\n        // Set object from all its attributes\r\n        let tempObj = {\r\n          \"value\":objValue, \r\n          \"label\":objLabel, \r\n          \"type\":objType, \r\n          // \"dataset\":\"\"\r\n          \"count\":objCount, \r\n          \"filledCount\":1, \r\n          \"data\":objData,\r\n          \"range\":objRange,\r\n          \"subPropertyOf\":objSubPropertyOf\r\n        };\r\n        // We push this tempObj onto keyColNeighbours\r\n        keyColNeighbours.push(tempObj)\r\n\r\n        // We now need to reset neighbourCount, neighbourToAdd, neighbourRange, neighbourSubPropertyOf, and valuesToAdd\r\n        neighbourCount = 1;\r\n        neighbourToAdd = curNeighbour;\r\n        valuesToAdd = [type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value)];\r\n        neighbourRange = processedBinding[i].range !== undefined ? processedBinding[i].range.value : \"\";\r\n        neighbourSubPropertyOf = processedBinding[i].subPropertyOf !== undefined ? processedBinding[i].subPropertyOf.value : \"\";\r\n      }\r\n    }\r\n    // Now, after the loop is done, we need to do one more iteration to determine how we want to add the last neighbour.\r\n    \r\n    // set value.\r\n    let objValue = neighbourToAdd;\r\n    // set label. We want to change the neighbour label if type === \"object\".\r\n    let objLabel = neighbourToAdd;\r\n    if (type === \"object\") {\r\n      objLabel = \"is \" + objLabel + \" of\";\r\n    }\r\n    // set type\r\n    let objType = type;\r\n    // set count\r\n    let objCount = neighbourCount;\r\n    // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\r\n    let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\r\n    // set range\r\n    let objRange = neighbourRange;\r\n    // set subPropertyOf\r\n    let objSubPropertyOf = neighbourSubPropertyOf;\r\n\r\n    // Set object from all its attributes\r\n    let tempObj = {\r\n        \"value\":objValue, \r\n        \"label\":objLabel, \r\n        \"type\":objType, \r\n        \"count\":objCount, \r\n        \"filledCount\":1, \r\n        \"data\":objData,\r\n        \"range\":objRange,\r\n        \"subPropertyOf\":objSubPropertyOf\r\n      };\r\n    // we push this tempObj onto keyColNeighbours\r\n    keyColNeighbours.push(tempObj)\r\n  }\r\n\r\n  // console.log(keyColNeighbours);\r\n  // console.log(processedBinding);\r\n\r\n  return keyColNeighbours;\r\n}\r\n\r\n// This helper function is designed to process the result bindings passed from contextCellPreview.\r\n// It should share some similarity with updateKeyColNeighbours\r\n\r\n// It takes two parameters:\r\n//  1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  2) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns previewInfoArray, a list of objects used to display a cell's preview info\r\n// This object has two properties:\r\n// 1) key: a string\r\n// 2) value: an array of strings\r\nfunction updatePreviewInfo(resultsBinding, type) {\r\n  // console.log(previewInfoArray);\r\n  // console.log(resultsBinding);\r\n  // console.log(type);\r\n\r\n  // Let's do some preprocessing of resultsBinding. We want to do sorting, deduping, and some filtering.\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 &&\r\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         || a.p.value === \"http://dbpedia.org/property/nba\"\r\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\r\n         )\r\n  );\r\n\r\n\r\n  // we then sort the resultsBinding by p.value.slice(28)\r\n  processedBinding = processedBinding.sort((a, b) =>\r\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n  );\r\n\r\n  // Now let's create the previewInfoArray based on processedBinding\r\n  // console.log(processedBinding);\r\n\r\n  let previewInfoArray = [];\r\n\r\n  if (processedBinding.length > 1) {\r\n    // We first push on the first element from processedBinding\r\n\r\n    previewInfoArray.push(\r\n      {\r\n        \"key\": type === \"subject\" ? processedBinding[0].p.value.slice(28) : \"is \"+processedBinding[0].p.value.slice(28)+\" of\",\r\n        \"value\": [removePrefix(processedBinding[0].o.value)],\r\n      }\r\n    )\r\n    let curIndex = 0;\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      let prevNeighbour = processedBinding[i-1].p.value.slice(28);\r\n      // console.log(curNeighbour);\r\n      // console.log(prevNeighbour);\r\n\r\n      // If this neighbour is the same as the previous one, we want to append this neighbour's value\r\n      // to the element's value array in previewInfoArray at curIndex\r\n      if (curNeighbour === prevNeighbour) {\r\n        // Note, we dont want each element in previewInfoArray to contain too many elements (5), so we do a check here.\r\n        if (previewInfoArray[curIndex].value.length < maxNeighbourCount) {\r\n          previewInfoArray[curIndex].value.push(removePrefix(processedBinding[i].o.value));\r\n        }\r\n      }\r\n      // Else, we push a fresh element onto previewInforArray, and update curIndex\r\n      else {\r\n        previewInfoArray.push(\r\n          {\r\n            \"key\": type === \"subject\" ? processedBinding[i].p.value.slice(28) : \"is \"+processedBinding[i].p.value.slice(28)+\" of\",\r\n            \"value\":[removePrefix(processedBinding[i].o.value)],\r\n          }\r\n        )\r\n        ++curIndex;\r\n      }\r\n    }\r\n  }\r\n\r\n  // At the current stage, previewInfoArray contains all the dbo and dbp neighbours. \r\n  // Let's also add support for the DB categories, so that those can be displayed in cell preview as well.\r\n  let categoryPreviewInfoArray = [];\r\n  if (type === \"subject\") {\r\n    let categoryBinding = resultsBinding.filter(\r\n      a => a.p.value.includes(\"dc/terms/subject\")\r\n    ) \r\n    // console.log(categoryBinding);\r\n    if (categoryBinding.length > 0) {\r\n      categoryPreviewInfoArray.push(\r\n        {\r\n          \"key\": \"Category\",\r\n          \"value\": [categoryBinding[0].o.value.slice(37)]\r\n        }\r\n      );\r\n      for (let i = 1; i < categoryBinding.length; ++i) {\r\n        categoryPreviewInfoArray[0].value.push(categoryBinding[i].o.value.slice(37));\r\n      }\r\n    }\r\n  }\r\n  // We concat categoryPreviewInfoArray with previewInfoArray.\r\n  previewInfoArray = categoryPreviewInfoArray.concat(previewInfoArray);\r\n  // console.log(previewInfoArray);\r\n\r\n  return previewInfoArray;\r\n}\r\n\r\n// This function processes the resultsBinding passed from handleStartSubject, to create the info needed for Action Panel.\r\n// It should share some similarity with updatePreviewInfo\r\n\r\n// It takes one parameter:\r\n// 1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n// Note: \"type\" parameter is not needed, since we are not dealing with object neighbours\r\n\r\nfunction updateFirstColSelection(resultsBinding) {\r\n\r\n  // we first filter out those in resultsBinding according to three criterias\r\n  // Note: the second criteria is a bit different from updateKeyColNeighbours and updatePreviewInfo\r\n\r\n  // 1) p.value.slice(28).length must > 1\r\n  // 2) p.value must include \"ontology\", \"property\", or \"dc/terms/subject\" (so it is one of dbo:XXXX, dbp:XXXX, or dct:subject)\r\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n  let processedBinding = resultsBinding.filter(\r\n    a => a.p.value.slice(28).length > 1 \r\n         &&\r\n         (a.p.value.includes(\"ontology\") \r\n         || a.p.value.includes(\"property\")\r\n         || a.p.value.includes(\"dc/terms/subject\")\r\n         ) \r\n         &&\r\n         !(a.p.value.includes(\"wikiPage\") \r\n         || a.p.value.includes(\"align\") \r\n         || a.p.value.includes(\"abstract\") \r\n         || a.p.value.includes(\"caption\") \r\n         || a.p.value.includes(\"image\") \r\n         || a.p.value.includes(\"width\") \r\n         || a.p.value.includes(\"thumbnail\") \r\n         || a.p.value.includes(\"blank\")\r\n         || a.p.value.includes(\"fec\")\r\n         || a.p.value.includes(\"viaf\")\r\n         || a.p.value.includes(\"soundRecording\")\r\n         || a.p.value.includes(\"votesmart\")\r\n         || a.p.value.includes(\"wordnet\")\r\n         || a.p.value.includes(\"float\")\r\n         || a.p.value.includes(\"bbr\")\r\n         || a.p.value === \"http://dbpedia.org/property/alt\"\r\n         || a.p.value === \"http://dbpedia.org/property/by\"\r\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n         || a.p.value === \"http://dbpedia.org/property/signature\"\r\n         || a.p.value === \"http://dbpedia.org/property/video\"\r\n         || a.p.value === \"http://dbpedia.org/property/logo\"\r\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/body\"\r\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n         || a.p.value === \"http://dbpedia.org/property/nba\"\r\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\r\n         )\r\n  );\r\n\r\n  // We remove predicate in dbp that appear in both dbo and dbp: \r\n  // ex: dbo:spouse and dbp:spouse\r\n  processedBinding = processedBinding.sort(function (a, b) {\r\n    if (a.p.value.slice(28) > b.p.value.slice(28)) {\r\n      return 1;\r\n    }\r\n    else if (a.p.value.slice(28) < b.p.value.slice(28)) {\r\n      return -1;\r\n    }\r\n    else {\r\n      if (a.p.value.includes(\"ontology\") && b.p.value.includes(\"property\")) {\r\n        return -1;\r\n      }\r\n      return 1;\r\n    }\r\n  })\r\n  \r\n  for (let i = 1; i < processedBinding.length; ++i) {\r\n    if (processedBinding[i].p.value.includes(\"property\") && processedBinding[i-1].p.value.includes(\"ontology\") &&\r\n        processedBinding[i].p.value.slice(28) === processedBinding[i-1].p.value.slice(28)) {\r\n      processedBinding.splice(i,1);\r\n      --i;\r\n    }\r\n  }\r\n  \r\n  // We then sort the processedBinding by some criterias.\r\n\r\n  // First Criteria: dct:subjects should show up at the top of the list, sorted by o.value.slice(37).\r\n\r\n  // Since a customized sort is a bit hard to write, let's break this array into two, sort each one, then concat them back together\r\n  let dctArray = [];\r\n  let dbopArray = [];\r\n  for (let i = 0; i < processedBinding.length; ++i) {\r\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\r\n      dctArray.push(processedBinding[i]);\r\n    }\r\n    else {\r\n      dbopArray.push(processedBinding[i]);\r\n    }\r\n  }\r\n\r\n  // We first sort the dctArray by o.value.slice(37).\r\n\r\n  dctArray.sort((a, b) => (a.o.value.slice(37) < b.o.value.slice(37) ? -1 : 1));\r\n\r\n  // We then sort dbop array by the following rules:\r\n  // Those that are dbr (so without a datatype) shows up higher\r\n  // Then those with a smaller count shows up higher\r\n  // Then alphabetical order.\r\n\r\n  // The following code gets the count for each property(or neighbour)\r\n  dbopArray.sort((a, b) => (a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1));\r\n  if (dbopArray.length > 0) {\r\n    dbopArray[0].p.count = getPCount(dbopArray[0].p.value, dbopArray);\r\n  }\r\n  for (let i = 1; i < dbopArray.length; ++i) {\r\n    let prevNeighbour = dbopArray[i-1];\r\n    let curNeighbour = dbopArray[i];\r\n    if (prevNeighbour.p.value === curNeighbour.p.value) {\r\n      curNeighbour.p.count = prevNeighbour.p.count;\r\n    }\r\n    else {\r\n      curNeighbour.p.count = getPCount(dbopArray[i].p.value, dbopArray);\r\n    }\r\n  }\r\n\r\n  // The following code sorts the array\r\n  dbopArray.sort(function (a, b) {\r\n    if (a.o.datatype === undefined && b.o.datatype !== undefined) {\r\n      return -1;\r\n    }\r\n    else if (b.o.datatype === undefined && a.o.datatype !== undefined) {\r\n      return 1;\r\n    }\r\n    else {\r\n      if (a.p.count === b.p.count) {\r\n        return a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1;\r\n      }\r\n      else {\r\n        return a.p.count < b.p.count ? -1 : 1;\r\n      }\r\n    }\r\n  });\r\n  // console.log(dbopArray);\r\n\r\n  // At this stage, we have finished sorting both dctArray and dbopArray. Let's put them back together.\r\n  processedBinding = dctArray.concat(dbopArray);\r\n\r\n  // console.log(processedBinding);\r\n\r\n  // Now we need to loop over the processedBinding, and create an array of objects. \r\n  // This array should have length equal to processedBinding.length.\r\n  // Each object should have 6 attributes.\r\n  // 1) pValue: value of predicate\r\n  // 2) pDataset: which dataset does this predicate belong to (one of dbo, dbp, and dct)\r\n  // 3) oValue: value of object\r\n  // 4) oType: datatype of object, such as \"http://www.w3.org/2001/XMLSchema#date\". This can be empty.\r\n\r\n  // 5) value: same as pValue: historical code\r\n  // 6) label: same as pValue: historical code\r\n\r\n  let firstColSelection = [];\r\n\r\n  for (let i = 0; i < processedBinding.length; ++i) {\r\n    // First case: current neighbour is from dct:subject\r\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\r\n      firstColSelection.push(\r\n        {\r\n          \"pValue\":\"category\",\r\n          \"pDataset\":\"dct\",\r\n          \"oValue\":processedBinding[i].o.value.slice(37),\r\n          \"oType\":\"\",\r\n          \"value\":\"category\",\r\n          \"label\":processedBinding[i].o.value.slice(37),\r\n        }\r\n      )\r\n    }\r\n    // Second case: current neighbour is from dbo or dbp\r\n    else {\r\n      firstColSelection.push(\r\n        {\r\n          \"pValue\":processedBinding[i].p.value.slice(28),\r\n          \"pDataset\":processedBinding[i].p.value.includes(\"property\") ? \"dbp\" : \"dbo\",\r\n          \"oValue\":removePrefix(processedBinding[i].o.value),\r\n          \"oType\":processedBinding[i].o.datatype === undefined ? \"\" : processedBinding[i].o.datatype,\r\n          \"value\":processedBinding[i].p.value.slice(28),\r\n          \"label\":processedBinding[i].p.value.slice(28)+\":\"+removePrefix(processedBinding[i].o.value),\r\n        }\r\n      )\r\n    }\r\n  }\r\n  // console.log(firstColSelection);\r\n  return firstColSelection;\r\n}\r\n\r\n\r\n// This function takes in the clean data for the first table, clean data for the second table, and colMapping between these two tables\r\n// And returns the unioned clean data for the first table\r\n\r\nfunction tableConcat(tableData, otherTableData, otherTableOrigin, tempMapping) {\r\n\r\n  // Now we insert the data into dataToAdd. dataToAdd will be concatenated with tableData\r\n  let dataToAdd = [];\r\n  for (let i = 0; i < otherTableData.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < tempMapping.length; ++j) {\r\n      let colInNew = tempMapping[j];\r\n      if (colInNew !== -1) {\r\n        tempRow.push(otherTableData[i][colInNew]);\r\n      } else {\r\n        tempRow.push({ \r\n          data: \"N/A\",\r\n          origin: [otherTableOrigin],\r\n        });\r\n      }\r\n    }\r\n    dataToAdd.push(tempRow);\r\n  }\r\n  return tableData.concat(dataToAdd);\r\n}\r\n\r\nfunction HTMLCleanCell(str) {\r\n  // Note that this function also removes leading and trailing whitespaces\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1).trim().split(\"[\")[0];\r\n  } else {\r\n    return str.trim().split(\"[\")[0];\r\n  }\r\n}\r\n\r\n// This function returns an array of table objects that are unionable with the selected table.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"tableHTML\" storing the HTML of the selected table\r\n//  2) HTML \"pageHTML\", storing the HTML of a sibling page\r\n\r\n// Table object has four attributes: isOpen, data, unionScore, colMapping\r\n\r\n// Once semantic mapping feature is added, the colMapping will be updated\r\n\r\nfunction findTableFromHTML(\r\n  tableHeader,\r\n  pageHTML,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // We first get the column names of the table in the table panel, using this.state.tableHeader.\r\n  // Note: the index starts from 1 because we don't care about the originURL column (column 0). ***\r\n  let originCols = [];\r\n  // BUGFIX needs to be applied here. (Seems to be fixed)\r\n  // console.log(tableHeader);\r\n  for (let j = 1; j < tableHeader.length; ++j) {\r\n    let curValue = \"\"\r\n    for (let k = 0; k < tableHeader[j].length; ++k) {\r\n      curValue+=tableHeader[j][k].value;\r\n    }\r\n    originCols.push(curValue);\r\n  }\r\n\r\n  // We now fetch all the tables from pageHTML (the current sibling page)\r\n  let doc = new DOMParser().parseFromString(pageHTML, \"text/html\");\r\n  let wikiTablesFound = doc.getElementsByClassName(\"wikitable\");\r\n  let tablesFound = [];\r\n  for (let i = 0; i < wikiTablesFound.length; ++i) {\r\n    // console.log(wikiTablesFound[i].tagName);\r\n    if (wikiTablesFound[i].tagName === \"TABLE\" && wikiTablesFound[i].rows !== undefined) {\r\n      tablesFound.push(wikiTablesFound[i]);\r\n    }\r\n  }\r\n\r\n  // console.log(tablesFound);\r\n\r\n  // This is the array we will return.\r\n  let tableArray = [];\r\n\r\n  // We now loop through all the tables found on this sibling page, and see if they are unionable with the selected table\r\n  let tablePromise = [];\r\n  for (let i = 0; i < tablesFound.length; ++i) {\r\n    tablePromise.push(\r\n      findTableFromTable(\r\n        tablesFound[i],\r\n        originCols,\r\n        selectedClassAnnotation,\r\n        semanticEnabled,\r\n        unionCutOff,\r\n        pageName\r\n      )\r\n    );\r\n  }\r\n\r\n  return allPromiseReady(tablePromise).then((values) => {\r\n    for (let i = 0; i < values.length; ++i) {\r\n      tableArray.push(values[i]);\r\n    }\r\n    // we filter the tableArray here by removing those tables that do not have a high enough unionScore\r\n    // Note: In the unfiltered table array, we are using -1 to represent tables with a low unionScore\r\n    tableArray = tableArray.filter(function (x) {\r\n      return x !== -1;\r\n    });\r\n    // console.log(tableArray);\r\n    // We sort the tableArray here by unionScore\r\n    tableArray.sort((a, b) => (a.unionScore < b.unionScore ? 1 : -1));\r\n    return Promise.resolve(tableArray);\r\n  });\r\n}\r\n\r\n// This function takes in four parameters:\r\n\r\n// 1) a tableHTML\r\n// 2) originCols (denoting the columns names of the selected table)\r\n// 3) class annotation of the selected table\r\n// 4) whether semantic mapping is enabled or not\r\n\r\n// and return a table Object with properties: isOpen, unionScore, colMapping, and data\r\nfunction findTableFromTable(\r\n  tableHTML,\r\n  originCols,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // Define some constants\r\n  const ontologySize = 780;\r\n  const matchCutOff = 0.999;\r\n\r\n  // We first fetch the cleaned column names of the current table\r\n  // console.log(pageName);\r\n  // console.log(tableHTML);\r\n  // console.log(tableHTML.rows);\r\n  let curHeaderCells = tableHTML.rows[0].cells;\r\n  let newCols = []; // stores the cleaned column names of the this table. Let's consider using this value for display as well.\r\n  let remainCols = []; // stores an array of the indices of the columns of the current table that are not yet mapped\r\n  let searchCols = []; // stores an array of the indices of the columns from the selected table that are not yet mapped\r\n\r\n  // We potentially need to resort to semantic mapping. So let's create a promiseArray.\r\n  // This promiseArray will only contain one element\r\n  let promiseArray = [];\r\n\r\n  for (let j = 0; j < curHeaderCells.length; ++j) {\r\n    let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\r\n    newCols.push(headerName);\r\n    remainCols.push(j);\r\n  }\r\n\r\n  // we want to make sure that newTable has more than half of the columns of the selectedTable\r\n  // because we require a >50% unionScore\r\n  // If it does not, we ignore this table automatically\r\n\r\n  if (newCols.length >= originCols.length * unionCutOff) {\r\n    // We use the proposed algo here.\r\n    // First we set the union score and column Mapping\r\n    let unionScore = 0;\r\n    let colMapping = [];\r\n    // We loop through the column headers in originCol, and see if they exist in newCols.\r\n    for (let k = 0; k < originCols.length; ++k) {\r\n      let curIndex = newCols.indexOf(originCols[k]);\r\n      if (curIndex !== -1) {\r\n        // This means the new table also contains column k from the selected table\r\n        // Thus we have found a mapping. We push it onto colMapping.\r\n        colMapping.push(curIndex);\r\n        unionScore += 1 / originCols.length;\r\n      } else {\r\n        colMapping.push(\"null\");\r\n      }\r\n    }\r\n    // In here we do a bit of string matching\r\n    // Chances are: tables from sibling pages with the same number of columns as the selected table, with structual invariability,\r\n    // is likely to be the \"same\" table as the selected on, we give it a chance for string matching\r\n    if (newCols.length === originCols.length) {\r\n      let sameStructure = true;\r\n      for (let i = 0; i < colMapping.length; ++i) {\r\n        if (colMapping[i] !== \"null\" && colMapping[i] !== i) {\r\n          sameStructure = false;\r\n          break;\r\n        }\r\n      }\r\n      if (sameStructure === true) {\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            if (\r\n              newCols[i].includes(originCols[i]) ||\r\n              originCols[i].includes(newCols[i])\r\n            ) {\r\n              colMapping[i] = i;\r\n              unionScore += 1 / originCols.length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // console.log(colMapping);\r\n      // If unionScore is 1, and newCols.length is equal to originCols.length, we want to reward it with 0.01 unionScore\r\n      // This helps us to rank the tables with the exact same column headers a bit higher\r\n      if (unionScore === 1) {\r\n        unionScore += 0.01;\r\n      }\r\n    }\r\n\r\n    // We proceed differently based on whether semantic mapping is enabled or not\r\n\r\n    // Case 1: semantic mapping is enabled\r\n\r\n    if (semanticEnabled === \"enabled\") {\r\n      // If we are not finding a perfect match, we want to do use semantic mapping here to see if it's possible to map the unmapped columns\r\n      // Note: this part is expected to take quite some time. Now it's implemented just for testing purposes\r\n      if (unionScore < 0.999) {\r\n        // We want to remove from remainCols the columns that are already mapped\r\n        // The remaining will be the columns that we can still use from the current table\r\n        remainCols = remainCols.filter(function (x) {\r\n          return colMapping.indexOf(x) < 0;\r\n        });\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            searchCols.push(i);\r\n          }\r\n        }\r\n        // if (newCols[1] === \"Scorer\") {\r\n        // console.log(\"We still need to find these columns from the original table: \"+searchCols);\r\n        // console.log(\"These columns are still available for use: \"+remainCols);\r\n        // console.log(\"The current column mappings are \"+colMapping);\r\n        // console.log(\"Here are the class annotations of the search columns: \")\r\n        // for (let i=0;i<searchCols.length;++i) {\r\n        //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n        // }\r\n        // }\r\n\r\n        // Now, searchCols stores the columns from the selected table that have not been mapped yet\r\n        // and remainCols stores the columns from the current table that can still be used for mapping\r\n        // Let's ask a query to find the class annotations for the remainCols\r\n        // if (remainCols.length > 0) {\r\n        promiseArray.push(findClassAnnotation(tableHTML, remainCols, pageName));\r\n        // }\r\n      }\r\n\r\n      // Because the return statement is here, it may be possible that we are pushing nothing onto the promiseArray!!!\r\n      // There is no need to worry about it.\r\n      return allPromiseReady(promiseArray).then((values) => {\r\n        // First, if we are in the perfect match case, we want to retrun straight away\r\n        if (unionScore >= 0.999) {\r\n          return Promise.resolve({\r\n            isOpen: false,\r\n            unionScore: unionScore,\r\n            colMapping: colMapping,\r\n            data: tableHTML,\r\n            title: newCols,\r\n          });\r\n        }\r\n        // Else, we want to look for semantic mapping opportunities\r\n        else {\r\n          // create a copy of values\r\n\r\n          // Note!!!! Sometimes the tableHTML only has one row, so values[0] would have a length of zero, in which case our algo breaks down\r\n          // Let's prevent it from happening\r\n          let remainClassAnnotation = values[0].slice();\r\n          if (remainClassAnnotation.length > 0) {\r\n            // let remainColsCopy = remainCols.slice();\r\n            // let remainClassAnnotationCopy = remainClassAnnotation.slice();\r\n            for (let i = 0; i < searchCols.length; ++i) {\r\n              let curSearchIndex = searchCols[i];\r\n              // console.log(curSearchIndex);\r\n              // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n              // If the class annotation for this column is empty, we skip it because there's no hope for semantic match.\r\n              // Otherwise we can work with it\r\n              if (selectedClassAnnotation[curSearchIndex].length > 0) {\r\n                // console.log(\"Current column being searched has index: \"+curSearchIndex);\r\n                // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n                // we loop through the remain cols and check their class annotations\r\n                for (let j = 0; j < remainCols.length; ++j) {\r\n                  // Let make sure this column does have a class annotation. Otherwise we skip it\r\n                  // console.log(remainClassAnnotation[j]);\r\n                  // Note: sometimes remainClassAnnotation[j] is undefined, which causes an error\r\n                  // if (remainClassAnnotation[j] === undefined) {\r\n                  //   console.log(\"This case is causing an error\");\r\n                  //   console.log(\"Remain cols are \"+remainCols);\r\n                  //   console.log(\"Remain class annotations are \"+remainClassAnnotation);\r\n                  //   console.log(\"Original remain cols are \"+remainColsCopy);\r\n                  //   console.log(\"original remain class annotations are \"+remainClassAnnotationCopy);\r\n                  //   console.log(\"Table HTML is \");\r\n                  //   console.log(tableHTML);\r\n                  //   console.log(values[0]);\r\n                  // }\r\n                  if (remainClassAnnotation[j].length > 0) {\r\n                    // console.log(\"Remain column index is \"+remainCols[j]);\r\n                    // console.log(\"Its class annotation is \"+remainClassAnnotation[j]);\r\n                    // Let make special cases when the any of search column class and current column class is [Number]\r\n                    // If they are both [Number], we will give it a match\r\n                    // Else it's not a match\r\n                    if (\r\n                      selectedClassAnnotation[curSearchIndex][0] === \"Number\" ||\r\n                      remainClassAnnotation[j][0] === \"Number\"\r\n                    ) {\r\n                      // This case we have a match\r\n                      if (\r\n                        selectedClassAnnotation[curSearchIndex][0] ===\r\n                        remainClassAnnotation[j][0]\r\n                      ) {\r\n                        // We need to update the colMapping and unionScore\r\n                        colMapping[curSearchIndex] = remainCols[j];\r\n                        unionScore += 1 / originCols.length;\r\n                        // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                        remainCols.splice(j, 1);\r\n                        remainClassAnnotation.splice(j, 1);\r\n                        // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                        // j to go back to the correct posiition\r\n                        --j;\r\n                        // Also we need to call break to prevent further looping: we are done with this search column\r\n                        break;\r\n                      }\r\n                      // Else there is no match. We simply ignore it.\r\n                    }\r\n                    // If neither of them is [Number], we need to use the test statistic\r\n                    else {\r\n                      // Let's first find the array intersection of selectedClassAnnotation[curSearchIndex] and remainClassAnnotation[j]\r\n                      let intersection = selectedClassAnnotation[\r\n                        curSearchIndex\r\n                      ].filter(function (x) {\r\n                        return remainClassAnnotation[j].indexOf(x) >= 0;\r\n                      });\r\n                      // console.log(\"Intersection is \"+intersection);\r\n                      // We only want to consider two column unionable if they at least have some intersections.\r\n                      if (intersection.length > 0) {\r\n                        let totalSuccess =\r\n                          selectedClassAnnotation[curSearchIndex].length;\r\n                        let numTrial = remainClassAnnotation[j].length;\r\n                        let numSuccess = intersection.length;\r\n                        let testStat = hyperCDF(\r\n                          numSuccess,\r\n                          ontologySize,\r\n                          totalSuccess,\r\n                          numTrial\r\n                        );\r\n                        // If testStat is larger than matchCutOff, we consider it a match\r\n                        if (testStat > matchCutOff) {\r\n                          // We need to update the colMapping and unionScore\r\n                          colMapping[curSearchIndex] = remainCols[j];\r\n                          unionScore += 1 / originCols.length;\r\n                          // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                          remainCols.splice(j, 1);\r\n                          remainClassAnnotation.splice(j, 1);\r\n                          // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                          // j to go back to the correct posiition\r\n                          --j;\r\n                          // Also we need to call break to prevent further looping: we are done with this search column\r\n                          break;\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          // console.log(\"Remain columns are \"+)\r\n          // console.log(\"Here is table HTML\");\r\n          // console.log(tableHTML);\r\n          // console.log(\"Here are the class annotations for columns that still need mapping\");\r\n          // for (let i=0;i<searchCols.length;++i) {\r\n          //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n          // }\r\n          // console.log(\"The remain columns are \"+remainCols);\r\n          // console.log(\"Here are the class annotations for the remaining columns\");\r\n          // console.log(values);\r\n          // console.log(\"This is column mapping \"+colMapping);\r\n          // console.log(\"Union score is \"+unionScore);\r\n\r\n          // We need to loop through the searchCols\r\n\r\n          // We push on tables with unionScore > unionCutOff\r\n          if (unionScore >= unionCutOff) {\r\n            // console.log(\"This table is unionable!\");\r\n            // console.log(\"Table is \"+tableHTML);\r\n            // console.log(\"Union Score is \"+unionScore);\r\n            // console.log(\"Column mapping is \"+colMapping);\r\n            // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n            // console.log(colMapping);\r\n            return Promise.resolve({\r\n              isOpen: false,\r\n              unionScore: unionScore,\r\n              colMapping: colMapping,\r\n              data: tableHTML,\r\n              title: newCols,\r\n            });\r\n          } else {\r\n            return Promise.resolve(-1);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Case 2: semantic mapping is disabled.\r\n    // In this case we check if the unionScore is high enough directly, without going through the semantic mapping process\r\n    else {\r\n      // We push on tables with unionScore > unionCutOff\r\n      if (unionScore >= unionCutOff) {\r\n        // console.log(\"This table is unionable!\");\r\n        // console.log(\"Table is \"+tableHTML);\r\n        // console.log(\"Union Score is \"+unionScore);\r\n        // console.log(\"Column mapping is \"+colMapping);\r\n        // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n        // console.log(colMapping);\r\n        return Promise.resolve({\r\n          isOpen: false,\r\n          unionScore: unionScore,\r\n          colMapping: colMapping,\r\n          data: tableHTML,\r\n          title: newCols,\r\n        });\r\n      } else {\r\n        return Promise.resolve(-1);\r\n      }\r\n    }\r\n  }\r\n  // This else clause means that this table does not even have enough number of columns.\r\n  // So we know right away it cannot be a match. So we return -1 (failure)\r\n  else {\r\n    return Promise.resolve(-1);\r\n  }\r\n}\r\n\r\n// This function takes in the HTML of a table, and returns a Promise that resolves to the class annotation for all the columns of the table\r\nfunction findClassAnnotation(tableHTML, remainCols, pageName) {\r\n  // console.log(\"Page Name is: \"+pageName);\r\n  // console.log(\"Table HTML is: \");\r\n  // console.log(tableHTML);\r\n  // console.log(remainCols);\r\n  let selectedTable = tableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // Note: this function potentially needs to be modified.\r\n  // Instead of using innerText for cell data, if its href exists, we should use its href instead\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n\r\n      // Note: We want to use the href as data for the first column (if such href exists) instead of its innerText.\r\n      if (i === 1) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = hrefArray[hrefArray.length - 1];\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            rowSpan: 1,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(\"Table data is: \");\r\n  // console.log(tempTable);\r\n\r\n  // Now tempTable contains the clean data we can use\r\n  let promiseArray = [];\r\n  // We take the minimum of (1, tempTable.length-1) number of values from each column to determine its class annotation\r\n  // Note!! This -1 here is important. It excludes the row corresponding to the column headers\r\n  let remainEntries = Math.min(1, tempTable.length - 1);\r\n\r\n  // This is a placeholder array to solve the 2D problem. It's a 1D array containing remainEntries number of -1's\r\n  // let placeHolderArray = [];\r\n  // let notFoundArray = [];\r\n  // for (let i=0;i<remainEntries;++i) {\r\n  //   placeHolderArray.push(-1);\r\n  //   notFoundArray.push(\"null\");\r\n  // }\r\n\r\n  // Let's loop through the table to ask our queries.\r\n  // If remainCols are undefined, we take every columns from the tempTable;\r\n  if (remainCols === undefined) {\r\n    remainCols = [];\r\n    for (let j = 0; j < tempTable[0].length; ++j) {\r\n      remainCols.push(j);\r\n    }\r\n  }\r\n\r\n  // console.log(\"Remain columns are: \"+remainCols);\r\n  for (let j = 0; j < remainCols.length; ++j) {\r\n    // console.log(\"We are taking this number of entries from this table: \"+remainEntries);\r\n    // Find the current column index\r\n    let curColIndex = remainCols[j];\r\n    // console.log(\"Current column index is: \"+curColIndex);\r\n\r\n    // Loop through the first three (or one) entries from this column\r\n    for (let i = 1; i <= remainEntries; ++i) {\r\n      // Here we make the query\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL =\r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      // console.log(tempTable[i][j].data);\r\n      // console.log(regexReplace(tempTable[i][j].data));\r\n      // console.log(tempTable[i][curColIndex]);\r\n      let curEntry =\r\n        tempTable[i][curColIndex] === undefined\r\n          ? \"NONEXISTING\"\r\n          : regexReplace(tempTable[i][curColIndex].data);\r\n      // console.log(curEntry);\r\n      // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n      // console.log(!isNaN(Number(curEntry)));\r\n      // console.log(\"Replaced data is \"+curEntry);\r\n      // console.log(curEntry === \"\");\r\n\r\n      // If we found out that the current entry is a number, we do not want to send a query.\r\n      // Note: Number(\"\") will show up as a number!! This was one of the bugs that we fixed\r\n      if (!isNaN(Number(curEntry)) && curEntry !== \"\") {\r\n        promiseArray.push(Promise.resolve([\"Number\"]));\r\n      }\r\n      // Else if we find the curEntry is too long, it will likely not exist in DBPedia\r\n      else if (curEntry.length > 40) {\r\n        promiseArray.push(Promise.resolve([\"Null\"]));\r\n      }\r\n      // Else we construct the query\r\n      else {\r\n        // console.log(\"Cur Entry is \"+curEntry);\r\n        if (curEntry === undefined || curEntry === \"\") {\r\n          curEntry = \"NONEXISTING\";\r\n        }\r\n        // if (curEntry === \"Sergio_Agero\") {\r\n        //   console.log(\"We have another problem here\");\r\n        // }\r\n        // console.log(curEntry);\r\n        // console.log(tempTable[i][curColIndex].data);\r\n        // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n        let queryBody =\r\n          \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n          curEntry +\r\n          \"+rdf%3Atype+%3Fo.%0D%0A++++++BIND%28STR%28%3Fo%29+AS+%3FoString+%29.%0D%0A++++++FILTER%28regex%28%3FoString%2C%22dbpedia.org%2Fontology%2F%22%2C%22i%22%29%29%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        // if (curEntry === \"Bangor_City_F%5Cu002EC%5Cu002E\") {\r\n        //   console.log(\"There is something wrong with this entry\")\r\n        //   console.log(queryURL);\r\n        // }\r\n        // console.log(\"Query is constructed!\");\r\n        // if (queryURL === \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\") {\r\n        //   console.log(\"Here is where the problem occurs\");\r\n        // }\r\n        // console.log(queryURL);\r\n        promiseArray.push(fetchJSON(queryURL));\r\n        // console.log(\"Query pushed successfully. This is queryBody: \");\r\n        // console.log(queryBody);\r\n      }\r\n    }\r\n  }\r\n  return allPromiseReady(promiseArray).then((values) => {\r\n    // console.log(values);\r\n    // for (let i=0;i<values.length;++i) {\r\n    //   console.log(values[i]);\r\n    // }\r\n    // console.log(\"Query results from Virtuoso are:\");\r\n    // console.log(values);\r\n    let classAnnotation = [];\r\n    for (let j = 0; j < remainCols.length; ++j) {\r\n      // console.log(\"Number of remain cols is \"+remainCols.length);\r\n      let curColumnClass = [];\r\n      // If we are dealing with number results, we just want to push on an array with one element \"Number\"\r\n      if (values[remainEntries * j] !== undefined) {\r\n        if (values[remainEntries * j][0] !== undefined) {\r\n          if (values[remainEntries * j][0] === \"Number\") {\r\n            classAnnotation.push([\"Number\"]);\r\n          }\r\n          // If we are dealing with invalid results, we just want to push on an empty array\r\n          else if (values[remainEntries * j][0] === \"Null\") {\r\n            classAnnotation.push([]);\r\n          }\r\n        }\r\n        // if (values[remainEntries*j][0] === -1) {\r\n        //   classAnnotation.push([\"Number\"]);\r\n        // }\r\n        // // If we are dealing with invalid results, we just want to push on an empty array\r\n        // else if (values[remainEntries*j][0] === \"null\") {\r\n        //   classAnnotation.push([]);\r\n        // }\r\n        // Else, we find its class annotation from query results\r\n        else {\r\n          for (let i = 0; i < remainEntries; ++i) {\r\n            let curCellClass = [];\r\n            // console.log(remainEntries*j+i);\r\n            let bindingArray = values[remainEntries * j + i].results.bindings;\r\n            for (let k = 0; k < bindingArray.length; ++k) {\r\n              curCellClass.push(bindingArray[k].o.value.slice(28));\r\n            }\r\n            curColumnClass = [...new Set([...curColumnClass, ...curCellClass])];\r\n          }\r\n          classAnnotation.push(curColumnClass);\r\n        }\r\n      }\r\n    }\r\n    // return classAnnotation;\r\n    // console.log(\"Current class annotation is \");\r\n    // if (pageName === \"200910_Premier_League\") {\r\n    //   console.log(\"TableData is \");\r\n    //   console.log(tempTable);\r\n    //   console.log(classAnnotation);\r\n    // }\r\n    // console.log(classAnnotation);\r\n\r\n    return Promise.resolve(classAnnotation);\r\n  });\r\n}\r\n\r\n// This function returns a 2D array of objects representing the data for tableDataExplore.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"selectedTableHTML\" storing the HTML of a table\r\n//  2) string \"urlOrigin\", storing which page this table is from\r\n\r\n// It returns a 2D array of objects representing the data for tableDataExplore.\r\nfunction setTableFromHTML(selecteTableHTML, urlOrigin) {\r\n  let selectedTable = selecteTableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // This is the part where we make the modification: use links instead of cell literals\r\n\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    // console.log(selectedTable.rows[i]);\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n      // Note: We want to use the href as data (if such href exists) instead of its innerText.\r\n      if (i > 0) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = decodeURIComponent(hrefArray[hrefArray.length - 1]);\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        origin: urlOrigin,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            origin: urlOrigin,\r\n            rowSpan: tempTable[i][j].rowSpan,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              origin: urlOrigin,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now add in an additional column: the originURL of the page\r\n  tempTable[0].splice(0, 0, {\r\n    data: \"OriginURL\",\r\n    origin: urlOrigin,\r\n    rowSpan: 1,\r\n    colSpan: 1,\r\n  });\r\n  for (let i = 1; i < tempTable.length; ++i) {\r\n    tempTable[i].splice(0, 0, {\r\n      data: urlOrigin,\r\n      origin: \"null\",\r\n      rowSpan: 1,\r\n      colSpan: 1,\r\n    });\r\n  }\r\n\r\n  // console.log(tempTable);\r\n  return tempTable; // tempTable is a 2D array of objects storing the table data. Object has two fields: data(string) and origin(string).\r\n}\r\n\r\n// This function takes in 1 parameter\r\n// 1) tableDataExplore, returned from setTableFromHTML.\r\n\r\n// And returns tableData (with no header rows) that can be unioned with the selected table.\r\n\r\nfunction setUnionData(tableDataExplore) {\r\n\r\n  // We first need to set the tableHeader, so that cells have the correct origins\r\n  let tableHeader = [];\r\n  for (let j=0;j<tableDataExplore[0].length;++j) {\r\n    tableHeader.push(\r\n      {\"value\":tableDataExplore[0][j].data\r\n      ,\"label\":tableDataExplore[0][j].data}\r\n    )\r\n  }\r\n  // We then need to handle both data and origin.\r\n  let tableData = [];\r\n  // console.log(tableDataExplore);\r\n  // This starts the loop for rows\r\n  for (let i=1;i<tableDataExplore.length;++i) {\r\n    let tempRow = [];\r\n    // This starts the loop for columns\r\n    let minLength = Math.min(tableDataExplore[i].length, tableHeader.length);\r\n    for (let j=0;j<minLength;++j) {\r\n      // First set the data\r\n      let data = tableDataExplore[i][j].data;\r\n      // Then set the origin\r\n      let origin = [];\r\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\r\n      origin.push(originText);\r\n      tempRow.push({\"data\":data,\"origin\":origin});\r\n    }\r\n    tableData.push(tempRow);\r\n  }\r\n  return tableData;\r\n}\r\n\r\n// This function takes in four parameters and return the CDF for hypergeometric distribution, for x\r\n// N: total number of elements (780 in our case)\r\n// K: total number of successful elements (length of selected column's class annotation)\r\n// n: number of trials (length of test column's class annotation)\r\n// x: (length of intersection of selected column and test column)\r\n\r\nfunction hyperCDF(x, N, K, n) {\r\n  let count = 0;\r\n  // console.log(combinations(5,2));\r\n  let denom = combinations(N, n);\r\n  for (let i = 0; i <= x; ++i) {\r\n    count += (combinations(K, i) * combinations(N - K, n - i)) / denom;\r\n  }\r\n  return count;\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\nfunction niceRender(str) {\r\n  let resultStr = str;\r\n  let bracketIndex = str.indexOf(\"(\");\r\n  // If ( is present in a string, we want to remove it\r\n  // We include the -1 because usually ( is preceeded by _\r\n  if (bracketIndex !== -1) {\r\n    resultStr = resultStr.slice(0, bracketIndex-1);\r\n  }\r\n  // now we turn all \"_\" into \" \"\r\n  return resultStr.replace(/_/g, \" \");\r\n}\r\n\r\n// This function takes in four parameters: \r\n// 1) resultsBinding: an array of JSON values representing entities satisfying the first column\r\n// 2) tableData:      the tableData before update\r\n// 3) tableHeader:    this.state.tableHeader\r\n// 4) colIndex:       which column usersa are filling (usually 0)\r\n\r\n// and returns the updated tableData, after updates have been made to the first column.\r\n\r\nfunction setFirstColumnData(resultsBinding, tableData, tableHeader, colIndex) {\r\n  // First we get the correct number of rows, which is equal to min(values[0].results.bindings.length, initialRowNum)\r\n  let updatedRowCount = Math.min(resultsBinding.length, initialRowNum);\r\n  // console.log(\"Original length is \"+values[0].results.bindings.length);\r\n  // console.log(\"Row Count is: \"+updatedRowCount);\r\n\r\n  // If tableData currently has too many rows, we slice it.\r\n  if (tableData.length > updatedRowCount) {\r\n    tableData = tableData.slice(0,updatedRowCount);\r\n  }\r\n  // Else, if tableData currently has too few rows, we need to add some empty rows.\r\n  else if (tableData.length < updatedRowCount) {\r\n    let rowsToAdd = updatedRowCount - tableData.length;\r\n    for (let i = 0; i < rowsToAdd; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < initialColNum; ++j) {\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n  }\r\n\r\n  let rowNum = tableData.length;\r\n  // console.log(\"Number of rows is \"+rowNum);\r\n\r\n  // We do not want to overwrite entries that users have filled in.\r\n  // Let's calculate how many entries we want to fill in.\r\n  let emptyEntryCount = rowNum;\r\n  for (let i = 0; i < rowNum; ++i) {\r\n    if (tableData[i][colIndex].data !== \"\") {\r\n      emptyEntryCount--;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  // console.log(\"number of empty entries is \"+emptyEntryCount);\r\n\r\n  let startingIndex = rowNum - emptyEntryCount;\r\n  // console.log(\"Starting index is\"+startingIndex);\r\n\r\n  for (let i = 0; i < emptyEntryCount; ++i) {\r\n    tableData[i + startingIndex][colIndex].data = \r\n      resultsBinding[i].somevar.value.slice(28);\r\n  }\r\n\r\n  // second part sets the origin for each cell\r\n  for (let i = 0; i < rowNum; ++i) {\r\n    // For the first column, let's just use its data as the origin\r\n    let tempOrigin = tableData[i][colIndex].data;\r\n    tableData[i][colIndex].origin.push(tempOrigin);\r\n  }\r\n\r\n  // Now we dedup by tableData by tableData[i][0].data\r\n  tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\r\n\r\n  // console.log(tableData);\r\n  return tableData;\r\n}\r\n\r\n// The following function takes in 2D array recording information of neighbours for the search column\r\n\r\n// It return a desired oneD keyColNeighbours that we can give to selection Headers.\r\n\r\nfunction processAllNeighbours(allNeighboursArray) {\r\n  let keyColNeighbours = [];\r\n  // console.log(allNeighboursArray);\r\n  let allNeighboursArrayCopy = _.cloneDeep(allNeighboursArray);\r\n\r\n  for (let i = 0; i < allNeighboursArrayCopy.length; ++i) {\r\n    keyColNeighbours = keyColNeighbours.concat(allNeighboursArrayCopy[i]);\r\n  }\r\n\r\n  // Now we sort keyColNeighbours based on value\r\n  keyColNeighbours.sort((a,b) => a.value < b.value ? -1 : 1);\r\n  // console.log(keyColNeighbours);\r\n\r\n  // Now, we run a loop to remove duplicates, and update count and filledCount\r\n  if (keyColNeighbours.length > 0) {\r\n    for (let i = 1; i < keyColNeighbours.length; ++i) {\r\n      let prevEntry = keyColNeighbours[i-1];\r\n      let curEntry = keyColNeighbours[i];\r\n\r\n      // If the current entry's data is equal to the previous entry's data, we want to \r\n      // 1) delete curEntry\r\n      // 2) (maybe) update prevEntry's count\r\n      // 3) increment prevEntry's filledCount\r\n      if (prevEntry.value === curEntry.value) {\r\n        keyColNeighbours[i-1].filledCount = keyColNeighbours[i-1].filledCount + 1;\r\n        keyColNeighbours[i-1].count = Math.max(prevEntry.count, curEntry.count);\r\n        keyColNeighbours.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n  }\r\n  // Now we want to sort (and potentially filter) keyColNeighbours, by filledCount \r\n  keyColNeighbours.sort((a,b) => a.filledCount < b.filledCount ? 1 : -1);\r\n\r\n  // Before we return, let's change the label to include filledCount\r\n  for (let i = 0; i < keyColNeighbours.length; ++i) {\r\n    let filledPercent = Math.round(keyColNeighbours[i].filledCount/allNeighboursArrayCopy.length * 100) / 100;\r\n    keyColNeighbours[i].filledPercent = filledPercent;\r\n    keyColNeighbours[i].label = keyColNeighbours[i].label + \" (\" + filledPercent + \")\";\r\n  }\r\n\r\n  // Take a look at keyColNeighbours\r\n  // console.log(keyColNeighbours);\r\n\r\n  return keyColNeighbours;\r\n}\r\n\r\n// The following function stores both predicate and object array for all entries in search column.\r\n// Its return value is an array, length is tableData.length\r\n\r\nfunction storeFirstDeg(neighbourArray) {\r\n  // console.log(neighbourArray);\r\n  let firstDegNeighbours = [];\r\n  let neighbourArrayCopy = _.cloneDeep(neighbourArray);\r\n  for (let i = 0; i < neighbourArrayCopy.length; ++i) {\r\n    let tempObj = {};\r\n    for (let j = 0; j < neighbourArrayCopy[i].length; ++j) {\r\n      // The following line creates a deduped version of neighbourArrayCopy[i][j].data, since some bug seems to exist in DBpedia\r\n      let dedupedData = _.uniq(neighbourArrayCopy[i][j].data.slice())\r\n      tempObj[neighbourArrayCopy[i][j].value] = dedupedData;\r\n      // console.log(neighbourArrayCopy[i][j].data.slice());\r\n      // console.log(_.uniq(neighbourArrayCopy[i][j].data.slice()));\r\n      // tempObj[neighbourArrayCopy[i][j].value] = neighbourArrayCopy[i][j].data;\r\n    }\r\n    firstDegNeighbours.push(tempObj);\r\n  } \r\n  // console.log(firstDegNeighbours);\r\n  return firstDegNeighbours;\r\n}\r\n\r\n// This function creates neighbourArrayText from neighbourArray\r\n\r\nfunction createNeighbourText(neighbourArray) {\r\n  let neighbourArrayText = \"\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    if (i > 0) {\r\n      neighbourArrayText+=\" OR \";\r\n    }\r\n    let curNeighbourText = neighbourArray[i].type === \"object\" ? \"is \" + neighbourArray[i].value + \" of\" : neighbourArray[i].value ;\r\n    neighbourArrayText+=curNeighbourText;\r\n  }\r\n  return neighbourArrayText;\r\n}\r\n\r\n// This function add in the recommendNeighbours to objects in processedNeighbours.\r\n// It takes in processedSubject(object)Neighbours, and returns the updated version.\r\n\r\n// For each element from processedNeighbours, we want to add an attribute called recommendNeighbours\r\n// recommendNeighbours is an array of objects with three attributes\r\n// 1) value:        value of the recommend attribute\r\n// 2) type:         type of the recommend attribute\r\n// 3) relation:     how the recommend attribute is related to the original attribute: string, or semantic\r\n\r\nfunction addRecommendNeighbours(processedNeighboursCopy) {\r\n  // console.log(processedNeighboursCopy);\r\n  let processedNeighbours = _.cloneDeep(processedNeighboursCopy);\r\n\r\n\r\n  // To do this, we need to a double loop over the processedNeighbours\r\n  for (let i = 0; i < processedNeighbours.length; ++i) {\r\n\r\n    // Initialize the recommendNeighbours array\r\n    let recommendNeighbours = [];\r\n    \r\n    for (let j = 0; j < processedNeighbours.length; ++j) {\r\n      // We only look at cases where i !== j\r\n      if (i !== j) {\r\n        // We consider two types of matching\r\n\r\n        // 1st type is String Similarity: if X is a substring of Y, or Y is a substring of X \r\n        let upperStrOne = processedNeighbours[i].value.toUpperCase();\r\n        let upperStrTwo = processedNeighbours[j].value.toUpperCase();\r\n        if (upperStrOne.includes(upperStrTwo) || upperStrTwo.includes(upperStrOne)) {\r\n          recommendNeighbours.push(\r\n            {\r\n              \"value\": processedNeighbours[j].value,\r\n              \"type\": processedNeighbours[j].type,\r\n              \"relation\": \"string\"\r\n            }\r\n          )\r\n        }\r\n\r\n        // 2nd type is semantic: if X and Y has the same range, or same subPropertyOf \r\n        if ((processedNeighbours[i].range === processedNeighbours[j].range && processedNeighbours[i].range !== \"\") ||\r\n            (processedNeighbours[i].subPropertyOf === processedNeighbours[j].subPropertyOf && processedNeighbours[i].subPropertyOf !== \"\")) {\r\n          recommendNeighbours.push(\r\n            {\r\n              \"value\": processedNeighbours[j].value,\r\n              \"type\": processedNeighbours[j].type,\r\n              \"relation\": \"semantic\"\r\n            }\r\n          )\r\n        }\r\n\r\n        // // updated on 9/13: hardcode \"starring\" to be in \"director\"'s attribute recommendations\r\n        // if ((processedNeighbours[i].value === \"director\" && processedNeighbours[i].type === \"subject\") &&\r\n        //     (processedNeighbours[j].value === \"starring\" && processedNeighbours[j].type === \"subject\")) {\r\n        //   // console.log(processedNeighbours[i]);\r\n        //   // console.log(processedNeighbours[j]);\r\n        //   recommendNeighbours.push(\r\n        //     {\r\n        //       \"value\": processedNeighbours[j].value,\r\n        //       \"type\": processedNeighbours[j].type,\r\n        //       \"relation\": \"magic!\",\r\n        //     }\r\n        //   )\r\n        // }\r\n      }\r\n    }\r\n    // We take a look at the recommendNeighbours\r\n    // console.log(\"Current neighbour is \"+processedNeighbours[i].value);\r\n    // if (recommendNeighbours.length > 0) {console.log(recommendNeighbours);}\r\n\r\n    // Now, we create the recommendNeighbours attributes for the current element in processedNeighbours\r\n    processedNeighbours[i][\"recommendNeighbours\"] = recommendNeighbours;\r\n  }\r\n  // console.log(processedNeighbours);\r\n  return processedNeighbours;\r\n}\r\n\r\n// The following function creates the list of recommend attributes passed to the ActionPanel.\r\n\r\n// It takes in one parameter: neighbourArray\r\n// returns an array: recommendArray\r\n\r\nfunction createRecommendArray(neighbourArray, keyColNeighbours) {\r\n  // We create the recommendArray variable using a simple rule:\r\n  // It should be union of recommendNeighbours of all neighbours from neighbourArray, minus the neighbours from neighbourArray\r\n  let recommendArray = [];\r\n\r\n  // First we run a loop to take the union of recommendNeighbours\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    recommendArray = recommendArray.concat(neighbourArray[i].recommendNeighbours);\r\n  }\r\n\r\n  // console.log(neighbourArray);\r\n  // console.log(recommendArray);\r\n\r\n  // We then remove recommendations that are completely duplicated\r\n  recommendArray = _.uniqBy(recommendArray, function(x) {\r\n    return x.value || x.type || x.relation;\r\n  });\r\n  // We then remove recommendations that are already in neighbourArray\r\n  recommendArray = _.differenceBy(recommendArray, neighbourArray, function(x) {\r\n    return x.value || x.type;\r\n  });\r\n\r\n  // We want to do one more thing here: get the filledPercentage for the recommendation attributes\r\n\r\n  // console.log(recommendArray);\r\n  // console.log(keyColNeighbours);\r\n\r\n  for (let i = 0; i < recommendArray.length; ++i) {\r\n    for (let j = 0; j < keyColNeighbours.length; ++j) {\r\n      if (recommendArray[i].value === keyColNeighbours[j].value && recommendArray[i].type === keyColNeighbours[j].type) {\r\n        recommendArray[i][\"label\"] = keyColNeighbours[j].label;\r\n        recommendArray[i][\"filledPercent\"] = keyColNeighbours[j].filledPercent;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  // We now sort the recommendArray by filledPercent attribute\r\n  recommendArray.sort((a, b) =>\r\n    a.filledPercent < b.filledPercent ? 1 : -1\r\n  );\r\n  // console.log(recommendArray);\r\n\r\n  return recommendArray;\r\n}\r\n\r\n// The following function is a helper function for sorting used in updateFirstColSelection.\r\n\r\nfunction getPCount(str, myArray) {\r\n  let count = 0;\r\n  for (let i = 0; i < myArray.length; ++i) {\r\n    if (myArray[i].p.value === str) {\r\n      ++count\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n// The following function scans through a string, and changes all \" \" to \"+\"\r\n\r\nfunction blankToPlus(str) {\r\n  return str.replace(/\\s/g, \"+\");\r\n}\r\n\r\n// The following function generates queryURL needed for Virtuoso, using information from neighbourArray (or tableHeader[0])\r\n\r\nfunction keyQueryGen(neighbourArray) {\r\n\r\n  // console.log(neighbourArray);\r\n\r\n  // Following boolean is for error detection\r\n  let error = false;\r\n\r\n  // Following is a complete query.\r\n\r\n  // select ?somevar\r\n  // where {\r\n  // ?somevar dct:subject dbc:Obama_family.\r\n  // ?somevar dbp:district \"13\"^^<http://www.w3.org/2001/XMLSchema#integer>.\r\n  // ?somevar dbo:birthPlace dbr:Hawaii.\r\n  // ?somevar dbp:name \"Barack Obama\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#langString>.\r\n  // ?somevar dbo:activeYearsEndDate \"2004-11-04\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n  // }\r\n\r\n  let prefixURL = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  let suffixURL = \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n  let queryBody = \"select+%3Fsomevar%0D%0Awhere+%7B\";\r\n  for (let i = 0; i < neighbourArray.length; ++i) {\r\n    // There are 5 cases that we have to deal with in total\r\n    let textToAdd = \"\"\r\n    // Case 1: dct (%0D%0A%3Fsomevar+dct%3Asubject+dbc%3AObama_family.)\r\n    if (neighbourArray[i].pDataset === \"dct\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+dct%3Asubject+dbc%3A\" \r\n        + regexReplace(neighbourArray[i].oValue) \r\n        + \".\";\r\n    }\r\n    // Case 2: oType is date (%0D%0A%3Fsomevar+dbo%3AactiveYearsEndDate+%222004-11-04%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#date\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\" \r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.\";\r\n    }\r\n    // Case 3: oType is integer (%0D%0A%3Fsomevar+dbp%3Adistrict+%2213%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#integer\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.\";\r\n    }\r\n    // Case 4: oType is string literal (%0D%0A%3Fsomevar+dbp%3Aname+%22Barack+Obama%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.)\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + blankToPlus(neighbourArray[i].oValue) // Note no regexReplace here, but blankToPlus is needed\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.\";\r\n    }\r\n    // Case 5: oType is nonnegative integer\r\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+%22\"\r\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\r\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23nonNegativeInteger%3E.\";\r\n    }\r\n    // Case 6: oType is \"\", in this case the object value is some dbr\r\n    else if (neighbourArray[i].oType === \"\") {\r\n      textToAdd = \r\n        \"%0D%0A%3Fsomevar+\"\r\n        + neighbourArray[i].pDataset\r\n        + \"%3A\"\r\n        + regexReplace(neighbourArray[i].pValue)\r\n        + \"+dbr%3A\"\r\n        + regexReplace(neighbourArray[i].oValue)\r\n        + \".\";\r\n    }\r\n    // Otherwise, we have run into some error potentially\r\n    else {\r\n      console.log(neighbourArray[i].oType);\r\n      error = true;\r\n    }\r\n    queryBody+=textToAdd;\r\n  }\r\n  // Finally we add in the last bit of text to queryBody\r\n  queryBody+=\"%0D%0A%7D%0D%0A&\";\r\n\r\n  // Create the queryURL and take a look\r\n  let queryURL = prefixURL + queryBody + suffixURL;\r\n  \r\n  // We now return. If error is true, we return error, else, we return queryURL\r\n  if (error === true) {\r\n    return \"ERROR\";\r\n  }\r\n  else {\r\n    return queryURL;\r\n  }\r\n}\r\n\r\n// The following is a helper function used to update firstDegNeighbours and keyColNeighbours.\r\n// It makes use of two query result arrays.\r\n\r\n// It return an object with two attributes: firstDegNeighbours and keyColNeighbours\r\n\r\n// This function should be called whenever number of rows are changed.\r\n\r\nfunction updateNeighbourInfo(valuesOne, valuesTwo) {\r\n  // console.log(valuesOne);\r\n  // console.log(valuesTwo);\r\n\r\n  // To support the firstDegNeighbours prefetching, let's store the first degree neighbours in state firstDegNeighbours\r\n  let firstDegNeighbours = {};\r\n\r\n  // First we deal with subject neighbours, so valuesOne\r\n  let subjectNeighbourArray = [];\r\n  for (let i = 0; i < valuesOne.length; ++i) {\r\n    let temp = updateKeyColNeighbours(\r\n      [],\r\n      valuesOne[i].results.bindings,\r\n      \"subject\"\r\n    )\r\n    subjectNeighbourArray.push(temp);\r\n  }\r\n  // console.log(subjectNeighbourArray);\r\n  firstDegNeighbours[\"subject\"] = storeFirstDeg(subjectNeighbourArray);\r\n  let processedSubjectNeighbours = processAllNeighbours(subjectNeighbourArray);\r\n  processedSubjectNeighbours = addRecommendNeighbours(processedSubjectNeighbours);\r\n\r\n  // Then we deal with object neighbours, so valuesTwo\r\n  let objectNeighbourArray = [];\r\n  for (let i = 0; i < valuesTwo.length; ++i) {\r\n    let temp = updateKeyColNeighbours(\r\n      [],\r\n      valuesTwo[i].results.bindings,\r\n      \"object\"\r\n    )\r\n    objectNeighbourArray.push(temp);\r\n  }\r\n  firstDegNeighbours[\"object\"] = storeFirstDeg(objectNeighbourArray);\r\n  let processedObjectNeighbours = processAllNeighbours(objectNeighbourArray);\r\n  processedObjectNeighbours = addRecommendNeighbours(processedObjectNeighbours);\r\n\r\n  // we now concat subjectNeighbours and objectNeighbours together\r\n  let keyColNeighbours = processedSubjectNeighbours.concat(processedObjectNeighbours);\r\n\r\n  // console.log(keyColNeighbours);\r\n  // console.log(firstDegNeighbours);\r\n  return {\r\n    \"firstDegNeighbours\":firstDegNeighbours,\r\n    \"keyColNeighbours\":keyColNeighbours,\r\n  }\r\n}\r\n\r\n// Added on Sept 13: \r\n// The following is helper function to update the firstColSelection options to include all entities from first column\r\n// This function should just use something very similar to updateFirstColSelection in a loop. Then do some processing in the end.\r\n\r\nfunction updateUnionSelection(valuesOne) {\r\n\r\n  // initialize array to store the union of all firstColSelection\r\n  let unionSelection = [];\r\n\r\n  // the two following arrays store the dct neighbours and dbo/p neighbours respectively\r\n  let dctArray = [];\r\n  let dbopArray = [];\r\n\r\n  // We loop over the first degree neighbours for every entry in the first column\r\n  for (let i = 0; i < valuesOne.length; ++i) {\r\n\r\n    // We first filter out those in resultsBinding according to three criterias\r\n    // Note: the second criteria is a bit different from updateKeyColNeighbours and updatePreviewInfo\r\n\r\n    // 1) p.value.slice(28).length must > 1\r\n    // 2) p.value must include \"ontology\", \"property\", or \"dc/terms/subject\" (so it is one of dbo:XXXX, dbp:XXXX, or dct:subject)\r\n    // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\r\n\r\n    let resultsBinding = valuesOne[i].results.bindings;\r\n\r\n    let processedBinding = resultsBinding.filter(\r\n      a => a.p.value.slice(28).length > 1 \r\n          &&\r\n          (a.p.value.includes(\"ontology\") \r\n          || a.p.value.includes(\"property\")\r\n          || a.p.value.includes(\"dc/terms/subject\")\r\n          ) \r\n          &&\r\n          !(a.p.value.includes(\"wikiPage\") \r\n          || a.p.value.includes(\"align\") \r\n          || a.p.value.includes(\"abstract\") \r\n          || a.p.value.includes(\"caption\") \r\n          || a.p.value.includes(\"image\") \r\n          || a.p.value.includes(\"width\") \r\n          || a.p.value.includes(\"thumbnail\") \r\n          || a.p.value.includes(\"blank\")\r\n          || a.p.value.includes(\"fec\")\r\n          || a.p.value.includes(\"viaf\")\r\n          || a.p.value.includes(\"soundRecording\")\r\n          || a.p.value.includes(\"votesmart\")\r\n          || a.p.value.includes(\"wordnet\")\r\n          || a.p.value.includes(\"float\")\r\n          || a.p.value.includes(\"bbr\")\r\n          || a.p.value === \"http://dbpedia.org/property/alt\"\r\n          || a.p.value === \"http://dbpedia.org/property/by\"\r\n          || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\r\n          || a.p.value === \"http://dbpedia.org/property/signature\"\r\n          || a.p.value === \"http://dbpedia.org/property/video\"\r\n          || a.p.value === \"http://dbpedia.org/property/logo\"\r\n          || a.p.value === \"http://dbpedia.org/property/shorts\"\r\n          || a.p.value === \"http://dbpedia.org/property/patternS\"\r\n          || a.p.value === \"http://dbpedia.org/property/patternB\"\r\n          || a.p.value === \"http://dbpedia.org/property/body\"\r\n          || a.p.value === \"http://dbpedia.org/property/hShorts\"\r\n          || a.p.value === \"http://dbpedia.org/property/hPatternS\"\r\n          || a.p.value === \"http://dbpedia.org/property/hPatternB\"\r\n          || a.p.value === \"http://dbpedia.org/property/hBody\"\r\n          || a.p.value === \"http://dbpedia.org/property/aShorts\"\r\n          || a.p.value === \"http://dbpedia.org/property/aPatternS\"\r\n          || a.p.value === \"http://dbpedia.org/property/aPatternB\"\r\n          || a.p.value === \"http://dbpedia.org/property/aBody\"\r\n          || a.p.value === \"http://dbpedia.org/property/3Shorts\"\r\n          || a.p.value === \"http://dbpedia.org/property/3PatternS\"\r\n          || a.p.value === \"http://dbpedia.org/property/3PatternB\"\r\n          || a.p.value === \"http://dbpedia.org/property/3Body\"\r\n          || a.p.value === \"http://dbpedia.org/property/nba\"\r\n          || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\r\n          )\r\n    );\r\n    // Now we run an inner loop to loop over each processedBinding\r\n    for (let j = 0; j < processedBinding.length; ++j) {\r\n      if (processedBinding[j].p.value === \"http://purl.org/dc/terms/subject\") {\r\n        dctArray.push(processedBinding[j]);\r\n      }\r\n      else {\r\n        dbopArray.push(processedBinding[j]);\r\n      }\r\n    } \r\n  }\r\n\r\n  // Now we deal with dctArray and dbopArray\r\n\r\n  // First is dctArray. We first dedup it based on o.value. Then sort by o.value.slice(37)\r\n  dctArray = _.uniqBy(dctArray, function(x) {return x.o.value});\r\n  dctArray.sort((a, b) => (a.o.value.slice(37) < b.o.value.slice(37) ? -1 : 1));\r\n\r\n  // Second is dbopArray. We first remove those entries with both p.value and o.value duplicated\r\n  dbopArray = _.uniqBy(dbopArray, function(x) {return x.p.value && x.o.value});\r\n  // Then we sort. Two sorting criterias: \r\n  // 1) Those that are dbr (so without a datatype) shows up higher.\r\n  // 2) Then in alphabetical order\r\n  dbopArray.sort(function (a, b) {\r\n    if (a.o.datatype === undefined && b.o.datatype !== undefined) {\r\n      return -1;\r\n    }\r\n    else if (b.o.datatype === undefined && a.o.datatype !== undefined) {\r\n      return 1;\r\n    }\r\n    else {\r\n      return a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1;\r\n    }\r\n  });\r\n\r\n  // Now that both dctArray and dbopArray have the corret elements, we push them onto unionSelection array\r\n  // console.log(dctArray);\r\n  // console.log(dbopArray);\r\n  for (let i = 0; i < dctArray.length; ++i) {\r\n    unionSelection.push(\r\n      {\r\n        \"pValue\":\"category\",\r\n        \"pDataset\":\"dct\",\r\n        \"oValue\":dctArray[i].o.value.slice(37),\r\n        \"oType\":\"\",\r\n        \"value\":\"category\",\r\n        \"label\":dctArray[i].o.value.slice(37),\r\n      }\r\n    )\r\n  }\r\n  for (let i = 0; i < dbopArray.length; ++i) {\r\n    unionSelection.push(\r\n      {\r\n        \"pValue\":dbopArray[i].p.value.slice(28),\r\n        \"pDataset\":dbopArray[i].p.value.includes(\"property\") ? \"dbp\" : \"dbo\",\r\n        \"oValue\":removePrefix(dbopArray[i].o.value),\r\n        \"oType\":dbopArray[i].o.datatype === undefined ? \"\" : dbopArray[i].o.datatype,\r\n        \"value\":dbopArray[i].p.value.slice(28),\r\n        \"label\":dbopArray[i].p.value.slice(28)+\":\"+removePrefix(dbopArray[i].o.value),\r\n      }\r\n    )\r\n  }\r\n  // console.log(unionSelection);\r\n\r\n  // Now we create unionChecked, which is an array of false, length === length of unionSelection\r\n  let unionChecked = [];\r\n  for (let i = 0; i < unionSelection.length; ++i) {\r\n    unionChecked.push(false);\r\n  }\r\n\r\n  // Now we create the return value\r\n  let selectionInfo = {\r\n    \"firstColSelection\":unionSelection,\r\n    \"firstColChecked\":unionChecked,\r\n  };\r\n\r\n  return selectionInfo;\r\n}\r\n\r\n// Helper function to computer the three most joinable columns \r\n// This function returns an array (max len 3) of objects with two attributes:\r\n// 1) indices: which two columns are we joining on\r\n// 2) joinScore: number storing the joinability score\r\nfunction computeJoinableColumn(originTableData, joinTableData, originTableHeader, joinTableHeader) {\r\n  // console.log(originTableData);\r\n  // console.log(joinTableData);\r\n  // console.log(originTableHeader);\r\n  // console.log(joinTableHeader);\r\n\r\n  // First thing to do is to get all the data in column format\r\n\r\n  // First we process originTableData\r\n  let originColumns = [];\r\n  let firstColIndex = originTableHeader[0].value === \"OriginURL\" ? 1 : 0;\r\n  for (let i = firstColIndex; i < originTableHeader.length; ++i) {\r\n    let curColData = [];\r\n    for (let j = 0; j < originTableData.length; ++j) {\r\n      curColData.push(originTableData[j][i].data);\r\n    }\r\n    originColumns.push(curColData);\r\n  }  \r\n  // console.log(originColumns);\r\n\r\n  // Then we process joinTableData. Note that the first column of joinTableData will be OriginURL for sure\r\n  let joinColumns = [];\r\n  for (let i = 1; i < joinTableHeader.length; ++i) {\r\n    let curColData = [];\r\n    // we start j index from 1 because joinTableData first row is the header\r\n    for (let j = 1; j < joinTableData.length; ++j) {\r\n      curColData.push(joinTableData[j][i].data);\r\n    }\r\n    joinColumns.push(curColData);\r\n  }\r\n  // console.log(joinColumns);\r\n\r\n  // Now we loop n^2 times, for each c_i in originColumns and c_j in joinColumns.\r\n  // for each pair, we will record its joinability score and the pair of indices\r\n  let allPairsRecord = [];\r\n  for (let i = 0; i < originColumns.length; ++i) {\r\n    for (let j = 0; j < joinColumns.length; ++j) {\r\n      let numFound = 0;\r\n      for (let k = 0; k < originColumns[i].length; ++k) {\r\n        let curVal = originColumns[i][k];\r\n        if (joinColumns[j].includes(curVal)) {\r\n          numFound++;\r\n        }\r\n      }\r\n      let indexAddOne = originTableHeader[0].value === \"OriginURL\" ? 1 : 0;\r\n      let joinScore = numFound/originColumns[i].length;\r\n      allPairsRecord.push(\r\n        {\r\n          \"indices\":[i+indexAddOne, j+1],\r\n          \"joinScore\":joinScore,\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n  // We sort the allPairsRecord by joinScore, then take the top min(allPairsRecord.length, 3)\r\n  allPairsRecord.sort((a, b) =>\r\n    a.joinScore < b.joinScore ? 1 : -1\r\n  );\r\n\r\n  allPairsRecord = allPairsRecord.slice(0, Math.min(allPairsRecord.length, 3))\r\n\r\n  // We do an extra filtering step here to remove entries with joinScore of 0\r\n  allPairsRecord = allPairsRecord.filter(a => a.joinScore > 0);\r\n\r\n  // Take a look to see if allPairsRecord looks correct\r\n  // console.log(allPairsRecord);\r\n\r\n  return allPairsRecord;\r\n}\r\n\r\n// Helper function that takes input: tableData and originCols (optional)\r\n// and outputs which second and third deg neighbours we need to fetch (the exact ones)\r\nfunction getAutofillInfo(tableData, originCols, newMapping) {\r\n  // First take a look at the data passed in\r\n  // console.log(tableData);\r\n  // console.log(originCols);\r\n  console.log(newMapping);\r\n\r\n  // IMPORTANT: WE HAVE TO MODIFY THIS FUNCTION, TO GET THE CORRECT CELLS THAT WE ARE REFERENCING\r\n  // BECAUSE IN STARTTABLE CASE WE DON'T KNOW WHICH COLUMN WE ARE DEALING WITH\r\n\r\n  // Since we have modified how origin is stored (now even N/A cells has origins)\r\n  // We look at the first row (first record) to get all the columns information\r\n  let firstRecord = tableData[0].slice();\r\n  let oneDegInfo = [];\r\n  let twoDegInfo = [];\r\n  let threeDegInfo = [];\r\n  let columnInfo = [];\r\n  let refInfo = [];\r\n  let longHopWarning = false;\r\n  for (let i = 1; i < firstRecord.length; ++i) {\r\n    let curOrigin = firstRecord[i].origin;\r\n    // We only care about columns that are 1 to 3 hops away. \r\n    // Note that for columns already unioned from semantic mapping, we ignore them as well.\r\n    let needToAutofill;\r\n    if (newMapping === undefined) {\r\n      needToAutofill = curOrigin.length >= 2 && curOrigin.length <= 4;\r\n    }\r\n    else {\r\n      needToAutofill = curOrigin.length >= 2 && curOrigin.length <= 4 && newMapping[i] === -1;\r\n    }\r\n    if (needToAutofill) {\r\n      // Modification made for startTable here:\r\n      // If we are in the startTable case (so originCols is not undefined)\r\n      // We have to figure out the current columns' reference col, based on curOrigin's first element\r\n      let firstOrigin = curOrigin[0];\r\n      let curRef = -1;\r\n      if (originCols !== undefined && originCols !== false) {\r\n        curRef = originCols.indexOf(firstOrigin.split(\":\")[0]) - 1;\r\n      }\r\n      // console.log(referenceCol);\r\n\r\n      curOrigin = curOrigin.slice(1);\r\n      let curInfo = [];\r\n      for (let j = 0; j < curOrigin.length; ++j) {\r\n        let curString = curOrigin[j].split(\":\")[0].split(\" OR \")[0];\r\n        let curType = curString.substring(0, 3) === \"is \" ? \"object\" : \"subject\";\r\n        let curValue = curType === \"object\" ? curString.substring(3, curString.length - 3) : curString; \r\n        curInfo.push({\r\n          \"value\": curValue,\r\n          \"type\": curType,  \r\n        });\r\n      }\r\n      if (curInfo.length === 1) {\r\n        oneDegInfo.push(curInfo);\r\n      }\r\n      else if (curInfo.length === 2) {\r\n        twoDegInfo.push(curInfo);\r\n      }\r\n      else if (curInfo.length === 3) {\r\n        threeDegInfo.push(curInfo);\r\n      }\r\n      else {\r\n        alert(\"Autofill information has caused an error!\");\r\n      }\r\n      columnInfo.push(curInfo);\r\n      refInfo.push(curRef);\r\n    }\r\n    else {\r\n      columnInfo.push([]);\r\n      refInfo.push(-1);\r\n    }\r\n    if (curOrigin.length > 4) {\r\n      longHopWarning = true;\r\n    }\r\n  }\r\n  // we store all these information in a single object with four properties \r\n  \r\n  // Note that when longHopWarning is true, that means not all columns will be auto-populated\r\n  // in which case we should display a warning \r\n  let returnVal = {\r\n    \"longHopWarning\": longHopWarning,\r\n    \"oneDegInfo\": oneDegInfo,\r\n    \"twoDegInfo\": twoDegInfo,\r\n    \"threeDegInfo\": threeDegInfo,\r\n    \"columnInfo\": columnInfo,\r\n    \"refInfo\": refInfo,\r\n  }\r\n\r\n  return returnVal;\r\n}\r\n\r\n// Helper function to automatically fill all the first degree neighbours\r\n// This function currently ignores the OR case.\r\n// It should look very similar to populateOtherColumn\r\n\r\nfunction autofillFirstDeg(tableDataPassed, columnInfo, colIndex, fillStartIndex, firstDegNeighboursPassed, keyColIndex) {\r\n  // console.log(tableDataPassed);\r\n  // console.log(columnInfo);\r\n  // console.log(colIndex);\r\n  // console.log(fillStartIndex);\r\n  // console.log(firstDegNeighboursPassed);\r\n  // console.log(keyColIndex);\r\n\r\n  let tableData = _.cloneDeep(tableDataPassed);\r\n  let firstDegNeighboursPassedCopy = _.cloneDeep(firstDegNeighboursPassed);\r\n\r\n  for (let i = fillStartIndex; i < tableData.length; ++i) {\r\n    // console.log(tableData[i]);\r\n    // curColumnArray is the dataArray for each entry (row) in search column\r\n    let curColumnArray = [];\r\n    // Since we are not worrying about OR case here. We only have one neighbour, which has a value and a type (subject or object)\r\n    let curNeighbour = columnInfo[0];\r\n    let firstDegNeighbours =\r\n      curNeighbour.type === \"subject\" ? firstDegNeighboursPassedCopy.subject : firstDegNeighboursPassedCopy.object;\r\n    // console.log(firstDegNeighbours);\r\n    let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\r\n    // console.log(\"Current neighbour data is \"+curNeighbourData);\r\n    // If yes, we want to concat those values with curColumnArray\r\n    if (curNeighbourData !== undefined) {\r\n      curColumnArray = curColumnArray.concat(curNeighbourData);\r\n    }\r\n    // Take a look at curColumnArray\r\n    // console.log(curColumnArray);\r\n\r\n    // If curColumnArray is empty, that means this entry in searchColumn do not the attribute we are looking for\r\n    if (curColumnArray.length === 0) {\r\n      // we set the data to N/A\r\n      let curData = \"N/A\";\r\n      tableData[i][colIndex].data = curData;\r\n      // Note that we still want to set origin to support autofill\r\n      let curNeighbourText = curNeighbour.type === \"object\" ? \"is \" + curNeighbour.value + \" of\" : curNeighbour.value;\r\n      let originToAdd = curNeighbourText + \":\" + curData;\r\n      let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n      keyOrigin.push(originToAdd);\r\n      tableData[i][colIndex].origin = keyOrigin;\r\n    }\r\n    // Otherwise, we have found at least one value.\r\n    else {\r\n      // we first set the data for the cell using curColumnArray[0]\r\n      let curData = curColumnArray[0]\r\n      tableData[i][colIndex].data = curData;\r\n      // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\r\n      let curNeighbourText = curNeighbour.type === \"object\" ? \"is \" + curNeighbour.value + \" of\" : curNeighbour.value;\r\n      let originToAdd = curNeighbourText + \":\" + curData;\r\n      let keyOrigin = tableData[i][keyColIndex].origin.slice();\r\n      keyOrigin.push(originToAdd);\r\n      tableData[i][colIndex].origin = keyOrigin;\r\n      // console.log(keyOrigin)\r\n    }\r\n  }\r\n  // Now, we are done with updating tableData. Take a look.\r\n  // console.log(tableData);\r\n  return tableData;\r\n}\r\n\r\n// This is a helper function to generate the query we needed to fetch the 2nd and 3rd deg neighbours\r\nfunction autofillFarPromise(tableData, columnInfo, fillStartIndex, usecaseSelected, refInfo) {\r\n  // console.log(tableData);\r\n  // console.log(columnInfo);\r\n  // console.log(fillStartIndex);\r\n\r\n  // Our task is to generate an array of queries that looks like below\r\n  // based on all the inputs\r\n\r\n  // First of all, we construct the promiseArray\r\n  let promiseArray = [];\r\n\r\n  // select ?o1 ?o2\r\n  // where {\r\n  // OPTIONAL {dbr:Devullu dbo:director/dbo:birthPlace ?o1}.\r\n  // OPTIONAL {dbr:Devullu dbo:director/dbo:birthPlace/^dbo:restingPlace ?o2}.\r\n  // }\r\n  // limit 1\r\n\r\n  // Alternatively, when we are in the startTable case\r\n\r\n  // select ?o1 ?o2 ?o3\r\n  // where {\r\n  // OPTIONAL {dbr:Barack_Obama dbo:spouse ?o1}.\r\n  // OPTIONAL {dbr:Devullu dbo:director/dbo:birthPlace ?o2}.\r\n  // OPTIONAL {dbr:Devullu dbo:director/dbo:birthPlace/^dbo:restingPlace ?o3}.\r\n  // }\r\n  // limit 1\r\n\r\n  // In startTable case, we fetch 1/2/3deg neighbours. In startSubject, only 2/3deg.\r\n  let degLimit = usecaseSelected === \"startTable\" ? 0 : 1;\r\n  // Let's generate our query clause by clause\r\n\r\n  // We loop over tableData because we need to generate multiple queries (30 or 45)\r\n\r\n  for (let j = fillStartIndex; j < tableData.length; ++j) {\r\n    // First is the prefix clause, this remains the same\r\n    let prefixClause = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n\r\n    // Next is the select clause\r\n    // we need to determine how many objects (variables, or columns) we are fetching\r\n\r\n    // Ex: \"select+%3Fo1+%3Fo2%0D%0A\"\r\n    let numVar = 0;\r\n    for (let i = 0; i < columnInfo.length; ++i) {\r\n      if (columnInfo[i].length > degLimit) {\r\n        numVar++;\r\n      }\r\n    }\r\n    let selectClause = \"select\";\r\n    for (let i = 1; i <= numVar; ++i) {\r\n      selectClause = selectClause + \"+%3Fo\" + i;\r\n    }\r\n    selectClause+=\"%0D%0A\";\r\n\r\n    // Next is the beginning of the where clause\r\n    let whereClause = \"where+%7B%0D%0A\";\r\n\r\n    // Next is an array of optional clauses.\r\n    // First we still need to set the o_i index, starting from 1.\r\n    // Ex: \"OPTIONAL+%7Bdbr%3ADevullu+dbo%3Adirector%2Fdbo%3AbirthPlace%2F%5Edbo%3ArestingPlace+%3Fo2%7D.%0D%0A\"\r\n    let optionClause = \"\";\r\n\r\n    let optionIndex = 1;\r\n    // We loop through all the columns (paths)\r\n    for (let i = 0; i < columnInfo.length; ++i) {\r\n      if (columnInfo[i].length > degLimit) {\r\n        let curClause = \"OPTIONAL+%7Bdbr%3A\";\r\n        // we can use 0 for the second index because the first column has to be the search column right now\r\n\r\n        let refColIndex = usecaseSelected === \"startTable\" ? refInfo[i] + 1 : 0;\r\n\r\n        let cellValue = regexReplace(tableData[j][refColIndex].data);\r\n        curClause = curClause + cellValue + \"+\";\r\n        // we now loop over all the predicates that form this query path \r\n        for (let k = 0; k < columnInfo[i].length; ++k) {\r\n          // if this is not the start of the path, we need to append the symbol \"/\"\r\n          if (k > 0) {\r\n            curClause += \"%2F\";\r\n          }\r\n          // if this current predict has type \"object\", we need to append the symbol \"^\" to indicate inverse path\r\n          if (columnInfo[i][k].type === \"object\") {\r\n            curClause += \"%5E\";\r\n          }\r\n          curClause = curClause + \"dbo%3A\" + columnInfo[i][k].value;\r\n        }\r\n        // After forming the path, we append the string for variable name and newline\r\n        curClause = curClause + \"+%3Fo\" + optionIndex + \"%7D.%0D%0A\";\r\n\r\n        // Lastly, we update optionIndex, and append curClause to optionClause\r\n        optionIndex++;\r\n        optionClause+=curClause;\r\n      }\r\n    }\r\n\r\n    // Now we are done with optionClause, we move on to the last clause\r\n    let endingClause = \"%7D%0D%0Alimit+1&format=application%2Fsparql-results%2Bjson&timeout=30000&signal_void=on&signal_unconnected=on\";\r\n\r\n    // We now append all the clauses together\r\n    let returnClause = prefixClause + selectClause + whereClause + optionClause + endingClause;\r\n\r\n    // console.log(returnClause);\r\n\r\n    // Code below is for testing\r\n    // if (j === fillStartIndex) {\r\n    //   console.log(prefixClause);\r\n    //   console.log(selectClause);\r\n    //   console.log(whereClause);\r\n    //   console.log(optionClause);\r\n    //   console.log(endingClause);\r\n      // console.log(returnClause);\r\n    // }\r\n\r\n    // We push onto promiseArray\r\n    if (optionClause !== \"\") {\r\n      promiseArray.push(fetchJSON(returnClause));\r\n    }\r\n  }\r\n  return promiseArray;\r\n}\r\n\r\n// This function is a helper function to support autofill, based on the starting use case.\r\n// Specifically, it return a 2D array of strings, as data for the 1/2/3 or 2/3 deg neighbour columns\r\n \r\nfunction processAutoInfo(columnInfo, valuesAuto, usecaseSelected) {\r\n  // First let's determine how many variables there are \r\n  let numVar = 0;\r\n  let degLimit = usecaseSelected === \"startTable\" ? 0 : 1;\r\n\r\n  for (let i = 0; i < columnInfo.length; ++i) {\r\n    if (columnInfo[i].length > degLimit && columnInfo[i].length < 4) {\r\n      numVar++;\r\n    }\r\n  }\r\n\r\n  let returnArray = [];\r\n  for (let i = 0; i < numVar; ++i) {\r\n    returnArray.push([]);\r\n  }\r\n\r\n  // Now let's loop over valuesAuto to fill our (2D) returnArray\r\n  for (let i = 0; i < valuesAuto.length; ++i) {\r\n    let curBinding = valuesAuto[i].results.bindings[0];\r\n    // console.log(curBinding);\r\n    for (let j = 0; j < numVar; ++j) {\r\n      let curIndex = j + 1;\r\n      let curVarName = \"o\" + curIndex;\r\n      if (curBinding[curVarName] === undefined) {\r\n        returnArray[j].push(\"\");\r\n      }\r\n      else {\r\n        let valueToAdd = curBinding[curVarName].value.includes(\"dbpedia.org\") ? curBinding[curVarName].value.slice(28) \r\n                                                                              : curBinding[curVarName].value;\r\n        returnArray[j].push(valueToAdd);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Lastly we return \r\n  return returnArray;\r\n}\r\n\r\n// Helper function to automatically fill all the 2nd/3rd degree neighbours\r\n// This function currently ignores the OR case.\r\nfunction autofillFarDeg(tableDataPassed, columnInfo, valueArray, colIndex, fillStartIndex) {\r\n  // First create a deep copy of table data\r\n  let tableData = _.cloneDeep(tableDataPassed);\r\n\r\n  for (let i = fillStartIndex; i < tableData.length; ++i) {\r\n    // We first set data\r\n    let curData = valueArray[i - fillStartIndex] === \"\" ? \"N/A\" : valueArray[i - fillStartIndex];\r\n    tableData[i][colIndex].data = curData;\r\n    // We then set origin\r\n    let totalNeighbourText = \"\";\r\n    for (let j = 0; j < columnInfo.length; ++j) {\r\n      if (j > 0) {\r\n        totalNeighbourText+=\"/\";\r\n      }\r\n      let curNeighbourText = columnInfo[j].type === \"object\" ? \"is \" + columnInfo[j].value + \" of\" : columnInfo[j].value;\r\n      totalNeighbourText+=curNeighbourText;\r\n    }\r\n    let originToAdd = totalNeighbourText + \":\" + curData;\r\n    let keyOrigin = tableData[i][0].origin.slice();\r\n    keyOrigin.push(originToAdd);\r\n    tableData[i][colIndex].origin = keyOrigin;\r\n  }\r\n\r\n  return tableData;\r\n}\r\n\r\n// Helper function for getting the rdf:types for the sample rows from the colIndex's column\r\nfunction getRDFType(sampleData, colIndex, startingType) {\r\n  // console.log(sampleData);\r\n  // console.log(colIndex);\r\n\r\n  // Now we construct a promise array to ask the queries\r\n  // The sparql query that we will ask looks like the following:\r\n\r\n  // select ?type\r\n  // where {\r\n  // dbr:Barack_Obama rdf:type ?type.\r\n  // }\r\n\r\n  let promiseArray = [];\r\n  let prefixURL = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  let suffixURL = \"format=application%2Fsparql-results%2Bjson&timeout=30000&signal_void=on&signal_unconnected=on\";\r\n\r\n  // In the case that colIndex !== -1, we are only getting the types for one column\r\n\r\n  if (colIndex !== -1) {\r\n\r\n    // First set up the array that contains the actual data\r\n    let dataArray = [];\r\n    for (let i = 0; i < sampleData.length; ++i) {\r\n      dataArray.push(sampleData[i][colIndex].data);\r\n    }\r\n    // console.log(dataArray);\r\n\r\n    for (let i = 0; i < dataArray.length; ++i) {\r\n      let cellValue = dataArray[i] === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(dataArray[i]);\r\n      let queryBody = \"select+%3Ftype%0D%0Awhere+%7B%0D%0Adbr%3A\" + cellValue + \"+rdf%3Atype+%3Ftype.%0D%0A%7D%0D%0A&\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      promiseArray.push(fetchJSON(queryURL));\r\n    }\r\n  }\r\n  // Else, we need to get the types for sampleData[0].length - 1 columns\r\n  else {\r\n\r\n    let startingIndex = startingType === \"startTable\" ? 1: 0;\r\n    // First set up the array that contains the actual data\r\n    let dataArray = [];\r\n    for (let j = startingIndex; j < sampleData[0].length; ++j) {\r\n      for (let i = 0; i < sampleData.length; ++i) {\r\n        dataArray.push(sampleData[i][j].data);\r\n      }\r\n    }\r\n    // console.log(dataArray);\r\n\r\n    for (let i = 0; i < dataArray.length; ++i) {\r\n      let cellValue = dataArray[i] === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(dataArray[i]);\r\n      let queryBody = \"select+%3Ftype%0D%0Awhere+%7B%0D%0Adbr%3A\" + cellValue + \"+rdf%3Atype+%3Ftype.%0D%0A%7D%0D%0A&\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      promiseArray.push(fetchJSON(queryURL));\r\n    }\r\n  }\r\n\r\n  return promiseArray;\r\n}\r\n\r\n// Helper function to build the semantic tree for one column or a full table (when colIndex === -1)\r\nfunction buildTypeRecord(sampleData, colIndex, values, startingType) {\r\n  \r\n  // Case one: when colIndex is not -1, we are processing info for a single column\r\n  if (colIndex !== -1) {\r\n    // First set up the array that contains the actual data\r\n    let dataArray = [];\r\n    for (let i = 0; i < sampleData.length; ++i) {\r\n      dataArray.push(sampleData[i][colIndex].data);\r\n    }\r\n\r\n    // Now we set up the array that contains the types\r\n    let typeArray = [];\r\n    for (let i = 0; i < values.length; ++i) {\r\n      let curBinding = values[i].results.bindings;\r\n      let curTypeArray = [];\r\n      curBinding = curBinding.filter(\r\n        a => a.type.value.includes(\"dbpedia.org/ontology\")\r\n      );\r\n      for (let j = 0; j < curBinding.length; ++j) {\r\n        curTypeArray.push(curBinding[j].type.value.slice(28))\r\n      }\r\n      typeArray.push(curTypeArray);\r\n    }\r\n\r\n    // Now we create a data structure, called typeRecord\r\n    let typeRecord = [];\r\n    for (let i = 0; i < dataArray.length; ++i) {\r\n      typeRecord.push(\r\n        {\r\n          \"data\": dataArray[i],\r\n          \"type\": typeArray[i],\r\n        }\r\n      )\r\n    }\r\n    return typeRecord;\r\n  }\r\n  // Case 2: when colIndex is -1, we have to build the type record for a full table\r\n  else {\r\n    let startingIndex = startingType === \"startTable\" ? 1 : 0;\r\n    // first we set up the dataArray for each column\r\n    let tableDataArray = [];\r\n    for (let j = startingIndex; j < sampleData[0].length; ++j) {\r\n      let dataArray = [];\r\n      for (let i = 0; i < sampleData.length; ++i) {\r\n        dataArray.push(sampleData[i][j].data);\r\n      }\r\n      tableDataArray.push(dataArray);\r\n    }\r\n    // console.log(tableDataArray);\r\n\r\n    // Now we set up the array that contains the tyeps\r\n    let tableTypeArray = [];\r\n    let curCounter = 0;\r\n    for (let j = startingIndex; j < sampleData[0].length; ++j) {\r\n      let typeArray = [];\r\n      for (let i = 0; i < sampleData.length; ++i) {\r\n        let curBinding = values[curCounter*sampleData.length + i].results.bindings;\r\n        let curTypeArray = [];\r\n        curBinding = curBinding.filter(\r\n          a => a.type.value.includes(\"dbpedia.org/ontology\")\r\n        );\r\n        for (let k = 0; k < curBinding.length; ++k) {\r\n          curTypeArray.push(curBinding[k].type.value.slice(28))\r\n        }\r\n        typeArray.push(curTypeArray);\r\n      }\r\n      ++curCounter;\r\n      tableTypeArray.push(typeArray);\r\n    }\r\n    // console.log(tableTypeArray);\r\n\r\n    // In the last step, we put tableDataArray and tableTypeArray together\r\n    let tableTypeRecord = [];\r\n    for (let i = 0; i < tableDataArray.length; ++i) {\r\n      let curTypeRecord = [];\r\n      if (tableDataArray[i].length > 0 && tableDataArray[i][0] !== \"\") {\r\n        for (let j = 0; j < tableDataArray[i].length; ++j) {\r\n          curTypeRecord.push({\r\n            \"data\": tableDataArray[i][j],\r\n            \"type\": tableTypeArray[i][j],\r\n          })\r\n        }\r\n      }\r\n      tableTypeRecord.push(curTypeRecord);\r\n    }\r\n\r\n    // To keep everything consistent, let's push on something empty in the startTable case as well\r\n    let originURLTypeRecord = [];\r\n    for (let i = 0; i < sampleData.length; ++ i) {\r\n      originURLTypeRecord.push({\r\n        \"data\": \"originURL\",\r\n        \"type\": [],\r\n      })\r\n    }\r\n\r\n    if (startingType === \"startTable\") {\r\n      tableTypeRecord.splice(0, 0, originURLTypeRecord);\r\n    }\r\n\r\n    return tableTypeRecord;\r\n  }\r\n}\r\n\r\n// This is a helper function that builds the semantic tree for a table\r\n// based on the typeRecord passed in\r\nfunction tableTreePromise(typeRecord) {\r\n  // console.log(typeRecord);\r\n\r\n  let tablePromise = [];\r\n  \r\n  // Since we perform the same operations for each column, we call another helper columnTreePromise\r\n  for (let i = 0; i < typeRecord.length; ++i) {\r\n    let curColumnPromise = columnTreePromise(typeRecord[i]);\r\n    tablePromise.push(curColumnPromise);\r\n  }\r\n\r\n  return allPromiseReady(tablePromise).then((values) => {\r\n    return Promise.resolve(values);\r\n  })\r\n}\r\n\r\n// This is a helper function for tableTreePromise\r\nfunction columnTreePromise(columnRecord) {\r\n  // console.log(columnRecord);\r\n\r\n  let promiseArray = [];\r\n\r\n  // For each entry in columnRecord, we need to make a query that looks like the following:\r\n\r\n  // SELECT ?type0 ?type1 ?type2 ?type3\r\n  // WHERE { \r\n  // {dbo:Person rdfs:subClassOf+ ?type0}\r\n  // UNION\r\n  // {dbo:Agent rdfs:subClassOf+ ?type1}\r\n  // UNION\r\n  // {dbo:Athlete rdfs:subClassOf+ ?type2}\r\n  // UNION\r\n  // {dbo:SoccerPlayer rdfs:subClassOf+ ?type3}\r\n  // }\r\n\r\n  for (let i = 0; i < columnRecord.length; ++i) {\r\n    let curColumnType = columnRecord[i].type;\r\n    // If this current entry has rdf:type, we need to ask the query\r\n    if (curColumnType.length > 0) {\r\n      // We start generating the query\r\n\r\n      // First is the prefix clause, this remains the same\r\n      let prefixClause = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n\r\n      // Second is the select clause\r\n      let selectClause = \"SELECT\";\r\n      for (let j = 0; j < curColumnType.length; ++j) {\r\n        selectClause = selectClause + \"+%3Ftype\" + j;\r\n      }\r\n      selectClause += \"%0D%0A\";\r\n\r\n      // Third is the whereClause\r\n      let whereClause = \"WHERE+%7B+%0D%0A\";\r\n\r\n      // Then it's the query body\r\n      let bodyClause = \"\";\r\n      for (let j = 0; j < curColumnType.length; ++j) {\r\n        if (j > 0) {\r\n          bodyClause += \"UNION%0D%0A\"\r\n        }\r\n        bodyClause = bodyClause + \"%7Bdbo%3A\" + curColumnType[j] + \"+rdfs%3AsubClassOf%2B+%3Ftype\" + j + \"%7D%0D%0A\"\r\n      }\r\n      bodyClause += \"%7D\";\r\n      \r\n      // Lastly is the ending clause\r\n      let endingClause = \"&format=application%2Fsparql-results%2Bjson&timeout=30000&signal_void=on&signal_unconnected=on\";\r\n\r\n      // Take a look at the clauses we have generated\r\n      // console.log(prefixClause);\r\n      // console.log(selectClause);\r\n      // console.log(whereClause);\r\n      // console.log(bodyClause);\r\n      // console.log(endingClause);\r\n\r\n      // We now append all the clauses together\r\n      let returnClause = prefixClause + selectClause + whereClause + bodyClause + endingClause;\r\n      promiseArray.push(fetchJSON(returnClause));\r\n    }\r\n  }\r\n  // return promiseArray;\r\n  return allPromiseReady(promiseArray).then((values) => {\r\n    return Promise.resolve(values);\r\n  })\r\n}\r\n\r\n// This helper function builds the semantic tree for each column in the table\r\n// based on the type lineage and typeRecord\r\n\r\nfunction buildTableTree(treeValues, typeRecord) {\r\n  // console.log(treeValues);\r\n  // console.log(typeRecord);\r\n\r\n  let semTree = [];\r\n\r\n  // Each entry in treeValues contains info for a column\r\n\r\n  // If it's empty, there's no type for this column.\r\n  // Otherwise for each column, we find the longest typeX, where X is a number\r\n  for (let i = 0; i < typeRecord.length; ++i) {\r\n    semTree.push(buildColumnTree(treeValues[i], typeRecord[i]));\r\n  }\r\n  // console.log(semTree);\r\n  return semTree;\r\n}\r\n\r\n// Helper function for buildTableTree\r\nfunction buildColumnTree(values, columnType) {\r\n  // Let's first process values\r\n  let columnTree = [];\r\n  let fullColumnTree = [];\r\n  // console.log(values);\r\n  // console.log(columnType);\r\n\r\n  // Note, we need to make a copy of columnType, and remove those entries with empty \"type\" arary\r\n  // This will make our columnType's length to be consistent with values\r\n  let columnTypeCopy = _.cloneDeep(columnType);\r\n  for (let i = 0; i < columnTypeCopy.length; ++i) {\r\n    if (columnTypeCopy[i].type.length === 0) {\r\n      columnTypeCopy.splice(i, 1);\r\n      --i;\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < values.length; ++i) {\r\n    // Below we construct the level tree for the current CELL \r\n    // We use a map to track which typeX is the lowest child (farthest descendent from owl:Thing)\r\n    let countMap = {};\r\n    // We store the most frequent typeX: these are the longest child (which can be more than 1)\r\n    let highestCount = 0;\r\n    let curBinding = values[i].results.bindings;\r\n    for (let j = 0; j < curBinding.length; ++j) {\r\n      let curType = Object.keys(curBinding[j])[0];\r\n      countMap[curType] = (countMap[curType] || 0) + 1;\r\n      if (countMap[curType] > highestCount) {\r\n        highestCount = countMap[curType];\r\n      }\r\n    }\r\n    // console.log(countMap);\r\n\r\n    // Now we store the typeX's with the highest key counts\r\n    let highestTypes = [];\r\n    for (let j = 0; j < Object.keys(countMap).length; ++j) {\r\n      let curType = Object.keys(countMap)[j];\r\n      if (countMap[curType] === highestCount) {\r\n        highestTypes.push(curType);\r\n      }\r\n    }\r\n    // console.log(highestTypes);\r\n\r\n    // Now that we have built the countMap, we can build our tree from them\r\n    let tempTree = [];\r\n    for (let j = 0; j < Object.keys(countMap).length; ++j) {\r\n      let curType = Object.keys(countMap)[j];\r\n      let curTypeTree = [];\r\n      for (let k = 0; k < curBinding.length; ++k) {\r\n        if (curBinding[k][curType] !== undefined) {\r\n          if (curBinding[k][curType].value !== \"http://www.w3.org/2002/07/owl#Thing\") {\r\n            curTypeTree.push(curBinding[k][curType].value.slice(28));\r\n          }\r\n        }\r\n      }\r\n      if (curTypeTree.length > 0) {\r\n        tempTree.push({\r\n          \"type\": curType,\r\n          \"tree\": curTypeTree,\r\n        });\r\n      }\r\n    }\r\n\r\n    // We now combine information from \r\n    // 1) highestTypes (an array of the lowest children),\r\n    // 2) tempTree (info about all lineaage)\r\n    // 3) columnTypeCopy[i].type\r\n    // To create the column tree\r\n\r\n    // We first sort tempTree by each object's \"tree\" field's length\r\n    // The shorter, the higher up it is on the tree\r\n    tempTree.sort((a, b) =>\r\n      a.tree.length > b.tree.length ? 1 : -1\r\n    );\r\n    // console.log(tempTree);\r\n\r\n    // We now fetch the lowest children using highestTypes and columnTypeCopy[i].type\r\n    for (let j = 0; j < highestTypes.length; ++j) {\r\n      let curHighType = Number(highestTypes[j].substring(4));\r\n      highestTypes[j] = columnTypeCopy[i].type[curHighType];\r\n    }\r\n    // console.log(highestTypes);\r\n\r\n    // We build the tree in top-down manner\r\n    let cellTree = [];\r\n    let typeUsed = [];\r\n    for (let j = 0; j < tempTree.length; ++j) {\r\n      let curLevel = [];\r\n      for (let k = 0; k < tempTree[j].tree.length; ++k) {\r\n        let curType = tempTree[j].tree[k];\r\n        if (!typeUsed.includes(curType)) {\r\n          typeUsed.push(curType);\r\n          curLevel.push(curType);\r\n        }\r\n      }\r\n      cellTree.push(curLevel);\r\n    }\r\n    cellTree.push(highestTypes);\r\n    // Take a look at cellTree\r\n    // console.log(cellTree);\r\n    columnTree.push(cellTree);\r\n  }\r\n\r\n  // Finally we construct the fullColumnTree. Its difference from columnTree is that it contains info about cells w/o types\r\n  let counter = 0;\r\n  for (let i = 0; i < columnType.length; ++i) {\r\n    if (columnType[i].type.length === 0) {\r\n      fullColumnTree.push([]);\r\n    }\r\n    else {\r\n      fullColumnTree.push(columnTree[counter]);\r\n      ++counter;\r\n    }\r\n  }\r\n  // console.log(fullColumnTree);\r\n\r\n  // Now that fullColumnTree looks correct. Let's merge each cellTree in a columnTree together.\r\n  // and store the fraction information\r\n\r\n  // Note that combinedTree should be a 2D array\r\n  // Each outer array (corresponding to each level) stores an array of objects with properties type and frac\r\n\r\n  // We first get the depth of the tree, from the deepest cell tree\r\n  let combinedTree = [];\r\n  let maxDepth = 0;\r\n\r\n  for (let i = 0; i < fullColumnTree.length; ++i) {\r\n    if (fullColumnTree[i].length > maxDepth) {\r\n      maxDepth = fullColumnTree[i].length;\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < maxDepth; ++i) {\r\n    let curLevel = {};\r\n    for (let j = 0; j < fullColumnTree.length; ++j) {\r\n      if (fullColumnTree[j].length > i) {\r\n        for (let k = 0; k < fullColumnTree[j][i].length; ++k) {\r\n          let curType = fullColumnTree[j][i][k];\r\n          curLevel[curType] = (curLevel[curType] || 0) + 1;\r\n        }\r\n      }\r\n    }\r\n    combinedTree.push(curLevel);\r\n  }\r\n\r\n  // Now the tree contains counts instead of fraction, let's convert it to fraction\r\n  let totalCount = columnType.length;\r\n  for (let i = 0; i < combinedTree.length; ++i) {\r\n    let curLevelMap = combinedTree[i];\r\n    for (let j = 0; j < Object.keys(curLevelMap).length; ++j) {\r\n      let curType = Object.keys(curLevelMap)[j];\r\n      curLevelMap[curType] /= totalCount;\r\n    }\r\n  }\r\n  return combinedTree;\r\n}\r\n\r\n// Helper function for finding a matching column based on semantic mapping\r\nfunction findSemanticUnion(originColIndex, tableTree, otherTableTree) {\r\n  // console.log(originColIndex);\r\n  // console.log(tableTree);\r\n  // console.log(otherTableTree);\r\n  // First case, the column looking for a matching does not have semantic info\r\n  if (tableTree[originColIndex].length === 0) {\r\n    return -1;\r\n  }\r\n  // Else we loop over all columns in otherTableTree\r\n  else {\r\n    let otherColIndex = -1;\r\n    let otherColScore = 0;\r\n    for (let i = 0; i < otherTableTree.length; ++i) {\r\n      let curColScore = calcColumnScore(tableTree[originColIndex], otherTableTree[i]);\r\n      if (curColScore > otherColScore) {\r\n        otherColScore = curColScore;\r\n        otherColIndex = i;\r\n      }\r\n    }\r\n    return otherColIndex;\r\n  }\r\n}\r\n\r\n// Helper function to calculate the similarity score between two semantic trees. Used in findSemanticUnion.\r\nfunction calcColumnScore(treeOne, treeTwo) {\r\n  // console.log(treeOne);\r\n  // console.log(treeTwo);\r\n  if (treeTwo.length === 0) {\r\n    return 0;\r\n  }\r\n  else {\r\n    let returnScore = 0;\r\n    // We loop over each level\r\n    for (let i = 0; i < treeOne.length; ++i) {\r\n      let originTypes = Object.keys(treeOne[i]);\r\n      if (treeTwo.length > i) {\r\n        for (let j = 0; j < originTypes.length; ++j) {\r\n          let curOriginType = originTypes[j];\r\n          // console.log(\"Current type is \"+curOriginType);\r\n          // If we go into the following clause, that means the type exists in the ith level of both\r\n          // treeOne and treeTwo\r\n          if (treeTwo[i][curOriginType] !== undefined) {\r\n            let scoreToAdd = Math.min(treeOne[i][curOriginType], treeTwo[i][curOriginType]);\r\n            // console.log(\"Score to add is \"+scoreToAdd);\r\n            returnScore += scoreToAdd * (2 ^ i);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return returnScore;\r\n  }\r\n}\r\n\r\n// This function removes N/A from \"Notes\" column\r\nfunction removeNAfromNotes(tableData, originCols) {\r\n  let tableDataUpdated = _.cloneDeep(tableData);\r\n\r\n  console.log(tableData);\r\n  console.log(originCols);\r\n\r\n  for (let i = 0; i < originCols.length; ++i) {\r\n    if (originCols[i] === \"Notes\") {\r\n      for (let j = 0; j < tableDataUpdated.length; ++j) {\r\n        if (tableDataUpdated[j][i].data === \"N/A\") {\r\n          tableDataUpdated[j][i].data = \"\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return tableDataUpdated;\r\n}\r\n\r\n\r\n// this following query is going to help with the recursive property recommendation\r\n\r\n// select ?superclass where{\r\n//   dbo:Person rdfs:subClassOf* ?superclass .\r\n//   dbo:Actor rdfs:subClassOf* ?superclass .\r\n// }\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\n// import Header from \"../components/Header\";\r\n// import Footer from \"../components/Footer\";\r\nimport MainBody from \"../components/MainBody\";\r\n\r\nclass App extends Component {\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"wrapper \">\r\n        <div className=\"font-body\">\r\n          {/* <div className=\"header\">\r\n            <Header />\r\n          </div> */}\r\n          <div>\r\n            <MainBody />\r\n          </div>\r\n          {/* <div className=\"footer\">\r\n            <Footer />\r\n          </div> */}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n\r\n\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport \"./assets/custom.css\";\r\nimport \"./assets/layout.css\";\r\n// import \"./assets/font-awesome.min.css\";\r\nimport App from \"./layouts/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}