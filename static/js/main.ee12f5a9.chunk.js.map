{"version":3,"sources":["components/Header.jsx","components/Footer.jsx","components/SettingModal.jsx","components/FilterModal.jsx","components/JoinModal.jsx","components/URLForm.jsx","components/LandingPage.jsx","components/TablePanel.jsx","components/TableSelection.jsx","components/TaskMenu.jsx","components/FirstColSelection.jsx","components/OtherColSelection.jsx","components/PreviewOrigin.jsx","components/ActionPanel.jsx","components/PagePanel.jsx","components/MainBody.jsx","layouts/App.jsx","index.js"],"names":["Header","state","className","href","class","title","onClick","props","copyTable","openModal","undoPreviousStep","Component","Footer","SettingModal","isOpen","this","showSetting","onChange","e","toggleSemantic","type","value","checked","semanticEnabled","unionCutOff","unionCutOffChange","min","max","step","closeModal","FilterModal","optionsEle","i","push","dataAndChecked","toggleChecked","data","replace","length","showFilter","checkAll","toggleAll","applyFilter","cancelFilter","JoinModal","showJoin","originColOptions","originJoinIndex","selectJoinColumn","placeholder","options","isMulti","joinColOptions","joinJoinIndex","runJoin","cancelJoin","URLForm","handleURLPaste","bind","preventDefault","urlPasted","clipboardData","window","getData","onPaste","LandingPage","TablePanel","showFullTitle","createSuperTable","createSelectedTableView","showPartialTitle","setState","colIndex","tableHeader","label","textLiteral","niceRender","firstColHeaderInfo","curText","j","onMouseEnter","onMouseLeave","textToAdd","rowNum","tableData","colNum","table","tempRow","tempHeader","buttonsEle","textEle","firstColFilled","columnHeaderGen","handlePlusClick","contextSetColumn","contextAddColumn","showFilterMethods","keyColIndex","buttonEle","getOtherOptions","contextDeleteColumn","rows","previewColIndex","style","backgroundColor","previewData","readOnly","cellColor","onCellChange","onDoubleClick","originPreviewPage","tableDataExplore","tableHeaderRow","tableRows","tableEle","border","str","TableSelection","createButtonArray","originTableArray","buttonArray","buttonText","headerCells","cells","headerData","removeNewLine","innerText","slice","tableContent","dangerouslySetInnerHTML","__html","outerHTML","selectButton","tableOpenList","listType","buttonFunction","toggleTable","Collapse","originTableArrayEle","TaskMenu","subject","resultStr","bracketIndex","indexOf","handleStartSubject","decodeURIComponent","toggleTableSelection","showTableSelection","CardBody","Card","handleStartTable","FirstColSelection","createFirstColSelection","keyCheckedIndex","firstColSelection","firstColChecked","selectedNeighbours","alert","populateEle","populateText","pDataset","oValue","pValue","Button","populateKeyColumn","confirmAddFirstCol","returnEle","toggleFirstNeighbour","selectionEle","OtherColSelection","createOtherColSelection","otherColSelection","otherColChecked","otherCheckedIndex","console","log","populateOtherColumn","toggleOtherNeighbour","PreviewOrigin","createPreviewEle","createOriginEle","previewInfoExpanded","previewInfoArray","previewEle","key","togglePreviewElement","brEle","selectedCell","originEle","origin","ActionPanel","createPropertyArray","createSiblingArray","createTableArray","createRecommendArray","createStartRecommend","firstIndex","secondIndex","tableArray","propertyNeighbours","siblingArray","tableElement","thirdIndex","tableTitleText","toggleOtherTable","unionTable","colMapping","siblingElement","zeroDividerSet","tooltipText","name","listClassSib","toggleSibling","unionPage","propertyElement","predicate","object","propertyText","listClass","togglePropertyNeighbours","recommendArray","recommendEle","neighbourArray","recommendText","populateRecommendation","recommendationText","createNeighbourText","actionInfo","neighbourArrayText","sameNeighbourOneRow","sameNeighbourDiffRow","curActionInfo","populateStartRecommend","actionEle","wrapperEle","titleEle","usecaseSelected","selectedTableIndex","task","addToFirstCol","createSameNeighbour","sameNeighbourEle","contextSortColumn","openFilter","contextDedupColumn","curIndex","tabIndex","selectedIndex","onSelect","index","handleTabSwitch","toggleUnionJoin","showUnionTables","showJoinTables","handleJoinTable","PagePanel","pageEle","wikiPageClass","iframeURL","buttonhideShow","toggleWikiPage","aria-hidden","pageHidden","id","src","MainBody","optionsMap","tablePasted","lastAction","prevState","keyColNeighbours","firstDegNeighbours","selectedClassAnnotation","curFilterIndex","showJoinModal","joinTableIndex","joinTableData","cellChange","selectColHeader","getKeyOptions","getNeighbourPromise","getOtherColPromise","addAllNeighbour","getTableStates","unionProperty","document","body","classList","add","includes","promiseArray","fetchText","allPromiseReady","then","values","htmlText","DOMParser","parseFromString","getElementsByClassName","remove","textArea","createElement","copiedText","undefined","appendChild","select","execCommand","removeChild","taskSelected","_","cloneDeep","fetchJSON","regexReplace","resultsBinding","processedBinding","filter","a","p","dctArray","dbopArray","sort","b","o","count","getPCount","prevNeighbour","curNeighbour","datatype","concat","removePrefix","updateFirstColSelection","results","bindings","neighbourIndex","curColumnArray","curNeighbourData","otherColCheckedIndex","firstColCheckedUpdated","target","allSubject","queryBody","queryURL","myJson","keyColOptions","curValue","somevar","tempObj","neighbour","colEmpty","colFilled","nonEmptyInfo","tempSelection","scrollTo","selectedOptions","keyColLabel","ownLabel","cellValue","curPromise","keyQueryGen","updatedRowCount","Math","rowsToAdd","emptyEntryCount","startingIndex","tempOrigin","uniqBy","x","setFirstColumnData","promiseArrayOne","promiseArrayTwo","valuesOne","valuesTwo","updatedNeighbours","updateNeighbourInfo","numNewRows","hasMultiple","originToAdd","keyOrigin","lastIndex","dataArray","recommendNeighbours","relation","differenceBy","filledPercent","numCols","fillRecommendation","keyColIndexUpdated","tableDataUpdated","k","newTableHeader","tableHeaderUpdated","selectedClassAnnotationUpdated","optionsMapUpdated","curCol","requiredLength","subjectNeighbours","objectNeighbours","curRow","rowToAdd","firstDegNeighboursUpdated","curData","curRecommendation","sliceIndex","splice","numRecommend","order","numericCol","isNaN","Number","aValue","bValue","rowIndex","otherColPromiseSubject","otherColPromiseObject","subjectInfoArray","updatePreviewInfo","objectInfoArray","originText","Promise","resolve","tableIndex","queryPromise","queryOne","urlReplace","queryTwo","findClassAnnotation","queryResults","propertyNeighboursPO","bindingArray","urlOrigin","curSiblingArray","siblingName","s","setTableFromHTML","stateInfo","siblingNameArray","tableArrayPromise","pageHTML","findTableFromHTML","tableArrayValues","aTableLength","bTableLength","aName","bName","selectedSibling","selectedTable","otherTableHTML","otherTableData","setUnionData","tempMapping","tableConcat","otherTableOrigin","headerRow","sameTable","diffColFound","m","Set","checkIndex","allFalse","valuesToKeep","originTableHeader","joinTableHeader","joinTableDataUpdated","curJoinEntry","curEntryFound","bodyEle","bottomContentClass","topContentClass","url","fetch","response","ok","Error","json","catch","error","text","all","updateKeyColNeighbours","subPropertyOf","neighbourCount","neighbourToAdd","valuesToAdd","neighbourRange","range","neighbourSubPropertyOf","objLabel","categoryPreviewInfoArray","categoryBinding","dataToAdd","colInNew","HTMLCleanCell","trim","split","pageName","originCols","wikiTablesFound","tablesFound","tagName","tablePromise","findTableFromTable","unionScore","tableHTML","curHeaderCells","newCols","remainCols","searchCols","headerName","sameStructure","remainClassAnnotation","curSearchIndex","intersection","totalSuccess","numTrial","hyperCDF","tempTable","curCellText","anchorArray","getElementsByTagName","hrefArray","curRowSpan","rowSpan","curColSpan","colSpan","remainEntries","curColIndex","curEntry","classAnnotation","curColumnClass","curCellClass","selecteTableHTML","N","K","n","denom","combinations","processAllNeighbours","allNeighboursArray","allNeighboursArrayCopy","prevEntry","filledCount","round","storeFirstDeg","neighbourArrayCopy","dedupedData","uniq","addRecommendNeighbours","processedNeighboursCopy","processedNeighbours","upperStrOne","toUpperCase","upperStrTwo","myArray","oType","subjectNeighbourArray","temp","processedSubjectNeighbours","objectNeighbourArray","processedObjectNeighbours","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.ee12f5a9.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { FaCopy, FaUndo } from \"react-icons/fa\";\nimport { FiSettings } from \"react-icons/fi\";\n\nclass Header extends Component {\n  state = {};\n  render() {\n    return (\n      <>\n        <div className=\"row header-body\">\n          <div className=\"col-md-8\">\n            <a href=\"index.html\" class=\"logo\">\n              <b>\n                <span>KG</span>Wrangler\n              </b>\n            </a>\n          </div>\n          <div className=\"offset-md-2 col-md-2 row\">\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"copy table to csv\"\n                onClick={() => this.props.copyTable()}\n              >\n                <FaCopy className=\"logo-left-color\" />\n              </button>\n            </div>\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"Union Table Settings\"\n              >\n                <FiSettings\n                  className=\"logo-left-color\"\n                  onClick={() => this.props.openModal()}\n                />\n              </button>\n            </div>\n            <div className=\"col-md-4\">\n              <button\n                className=\"btn btn-default\"\n                title=\"undo previous action\"\n                onClick={() => this.props.undoPreviousStep()}\n              >\n                <FaUndo className=\"color-wrangler\" />\n              </button>\n            </div>\n          </div>\n        </div>\n        <hr class=\"header-hr\"></hr>\n      </>\n    );\n  }\n}\n\nexport default Header;\n","import React, { Component } from \"react\";\nclass Footer extends Component {\n  state = {};\n  render() {\n    return (\n      <>\n        {/* <hr className=\"m-0\"></hr> */}\n        <div className=\"text-center text-sm\">\n          <small>University of Waterloo, 2020</small>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default Footer;\n","import React, { Component } from \"react\";\nimport Modal from 'react-modal';\n// The two following lines are for range sliders\nimport RangeSlider from \"react-bootstrap-range-slider\";\nimport \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\n\nclass SettingModal extends Component {\n  state = {};\n  render() {\n    return (\n      <div>\n        <Modal \n          isOpen={this.props.showSetting}\n          className=\"setting-modal\"\n        >\n          <div className=\"container\">\n            <div className=\"row\">\n              <div className=\"col-md-6 offset-md-3\">\n                <h4>Table Union Search Settings</h4>\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4\">Semantic Mapping:</div>\n              <div className=\"col-md-6\">\n                <div onChange={(e) => this.props.toggleSemantic(e)}>\n                  <input\n                  type=\"radio\"\n                  value=\"enabled\"\n                  checked={this.props.semanticEnabled === \"enabled\"}\n                  />{\" \"}\n                  Enabled\n                  <input\n                    type=\"radio\"\n                    value=\"disabled\"\n                    checked={this.props.semanticEnabled === \"disabled\"}\n                  />{\" \"}\n                  Disabled\n                </div>\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4\">Percentage of Columns to Union:</div>\n              <div className=\"col-md-6\">\n                <RangeSlider\n                  value={this.props.unionCutOff}\n                  onChange={(e) => this.props.unionCutOffChange(e)}\n                  min={0}\n                  max={1}\n                  step={0.05}\n                />\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-4 offset-md-4\">\n                <button onClick={() => this.props.closeModal()}>Confirm Settings</button>\n              </div>\n            </div>\n          </div>\n        </Modal>\n      </div>\n    );\n  }\n}\n\nexport default SettingModal;\n","import React, { Component } from \"react\";\nimport Modal from 'react-modal';\n\nclass FilterModal extends Component {\n  state = {};\n\n  render() {\n\n    let optionsEle = [];\n    for (let i=0;i<this.props.dataAndChecked.length;++i) {\n      optionsEle.push(\n        <div>\n          <input\n            type=\"checkbox\"\n            checked={this.props.dataAndChecked[i].checked}\n            onChange={(e) => this.props.toggleChecked(e, i)}\n          />\n          {niceRender(this.props.dataAndChecked[i].data)}\n        </div>\n      )\n    }\n    // console.log(optionsEle);\n\n    return (\n      <div>\n        <Modal \n          isOpen={this.props.showFilter}\n          className=\"filter-modal\"\n        >\n          <div className=\"container\">\n            <div>\n              Here is the list of data to filter.\n            </div>\n            <br />\n            <div className=\"checkbox-list\">\n              <div>\n                <input\n                  type=\"checkbox\"\n                  checked={this.props.checkAll}\n                  onChange={(e) => this.props.toggleAll(e)}\n                />\n                Check/Uncheck all\n              </div>\n              <br />\n              {optionsEle}\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-1 offset-md-9\">\n                <button onClick={(e) => this.props.applyFilter(e)}>OK</button>\n              </div>\n              <div className=\"col-md-2\">\n                <button onClick={(e) => this.props.cancelFilter(e)}>Cancel</button>\n              </div>\n            </div>\n          </div>\n        </Modal>\n      </div>\n    );\n  }\n}\n\nexport default FilterModal;\n\n// This function renders data in a nicer way. \n// It removes all occurence of (...), and changes all \"_\" to \" \".\n\nfunction niceRender(str) {\n  return str.replace(/_\\(.*?\\)/g, \"\")\n            .replace(/_/g, \" \");\n}\n","import React, { Component } from \"react\";\nimport Modal from 'react-modal';\nimport Select from \"react-select\";\n\nclass JoinModal extends Component {\n  state = {};\n\n  render() {\n\n    // let optionsEle = [];\n\n    // console.log(this.props.originColOptions);\n    // console.log(this.props.joinColOptions);\n\n    // Note, the props originColOptions and joinColOptions are what we are going to pass to react select as options\n\n    return (\n      <div>\n        <Modal \n          isOpen={this.props.showJoin}\n          className=\"join-modal\"\n        >\n          <div className=\"container\">\n            <div className=\"row\"> \n              <div className=\"col-md-5\">\n                Choose join column from table panel\n              </div>\n              <div className=\"offset-md-1 col-md-5\">\n                Choose join column from selected table\n              </div>\n            </div>\n            <br />\n            <div className=\"row\">\n              <Select\n                className=\"col-md-5\"\n                value={this.props.originColOptions[this.props.originJoinIndex]}\n                onChange={(e) => this.props.selectJoinColumn(e, \"originTable\")}\n                placeholder={\"Choose Join Column\"}\n                options={this.props.originColOptions}\n                isMulti={false}\n              />\n              <Select\n                className=\"offset-md-1 col-md-5\"\n                value={this.props.joinColOptions[this.props.joinJoinIndex]}\n                onChange={(e) => this.props.selectJoinColumn(e, \"joinTable\")}\n                placeholder={\"Choose Join Column\"}\n                options={this.props.joinColOptions}\n                isMulti={false}\n              />\n            </div>\n            <br />\n            <div className=\"row\">\n              <div className=\"col-md-1 offset-md-9\">\n                <button onClick={(e) => this.props.runJoin(e)}>OK</button>\n              </div>\n              <div className=\"col-md-2\">\n                <button onClick={(e) => this.props.cancelJoin(e)}>Cancel</button>\n              </div>\n            </div>\n          </div>\n        </Modal>\n      </div>\n    );\n  }\n}\n\nexport default JoinModal;\n","import React, { Component } from \"react\";\n\nclass URLForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.handleURLPaste = this.handleURLPaste.bind(this);\n  }\n\n  handleURLPaste(e) {\n    e.preventDefault();\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\n    this.props.handleURLPaste(urlPasted);\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"row text-center\">\n          <div className=\"col-md-6 offset-md-3\">\n            <input\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\n              onPaste={this.handleURLPaste}\n              className=\" form-control\"\n            ></input>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default URLForm;\n","import React, { Component } from \"react\";\nimport URLForm from \"../components/URLForm\";\n\nclass LandingPage extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    return (\n      <>\n        <div class=\"landing-page\">\n          <div class=\" row text-center\">\n            <div class=\"white-form col-md-5\">\n              <h1 class=\"\"> Welcome!</h1>\n              <hr className=\"header-hr\"></hr>\n              <h4>Enter the URL of a Wikipedia page and start wrangling!</h4>\n              <URLForm handleURLPaste={this.props.handleURLPaste} />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default LandingPage;\n","import React, { Component } from \"react\";\n// import TableSelection from \"../components/TableSelection\";\n// import Tooltip from '@atlaskit/tooltip';\n// import Select from \"react-select\";\n// import { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\nimport { FaSearch, FaEdit, FaPlus, FaMinus, FaFilter, FaArrowDown, FaEllipsisH} from \"react-icons/fa\";\n\nclass TablePanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      showFullTitle: false, // boolean storing whether we want to display the full title for the first column, in the startSubject case\n    };\n    this.createSuperTable = this.createSuperTable.bind(this);\n    this.createSelectedTableView = this.createSelectedTableView.bind(this);\n    // The following functions are for first column's display in the startSubject case. They are helpers for columnHeaderGen\n    this.showFullTitle = this.showFullTitle.bind(this);\n    this.showPartialTitle = this.showPartialTitle.bind(this);\n  }\n\n  showFullTitle() {\n    this.setState({\n      showFullTitle: true,\n    })\n  }\n\n  showPartialTitle() {\n    this.setState({\n      showFullTitle: false,\n    })\n  }\n\n  // This function creates the i-th column header from this.props.tableHeader[i]\n  // It is a helper function for createSuperTable\n\n  columnHeaderGen(colIndex) {\n    // console.log(colIndex);\n    // console.log(this.props.tableHeader);\n\n    // In this case we deal with the first column header\n    // We want to divide it into two subcases: \"start table\" vs. \"start subject\"\n    if (colIndex === 0) {\n      // First subcase is start table\n      if (this.props.tableHeader.length > 0 && \n          this.props.tableHeader[0].length === 1 && \n          this.props.tableHeader[0][0].label === \"OriginURL\") {\n        let textLiteral = \"\";\n        for (let i = 0; i < this.props.tableHeader[0].length; ++i) {\n          let textToAdd = i > 0 ? \"\\nAND \" + niceRender(this.props.tableHeader[0][i].label) : niceRender(this.props.tableHeader[0][i].label);\n          textLiteral+=textToAdd;\n        }\n        let textEle = \n          <div>\n            {textLiteral}\n          </div>\n        return textEle;\n      }\n      // Second subcase is start subject\n      else {\n        // In this subcase, we first check if firstColHeaderInfo has length < 2\n        let firstColHeaderInfo = this.props.firstColHeaderInfo;\n\n        // If yes, we simply display it\n        if (firstColHeaderInfo.length < 2) {\n          let textLiteral = [];\n          for (let i = 0; i < firstColHeaderInfo.length; ++i) {\n            let curText = \"\";\n            for (let j = 0; j < firstColHeaderInfo[i].length; ++j) {\n              let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[i][j].label) : niceRender(firstColHeaderInfo[i][j].label);\n              curText+=textToAdd;\n            }\n            textLiteral.push(\n              <p>\n                {curText}\n              </p>\n            )\n          }\n          let textEle = \n            <div>\n              {textLiteral}\n            </div>\n          return textEle;\n        }\n\n        // Else, firstColHeaderInfo has length longer than 1, so we have to check this.state.showFullTitle\n        // what we render depends on whether this.state.showFullTitle is true or not\n        else {\n          let showFullTitle = this.state.showFullTitle;\n\n          // If showFullTitle is false, we display the first element from firstColHeaderInfo\n          // As well as an icon that, on hover, sets showFullTitle to true\n          if (showFullTitle === false) {\n            let textLiteral = [];\n            let curText = \"\";\n            for (let j = 0; j < firstColHeaderInfo[0].length; ++j) {\n              let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[0][j].label) : niceRender(firstColHeaderInfo[0][j].label);\n              curText+=textToAdd;\n            }\n            textLiteral.push(\n              <p>\n                {curText}\n                {\"\\u00A0\"}\n                <FaEllipsisH \n                  onMouseEnter={() => this.showFullTitle()}\n                  onMouseLeave={() => this.showPartialTitle()}\n                />\n              </p>\n            )\n            let textEle = \n              <div>\n                {textLiteral}\n              </div>\n            return textEle;\n          }\n          // If showFullTitle is true, we display the full table header for the first column\n          else {\n            let textLiteral = [];\n            for (let i = 0; i < firstColHeaderInfo.length; ++i) {\n              let curText = \"\";\n              for (let j = 0; j < firstColHeaderInfo[i].length; ++j) {\n                let textToAdd = j > 0 ? \"\\nAND \" + niceRender(firstColHeaderInfo[i][j].label) : niceRender(firstColHeaderInfo[i][j].label);\n                curText+=textToAdd;\n              }\n              if (i === 0) {\n                textLiteral.push(\n                  <p>\n                    {curText}\n                    {\"\\u00A0\"}\n                    <FaEllipsisH \n                      onMouseEnter={() => this.showFullTitle()}\n                      onMouseLeave={() => this.showPartialTitle()}\n                    />\n                  </p>\n                )\n              }\n              else {\n                textLiteral.push(\n                  <p>\n                    {curText}\n                  </p>\n                )\n              }\n            }\n            let textEle = \n              <div>\n                {textLiteral}\n              </div>\n            return textEle;\n          }\n        }\n      }\n    }\n    // In this case we deal with non-first column headers\n    else {\n      let textLiteral = \"\";\n      for (let i = 0; i < this.props.tableHeader[colIndex].length; ++i) {\n        let textToAdd = \n          this.props.tableHeader[colIndex][i].type === \"object\" ? \"is \" + this.props.tableHeader[colIndex][i].value + \" of\" \n          : this.props.tableHeader[colIndex][i].value;\n        textToAdd = i > 0 ? \"\\nOR \" + textToAdd : textToAdd;\n        textLiteral+=textToAdd;\n      }\n      let textEle = \n        <div>\n          {textLiteral}\n        </div>\n      return textEle;\n    }\n  }\n\n  // This function takes the states tableData, keyColIndex, tableHeader, optionsMap\n  // And convert them into HTML for the super table\n\n  createSuperTable() {\n\n    // console.log(this.props.firstColHeaderInfo);\n    // console.log(\"Has first column been filled? \" + this.props.firstColFilled);\n    // console.log(this.props.tableData);\n    // console.log(\"The current previewColIndex is \"+this.props.previewColIndex);\n    \n    const rowNum = this.props.tableData.length;\n    const colNum = this.props.tableData[0].length;\n\n    let table = [];\n\n    // This part creates the table header row\n\n    let tempRow = [];\n    for (let colIndex = 0; colIndex < colNum; ++colIndex) {\n      let tempHeader;\n      // This part deals with the column 0 \n      if (colIndex === 0) {\n        let buttonsEle = null;\n        let textEle = <div><br /></div>;\n        if (this.props.firstColFilled === true) {\n          // If we have filled in the first column already, then we can generate its header text\n          textEle = this.columnHeaderGen(colIndex);\n          // Moreover, if the first column head is not [\"OriginURL\"], then we can create the button element\n          if (this.props.tableHeader[0][0].value !== \"OriginURL\") {\n            buttonsEle = \n              <div>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Add entities\"\n                  onClick={() => this.props.handlePlusClick()}\n                >\n                  <FaArrowDown />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Set as key column\"\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\n                >\n                  <FaSearch />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Add column to the right\"\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\n                >\n                  <FaPlus />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Filter this column\"\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\n                >\n                  <FaFilter />\n                </button>\n                {/* <button\n                  className=\"btn btn-default\"\n                  title=\"Delete this column\"\n                  // onClick={(e) => this.props.contextSetColumn(e, colIndex)}\n                >\n                  <FaMinus />\n                </button> */}\n              </div>\n          }\n          else {\n            buttonsEle =\n              <div>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Add column to the right\"\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\n                >\n                  <FaPlus />\n                </button>\n              </div>\n          }\n        }\n        tempHeader = (\n          <th className=\"table-head\">\n            <div\n              className=\"super-header-div\"\n            >\n            </div>\n            {buttonsEle}\n            {textEle}\n          </th>\n        )\n      }\n      // This part deals with key columns that are not column 0\n      else if (colIndex === this.props.keyColIndex) {\n        let textEle = this.columnHeaderGen(colIndex);\n        let buttonEle = <div><br /></div>;\n        if (this.props.firstColFilled === true) {\n          buttonEle = \n            <div>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Add column to the right\"\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\n                >\n                  <FaPlus />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Filter this column\"\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\n                >\n                  <FaFilter />\n                </button>\n            </div>\n        }\n        tempHeader = (\n          <th className=\"table-head\">\n            {buttonEle}\n            {textEle}\n          </th>\n        );\n      }\n      // This part deals with the non-key, non-first column headers\n      else {\n        let textEle = this.columnHeaderGen(colIndex);\n        let buttonEle = <div><br /></div>;;\n        if (this.props.firstColFilled === true) {\n          buttonEle = \n            <div>\n              <button\n                className=\"btn btn-default\"\n                title=\"Add entities\"\n                onClick={(e) => this.props.getOtherOptions(e, colIndex)}\n              >\n                <FaEdit />\n              </button>\n              <button\n                  className=\"btn btn-default\"\n                  title=\"Set as key column\"\n                  onClick={(e) => this.props.contextSetColumn(e, colIndex)}\n                >\n                  <FaSearch />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Add column to the right\"\n                  onClick={(e) => this.props.contextAddColumn(e, colIndex)}\n                >\n                  <FaPlus />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Delete this column\"\n                  onClick={(e) => this.props.contextDeleteColumn(e, colIndex)}\n                >\n                  <FaMinus />\n                </button>\n                <button\n                  className=\"btn btn-default\"\n                  title=\"Filter this column\"\n                  onClick={(e) => this.props.showFilterMethods(e, colIndex)}\n                >\n                  <FaFilter />\n                </button>\n            </div>\n        }\n        tempHeader = (\n          <th className=\"table-head\">\n            {buttonEle}\n            {textEle}\n          </th>\n        );\n      }\n      tempRow.push(tempHeader);\n    }\n    table.push(\n      <thead className=\"table-head\">\n        <tr>{tempRow}</tr>\n      </thead>\n    );\n\n    // i corresponds to the row number, j corresponds to the column number\n\n    // We are adding an ID for each cell for contextmenu\n    let rows = [];\n    for (let i = 0; i < rowNum; i++) {\n      let tempRow = [];\n      // Inner loop to create each cell of the row\n      for (let j = 0; j < colNum; j++) {\n        // We want to treat preview columns and other columns differently\n\n        // First we deal with preview column\n        if (j === this.props.previewColIndex) {\n          let cellColor = {backgroundColor: \"LightGray\"};\n          tempRow.push(\n            <td style={cellColor}>\n              <input\n                className=\"twenty-vw column-preview-color\"\n                type=\"text\"\n                value={niceRender(this.props.tableData[i][j].previewData)}\n                readOnly\n              />\n            </td>\n          );\n        }\n        // Else we are dealing with a regular column\n        else {\n          let cellColor;\n          // We use light blue to represent search column\n          if (j === this.props.keyColIndex) {\n            cellColor = { backgroundColor: \"LightBlue\" };\n          }\n          // We use white to represent other columns\n          else {\n            cellColor = { backgroundColor: \"White\" };\n          }\n          // console.log(\"Current data is \"+this.props.tableData[i][j]);\n          tempRow.push(\n            <td style={cellColor}>\n              <input\n                className=\"twenty-vw\"\n                type=\"text\"\n                value={niceRender(this.props.tableData[i][j].data)}\n                title={niceRender(this.props.tableData[i][j].data)}\n                onChange={(e) => this.props.onCellChange(e, i, j)}\n                onDoubleClick={(e) => this.props.originPreviewPage(e, i, j)}\n              />\n            </td>\n          );\n        }\n      }\n      //Create the parent and add the children\n      rows.push(<tr>{tempRow}</tr>);\n    }\n    table.push(<tbody>{rows}</tbody>);\n    return table;\n  }\n\n  // This function makes no modification of the data at all.\n  // It takes all the data from this.props.tableDataExplore, and convert them into HTML\n  createSelectedTableView() {\n    // console.log(rowNum);\n    // console.log(colNum);\n    // console.log(this.props.tableDataExplore[0][0].data);\n    // console.log(this.props.tableDataExplore[0][0].origin);\n    const rowNum = this.props.tableDataExplore.length;\n    const colNum = this.props.tableDataExplore[0].length;\n\n    let table = [];\n\n    // This part creates the table header row\n    let tempRow = [];\n    for (let j = 0; j < colNum; ++j) {\n      let tempHeader = (\n        <th className=\"table-head table-col\">\n          {this.props.tableDataExplore[0][j].data}\n        </th>\n      );\n      tempRow.push(tempHeader);\n    }\n    let tableHeaderRow = <tr className=\"table-head table-col\">{tempRow}</tr>;\n    table.push(<thead>{tableHeaderRow}</thead>);\n\n    // i corresponds to the row number, j corresponds to the column number\n    let tableRows = [];\n    for (let i = 1; i < rowNum; i++) {\n      let tempRow = [];\n      //Inner loop to create each cell of the row\n      for (let j = 0; j < colNum; j++) {\n        // Create the each cell\n        tempRow.push(\n          <td className=\"table-col\">\n            {this.props.tableDataExplore[i][j].data}\n          </td>\n        );\n      }\n      //Create the parent and add the children\n      tableRows.push(<tr>{tempRow}</tr>);\n    }\n    table.push(<tbody>{tableRows}</tbody>);\n    return table;\n  }\n\n  render() {\n    let tableEle = null;\n\n    // In all cases, once we have pasted the URL. We want to display the super table in the table panel.\n    tableEle = (\n      // class table-fixed helps with sticky column headers\n      <div>\n        <table class border=\"1\" className=\"table table-sm table-bordered\">\n          {this.createSuperTable()}\n        </table>\n        {/* {menuArray} */}\n      </div>\n    );\n    return <div>{tableEle}</div>;\n  }\n}\n\nexport default TablePanel;\n\n// This function renders this.props.tableData[i][j].data in a nicer way. \n// It removes all occurence of (...), and changes all \"_\" to \" \".\n\nfunction niceRender(str) {\n  return str.replace(/_\\(.*?\\)/g, \"\")\n            .replace(/_/g, \" \");\n}\n\n","// This component takes in 5 props:\n\n// 1) originTableArray: 1D array storing all tables found on pasted URL\n// 2) tableOpenList:    1D array storing whether each table in originTableArray has been toggled open or not\n// 3) toggleTable:      function that handles the toggling on/off of a table\n// 4) listType:         string. Has value \"select\" when we are using TableSelection to select the starting table.\n//                              Has value \"join\" when we are using TableSelection in the join tables setting.\n// 5) buttonFunction:   function corresponding to the listType.\n\nimport React, { Component } from \"react\";\nimport { Collapse } from \"reactstrap\";\nimport { FaTable } from \"react-icons/fa\";\n\nclass TableSelection extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createButtonArray = this.createButtonArray.bind(this);\n  }\n\n  createButtonArray() {\n    const originTableArray = this.props.originTableArray;\n    let buttonArray = [];\n    for (let i = 0; i < originTableArray.length; ++i) {\n      // This first part create the buttons with text: table index plus column names\n      // It also removes some newline characters\n      let buttonText = \"Table \" + i + \": \";\n      let headerCells = originTableArray[i].rows[0].cells;\n      for (let j = 0; j < headerCells.length; ++j) {\n        let headerData = removeNewLine(headerCells[j].innerText);\n        if (headerData[headerData.length - 1] === \"\\n\") {\n          headerData = headerData.slice(0, -1);\n        }\n        buttonText = buttonText + headerData + \"| \";\n      }\n      // Now let's update the table content\n      let tableContent = (\n        <div\n          dangerouslySetInnerHTML={{\n            __html: this.props.originTableArray[i].outerHTML,\n          }}\n        />\n      );\n      let selectButton;\n      if (this.props.tableOpenList[i] === true) {\n        let buttonText = \"\";\n        if (this.props.listType === \"select\") {\n          buttonText = \"Select\";\n        }\n        else {\n          buttonText = \"Join\"\n        }\n        selectButton = \n          <button\n            onClick={(e) => this.props.buttonFunction(e, i)}\n          >\n            {buttonText}\n          </button>\n      }\n      buttonArray.push(\n        <li\n          className=\"list-group-item\"\n        >\n        <span \n          onClick={(e) => this.props.toggleTable(e, i)}\n        >\n          {buttonText} {}\n          <FaTable />\n        </span>\n        {selectButton}\n          <Collapse isOpen={this.props.tableOpenList[i]}>\n            <div>{tableContent}</div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">{buttonArray}</ul>\n    );\n  }\n\n  render() {\n    const numTables = this.props.originTableArray.length;\n    let originTableArrayEle = null;\n    if (numTables !== 0) {\n      originTableArrayEle = <div>{this.createButtonArray()}</div>;\n    }\n    return <div>{originTableArrayEle}</div>;\n  }\n}\n\nexport default TableSelection;\n\nfunction removeNewLine(str) {\n  if (str[str.length - 1] === \"\\n\") {\n    return str.slice(0, -1);\n  } else {\n    return str;\n  }\n}\n","import React, { Component } from \"react\";\nimport { Collapse, CardBody, Card } from \"reactstrap\";\nimport { FaList } from \"react-icons/fa\";\nimport TableSelection from \"../components/TableSelection\";\n\nclass TaskMenu extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const subject = niceRender(reverseReplace(this.props.urlPasted.slice(30)));\n    return (\n      <div className=\"action-scrollable\">\n        <ul class=\"list-group list-css list-group-flush\">\n          <hr className=\"m-0\"></hr>\n          <li\n            className=\"list-group-item\"\n            onClick={(e) => this.props.handleStartSubject(e, \"startSubject\")}\n          >\n            Start creating a table about {decodeURIComponent(subject)}\n          </li>\n          <li className=\"list-group-item\">\n            <span onClick={() => this.props.toggleTableSelection()}>\n              Start with an existing table from page <FaList />\n            </span>\n\n            <Collapse isOpen={this.props.showTableSelection}>\n              <CardBody>\n                <Card>\n                  <div>\n                    <TableSelection\n                      originTableArray={this.props.originTableArray}\n                      tableOpenList={this.props.tableOpenList}\n                      toggleTable={this.props.toggleTable}\n                      buttonFunction={this.props.handleStartTable}\n                      listType={\"select\"}\n                    />\n                  </div>\n                </Card>\n              </CardBody>\n            </Collapse>\n          </li>\n          <hr className=\"m-0\"></hr>\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TaskMenu;\n\n// This function changes the copied text \"%E2%80%93\" to \"-\" when we copy a URL from google.\n\nfunction reverseReplace(str) {\n  return str.replace(/%E2%80%93/, \"\");\n}\n\n// This function renders this.props.tableData[i][j].data in a nicer way.\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\n\nfunction niceRender(str) {\n  let resultStr = str;\n  let bracketIndex = str.indexOf(\"(\");\n  // If ( is present in a string, we want to remove it\n  // We include the -1 because usually ( is preceeded by _\n  if (bracketIndex !== -1) {\n    resultStr = resultStr.slice(0, bracketIndex - 1);\n  }\n  // now we turn all \"_\" into \" \"\n  return resultStr.replace(/_/g, \" \");\n}\n","import React, { Component } from \"react\";\nimport { Button } from \"reactstrap\";\n\nclass FirstColSelection extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createFirstColSelection = this.createFirstColSelection.bind(this);\n  }\n\n  createFirstColSelection() {\n    let keyCheckedIndex = this.props.keyCheckedIndex;\n    let firstColSelection = this.props.firstColSelection;\n    let firstColChecked = this.props.firstColChecked;\n\n    let selectedNeighbours = [];\n    // We will create the selectedNeighbours array from this.props.firstColSelection and this.props.firstColChecked\n    if (firstColChecked.length !== firstColSelection.length) {\n      alert(\"Some error exists\");\n    }\n    for (let i = 0; i < firstColChecked.length; ++i) {\n      if (firstColChecked[i] === true) {\n        selectedNeighbours.push(firstColSelection[i]);\n      }\n    }\n\n    // console.log(selectedNeighbours);\n\n    // We initialize the populateEle as text telling users they should select from the attribute list\n    let populateEle = (\n      <div className=\"fixed-populateEle\">\n        <b>Choose from attributes below</b> to determine the content for the\n        first column\n        {/* <br /> */}\n      </div>\n    );\n\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\n    if (keyCheckedIndex !== -1 && selectedNeighbours.length > 0) {\n      let populateText =\n        this.props.firstColFilled === false\n          ? \"Populate first column with entities that\"\n          : \"Add to first column with entities that\";\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\n        let curText = i > 0 ? \", and\" : \"\";\n        if (selectedNeighbours[i].pDataset === \"dct\") {\n          curText =\n            curText + \" are \" + niceRender(selectedNeighbours[i].oValue);\n        } else {\n          curText =\n            curText +\n            \" have \" +\n            selectedNeighbours[i].pValue +\n            \"=\" +\n            niceRender(selectedNeighbours[i].oValue);\n        }\n        populateText += curText;\n      }\n      populateText += \"?\";\n      // We conditionally create the button element\n      // If firstColFilled is false, we want to run populateKeyColumn\n      // Otherwise, we want to run addKeyColumn\n      let buttonEle =\n        this.props.firstColFilled === false ? (\n          <Button\n            className=\"btn-sm\"\n            onClick={(e) =>\n              this.props.populateKeyColumn(e, 0, selectedNeighbours)\n            }\n          >\n            OK\n          </Button>\n        ) : (\n          <Button\n            className=\"btn-sm\"\n            onClick={(e) =>\n              this.props.confirmAddFirstCol(e, selectedNeighbours)\n            }\n          >\n            OK\n          </Button>\n        );\n      populateEle = (\n        <div className=\"fixed-populateEle\">\n          <b>{populateText}</b>\n          {\"\\u00A0\"}\n          {buttonEle}\n          <br />\n        </div>\n      );\n    }\n\n    // We now create the returnEle. First, we push on the populateEle\n    let returnEle = [];\n    // returnEle.push(populateEle);\n\n    // We loop over the firstColSelection array, and push on the needed radio checkbox and textual information\n    for (let i = 0; i < firstColSelection.length; ++i) {\n      if (firstColSelection[i].pValue === \"category\") {\n        returnEle.push(\n          <div>\n            <div>\n              <p>\n                <input\n                  type=\"checkbox\"\n                  checked={firstColChecked[i]}\n                  onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\n                />\n                {\"\\u00A0\"}\n                {\"\\u00A0\"}\n                {niceRender(firstColSelection[i].oValue)}\n              </p>\n            </div>\n          </div>\n        );\n      } else {\n        returnEle.push(\n          // <div>\n          <div>\n            <p>\n              <input\n                type=\"checkbox\"\n                checked={firstColChecked[i]}\n                onChange={(e) => this.props.toggleFirstNeighbour(e, i)}\n              />\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {firstColSelection[i].pValue}\n              {\":\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {niceRender(firstColSelection[i].oValue)}\n            </p>\n          </div>\n          // </div>\n        );\n      }\n    }\n    return (\n      <div>\n        {populateEle}\n        <div className=\"padding-top-5vh\">{returnEle}</div>\n      </div>\n    );\n  }\n\n  render() {\n    let selectionEle = this.createFirstColSelection();\n\n    return <div>{selectionEle}</div>;\n  }\n}\n\nexport default FirstColSelection;\n\n// This function renders this.props.tableData[i][j].data in a nicer way.\n// It removes all occurence of (...), and changes all \"_\" to \" \".\n\nfunction niceRender(str) {\n  return str.replace(/_\\(.*?\\)/g, \"\").replace(/_/g, \" \");\n}\n","import React, { Component } from \"react\";\nimport { Button } from \"reactstrap\";\n\nclass OtherColSelection extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createOtherColSelection = this.createOtherColSelection.bind(this);\n  }\n\n  createOtherColSelection() {\n    let otherColSelection = this.props.otherColSelection;\n    let otherColChecked = this.props.otherColChecked;\n    let otherCheckedIndex = this.props.otherCheckedIndex;\n\n    // console.log(otherColSelection);\n    // console.log(otherColChecked);\n    // console.log(otherCheckedIndex);\n\n    // First do some basic error checking\n    if (otherColChecked.length !== otherColSelection.length) {\n      console.log(\"Some error exists\");\n    }\n\n    // Now, we will create the selectedNeighbours array from otherColSelection and otherColChecked\n    let selectedNeighbours = [];\n    for (let i = 0; i < otherColChecked.length; ++i) {\n      if (otherColChecked[i] === true) {\n        selectedNeighbours.push(otherColSelection[i]);\n      }\n    }\n\n    // We initialize the populateEle as text telling users they should select from the attribute list\n    let populateEle = (\n      <div className=\"fixed-populateEle\">\n        <b>Choose from attributes below</b> to determine the content for this\n        column\n        <br />\n      </div>\n    );\n\n    // If selectedNeighbours is not empty, we have to create the populateText and populateEle\n    if (otherCheckedIndex !== -1 && selectedNeighbours.length > 0) {\n      let populateText = \"Populate this column with attributes \";\n      for (let i = 0; i < selectedNeighbours.length; ++i) {\n        let curText =\n          selectedNeighbours[i].type === \"object\"\n            ? \"is \" + selectedNeighbours[i].value + \" of\"\n            : selectedNeighbours[i].value;\n        curText = i > 0 ? \" OR \" + curText : curText;\n        populateText += curText;\n      }\n      populateText += \"?\";\n      populateEle = (\n        <div className=\"fixed-populateEle\">\n          <b>{populateText}</b>\n          {\"\\u00A0\"}\n          <Button\n            className=\"btn-sm\"\n            onClick={(e) =>\n              this.props.populateOtherColumn(\n                e,\n                this.props.colIndex,\n                selectedNeighbours\n              )\n            }\n          >\n            OK\n          </Button>\n          <br />\n        </div>\n      );\n    }\n\n    let returnEle = [];\n    // Modified on August 23rd: We want to display the textual information separately (not right next to any attribute)\n    // We also want to make this div fixed\n    returnEle.push(populateEle);\n\n    // We loop through the otherColSelection array, and push on the needed radio checkbox\n    for (let i = 0; i < otherColSelection.length; ++i) {\n      returnEle.push(\n        <div>\n          <div>\n            <p>\n              <input\n                type=\"checkbox\"\n                checked={otherColChecked[i]}\n                onChange={(e) =>\n                  this.props.toggleOtherNeighbour(e, i, this.props.colIndex)\n                }\n              />\n              {\"\\u00A0\"}\n              {\"\\u00A0\"}\n              {otherColSelection[i].label}\n            </p>\n          </div>\n        </div>\n      );\n    }\n    return returnEle;\n  }\n\n  render() {\n    let selectionEle = this.createOtherColSelection();\n\n    return <div>{selectionEle}</div>;\n  }\n}\n\nexport default OtherColSelection;\n","import React, { Component } from \"react\";\nimport { FaPlus, FaMinus } from \"react-icons/fa\";\n\nclass PreviewOrigin extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createPreviewEle = this.createPreviewEle.bind(this);\n    this.createOriginEle = this.createOriginEle.bind(this);\n  }\n\n  createPreviewEle() {\n    let previewInfoExpanded = this.props.previewInfoExpanded;\n    let previewInfoArray = this.props.previewInfoArray;\n    // We do some preliminary error checking\n    if (previewInfoExpanded.length !== previewInfoArray.length) {\n      alert(\"Some error exists!\");\n    }\n\n    // Move on to actual body of the function\n    let previewEle = [];\n    for (let i = 0; i < previewInfoArray.length; ++i) {\n      // First case: the current previewInfoArray element's value array only has one element. We just want to show some text.\n      if (previewInfoArray[i].value.length === 1) {\n        previewEle.push(\n          <div>\n            <div className=\"row\">\n              <div className=\"col-md-4\">\n                <b>{previewInfoArray[i].key}:</b>\n              </div>\n              <div className=\"col-md-7\">\n                {niceRender(previewInfoArray[i].value[0])}\n              </div>\n            </div>\n            <br />\n          </div>\n        )\n      } \n      // Second case: the current previewInfoArray element's value array has more than one element.\n      // In this case we have to check for the previewInfoExpanded's variable.\n      else {\n        // Subcase one: previewInfoExpanded[i] is false, which means we want to push on one element only, and show a plus button\n        if (previewInfoExpanded[i] === false) {\n          previewEle.push(\n            <div>\n              <div className=\"row\">\n                <div className=\"col-md-4\">\n                  <b>{previewInfoArray[i].key}:</b>\n                </div>\n                <div className=\"col-md-7\">\n                  {niceRender(previewInfoArray[i].value[0])}\n                </div>\n                <div className=\"col-md-1\">\n                  <button\n                    className=\"btn btn-default\"\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\n                  >\n                    <FaPlus />\n                  </button>\n                </div>\n              </div>\n              <br />\n            </div>\n          )\n        }\n        // Subcase one: previewInfoExpanded[i] is true, which means we want to push on value.length number of elements.\n        // In this case we want to give a minus, or collapse icon\n        else {\n          // We first push on the first element(or row), which will include the minus icon\n          previewEle.push(\n            <div>\n              <div className=\"row\">\n                <div className=\"col-md-4\">\n                  <b>{previewInfoArray[i].key}:</b>\n                </div>\n                <div className=\"col-md-7\">\n                  {niceRender(previewInfoArray[i].value[0])}\n                </div>\n                <div className=\"col-md-1\">\n                  <button\n                    className=\"btn btn-default\"\n                    onClick={(e) => this.props.togglePreviewElement(e, i)}\n                  >\n                    <FaMinus />\n                  </button>\n                </div>\n              </div>\n            </div>\n          )\n          // We then push on the subsequent values\n          for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\n            let brEle = j === previewInfoArray[i].value.length - 1 ? <br /> : null;\n            previewEle.push(\n              <div>\n                <div className=\"row\">\n                  <div className=\"offset-md-4 col-md-7\">\n                    {niceRender(previewInfoArray[i].value[j])}\n                  </div>\n                </div>\n                {brEle}\n              </div>\n            )\n          }\n        }\n      }\n    }\n    let returnEle = (\n      <div>\n        <p>Preview of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\n        {previewEle}\n      </div>\n    )\n    return returnEle;\n  }\n\n  createOriginEle() {\n    let originEle = [];\n    for (let i = 0; i < this.props.selectedCell.origin.length; ++i) {\n      originEle.push(\n        <p>\n          {niceRender(this.props.selectedCell.origin[i])}\n        </p>\n      );\n    }\n    let returnEle = (\n      <div>\n        <p>Origin of <b>{niceRender(this.props.selectedCell.data)}</b> is:</p>\n        {originEle}\n      </div>\n    )\n    return returnEle;\n  }\n\n  render() {\n    // console.log(this.props.previewInfoArray);\n    // console.log(this.props.previewInfoExpanded);\n    // console.log(this.props.selectedCell);\n    let previewEle = this.createPreviewEle();\n    let originEle = this.createOriginEle();\n    return (\n      <div>\n        {previewEle}\n        <hr className=\"preview-origin-divider\"/>\n        {originEle}\n      </div>\n    );\n  }\n}\n\nexport default PreviewOrigin;\n\n// This function renders strings in a nicer way. \n// It removes all occurence of (...), and changes all \"_\" to \" \".\n\nfunction niceRender(str) {\n  return str.replace(/_\\(.*?\\)/g, \"\")\n            .replace(/_/g, \" \");\n}\n","import React, { Component } from \"react\";\nimport TaskMenu from \"../components/TaskMenu\";\nimport { Collapse, Button, CardBody, Card } from \"reactstrap\";\nimport { FaList, FaTable } from \"react-icons/fa\";\n// import TableSelection from \"../components/TableSelection\";\n// The two following lines are for tabs\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\nimport \"react-tabs/style/react-tabs.css\";\nimport TableSelection from \"./TableSelection\";\n// The two following lines are for range sliders\n// import RangeSlider from \"react-bootstrap-range-slider\";\n// import \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\nimport FirstColSelection from \"./FirstColSelection\";\nimport OtherColSelection from \"./OtherColSelection\";\nimport PreviewOrigin from \"./PreviewOrigin\";\n\nclass ActionPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.createPropertyArray = this.createPropertyArray.bind(this);\n    this.createSiblingArray = this.createSiblingArray.bind(this);\n    this.createTableArray = this.createTableArray.bind(this);\n    this.createRecommendArray = this.createRecommendArray.bind(this);\n    this.createStartRecommend = this.createStartRecommend.bind(this);\n  }\n\n  createTableArray(firstIndex, secondIndex) {\n    const tableArray = this.props.propertyNeighbours[firstIndex].siblingArray[\n      secondIndex\n    ].tableArray;\n    let tableElement = [];\n    for (let thirdIndex = 0; thirdIndex < tableArray.length; ++thirdIndex) {\n      // console.log(\"Hello\");\n      // console.log(tableArray[thirdIndex].title);\n      let tableTitleText = \"Table \" + thirdIndex + \": \";\n      for (let i = 0; i < tableArray[thirdIndex].title.length; ++i) {\n        tableTitleText = tableTitleText + tableArray[thirdIndex].title[i] + \"|\";\n      }\n      tableElement.push(\n        <div>\n          <Button\n            onClick={(e) =>\n              this.props.toggleOtherTable(\n                e,\n                firstIndex,\n                secondIndex,\n                thirdIndex\n              )\n            }\n          >\n            {tableTitleText}\n            <FaTable />\n          </Button>\n          <Collapse isOpen={tableArray[thirdIndex].isOpen}>\n            <Card>\n              <CardBody>\n                <div>\n                  <ul className=\"list-group list-css\">\n                    <li\n                      className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\n                      onClick={(e) =>\n                        this.props.unionTable(\n                          firstIndex,\n                          secondIndex,\n                          tableArray[thirdIndex].data,\n                          tableArray[thirdIndex].colMapping\n                        )\n                      }\n                    >\n                      Union table\n                    </li>\n                  </ul>\n                  <div\n                    dangerouslySetInnerHTML={{\n                      __html: tableArray[thirdIndex].data.outerHTML,\n                    }}\n                  ></div>\n                </div>\n              </CardBody>\n            </Card>\n          </Collapse>\n        </div>\n      );\n    }\n    return tableElement;\n  }\n\n  createSiblingArray(firstIndex) {\n    const siblingArray = this.props.propertyNeighbours[firstIndex].siblingArray;\n    let siblingElement = [];\n    let zeroDividerSet = false;\n    for (\n      let secondIndex = 0;\n      secondIndex < siblingArray.length;\n      ++secondIndex\n    ) {\n      let tooltipText =\n        \"Examine tables on page \" + siblingArray[secondIndex].name;\n      // let divider = null;\n      let listClassSib = \"list-group-item\";\n      if (siblingArray[secondIndex].isOpen) {\n        listClassSib = \"list-group-item list-with-background\";\n      }\n      if (\n        zeroDividerSet === false &&\n        siblingArray[secondIndex].tableArray.length === 0\n      ) {\n        zeroDividerSet = true;\n        // divider = (\n        //   <li>\n        //     <h5>\n        //       Below are sibling pages on which no similar tables are found:\n        //     </h5>\n        //     <hr />\n        //   </li>\n        // );\n        siblingElement.push(\n          <li className=\"list-group-item\">\n            <hr />\n            <h5>\n              Below are sibling pages on which no similar tables are found:\n            </h5>\n            <hr />\n          </li>\n        );\n      }\n\n      siblingElement.push(\n        <li\n          className={listClassSib}\n          title={tooltipText}\n          // onClick={(e) =>\n          //   this.props.toggleSibling(e, firstIndex, secondIndex)\n          // }\n        >\n          <span\n            onClick={(e) =>\n              this.props.toggleSibling(e, firstIndex, secondIndex)\n            }\n          >\n            {niceRender(siblingArray[secondIndex].name) + \" \"}\n            <FaList />\n          </span>\n\n          <Collapse isOpen={siblingArray[secondIndex].isOpen}>\n            <div>\n              <ul className=\"list-group list-css\">\n                <li\n                  className=\"col-md-4 list-group-item list-button\"\n                  onClick={(e) => this.props.unionPage(firstIndex, secondIndex)}\n                >\n                  Union from page\n                </li>\n              </ul>\n              {this.createTableArray(firstIndex, secondIndex)}\n            </div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">\n        {\" \"}\n        {siblingElement}{\" \"}\n      </ul>\n    );\n  }\n\n  createPropertyArray() {\n    // console.log(\"Getting here meaning we are recreating the property array\");\n    const propertyNeighbours = this.props.propertyNeighbours;\n    // console.log(propertyNeighbours);\n    let propertyElement = [];\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      // We create the text for property buttons: table index plus column names\n      const predicate = propertyNeighbours[i].predicate;\n      const object = propertyNeighbours[i].object;\n      let propertyText =\n        predicate !== \"subject\"\n          ? predicate + \": \" + object + \" \"\n          : object + \" \";\n      let tooltipText = \"Show other pages with \" + predicate + \": \" + object;\n\n      let listClass = \"list-group-item\";\n      if (this.props.propertyNeighbours[i].isOpen) {\n        listClass = \"list-group-item list-with-background\";\n      }\n\n      propertyElement.push(\n        <li class={listClass} title={tooltipText}>\n          <span onClick={(e) => this.props.togglePropertyNeighbours(e, i)}>\n            {niceRender(propertyText)}\n            <FaList />\n          </span>\n\n          <Collapse isOpen={this.props.propertyNeighbours[i].isOpen}>\n            <div>\n              <hr />\n              {/* <ul className=\"list-group list-css\">\n                <li\n                  className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\n                  onClick={(e) => this.props.unionProperty(i)}\n                >\n                  Union from all pages\n                </li>\n              </ul> */}\n              {this.createSiblingArray(i)}\n            </div>\n          </Collapse>\n        </li>\n      );\n    }\n    return (\n      <ul className=\"list-group list-css list-group-flush\">\n        {propertyElement}\n      </ul>\n    );\n  }\n\n  // This function creates the HTML element for recommend array\n\n  createRecommendArray(colIndex, recommendArray) {\n    // console.log(recommendArray);\n    let recommendEle = [];\n    // stringRecommend and semanticRecommend are both HTML elements that should be constructed from recommend array\n    for (let i = 0; i < recommendArray.length; ++i) {\n      let neighbourArray = [\n        {\n          value: recommendArray[i].value,\n          type: recommendArray[i].type,\n        },\n      ];\n      let recommendText = recommendArray[i].label;\n      recommendEle.push(\n        <div>\n          <p>\n            <Button\n              onClick={(e) =>\n                this.props.populateRecommendation(e, colIndex, neighbourArray)\n              }\n            >\n              {recommendText}\n            </Button>\n          </p>\n        </div>\n      );\n    }\n    // Now, we also want to tell user they are adding attributes with respect to which column.\n    let recommendationText = \"\";\n    if (this.props.keyColIndex !== -1) {\n      let neighbourArray = this.props.tableHeader[this.props.keyColIndex];\n      recommendationText =\n        this.props.keyColIndex !== 0\n          ? createNeighbourText(neighbourArray)\n          : \"First Column\";\n    }\n    let returnEle = (\n      <div className=\"container\">\n        <p>Attribute recommendations:</p>\n        <p>\n          Current Search Column: <b>{recommendationText}</b>\n        </p>\n        {recommendEle}\n      </div>\n    );\n    return returnEle;\n  }\n\n  // This function creates the HTML element for populateSameNeighbour\n  createSameNeighbour(actionInfo) {\n    let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\n    let returnEle = (\n      <div className=\"container\">\n        <p>Some cells in this column contain multiple values.</p>\n        <p>Expand all other values that are also</p>\n        <p>\n          <b>{neighbourArrayText}</b> ?\n        </p>\n        <div className=\"row\">\n          <Button\n            className=\"col-md-4\"\n            onClick={(e) =>\n              this.props.sameNeighbourOneRow(\n                e,\n                actionInfo.colIndex,\n                actionInfo.neighbourArray\n              )\n            }\n          >\n            In One Row\n          </Button>\n          <Button\n            className=\"offset-md-1 col-md-4\"\n            onClick={(e) =>\n              this.props.sameNeighbourDiffRow(\n                e,\n                actionInfo.colIndex,\n                actionInfo.neighbourArray\n              )\n            }\n          >\n            In Separate Rows\n          </Button>\n        </div>\n      </div>\n    );\n    return returnEle;\n  }\n\n  // This function creates the starting recommendations, when actionInfo.task is showStartRecommend\n  createStartRecommend() {\n    console.log(this.props.curActionInfo);\n    let recommendEle = [];\n    let recommendArray = this.props.curActionInfo.recommendArray;\n    for (let i = 0; i < recommendArray.length; ++i) {\n      let neighbourArray = [\n        {\n          value: recommendArray[i].value,\n          type: recommendArray[i].type,\n        },\n      ];\n      let recommendText = recommendArray[i].label;\n      recommendEle.push(\n        <div>\n          <p>\n            <Button\n              onClick={(e) =>\n                this.props.populateStartRecommend(\n                  e,\n                  this.props.curActionInfo.colIndex,\n                  neighbourArray\n                )\n              }\n            >\n              {recommendText}\n            </Button>\n          </p>\n        </div>\n      );\n    }\n    // Now, we also want to tell user they are adding attributes with respect to which column.\n    let recommendationText = \"\";\n    if (this.props.keyColIndex !== -1) {\n      let neighbourArray = this.props.tableHeader[this.props.keyColIndex];\n      recommendationText =\n        this.props.keyColIndex !== 0\n          ? createNeighbourText(neighbourArray)\n          : \"First Column\";\n    }\n    let returnEle = (\n      <div className=\"container\">\n        <p>Attribute recommendations:</p>\n        <p>\n          Current Search Column: <b>{recommendationText}</b>\n        </p>\n        {recommendEle}\n      </div>\n    );\n    return returnEle;\n  }\n\n  render() {\n    let actionEle; // contains either wrangling actions or unionable tables for the action panel\n    let wrapperEle; // wrapper element for actionEle. This is what we will render in the HTML.\n    let titleEle; // contains what we will display as the title for the action panel\n\n    // We first decide the content for the titleElement\n    if (\n      this.props.usecaseSelected === \"\"\n      // ||\n      // (this.props.usecaseSelected === \"startTable\" &&\n      //   this.props.selectedTableIndex === -1)\n    ) {\n      titleEle = (\n        <div className=\"row\">\n          <div className=\"col-md-8\">\n            <h4 className=\"logo-left-color\">\n              ACTIONS\n              <span> </span>\n              <span className=\"logo-right-color xsmall\">\n                Select your starting action\n              </span>\n            </h4>\n          </div>\n        </div>\n      );\n    } else {\n      titleEle = (\n        <div className=\"row action-header\">\n          <div className=\"col-md-8\">\n            <h4 className=\"logo-left-color\">\n              ACTIONS\n              <span> </span>\n              <span className=\"logo-right-color xsmall\">\n                Select your next action\n              </span>\n            </h4>\n          </div>\n        </div>\n      );\n    }\n\n    // We now decide the content for the actionElement\n    // Case 1: URL has been pasted, but task has not been selected. User needs to select task.\n    if (this.props.usecaseSelected === \"\") {\n      wrapperEle = (\n        <TaskMenu\n          handleStartSubject={this.props.handleStartSubject}\n          urlPasted={this.props.urlPasted}\n          showTableSelection={this.props.showTableSelection}\n          toggleTableSelection={this.props.toggleTableSelection}\n          originTableArray={this.props.originTableArray}\n          tableOpenList={this.props.tableOpenList}\n          toggleTable={this.props.toggleTable}\n          selectedTableIndex={this.props.selectedTableIndex}\n          handleStartTable={this.props.handleStartTable}\n        />\n      );\n    }\n    // Case 2: Task has been selected. curActionInfo is not null, meaning we have to display some task in ActionPanel\n    else if (this.props.curActionInfo !== null) {\n      const actionInfo = this.props.curActionInfo;\n      // Case 2.1: Users have selected \"Create Table from subject\".\n      // We ask users to select a column header for the first column.\n      if (actionInfo.task === \"afterStartSubject\") {\n        actionEle = (\n          <FirstColSelection\n            firstColSelection={this.props.firstColSelection}\n            firstColChecked={this.props.firstColChecked}\n            firstColFilled={this.props.firstColFilled}\n            toggleFirstNeighbour={this.props.toggleFirstNeighbour}\n            tableHeader={this.props.tableHeader}\n            keyCheckedIndex={this.props.keyCheckedIndex}\n            populateKeyColumn={this.props.populateKeyColumn}\n            confirmAddFirstCol={this.props.confirmAddFirstCol}\n          />\n        );\n      }\n      // Case 2.2: Users have clicked on the down arrow for non-first columns.\n      // We ask users to select a column header for this column.\n      else if (actionInfo.task === \"showOtherColSelection\") {\n        actionEle = (\n          <OtherColSelection\n            otherColSelection={this.props.otherColSelection}\n            otherColChecked={this.props.otherColChecked}\n            otherCheckedIndex={this.props.otherCheckedIndex}\n            toggleOtherNeighbour={this.props.toggleOtherNeighbour}\n            populateOtherColumn={this.props.populateOtherColumn}\n            colIndex={actionInfo.colIndex}\n          />\n        );\n      }\n      // Case 2.2: Users have click on the PLUS icon on first column's header.\n      // We ask users if they want to add more entities to the first column.\n      else if (actionInfo.task === \"plusClicked\") {\n        // We want to do an error check here: if the first column is not the current search column, we disable adding more entities to it.\n        if (this.props.keyColIndex !== 0) {\n          actionEle = (\n            <div>\n              <p>\n                <b>\n                  Please set the first column as the search column before adding\n                  more entities to it.\n                </b>\n              </p>\n            </div>\n          );\n        } else {\n          actionEle = (\n            <div>\n              <p>Add more entities to the first column?</p>\n              <Button onClick={() => this.props.addToFirstCol()}>OK</Button>\n            </div>\n          );\n        }\n      }\n      // In this case, we tell users they can keep wrangling by selecting column header for empty columns\n      else if (actionInfo.task === \"afterPopulateColumn\") {\n        actionEle = (\n          <div>\n            <p>\n              <b>Fill an empty column</b> by clicking on its <b>edit icon</b>\n            </p>\n            <p>OR</p>\n            <p>\n              <b>Add a new column</b> by clicking on a column's <b>plus icon</b>\n            </p>\n          </div>\n        );\n      }\n      // In this case we give user a button to allow the population of first column\n      else if (actionInfo.task === \"populateKeyColumn\") {\n        let neighbourArrayText = \"\";\n        for (let i = 0; i < actionInfo.neighbourArray.length; ++i) {\n          if (i > 0) {\n            neighbourArrayText += \" & \";\n          }\n          neighbourArrayText += actionInfo.neighbourArray[i].label;\n        }\n        if (neighbourArrayText !== \"\") {\n          actionEle = (\n            <div>\n              <p>Fill this column with:</p>\n              <p>\n                <b>{neighbourArrayText}</b> ?\n              </p>\n              <Button\n                onClick={(e) =>\n                  this.props.populateKeyColumn(\n                    e,\n                    actionInfo.colIndex,\n                    actionInfo.neighbourArray\n                  )\n                }\n              >\n                OK\n              </Button>\n            </div>\n          );\n        } else {\n          actionEle = (\n            <div>\n              <p className=\"suggestion-text\">\n                Fill the <b>first column header</b> by choosing from its{\" \"}\n                <b>down arrow</b>\n              </p>\n            </div>\n          );\n        }\n      }\n      // In this case we give user a button to allow the population of a new column\n      else if (actionInfo.task === \"populateOtherColumn\") {\n        let neighbourArrayText = createNeighbourText(actionInfo.neighbourArray);\n        actionEle = (\n          <div>\n            <p>Fill this column with:</p>\n            <p>\n              <b>{neighbourArrayText}</b> ?\n            </p>\n            <Button\n              onClick={(e) =>\n                this.props.populateOtherColumn(\n                  e,\n                  actionInfo.colIndex,\n                  actionInfo.neighbourArray\n                )\n              }\n            >\n              OK\n            </Button>\n          </div>\n        );\n      }\n      // In this case we give user a button to allow the population of same neighbour\n      else if (actionInfo.task === \"populateSameNeighbour\") {\n        actionEle = this.createSameNeighbour(actionInfo);\n      }\n      // In this case we give users an array of recommended neighbours to add to the table\n      else if (actionInfo.task === \"populateRecommendation\") {\n        let recommendArray = this.createRecommendArray(\n          actionInfo.colIndex,\n          actionInfo.recommendArray\n        );\n        actionEle = <div>{recommendArray}</div>;\n      }\n      // In this case we have to include both populateSameNeighbour and populateRecommendation\n      else if (actionInfo.task === \"sameNeighbourAndRecommendation\") {\n        let sameNeighbourEle = this.createSameNeighbour(actionInfo);\n        let recommendEle = this.createRecommendArray(\n          actionInfo.colIndex,\n          actionInfo.recommendArray\n        );\n        actionEle = (\n          <div>\n            <Card className=\"action-panel-card\">{recommendEle}</Card>\n            <br />\n            <Card className=\"action-panel-card\">{sameNeighbourEle}</Card>\n          </div>\n        );\n      }\n      // In this case we give user four column filter methods: sort asc, sort des, filter, and dedup\n      else if (actionInfo.task === \"showFilterMethods\") {\n        let textEle = null;\n        if (actionInfo.colIndex === 0) {\n          textEle = (\n            <p>\n              <b>How would you like to process the first column?</b>\n            </p>\n          );\n        } else {\n          textEle = (\n            <p>\n              <b>\n                How would you like to process column{\" \"}\n                {createNeighbourText(\n                  this.props.tableHeader[actionInfo.colIndex]\n                )}{\" \"}\n                ?\n              </b>\n            </p>\n          );\n        }\n        // console.log(textEle);\n        actionEle = (\n          <div>\n            <div>{textEle}</div>\n            <div>\n              <Button\n                onClick={(e) =>\n                  this.props.contextSortColumn(\n                    e,\n                    actionInfo.colIndex,\n                    \"ascending\"\n                  )\n                }\n              >\n                Sort ascending\n              </Button>\n            </div>\n            <br />\n            <div>\n              <Button\n                onClick={(e) =>\n                  this.props.contextSortColumn(\n                    e,\n                    actionInfo.colIndex,\n                    \"descending\"\n                  )\n                }\n              >\n                Sort descending\n              </Button>\n            </div>\n            <br />\n            <div>\n              <Button\n                onClick={(e) => this.props.openFilter(e, actionInfo.colIndex)}\n              >\n                Filter this column\n              </Button>\n            </div>\n            <br />\n            <div>\n              <Button\n                onClick={(e) =>\n                  this.props.contextDedupColumn(e, actionInfo.colIndex)\n                }\n              >\n                Dedup this column\n              </Button>\n            </div>\n          </div>\n        );\n      }\n      // In this case we display the origin of selected cell\n      else if (actionInfo.task === \"contextCellOrigin\") {\n        actionEle = (\n          <div>\n            <p>Origin of selected cell is:</p>\n            <div>{actionInfo.origin}</div>\n          </div>\n        );\n      }\n      // In this case we display the origin of selected cell\n      else if (actionInfo.task === \"originPreviewPage\") {\n        actionEle = (\n          // <div>\n          //   <div>\n          //     <p>Preview of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\n          //     <div>\n          //       {renderPreview(actionInfo.preview)}\n          //     </div>\n          //   </div>\n          //   <hr className=\"preview-origin-divider\"/>\n          //   <div>\n          //     <p>Origin of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\n          //     <div>{actionInfo.origin}</div>\n          //   </div>\n          // </div>\n          <PreviewOrigin\n            previewInfoArray={this.props.previewInfoArray}\n            previewInfoExpanded={this.props.previewInfoExpanded}\n            selectedCell={this.props.selectedCell}\n            togglePreviewElement={this.props.togglePreviewElement}\n          />\n        );\n      }\n      // In this case we display the starting recommendations\n      else if (actionInfo.task === \"showStartRecommend\") {\n        let recommendEle = this.createStartRecommend();\n        actionEle = <div>{recommendEle}</div>;\n      }\n      // In this case we have to include both populateSameNeighbour and populateStartRecommend\n      else if (actionInfo.task === \"sameNeighbourAndStartRecommend\") {\n        let sameNeighbourEle = this.createSameNeighbour(actionInfo);\n        let recommendEle = this.createStartRecommend();\n        actionEle = (\n          <div>\n            <Card className=\"action-panel-card\">{recommendEle}</Card>\n            <br />\n            <Card className=\"action-panel-card\">{sameNeighbourEle}</Card>\n          </div>\n        );\n      }\n    }\n    // This is an empty else clause\n    else {\n    }\n\n    // Now we have to determine whether we are rendering one tab or two tabs.\n    // One tab for startSubject. Two tabs for startTable.\n    // console.log(this.props.usecaseSelected);\n\n    // Modified after JOIN has been added in:\n    // In the startSubject case, we will have two tab: wrangling actions, and table actions.\n    // Wrangling Actions: same as before.\n    // Table Actions: Union will be empty, JOIN will use the pasted URL from the beginning.\n\n    if (this.props.usecaseSelected === \"startSubject\") {\n      let curIndex = this.props.tabIndex;\n      wrapperEle = (\n        <div className=\"height-inherit\">\n          <Tabs\n            selectedIndex={curIndex}\n            onSelect={(index) => this.props.handleTabSwitch(index)}\n          >\n            <TabList>\n              <Tab>Wrangling Actions</Tab>\n              <Tab>Table Actions</Tab>\n            </TabList>\n            <div className=\"action-scrollable\">\n              <TabPanel>{actionEle}</TabPanel>\n              <TabPanel>\n                <div>\n                  <ul class=\"list-group list-css list-group-flush\">\n                    <hr className=\"m-0\"></hr>\n                    <li className=\"list-group-item\">\n                      <span\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"union\")}\n                      >\n                        Union Tables from Wikipedia\n                      </span>\n\n                      <Collapse isOpen={this.props.showUnionTables}>\n                        <CardBody>\n                          <Card>\n                            Currently, finding unionable tables for customized\n                            table is not supported.\n                          </Card>\n                        </CardBody>\n                      </Collapse>\n                    </li>\n                    <li className=\"list-group-item\">\n                      <span\n                        onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\n                      >\n                        Join Tables from Wikipedia\n                      </span>\n\n                      <Collapse isOpen={this.props.showJoinTables}>\n                        <CardBody>\n                          <Card>\n                            <p>\n                              The following tables are from page:{\" \"}\n                              <b>\n                                {decodeURIComponent(\n                                  this.props.urlPasted.slice(30)\n                                )}\n                              </b>\n                            </p>\n                            <TableSelection\n                              originTableArray={this.props.originTableArray}\n                              tableOpenList={this.props.tableOpenList}\n                              toggleTable={this.props.toggleTable}\n                              buttonFunction={this.props.handleJoinTable}\n                              listType={\"join\"}\n                            />\n                          </Card>\n                        </CardBody>\n                      </Collapse>\n                    </li>\n                    <hr className=\"m-0\"></hr>\n                  </ul>\n                </div>\n              </TabPanel>\n            </div>\n          </Tabs>\n        </div>\n      );\n    } else if (this.props.usecaseSelected === \"startTable\") {\n      // If we have not selected a table, we show both tabs, as we are fully ready.\n      if (this.props.selectedTableIndex !== -1) {\n        let curIndex = this.props.tabIndex;\n        wrapperEle = (\n          <div className=\"height-inherit\">\n            <Tabs\n              selectedIndex={curIndex}\n              onSelect={(index) => this.props.handleTabSwitch(index)}\n              className=\"height-inherit\"\n            >\n              <TabList>\n                <Tab>Wrangling Actions</Tab>\n                <Tab>Table Actions</Tab>\n              </TabList>\n              <div className=\"action-scrollable\">\n                <TabPanel>{actionEle}</TabPanel>\n                <TabPanel>\n                  <div>\n                    <ul class=\"list-group list-css list-group-flush\">\n                      <hr className=\"m-0\"></hr>\n                      <li className=\"list-group-item\">\n                        <span\n                          onClick={(e) =>\n                            this.props.toggleUnionJoin(e, \"union\")\n                          }\n                        >\n                          Union Tables from Wikipedia\n                        </span>\n\n                        <Collapse isOpen={this.props.showUnionTables}>\n                          <CardBody>\n                            <Card>\n                              Expand relations below to look at other pages with\n                              similar tables:\n                              <br />\n                              {this.createPropertyArray()}\n                            </Card>\n                          </CardBody>\n                        </Collapse>\n                      </li>\n                      <li className=\"list-group-item\">\n                        <span\n                          onClick={(e) => this.props.toggleUnionJoin(e, \"join\")}\n                        >\n                          Join Tables from Wikipedia\n                        </span>\n\n                        <Collapse isOpen={this.props.showJoinTables}>\n                          <CardBody>\n                            <Card>\n                              <p>\n                                The following tables are from page:{\" \"}\n                                <b>\n                                  {decodeURIComponent(\n                                    this.props.urlPasted.slice(30)\n                                  )}\n                                </b>\n                              </p>\n                              <TableSelection\n                                originTableArray={this.props.originTableArray}\n                                tableOpenList={this.props.tableOpenList}\n                                toggleTable={this.props.toggleTable}\n                                buttonFunction={this.props.handleJoinTable}\n                                listType={\"join\"}\n                              />\n                            </Card>\n                          </CardBody>\n                        </Collapse>\n                      </li>\n                      <hr className=\"m-0\"></hr>\n                    </ul>\n                  </div>\n                </TabPanel>\n              </div>\n            </Tabs>\n          </div>\n        );\n      }\n      // Else, we have not selected a table yet. In this case, wrapperEle should be equal to actionEle\n      else {\n        wrapperEle = actionEle;\n      }\n    }\n    return (\n      <div className=\"height-inherit\">\n        <div>{titleEle}</div>\n        <div className=\"height-inherit\">{wrapperEle}</div>\n      </div>\n    );\n  }\n}\n\nexport default ActionPanel;\n\n// // The following helper function creates HTML elements from previewInfoArray,\n// // an array of key-val pairs containing the info for a cell's preview.\n\n// // It also makes use of niceRender, so that preview looks clean.\n\n// function renderPreview(previewInfoArray) {\n//   // console.log(previewInfoArray);\n//   let infoEle = [];\n//   for (let i = 0; i < previewInfoArray.length; ++i) {\n//     let keyLiteral = previewInfoArray[i].key;\n//     // We get the first element from value Array\n//     let valLiteral = niceRender(previewInfoArray[i].value[0]);\n//     // Since we have already included thte first element, we start the index from 1\n//     for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\n//       valLiteral = valLiteral + \"; \"+niceRender(previewInfoArray[i].value[j]);\n//     }\n//     infoEle.push(\n//       <p><b>{keyLiteral}</b>{\":\"}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{valLiteral}</p>\n//     )\n//   }\n//   return infoEle;\n// }\n\n// // This function renders this.props.tableData[i][j].data in a nicer way.\n// // It removes all occurence of (...), and changes all \"_\" to \" \".\n\n// function niceRender(str) {\n//   return str.replace(/_\\(.*?\\)/g, \"\")\n//             .replace(/_/g, \" \");\n// }\n\n// This function creates neighbourArrayText from neighbourArray\n\nfunction createNeighbourText(neighbourArray) {\n  let neighbourArrayText = \"\";\n  for (let i = 0; i < neighbourArray.length; ++i) {\n    if (i > 0) {\n      neighbourArrayText += \" OR \";\n    }\n    let curNeighbourText =\n      neighbourArray[i].type === \"object\"\n        ? \"is \" + neighbourArray[i].value + \" of\"\n        : neighbourArray[i].value;\n    neighbourArrayText += curNeighbourText;\n  }\n  return neighbourArrayText;\n}\n\n// This function renders this.props.tableData[i][j].data in a nicer way.\n// It removes all occurence of (...), and changes all \"_\" to \" \".\n\nfunction niceRender(str) {\n  return str.replace(/_\\(.*?\\)/g, \"\").replace(/_/g, \" \");\n}\n","import React, { Component } from \"react\";\n\nclass PagePanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    let pageEle = null;\n    let wikiPageClass = \"small-padding wiki-page-hidden\";\n    let buttonClass = \"btn btn-sm btn-info toggle-button\";\n    if (this.props.iframeURL !== \"\") {\n      let buttonhideShow = (\n        <button\n          className={buttonClass}\n          onClick={() => this.props.toggleWikiPage()}\n        >\n          <i class=\"fa fa-chevron-up\" aria-hidden=\"true\"></i>\n          Show\n        </button>\n      );\n      if (!this.props.pageHidden) {\n        wikiPageClass = \"small-padding wiki-page\";\n        buttonhideShow = (\n          <div>\n            <hr className=\"m-1\"></hr>\n            <button\n              className={buttonClass}\n              onClick={() => this.props.toggleWikiPage()}\n            >\n              <i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i>\n              Hide\n            </button>\n          </div>\n        );\n      }\n      pageEle = (\n        <div className=\"page-panel text-right\">\n          {buttonhideShow}\n          <div className={wikiPageClass}>\n            <iframe\n              id=\"iframe\"\n              title=\"URLPage\"\n              src={this.props.iframeURL}\n              className=\"iframe-cls\"\n            ></iframe>\n          </div>\n        </div>\n      );\n    }\n    return <div>{pageEle}</div>;\n  }\n}\n\nexport default PagePanel;\n","// import { Route, Switch, Link } from \"react-router-dom\";\nimport React, { Component } from \"react\";\nimport { combinations } from \"mathjs\";\nimport Header from \"../components/Header\";\nimport Footer from \"../components/Footer\";\nimport SettingModal from \"../components/SettingModal\";\nimport FilterModal from \"../components/FilterModal\";\nimport JoinModal from \"../components/JoinModal\";\nimport LandingPage from \"../components/LandingPage\";\nimport TablePanel from \"../components/TablePanel\";\nimport ActionPanel from \"../components/ActionPanel\";\nimport PagePanel from \"../components/PagePanel\";\nimport _ from \"lodash\";\n\nconst maxNeighbourCount = 10;\nconst maxFetchCount = 30;\nconst initialColNum = 4;\nconst initialRowNum = 45;\n\nclass MainBody extends Component {\n  constructor(props) {\n    super(props);\n    let tableData = [];\n    let tableHeader = [];\n    let optionsMap = [];\n    for (let i = 0; i < initialRowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < initialColNum; ++j) {\n        // Initially, cell has no data or origin\n        // data field is a string\n        // origin field is an array of strings\n        tempRow.push({ data: \"\", origin: [] });\n      }\n      tableData.push(tempRow);\n    }\n    for (let j = 0; j < initialColNum; ++j) {\n      let emptyOptions = [];\n      optionsMap.push(emptyOptions);\n      tableHeader.push([]);\n    }\n    this.state = {\n      // states below are general states used throughout the app\n      urlPasted: \"\",  \n      tablePasted: \"\",\n      usecaseSelected: \"\",\n      pageHidden: false,\n      iframeURL: \"\",\n      curActionInfo: null, // object storing the current action that should be displayed in ActionPanel. Initially null.\n      lastAction: \"\",      // string storing the last action that has modified the result table in the table panel\n      prevState: \"\",       // objects storing the information needed to undo the last step. Information stored depends on lastAction\n      showSetting: false,    // boolean storing whether setting modal is shown or not. Default to false.\n      showTableSelection: false,    // boolean storing whether the list of tables from page is shown. Default to false.\n      tabIndex: 1,         // integer storing the index of the tab currently displaying. Default to 1.\n      showUnionTables: false,  // boolean storing whether all the unionable pages and tables is shown. Default to false.\n      showJoinTables: false,   // boolean storing whether the page storing joinable tables is shown. Default to false.\n\n      // states below are useful for startSubject\n      keyColIndex: 0,   // number storing the index of the search column. initially the key column is the first column\n      // 1D array of objects with four properties storing the table headers. This array is used to create the column headers in table panel\n      // 1) label:  string storing the label of an option (ex: spouse)\n      // 2) value:  string storing the value of an option (ex: spouse)\n      // 3) type:   string that's either \"subject\" or \"object\". Storing whether the current option is ?s or ?o with respect to key column. Can be empty.\n      // 4) range:  string storing the rdfs:range of the current option.\n      tableHeader: tableHeader,\n      tableData: tableData, // 2D array of objects storing the table data (not including the table headers).\n      optionsMap: optionsMap, // 2D array storing the options map\n      keyColNeighbours: [], // 1D array storing the neighbours of the key column\n      // An object with two attributes: subject and object\n      // Subject and Object are both 1D arrays \n      // - Length tableData.length\n      // - Each element is an object with multiple attributes. Ex: {birthdate:[1998-01-01], almaMater:[a, b, c]}\n      firstDegNeighbours: [],\n\n      // states below are useful for first column header selection\n      firstColSelection: [],   // 1D array of objects storing information about the starting subject's neighbours\n      firstColChecked: [],     // 1D array of booleans storing whether a neighbour of the starting subject is selected or not\n      firstColFilled: false,   // boolean indicating whether the first column has been filled. \n                               // Will be set to true and remain that way after calling populateKeyColumn, or handleStartTable\n      keyCheckedIndex: -1,     // index storing the most recent index that has just been toggled for the first column. Initially -1.\n      firstColHeaderInfo: [],  // 2D array of objects storing information needed to create the first column's header. (since both AND and OR need to be considered)\n\n      // states below are useful for other column header selection\n      otherColSelection: [],    // 1D array of objects storing information about the search column's neighbours\n      otherColChecked: [],      // 1D array of booleans storing whether a neighbour of the search column is selected or not\n      otherCheckedIndex: -1,    // index storing the most recent index that has just been toggled for a non-first column. Initially -1.\n\n      // states below are useful for startTable\n      originTableArray: [], // 1D array storing all tables found on pasted URL\n      tableOpenList: [], // 1D array storing whether each table in originTableArray has been toggled open or not\n      selectedTableIndex: -1, // index of table selected by user. If it's -1, take user to table selection. Else, show the table in Table Panel.\n      selectedClassAnnotation: [], // semantic class annotation for each column of selected table\n      // 2D arary of objects with three properties, which store the table data from explore table task. Similar to tableData above. \n      // Three properties: data, origin, rowSpan, colSpan.\n      tableDataExplore: [], \n      // array of objects with four properties storing the status/content for each property neighbour\n      // 1) predicate: string storing the predicate (ex. dbp:league)\n      // 2) object: string storing the object (ex. dbo:NBA)\n      // 3) isOpen: boolean storing whether the current property neighbour is toggled on or not\n      // 4) siblingArary: array of objects with two properties storing the staus/content for each sibling URL\n      //    4.1) isOpen:      boolean storing whether the current sibling is toggled on or not\n      //    4.2) tableArray:  array of objects storing the status/content for each \"same\" table on the sibling URL\n      //         4.2.1) isOepn:        boolean storing whether the current table is toggled on or not\n      //         4.2.2) unionScore:    number storing teh union score of the current table (how \"similar\" it is to the original table)\n      //         4.2.3) colMapping:    array of numbers storing the column mapping between the current table and the selected table\n      //         4.2.4) data:          HTML of a table\n      //         4.2.5) title:         array of strings storing the column headers of the current table\n      propertyNeighbours: [],\n      semanticEnabled: \"disabled\", // boolean value indicating whether semantic mapping is enabled or not. Default to true\n      unionCutOff: 0.75, // number representing the union percentage a table must have to be considered unionable (>=)\n\n      // states below are for column filter\n      showFilter: false,        // boolean storing whether we want to show column filter or not. Initially false.\n      checkAll: true,           // boolean that when toggled to true, all dataAndChecked will be set to true, \n                                // and when false, all dataAndChecked will be set to false.\n      curFilterIndex: -1,       // number storing the index of the column on which we apply the filter. Initially -1 (no filter.)\n      dataAndChecked: [],       // array of [data, checked] pairs storing which data are in the filter column, and whether we should keep them.\n    \n      // states below are for table join\n      showJoinModal: false,    // boolean storing whether the join option modal is show or not. Default to false.\n      joinTableIndex: -1,      // number storing the index of the table we want to join from originTableArray.\n      joinTableData: [],       // 2D array storing the data of the table we want to join from originTableArray. Initially empty.\n      originColOptions: [],    // 1D array storing the selection options for the original table.\n      joinColOptions: [],      // 1D array storing the selection options for the newly selected table.\n      originJoinIndex: -1,     // number storing the index of the column of the original table that we are joining.\n      joinJoinIndex: -1,       // number storing the index of the column of the newly selected table that we are joining.\n\n      // states below are for column preview\n      previewColIndex: -1,     // number storing the index of the column that we want to show preview for. \n                               // When -1, we do not want to show any preview. This state needs to be passed to TablePanel\n                               // It should only be set to non -1 when we have toggled some selections on, but haven't confirmed on selections yet. \n      // states below are useful for cell preview and origin\n      selectedCell: null,      // data in the format of tableData[i][j] (has both data and origin attribute). \n                               // (origin element can be determined from this)\n      previewInfoArray: [],    // array storing the information used to create the preview element. \n                               // It contains categories, subject, object first degree neighbours.\n      previewInfoExpanded: [], // array of booleans storing whether each element from previewInfoArray is expanded or not.\n                               // This can only be set to true for previewInfoArray elements that have value length longer than 1.\n    };\n\n    // functions below are useful during start up\n    this.handleURLPaste = this.handleURLPaste.bind(this);\n    this.handleStartSubject = this.handleStartSubject.bind(this);\n    this.handleStartTable = this.handleStartTable.bind(this);\n\n    // functions below are useful for startSubject\n    this.cellChange = this.cellChange.bind(this);\n    this.selectColHeader = this.selectColHeader.bind(this);\n    this.getKeyOptions = this.getKeyOptions.bind(this);\n    this.getOtherOptions = this.getOtherOptions.bind(this);\n    this.getNeighbourPromise = this.getNeighbourPromise.bind(this);\n    this.populateKeyColumn = this.populateKeyColumn.bind(this);\n    this.getOtherColPromise = this.getOtherColPromise.bind(this);\n    // this.getOtherColPromiseTwo = this.getOtherColPromiseTwo.bind(this);\n    this.populateOtherColumn = this.populateOtherColumn.bind(this);\n    this.addAllNeighbour = this.addAllNeighbour.bind(this);\n    this.getTableStates = this.getTableStates.bind(this);\n    this.sameNeighbourDiffRow = this.sameNeighbourDiffRow.bind(this);\n    this.sameNeighbourOneRow = this.sameNeighbourOneRow.bind(this);\n\n    // functions below are for column processing\n    this.contextAddColumn = this.contextAddColumn.bind(this);\n    this.contextDeleteColumn = this.contextDeleteColumn.bind(this);\n    this.contextSetColumn = this.contextSetColumn.bind(this);\n    this.originPreviewPage = this.originPreviewPage.bind(this);\n    this.contextSortColumn = this.contextSortColumn.bind(this);\n    this.contextDedupColumn = this.contextDedupColumn.bind(this);\n    this.showFilterMethods = this.showFilterMethods.bind(this);\n\n    // functions below are useful for startTable\n    this.toggleTable = this.toggleTable.bind(this);\n    this.togglePropertyNeighbours = this.togglePropertyNeighbours.bind(this);\n    this.toggleSibling = this.toggleSibling.bind(this);\n    this.toggleOtherTable = this.toggleOtherTable.bind(this);\n    this.unionTable = this.unionTable.bind(this);\n    this.unionPage = this.unionPage.bind(this);\n    this.unionProperty = this.unionProperty.bind(this);\n    this.toggleSemantic = this.toggleSemantic.bind(this);\n    this.unionCutOffChange = this.unionCutOffChange.bind(this);\n\n    // functions below are generally usefull\n    this.copyTable = this.copyTable.bind(this);\n    this.toggleWikiPage = this.toggleWikiPage.bind(this);\n    this.undoPreviousStep = this.undoPreviousStep.bind(this);\n    this.handleTabSwitch = this.handleTabSwitch.bind(this);\n    this.openModal = this.openModal.bind(this);\n    this.closeModal = this.closeModal.bind(this);\n    this.toggleTableSelection = this.toggleTableSelection.bind(this);\n    this.toggleUnionJoin = this.toggleUnionJoin.bind(this);\n\n    // functions below are for column filter\n    this.openFilter = this.openFilter.bind(this);\n    this.cancelFilter = this.cancelFilter.bind(this);\n    this.toggleChecked = this.toggleChecked.bind(this);\n    this.toggleAll = this.toggleAll.bind(this);\n    this.applyFilter = this.applyFilter.bind(this);\n\n    // functions below are for join feature\n    this.handleJoinTable = this.handleJoinTable.bind(this);\n    this.cancelJoin = this.cancelJoin.bind(this);\n    this.selectJoinColumn = this.selectJoinColumn.bind(this);\n    this.runJoin = this.runJoin.bind(this);\n\n    // functions below are for first column selection\n    this.toggleFirstNeighbour = this.toggleFirstNeighbour.bind(this);\n    this.handlePlusClick = this.handlePlusClick.bind(this);\n    this.addToFirstCol = this.addToFirstCol.bind(this);\n    this.confirmAddFirstCol = this.confirmAddFirstCol.bind(this);\n\n    // functions below are for other column selection\n    this.toggleOtherNeighbour = this.toggleOtherNeighbour.bind(this);\n\n    // functions below are for cell preview and origin\n    this.togglePreviewElement = this.togglePreviewElement.bind(this);\n\n    // functions below are for recommendations\n    this.populateRecommendation = this.populateRecommendation.bind(this);\n    this.createStartRecommend = this.createStartRecommend.bind(this);\n    this.populateStartRecommend = this.populateStartRecommend.bind(this);\n  }\n\n  // As soon as the URL has been pasted, we want to fetch all tables from the pasted URL.\n  // We then update the originTableArray, which stores all the tables found on the pasted URL\n  // We also initialize tableOpenList to all false\n  handleURLPaste(urlPasted) {\n    document.body.classList.add('waiting');\n\n    // We first check if user has pasted a valid wikipedia page.\n\n    if (!urlPasted.includes(\"https://en.wikipedia.org/wiki/\")) {\n      document.body.classList.remove('waiting');\n      alert(\"Please paste a valid Wikipedia link.\");\n    }\n\n    // If yes, we fetch the tables from the pasted Wikipedia page\n    else {\n      let promiseArray = [];\n      promiseArray.push(fetchText(urlPasted));\n      allPromiseReady(promiseArray).then((values) => {\n        // We first parse the pasted URL and store the list of tables from the pasted URL\n        let htmlText = values[0];\n        let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\n        let originTableArray = doc.getElementsByClassName(\"wikitable\");\n        let tableOpenList = [];\n        for (let i = 0; i < originTableArray.length; ++i) {\n          tableOpenList.push(false);\n        }\n\n        // Adding support for undo:\n        document.body.classList.remove('waiting');\n\n        let lastAction = \"handleURLPaste\";\n        let prevState = \n          {\n            \"urlPasted\":\"\",\n            \"iframeURL\":\"\",\n            \"originTableArray\":[],\n            \"tableOpenList\":[],\n          };\n\n        this.setState({\n          originTableArray: originTableArray,\n          tableOpenList: tableOpenList,\n          urlPasted: urlPasted,\n          iframeURL: urlPasted,\n          lastAction: lastAction,\n          prevState: prevState,\n        });\n      });\n    }\n  }\n\n  // This function copies the table content to clipboard\n\n  copyTable() {\n    const textArea = document.createElement(\"textarea\"); // this line allows the use of select() function\n    let copiedText = \"\";\n    // // We handle the case for startTable and startSubject differently\n\n    // // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\n    // if (this.state.usecaseSelected === \"startTable\") {\n    //   // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\n    //   const rowNum = this.state.tableDataExplore.length;\n    //   const colNum = this.state.tableDataExplore[0].length;\n    //   for (let i = 0; i < rowNum; ++i) {\n    //     for (let j = 0; j < colNum - 1; ++j) {\n    //       copiedText =\n    //         copiedText + this.state.tableDataExplore[i][j].data + \"\\t\";\n    //     }\n    //     copiedText =\n    //       copiedText + this.state.tableDataExplore[i][colNum - 1].data + \"\\n\";\n    //   }\n    // }\n\n    // This case handles the copy table for start subject\n    if (this.state.usecaseSelected === \"startSubject\" || this.state.usecaseSelected === \"startTable\") {\n      // We first push on the text for column headers (using the labels)\n      let tableHeader = this.state.tableHeader;\n      for (let i = 0; i < tableHeader.length; ++i) {\n        let curText = tableHeader[i].label;\n        // console.log(curText);\n        if (curText === undefined && tableHeader[i].length > 0) {\n          curText = \"\";\n          for (let j = 0; j < tableHeader[i].length; ++j) {\n            if (j > 0) {\n              if (i === 0) {\n                curText += \" AND \";\n              }\n              else {\n                curText += \" OR \";\n              }\n            }\n            curText += niceRender(tableHeader[i][j].label);\n          }\n        }\n        if (curText !== undefined && curText !== \"\") {\n          copiedText = copiedText + curText + \"\\t\";\n        }\n      }\n      copiedText += \"\\n\";\n      // Now we need to fetch the rows that are not column headers\n      let tableData = this.state.tableData;\n      const rowNum = tableData.length;\n      const colNum = tableData[0].length;\n      for (let i = 0; i < rowNum; ++i) {\n        for (let j = 0; j < colNum; ++j) {\n          let curText = niceRender(tableData[i][j].data);\n          if (curText !== undefined && curText !== \"\") {\n            copiedText = copiedText + curText + \"\\t\";\n          }\n        }\n        copiedText += \"\\n\";\n      }\n    }\n    textArea.value = copiedText;\n    document.body.appendChild(textArea);\n    textArea.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(textArea);\n    alert(\"Table content has been pasted!\");\n  }\n\n  // This function handles the toggling of the WikiPage at bottom\n\n  toggleWikiPage() {\n    let pageHidden = this.state.pageHidden;\n    this.setState({\n      pageHidden: !pageHidden,\n    });\n  }\n\n  // This function handles the selection of the starting task \"startSubject\"\n\n  handleStartSubject(e, taskSelected) {\n\n    if (taskSelected === \"startSubject\") {\n      \n      // Change the cursor since we are making a fetch request\n      document.body.classList.add('waiting');\n\n      // Since the starting task is \"startSubject\", we set the URL to be the first cell in the table\n      const subject = decodeURIComponent(this.state.urlPasted.slice(30)); \n      let tableData = _.cloneDeep(this.state.tableData);\n      tableData[0][0].data = subject;\n\n      // Let's run some queries here to fetch some first degree properties \n\n      // The query we will run is simply as follows\n      // select ?p ?o\n      // where {\n      // dbr:Barack_Obama ?p ?o.\n      // }\n\n      // Note: we are not taking account of the object neighbours. Subject neighbours only.\n\n      let prefixURL = \n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let suffixURL = \n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      let queryBody = \n        \"select+%3Fp+%3Fo%0D%0Awhere+%7B%0D%0Adbr%3A\" + \n        regexReplace(subject) +\n        \"+%3Fp+%3Fo.%0D%0A%7D&\";\n      let queryURL = prefixURL + queryBody + suffixURL;\n      \n      let promiseArray = [fetchJSON(queryURL)]\n      \n      allPromiseReady(promiseArray).then((values) => {\n\n        // We set up the firstColSelection and firstColChecked states here\n        let firstColSelection = updateFirstColSelection(values[0].results.bindings);\n        let firstColChecked = [];\n        // Initially, firstColChecked is all false\n        for (let i = 0; i < firstColSelection.length; ++i) {\n          firstColChecked.push(false);\n        }\n        // console.log(firstColSelection);\n        // console.log(firstColChecked);\n\n        // We create the InfoObject needed for Action Panel\n        let tempObj = {\n          \"task\":\"afterStartSubject\",\n        };\n\n        // Adding support for undo:\n        let lastAction = \"handleStartSubject\";\n        let prevState = \n          {\n            \"usecaseSelected\":this.state.usecaseSelected,\n            \"tableData\":this.state.tableData,\n            \"tabIndex\":this.state.tabIndex,\n            \"curActionInfo\":this.state.curActionInfo,\n            \"firstColSelection\":this.state.firstColSelection,\n            \"firstColChecked\":this.state.firstColChecked,\n          };\n        \n        // Check the cursor back because we are done with the function\n        document.body.classList.remove('waiting');\n\n        this.setState({\n          usecaseSelected: taskSelected,\n          tableData: tableData,\n          firstColSelection: firstColSelection,\n          firstColChecked: firstColChecked,\n          curActionInfo: tempObj,\n          tabIndex: 0,\n          lastAction: lastAction,\n          prevState: prevState,\n        });\n      })\n    } \n  }\n\n  // This function handles the toggling of the starting subject's neighbours\n  // Also, we store this toggledIndex, so that we can display the suggestion text at the right location.\n  // Obviously, we need to update this.state.firstColChecked array.\n\n  toggleFirstNeighbour(e, index) {\n    // console.log(\"Toggled index is \"+index);\n    \n    // We first create a copy of firstColChecked\n    let firstColChecked = this.state.firstColChecked.slice();\n\n    // Now we deal with keyCheckedIndex\n    let keyCheckedIndex = index;\n  \n    // We handle the toggling here\n    firstColChecked[index] = !firstColChecked[index];\n\n    // Lastly, we make the state changes\n    this.setState({\n      firstColChecked:firstColChecked,\n      keyCheckedIndex:keyCheckedIndex,\n    })\n  }\n\n  // This function handles the toggling of a non-first column's attribute selection\n  // Note: since the preview feature is being addded, this function needs to handle preview as well.\n  // It will handle the preview similarly to how it handles populateOtherColumn, \n  // Except it sets previewData attribute, instead of data attribute.\n  toggleOtherNeighbour(e, neighbourIndex, colIndex) {\n    // We first get all the variables we needed\n    let previewColIndex;\n    let tableData = _.cloneDeep(this.state.tableData); \n    let otherColChecked = _.cloneDeep(this.state.otherColChecked);\n\n    // We first deal with the toggling of otherCheckedIndex and otherColChecked\n    let otherCheckedIndex = neighbourIndex;\n    otherColChecked[neighbourIndex] = !otherColChecked[neighbourIndex];\n\n    // We then deal with column preview.\n\n    // First step is to create a selectedNeighbours array for preview, similar to OtherColSelection.\n    // We will create the selectedNeighbours array from otherColSelection and otherColChecked\n    let selectedNeighbours = [];\n    for (let i = 0; i < otherColChecked.length; ++i) {\n      if (otherColChecked[i] === true) {\n        selectedNeighbours.push(this.state.otherColSelection[i]);\n      }\n    }\n    // console.log(selectedNeighbours);\n    // console.log(colIndex);\n    \n    // If selectedNeighbours is non-empty, we need to set previewColIndex to colIndex, and set tableData's previewData attribute\n    if (selectedNeighbours.length > 0) {\n      // We first set tableData, based on selectedNeighbours and colIndex. The following part will be similar to populateOtherColumn.\n      for (let i = 0; i < tableData.length; ++i) {\n        // curColumnArray is the previewData array, for each entry in search column, for all neighbours in selectedNeighbours\n        let curColumnArray = [];\n        // We loop through selectedNeighbours\n        for (let j = 0; j < selectedNeighbours.length; ++j) {\n          let curNeighbour = selectedNeighbours[j];\n          let firstDegNeighbours = \n            curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n          let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n          if (curNeighbourData !== undefined) {\n            curColumnArray = curColumnArray.concat(curNeighbourData);\n          }\n        }\n        // If curColumnArray is empty, that means this entry in search column do not have any of the attributes from selectedNeighbours\n        // We want to set previewData to N/A\n        if (curColumnArray.length === 0) {\n          tableData[i][colIndex].previewData = \"N/A\";\n        }\n        // Else, we have found at least one value. We want to set previewData to curColumnArray[0]\n        else {\n          tableData[i][colIndex].previewData = curColumnArray[0];\n        }\n      }\n\n      // Now that we are done with setting tableData, we set previewColIndex.\n      previewColIndex = colIndex;\n    }\n    // In this case, selectedNeighbours is empty, we want to set previewColIndex back to -1.\n    else {\n      previewColIndex = -1;\n    }\n\n    // Support for undo:\n    let lastAction = \"toggleOtherNeighbour\";\n    let prevState = \n    {\n      otherColChecked: this.state.otherColChecked,\n      otherColCheckedIndex: this.state.otherCheckedIndex,\n      tableData: this.state.tableData,\n      previewColIndex: this.state.previewColIndex,\n    }\n\n    this.setState({\n      otherColChecked: otherColChecked,\n      otherCheckedIndex: otherCheckedIndex,\n      tableData: tableData,\n      previewColIndex: previewColIndex,\n      lastAction: lastAction,\n      prevState: prevState,\n    })\n  }\n\n  // This function is a simple function that creates an object and passes to Action Panel\n  handlePlusClick() {\n    this.setState({\n      curActionInfo:{\"task\":\"plusClicked\"},\n      previewColIndex: -1, // we also want to set preview column index to -1 (clear previews)\n      tabIndex: 0,\n    })\n  }\n\n  // This function handles when users want to add more entities to the first column\n  addToFirstCol() {\n    // We need to make the Action Panel display FirstColSelection component again.\n    // Before doing so, we need to first clear out this.state.firstColChecked, and this.state.keyCheckedIndex\n    // So that we do not have information carried over from the previous first column selection.\n\n    // First we update firstColChecked\n    let firstColCheckedUpdated = [];\n    for (let i = 0; i < this.state.firstColChecked.length; ++i) {\n      firstColCheckedUpdated.push(false);\n    }\n\n    // Then we reset keyCheckedIndex\n    let keyCheckedIndexUpdated = -1;\n\n    // We now set up tempObj for Action Panel\n    let tempObj = {\n      \"task\":\"afterStartSubject\",\n    };\n\n    // Finallym we set the states.\n    this.setState({\n      firstColChecked:firstColCheckedUpdated,\n      keyCheckedIndex:keyCheckedIndexUpdated,\n      curActionInfo:tempObj,\n    })\n  }\n\n  // This function handles manually changing cell in a table\n\n  cellChange(e, i, j) {\n    e.preventDefault();\n    let tableData = this.state.tableData.slice();\n    tableData[i][j].data = e.target.value;\n    this.setState({\n      tableData: tableData,\n    });\n  }\n\n  // This function updates the options for selections when we click on selection for a key column\n  // based on cells already filled in this column\n\n  getKeyOptions(e, colIndex) {\n    if (colIndex === this.state.keyColIndex) {\n      \n      // We first get all the non-empty values from the key column\n      let allSubject = [];\n      for (let i = 0; i < this.state.tableData.length; ++i) {\n        if (this.state.tableData[i][colIndex].data === \"\") {\n          break;\n        } else {\n          allSubject.push(regexReplace(this.state.tableData[i][colIndex].data));\n        }\n      }\n\n      // In here we fetch the options for first column's selection\n      // It uses the common dct:subject of all cells entered in the key column\n\n      // Modification: let's also find the common rdf:type dbo:xxx of cells filled.\n\n      let prefixURL =\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\n      for (let i = 0; i < allSubject.length; ++i) {\n        queryBody +=\n          \"%0D%0A++++++++dbr%3A\" + allSubject[i] + \"+%28dct%3Asubject%7Crdf%3Atype%29+%3Fsomevar.\";\n      }\n      let suffixURL =\n        \"%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let promiseArray = [];\n      promiseArray.push(fetchJSON(queryURL));\n      allPromiseReady(promiseArray).then((values) => {\n        let myJson = values[0];\n        let keyColOptions = [];\n        // We loop through the result bindings. \n        // If it's from dct:subject, or rdf:type dbo:xxxx, we push it onto keyColOptions\n        for (let i = 0; i < myJson.results.bindings.length; ++i) {\n          let curValue = myJson.results.bindings[i].somevar.value;\n          // This clause deals with dct:subject\n          if (curValue.includes(\"dbpedia.org/resource/Category:\")) {\n            let tempObj = {};\n            let neighbour = curValue.slice(37);\n            tempObj[\"label\"] = neighbour;\n            tempObj[\"value\"] = neighbour;\n            tempObj[\"dataset\"] = \"dct\";\n            keyColOptions.push(tempObj);\n          }\n          // This clause deals with rdf:type dbo:xxxx\n          else if (curValue.includes(\"dbpedia.org/ontology/\") && !curValue.includes(\"Wikidata\")) {\n            let tempObj = {};\n            let neighbour = curValue.slice(28);\n            tempObj[\"label\"] = neighbour;\n            tempObj[\"value\"] = neighbour;\n            tempObj[\"dataset\"] = \"rdf\";\n            keyColOptions.push(tempObj);\n          }\n        }\n        // Take a look at keyColOptions\n        // console.log(keyColOptions);\n        // We create a copy of the optionsMap.\n        // Then change the entry in the optionsMap corresponding to the key column to what we have just fetched: keyColOptions.\n        let optionsMap = this.state.optionsMap.slice();\n        optionsMap[this.state.keyColIndex] = keyColOptions;\n        this.setState({\n          optionsMap: optionsMap,\n        });\n      });\n    }\n  }\n\n  // This function updates the options for selections when we want to open selection for non-key column\n  // based on cells already filled in this column, and the cells in the key column\n  // aka: Michelle Obama is Barack Obama' wife\n\n  // It needs to update Action Panel to display the correct content.\n\n  // If this column is empty or completely filled, it will just pass keyColNeighbours to Action Panel.\n\n  getOtherOptions(e, colIndex) {\n\n    // console.log(\"Column index clicked is \"+colIndex);\n\n    // The first thing we need to do is to determine the content for otherColSelection\n    let otherColSelection = [];\n\n    // We check if this column is all-empty, or all filled\n    let colEmpty = true;\n    let colFilled = true;\n    let nonEmptyInfo = [];\n    for (let i = 0; i < this.state.tableData.length; ++i) {\n      // If some data is not \"\", that means this column is not empty\n      if (this.state.tableData[i][colIndex].data !== \"\") {\n        colEmpty = false;\n        nonEmptyInfo.push([i, this.state.tableData[i][colIndex].data]);\n      }\n      // If some data is \"\", that means this column is not filled\n      else {\n        colFilled = false;\n      }\n    }\n\n    // Case 1:\n    // If this column is non-empty, and not completely filled, we want to deal with special otherColSelection\n    if (colEmpty === false && colFilled === false) {\n      document.body.classList.add('waiting');\n      let prefixURL =\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let suffixURL =\n        \"%0D%0A%7D%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\n      // Bugfix added on August 17th: instead of using every entry from nonEmptyInfo to determine the relation, we will use the first one\n      // for (let i = 0; i < nonEmptyInfo.length; ++i) {\n      for (let i = 0; i < 1; ++i) {\n        let curKeySubject = regexReplace(\n          this.state.tableData[nonEmptyInfo[i][0]][this.state.keyColIndex].data\n        );\n        let curEnteredSubject = regexReplace(nonEmptyInfo[i][1]);\n        queryBody +=\n          \"%0D%0A++++++++dbr%3A\" +\n          curKeySubject +\n          \"+%3Fsomevar+dbr%3A\" +\n          curEnteredSubject +\n          \".\";\n      }\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let promiseArray = [];\n      promiseArray.push(fetchJSON(queryURL));\n      allPromiseReady(promiseArray).then((values) => {\n      let myJson = values[0];\n      // we create a temporary variable to hold results from myJson.results.bindings\n      let tempSelection = [];\n      for (let i = 0; i < myJson.results.bindings.length; ++i) {\n        let tempObj = {};\n        let neighbour = myJson.results.bindings[i].somevar.value.slice(28);\n        tempObj[\"label\"] = neighbour;\n        tempObj[\"value\"] = neighbour;\n        tempObj[\"type\"] = \"subject\"; // for now we only allow the subject search\n        tempSelection.push(tempObj);\n      }\n      // We push onto otherColSelection the right elements from keyColNeighbours, based on tempSelection\n      // console.log(this.state.keyColNeighbours);\n      // console.log(tempSelection);\n      for (let i = 0; i < tempSelection.length; ++i) {\n        for (let j = 0; j < this.state.keyColNeighbours.length; ++j) {\n          if (tempSelection[i].value === this.state.keyColNeighbours[j].value \n              && tempSelection[i].type === this.state.keyColNeighbours[j].type) {\n            otherColSelection.push(this.state.keyColNeighbours[j]);\n            break; \n          }\n        }\n      }\n      // Now, we do not want to have an empty otherColSelection.\n      // Thus, if it is, we just want to set it as this.state.keyColNeighbours\n      if (otherColSelection.length === 0) {\n        otherColSelection = this.state.keyColNeighbours;\n      }\n      // Take a look at otherColSelection\n      // console.log(otherColSelection);\n\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\n\n      let otherColChecked = [];\n      for (let i = 0; i < otherColSelection.length; ++i) {\n        otherColChecked.push(false);\n      }\n      let otherCheckedIndex = -1;\n\n      let tempObj = \n        {\n          \"task\":\"showOtherColSelection\",\n          \"colIndex\":colIndex,\n        }\n\n      document.body.classList.remove('waiting');\n      this.setState({\n        otherColSelection:otherColSelection,\n        otherColChecked:otherColChecked,\n        otherCheckedIndex:otherCheckedIndex,\n        curActionInfo:tempObj,\n      })\n      })\n    }\n\n    // Case 2:\n    // If this column is empty or completely filled, we just set otherColSelection to be keyColNeighbours\n    else {\n      otherColSelection = this.state.keyColNeighbours;\n      // Take a look at otherColSelection\n      // console.log(otherColSelection);\n\n      // Now we have figured out the content for otherColSelection, we move on otherColChecked and otherCheckedIndex.\n      // Every time we are running this function, we need to reset otherColChecked and otherCheckedIndex\n\n      // Maybe some modifications need to be done here when colFilled === true\n      let otherColChecked = [];\n      for (let i = 0; i < otherColSelection.length; ++i) {\n        otherColChecked.push(false);\n      }\n      let otherCheckedIndex = -1;\n\n      let tempObj = \n        {\n          \"task\":\"showOtherColSelection\",\n          \"colIndex\":colIndex,\n        }\n\n      window.scrollTo(0, 0);\n      this.setState({\n        otherColSelection:otherColSelection,\n        otherColChecked:otherColChecked,\n        otherCheckedIndex:otherCheckedIndex,\n        curActionInfo:tempObj,\n      })\n    }\n  }\n\n  // This function handles the the selection of a column header.\n  // Note: we want to deal with the selection of key column header vs non key column header differently\n\n  selectColHeader(e, colIndex) {\n\n    let tableHeader = this.state.tableHeader.slice();\n\n    if (e !== null) {\n\n      // We first get the selectedOptions\n      let selectedOptions = _.cloneDeep(e);\n      // console.log(selectedOptions);\n      tableHeader[colIndex] = selectedOptions;\n\n      // This part deals with the selection of a key column header\n      if (colIndex === this.state.keyColIndex) {\n        let tempObj = {};\n        tempObj[\"task\"] = \"populateKeyColumn\";\n        tempObj[\"colIndex\"] = colIndex;\n        tempObj[\"neighbourArray\"] = [];\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\n        for (let i = 0; i < selectedOptions.length; ++i) {\n          tempObj.neighbourArray.push(selectedOptions[i]);\n        }\n        // console.log(tempObj);\n        this.setState({\n          tableHeader: tableHeader,\n          curActionInfo: tempObj,\n        })\n      }\n\n      // This part deals with the selection of a non key column header\n      else {\n        // We want to change the label of non-key column headers with respect to the label of key column\n        // First step: set up the label text for the key column\n        let keyColLabel = \"\";\n        for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\n          let labelToAdd = i > 0 ? \"&\" + tableHeader[this.state.keyColIndex][i].label : tableHeader[this.state.keyColIndex][i].label;\n          keyColLabel+=labelToAdd;\n        }\n        // Then, since tableHeader[colIndex] is an array, we update all element's label from the array\n        for (let i = 0; i < selectedOptions.length; ++i) {\n          let ownLabel = tableHeader[colIndex][i].type === \"subject\" ? tableHeader[colIndex][i].value : \"is \" + tableHeader[colIndex][i].value + \" of\";\n          tableHeader[colIndex][i].label = ownLabel + \"--\" + keyColLabel;\n        }\n        // console.log(tableHeader);\n\n        // Now, we want to ask in ActionPanel whether user wants to populate the column based on the chosen column names\n        let tempObj = {};\n        tempObj[\"task\"] = \"populateOtherColumn\";\n        tempObj[\"colIndex\"] = colIndex;\n        tempObj[\"neighbourArray\"] = [];\n        // Since neighbourArray is an array, let's push on selectedOptions one by one\n        for (let i = 0; i < selectedOptions.length; ++i) {\n          tempObj.neighbourArray.push(selectedOptions[i]);\n        }\n        // Because we are allowing multi-selects now, type and range are no long two single strings.\n        // Rather, their values can be figured out from neighbourArray\n        // console.log(tempObj);\n        this.setState({\n          tableHeader: tableHeader,\n          curActionInfo: tempObj,\n        })\n      }\n    }\n\n\n\n    // // console.log(\"Check table header here\");\n    // // console.log(this.state.tableHeader);\n    // //  We first create a copy of the existing table headers\n    // let tableHeader = this.state.tableHeader.slice();\n\n    // // This part deals with the selection of key column header\n    // if (colIndex === this.state.keyColIndex) {\n    //   // We create a copy of the selected option\n    //   if (e !== null) {\n    //     let selectedOptions = e.slice();\n    //     // console.log(selectedOptions);\n    //     tableHeader[colIndex] = selectedOptions;\n    //     let tempObj = {};\n    //     tempObj[\"task\"] = \"populateKeyColumn\";\n    //     tempObj[\"colIndex\"] = colIndex;\n    //     tempObj[\"neighbourArray\"] = [];\n    //     // Modification here: instead of simplying passing the value, we want to pass the selectedOptions as a whole\n    //     // Because we need its \"dataset\" attribute\n    //     for (let i = 0; i < selectedOptions.length; ++i) {\n    //       tempObj.neighbourArray.push(selectedOptions[i]);\n    //     }\n    //     // console.log(tempObj);\n    //     this.setState({\n    //       tableHeader: tableHeader,\n    //       curActionInfo: tempObj,\n    //     });\n    //   }\n    // }\n    // // This part deals with the selection of non key column header\n    // else {\n    //   // The first few lines fix some pass by reference problems\n    //   let evalue = e.value;\n    //   let elabel = e.label;\n    //   // let ecount = e.count;\n    //   tableHeader[colIndex] = { value: evalue, label: elabel };\n    //   // We want to change the label of non-key column headers with respect to the label of key column\n    //   // We first create the label text for the key column\n    //   let keyColLabel = \"\";\n    //   if (this.state.keyColIndex === 0) {\n    //     for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\n    //       if (i > 0) {\n    //         keyColLabel += \"&\";\n    //       }\n    //       keyColLabel += tableHeader[this.state.keyColIndex][i].label;\n    //     }\n    //   } else {\n    //     keyColLabel = tableHeader[this.state.keyColIndex].label;\n    //   }\n    //   // Bugfix for Go Table Creation: if at this stage, keyColLable is still \"\", that means we came from the tabel union task first.\n    //   // In this case, tableHeader[keyColIndex] is an object, not an array. \n    //   // So we just set keyColLabel as tableHeader[this.state.keyColIndex].label\n    //   if (keyColLabel === \"\") {\n    //     keyColLabel = tableHeader[this.state.keyColIndex].label;\n    //   }\n    //   // We then append the current column's label to it\n    //   // console.log(keyColLabel);\n    //   tableHeader[colIndex].label =\n    //     tableHeader[colIndex].label + \"--\" + keyColLabel;\n    //   // After we have selected the column header, not only do we want to fill in the name of the column, we also want to\n    //   // ask in ActionPanel whether user wants to populate the column based on the chosen column name\n    //   let tempObj = {};\n    //   tempObj[\"task\"] = \"populateOtherColumn\";\n    //   tempObj[\"colIndex\"] = colIndex;\n    //   tempObj[\"neighbour\"] = e.value;\n    //   tempObj[\"type\"] = e.type;\n\n    //   // If type is subject, let's check if this neighbour also has a \"range\" (rdfs:range)\n    //   if (e.type === \"subject\" && e.range !== undefined) {\n    //     tempObj[\"range\"] = e.range;\n    //   }\n    //   // console.log(tempObj);\n\n    //   this.setState({\n    //     tableHeader: tableHeader,\n    //     curActionInfo: tempObj,\n    //   });\n    // }\n  }\n\n  // This function is a helper function for populateKeyColumn. It is similar to getOtherColPromise.\n  // It makes an array of queries to find the union of neighbours for the first column (key column).\n\n  // Some modification needs to be made to the queries\n  // So that ?o in the first query and ?s in the second query have to be included as well.\n\n  // It takes in three parameters\n  // 1) tableData: tableData (with updated values in the first column)\n  // 2) type: either \"subject\" or \"object\"\n  // 3) colIndex:  integer representing which column's neighbours we are fetching\n\n  getNeighbourPromise(tableData, type, colIndex) {\n    // console.log(tableData);\n    // console.log(type);\n\n    // Query we make if type is subject\n\n    // select ?p ?o ?range ?subPropertyOf\n    // where {\n    // dbr:Barack_Obama ?p ?o.\n    // OPTIONAL {?p rdfs:range ?range}.\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\n    // }\n\n    // Query we make if type is object\n\n    // select ?s ?p ?range ?subPropertyOf\n    // where {\n    // ?s ?p dbr:Barack_Obama.\n    // OPTIONAL {?p rdfs:range ?range}.\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\n    // }\n\n    // BUGFIX August 17th: The query below may need to be used for performance issues\n\n    // select ?s ?p ?range ?subPropertyOf\n    // where {\n    // ?s ?p dbr:Barack_Obama.\n    // OPTIONAL {?p rdfs:range ?range}.\n    // OPTIONAL {?p rdfs:subPropertyOf ?subPropertyOf}.\n    // {\n    // select ?p (count(?s) as ?count) \n    // where {\n    // ?s ?p dbr:Barack_Obama\n    // }\n    // group by ?p\n    // having (count(?s) <= maxFetchCount)\n    // }\n    // }\n\n    let promiseArray = [];\n    let prefixURL =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURL =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    for (let i = 0; i < tableData.length; ++i) {\n      let cellValue = tableData[i][colIndex].data === \"N/A\" ? \"NONEXISTINGSTRING\" : regexReplace(tableData[i][colIndex].data);\n      // console.log(cellValue);\n      let queryBody;\n      if (type === \"subject\") {\n        queryBody =\n          \"select+%3Fp+%3Fo+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0Adbr%3A\" +\n          cellValue +\n          \"+%3Fp+%3Fo.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\n      }\n      else {\n        // queryBody = \n        //   \"select+%3Fs+%3Fp+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" +\n        //   cellValue +\n        //   \".%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7D&\";\n\n        // Above code is the query before bugfix on August 17th. Below is the fixed version of the code\n        queryBody = \n          \"select+%3Fs+%3Fp+%3Frange+%3FsubPropertyOf%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" + \n          cellValue + \n          \".%0D%0AOPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0AOPTIONAL+%7B%3Fp+rdfs%3AsubPropertyOf+%3FsubPropertyOf%7D.%0D%0A%7B%0D%0Aselect+%3Fp+%28count%28%3Fs%29+as+%3Fcount%29+%0D%0Awhere+%7B%0D%0A%3Fs+%3Fp+dbr%3A\" +\n          cellValue + \n          \"%0D%0A%7D%0D%0Agroup+by+%3Fp%0D%0Ahaving+%28count%28%3Fs%29+%3C%3D+\" + \n          maxFetchCount +\n          \"%29%0D%0A%7D%0D%0A%7D%0D%0A&\";\n      }\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let curPromise = fetchJSON(queryURL);\n      promiseArray.push(curPromise);\n    }\n    return promiseArray;\n  }\n\n  // This function populates the key column\n  // It also fetches the neighbours of the key column (based on the first cell in the table)\n  // as well as setting the origins of cells in the key column\n\n  // Note: we need to do some modification here. Instead of having a fixed number of entries in the key column,\n  // Let's make it more flexible. (but also pose a limit, so we don't get way too many entries)\n\n  populateKeyColumn(e, colIndex, neighbourArray) {\n    // Let's first take a look at parameters passed in\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n\n    // Let's create a helper function to generate the query text.\n    let queryURL = keyQueryGen(neighbourArray)\n    // console.log(queryURL);\n\n    // If queryURL is error, we have encountered some previously unseen datatypes. In this case we just print an error.\n    if (queryURL === \"ERROR\") {\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\")\n    }\n\n    // Else we run the body of the funnction\n\n    else {\n      document.body.classList.add('waiting');\n\n      let promiseArray = [fetchJSON(queryURL)];\n\n      allPromiseReady(promiseArray).then((values) => {\n        // let's first work with the first promise result: fill in table data with the entities we have fetched\n  \n        // console.log(values[0].results.bindings);\n\n        // We set the tableHeader[0] here, from a deep copy of tableHeader\n        // tableHeader[0] should be set as neighbourArray\n        let tableHeader = _.cloneDeep(this.state.tableHeader);\n        tableHeader[0] = neighbourArray;\n\n        // Addition: we want to display the first column's header correctly. Let's add support for that\n        let firstColHeaderInfo = [];\n        firstColHeaderInfo.push(neighbourArray);\n  \n        // This part sets the data for each cell\n        let tableData = _.cloneDeep(this.state.tableData);\n  \n        if (this.state.tableHeader[0].length === 0) {\n          tableData = setFirstColumnData(\n            values[0].results.bindings,\n            tableData,\n            tableHeader,\n            colIndex\n          )\n        }\n  \n        // console.log(tableData);\n  \n        // We need to make modification here: find neighbours of a column, instead of neighbours of a cell\n        // To do this, we need to use this tableData to ask more queries (number of queires is equal to tableData.length)\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n          // We call updateNeighbourInfo here because we are changing the rows\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n          // Lastly, we set up the information for the action panel\n          let tempObj = {};\n          tempObj[\"task\"] = \"showStartRecommend\";\n          tempObj[\"colIndex\"] = colIndex;\n          tempObj[\"recommendArray\"] = this.createStartRecommend(keyColNeighbours);\n  \n          // Support for undo: \n          // Let's save the previous state in an object\n          let lastAction = \"populateKeyColumn\";\n          let prevState = \n            {\n              \"keyColIndex\":this.state.keyColIndex,\n              \"keyColNeighbours\":this.state.keyColNeighbours,\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\n              \"curActionInfo\":this.state.curActionInfo,\n              \"tableData\":this.state.tableData,\n              \"tableHeader\":this.state.tableHeader,\n              \"firstColFilled\":this.state.firstColFilled,\n              \"firstColHeaderInfo\":this.state.firstColHeaderInfo,\n            };\n\n          document.body.classList.remove('waiting');\n  \n          this.setState({\n            keyColIndex: colIndex,\n            keyColNeighbours: keyColNeighbours,\n            firstDegNeighbours: firstDegNeighbours,\n            // curActionInfo: {\"task\":\"afterPopulateColumn\"},\n            curActionInfo: tempObj, // Changed on Aug 20th\n            tableData: tableData,\n            tableHeader: tableHeader,\n            firstColFilled: true,\n            firstColHeaderInfo: firstColHeaderInfo,\n            lastAction: lastAction,\n            prevState: prevState,\n          });\n        })\n        })\n      });\n    }\n  }\n\n  // This function adds more entities to the first column.\n  // It should be similar to populateKeyColumn, with some differences\n\n  confirmAddFirstCol(e, neighbourArray) {\n    // console.log(neighbourArray);\n    let queryURL = keyQueryGen(neighbourArray);\n\n    // Let's first make sure that the neighbourArray do not contain attributes of unknown datatypes.\n    if (queryURL === \"ERROR\") {\n      alert(\"Unsupported datatype in selected neighbours. Please select some other neighbours.\");\n    }\n\n    else {\n      document.body.classList.add(\"waiting\");\n\n      let promiseArray = [fetchJSON(queryURL)];\n\n      allPromiseReady(promiseArray).then((values) => {\n        // console.log(values[0].results.bindings);\n        // Now we append the new query results to tableData\n        let numNewRows = Math.min(values[0].results.bindings.length, initialRowNum);\n        let tableData = [];\n        // We first push on numNewRows number of rows, while setting up data and origin\n        for (let i = 0; i < numNewRows; ++i) {\n          let tempRow = [];\n          for (let j = 0; j < this.state.tableHeader.length; ++j) {\n            if (j === 0) {\n              tempRow.push({\n                data: values[0].results.bindings[i].somevar.value.slice(28),\n                origin: [values[0].results.bindings[i].somevar.value.slice(28)]\n              })\n            }\n            else {\n              tempRow.push({ data: \"\", origin: []});\n            }\n          }\n          tableData.push(tempRow);\n        }\n        // We concat this.state.tableData and tableData together, and dedup by first column's data\n        tableData = _.cloneDeep(this.state.tableData).concat(tableData);\n        tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\n        // console.log(tableData);\n\n        // Now, we move on to update firstDegNeighbours and keyColNeighbours\n        let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", 0);\n        let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", 0);\n        allPromiseReady(promiseArrayOne).then((valuesOne) => {\n        allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n  \n          // We call updateNeighbourInfo here because we are changing the rows\n          let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n          let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n          let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n          document.body.classList.remove('waiting');\n\n          let firstColHeaderInfo = _.cloneDeep(this.state.firstColHeaderInfo);\n          firstColHeaderInfo.push(neighbourArray);\n\n          // Support for undo\n          let lastAction = \"confirmAddFirstCol\";\n          let prevState = \n            {\n              \"tableData\": this.state.tableData,\n              \"keyColNeighbours\": this.state.keyColNeighbours,\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\n              \"firstColHeaderInfo\": this.state.firstColHeaderInfo,\n              \"previewColIndex\": this.state.previewColIndex,\n            }\n  \n          this.setState({\n            tableData: tableData,\n            keyColNeighbours: keyColNeighbours,\n            firstDegNeighbours: firstDegNeighbours,\n            firstColHeaderInfo: firstColHeaderInfo,\n            curActionInfo: {\"task\":\"afterPopulateColumn\"},\n            previewColIndex: -1,\n            lastAction: lastAction,\n            prevState: prevState,\n          });\n        })\n        })\n      })\n    }\n  }\n\n  // // TEST FUNCTION----------------------------------------------------\n\n  // getOtherColPromiseTwo(neighbour, type) {\n  //   let promiseArray = [];\n  //   // The following is the query we will make\n\n  //   // SELECT ?key ?val\n  //   // WHERE{\n  //   //       ?key (dbo:spouse|dbp:spouse) ?val.\n  //   //       VALUES ?key {dbr:Barack_Obama dbr:Ronald_Reagan dbr:Donald_Trump }\n  //   // }\n\n\n  //   let prefixURL = \n  //     \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n  //   let suffixURL = \n  //     \"%7D%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=300000&debug=on&run=+Run+Query+\";\n  //   let queryBody;\n  //   // This clause handles the case of \"Obama -> property -> object\"\n  //   if (type === \"subject\") {\n  //     queryBody = \n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fkey+%28dbo%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%7Cdbp%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%29+%3Fval.%0D%0A++++++VALUES+%3Fkey+%7B\";\n  //   } \n  //   // This clause handles the case of \"subject -> property -> Obama\"\n  //   else {\n  //     queryBody = \n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fval+%28dbo%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%7Cdbp%3A\" +\n  //       regexReplace(neighbour) +\n  //       \"%29+%3Fkey.%0D%0A++++++VALUES+%3Fkey+%7B\";\n  //   }\n  //   for (let i = 0; i < this.state.tableData.length; ++i) {\n  //     let cellValue = regexReplace(\n  //       this.state.tableData[i][this.state.keyColIndex].data\n  //     );\n  //     // N/A's will block the search, let's replace it with some string that does not block the search\n  //     if (cellValue === \"N/A\") {\n  //       cellValue = \"NONEXISTINGSTRING\";\n  //     }\n  //     let curQueryText = \"dbr%3A\"+cellValue+\"+\";\n  //     queryBody+=curQueryText;\n  //   }\n  //   let queryURL = prefixURL + queryBody + suffixURL;\n  //   // console.log(queryURL);\n  //   promiseArray.push(fetchJSON(queryURL));\n  //   return promiseArray;\n  // }\n\n  // The following function serves as a helper function for \"populateOtherColumn\" and \"populateSameNeighbour\"\n  // It makes an array of queries, which may affect the performance of our system. Let's change it now.\n\n  getOtherColPromise(neighbour, type) {\n    let promiseArray = [];\n    let prefixURL =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURL =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    for (let i = 0; i < this.state.tableData.length; ++i) {\n      let cellValue = regexReplace(\n        this.state.tableData[i][this.state.keyColIndex].data\n      );\n      // N/A's will block the search, let's replace it with some string that does not block the search\n      if (cellValue === \"N/A\") {\n        cellValue = \"NONEXISTINGSTRING\";\n      }\n      let queryBody;\n      if (type === \"subject\") {\n        queryBody =\n          \"SELECT+%3Fsomevar%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\" +\n          cellValue +\n          \"+%28dbo%3A\" +\n          regexReplace(neighbour) +\n          \"%7Cdbp%3A\" +\n          regexReplace(neighbour) +\n          \"%29+%3Fsomevar.%0D%0A%7D%0D%0A%0D%0A&\";\n      } else {\n        queryBody =\n          \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A++++++++%3Fsomevar+%28dbo%3A\" +\n          regexReplace(neighbour) +\n          \"%7Cdbp%3A\" +\n          regexReplace(neighbour) +\n          \"%29+dbr%3A\" +\n          cellValue +\n          \"%0D%0A%7D%0D%0A&\";\n      }\n      let queryURL = prefixURL + queryBody + suffixURL;\n      let curPromise = fetchJSON(queryURL);\n      promiseArray.push(curPromise);\n    }\n    return promiseArray;\n  }\n\n  // document.body.classList.add('waiting');\n\n  // console.log(neighbourIndex);\n\n  // Support for \"populateSameRange\":\n\n  // When the range is not equal to undefined, we want to ask user if they want to populate all other attributes from this range\n  // console.log(range);\n\n  // we need to make a number of queries in the form of: dbr:somekeycolumnentry dbp:neighbour|dbo:neighbour somevar\n  // let promiseArrayTwo = this.getOtherColPromiseTwo(neighbour, type); // this is for testing\n  // let promiseArray = this.getOtherColPromise(neighbour, type);\n\n  // allPromiseReady(promiseArray).then((values) => {\n  // // allPromiseReady(promiseArrayTwo).then((testValues) => {\n\n  // //   // Let's compare the different values we get from getOtherColPromise and getOtherColPromiseTwo\n  // //   console.log(values);\n  // //   console.log(testValues);\n\n  // //   // Now we need to process the testValues\n\n  // //   let pairArray = [];\n\n  // //   // First we removed the prefixes from resultArray\n  // //   for (let i=0; i<testValues[0].results.bindings.length; ++i) {\n  // //     pairArray.push(\n  // //       {\n  // //         \"key\":removePrefix(testValues[0].results.bindings[i].key.value),\n  // //         \"value\":removePrefix(testValues[0].results.bindings[i].val.value)\n  // //       }\n  // //     )\n  // //   }\n  // //   console.log(pairArray);\n\n  // //   // Then we create a keyArray\n  // //   let keyArray = [];\n\n  // //   for (let i=0; i<this.state.tableData.length; ++i) {\n  // //     keyArray.push(this.state.tableData[i][this.state.keyColIndex].data);\n  // //   }\n  // //   console.log(keyArray);\n  populateOtherColumn(e, colIndex, neighbourArray) {\n\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n\n    let tableData = _.cloneDeep(this.state.tableData);\n    // We use a boolean to keep track of if any cell contains multiple values\n    let hasMultiple = false;\n\n    for (let i = 0; i < tableData.length; ++i) {\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\n      let curColumnArray = [];\n      // We loop through the neighbourArray\n      for (let j = 0; j < neighbourArray.length; ++j) {\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\n        let curNeighbour = neighbourArray[j];\n        let firstDegNeighbours = \n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n        // console.log(firstDegNeighbours);\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\n        // If yes, we want to concat those values with curColumnArray\n        if (curNeighbourData !== undefined) {\n          curColumnArray = curColumnArray.concat(curNeighbourData);\n        }\n      }\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\n      if (curColumnArray.length === 0) {\n        tableData[i][colIndex].data = \"N/A\";\n      }\n      // Otherwise, we have found at least one value.\n      else {\n        // we first set the data for the cell using curColumnArray[0]\n        tableData[i][colIndex].data = curColumnArray[0];\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\n        keyOrigin.push(originToAdd);\n        tableData[i][colIndex].origin = keyOrigin;\n        // console.log(keyOrigin)\n\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\n        if (curColumnArray.length > 1) {\n          hasMultiple = true;\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\n        } \n      }\n    }\n    // Now, we are done with updating tableData.\n    // We want to update tableHeader as well.\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\n    tableHeader[colIndex] = neighbourArray;\n\n    // We start setting up the content for the Action Panel.\n\n    let recommendArray = createRecommendArray(neighbourArray, this.state.keyColNeighbours);\n    // console.log(recommendArray);\n\n    // tempObj stores the information passed to ActionPanel\n    let tempObj = {};\n\n    // Case 1: hasMultiple is true, and there are recommendations\n    if (hasMultiple === true && recommendArray.length > 0) {\n      tempObj[\"task\"] = \"sameNeighbourAndRecommendation\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n      tempObj[\"recommendArray\"] = recommendArray;\n    }\n    // Case 2: only hasMultiple is true\n    else if (hasMultiple === true) {\n      tempObj[\"task\"] = \"populateSameNeighbour\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n    }\n    // Case 3: only hasRecommendation is true\n    else if (recommendArray.length > 0) {\n      tempObj[\"task\"] = \"populateRecommendation\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"recommendArray\"] = recommendArray; \n    }\n    // Case 4: neither hasMultiple or hasRecommendation is true. In which case we just tell users that they can fill more columns.\n    else {\n      tempObj[\"task\"] = \"afterPopulateColumn\";\n    }\n\n    // Support for undo: \n    // Let's save the previous state in an object\n    let lastAction = \"populateOtherColumn\";\n    let prevState = \n      {\n        \"curActionInfo\":this.state.curActionInfo,\n        \"tableData\":this.state.tableData,\n        \"tableHeader\":this.state.tableHeader,\n        \"previewColIndex\":this.state.previewColIndex,\n      };\n\n    this.setState({\n      curActionInfo: tempObj,\n      tableData: tableData,\n      tableHeader: tableHeader,\n      previewColIndex: -1,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n\n\n    // let tableData = _.cloneDeep(this.state.tableData);\n    // let firstDegNeighbours = type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n    // let longestDataArray = [];\n    // for (let i = 0; i < tableData.length; ++i) {\n    //   let dataArray = firstDegNeighbours[i][neighbour];\n    //   // console.log(dataArray);\n    //   // If dataArray is empty, this current entry in search column does not have this neighbour at all.\n    //   if (dataArray === undefined) {\n    //     tableData[i][colIndex].data = \"N/A\";\n    //   } \n    //   // Otherwise, we have found at least one value. Let's use dataArray[0]\n    //   else {\n    //     // we first set data for the cell\n    //     tableData[i][colIndex].data = dataArray[0];\n    //     // we then set origin for the cell. The origin depends on whether type is \"subject\" or \"object\"\n    //     let originToAdd = type === \"subject\" ? neighbour + \":\" + dataArray[0] : \"is \" + neighbour + \" of:\" + dataArray[0];\n    //     let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\n    //     keyOrigin.push(originToAdd);\n    //     tableData[i][colIndex].origin = keyOrigin;\n    //     // If dataArray's length is longer than longestDataArray's length, we want to update it\n    //     if (dataArray.length > longestDataArray.length) {\n    //       longestDataArray = dataArray;\n    //     }\n    //   }\n    // }\n    // // console.log(longestDataArray);\n    // let maxCount = Math.min(longestDataArray.length, maxNeighbourCount);\n    // let remainNeighbourCount = maxCount - 1;\n\n    // console.log(remainNeighbourCount);\n    \n    // // Now we set up the content for ActionPanel\n    // let tempObj = {};\n\n    // // In this case, we give users option to populate duplicate neighbours\n    // if (remainNeighbourCount > 0) {\n    //   tempObj[\"task\"] = \"populateSameNeighbour\";\n    //   tempObj[\"colIndex\"] = colIndex;\n    //   tempObj[\"neighbour\"] = neighbour;\n    //   tempObj[\"type\"] = type;\n    //   tempObj[\"numCols\"] = remainNeighbourCount;\n    //   if (range !== undefined) {\n    //     tempObj[\"range\"] = range;\n    //   }\n    // }\n    // // In this case, users are not populating column with duplicate names, but it has a range.\n    // // We may need to ask user if they want to populate other columns from the same range\n    // else if (range !== undefined) {\n    //   let siblingNeighbour = [];\n    //   // console.log(\"Range is \"+range);\n    //   // console.log(this.state.keyColNeighbours);\n    //   for (let i = 0; i < this.state.keyColNeighbours.length; ++i) {\n    //     if (\n    //       this.state.keyColNeighbours[i].range === range &&\n    //       this.state.keyColNeighbours[i].value !== neighbour\n    //     ) {\n    //       siblingNeighbour.push(this.state.keyColNeighbours[i]);\n    //     }\n    //   }\n    //   // If we have found columns from the same range (other than the current neighbour),\n    //   console.log(siblingNeighbour);\n    //   // If sibling neighbour is non-empty, we give user the option to populate other columns from the same range.\n    //   if (siblingNeighbour.length > 0) {\n    //     // Let's do some string processing to improve UI clarity\n    //     let rangeLiteral = \"\";\n    //     if (range.includes(\"http://dbpedia.org/ontology/\")) {\n    //       rangeLiteral = range.slice(28);\n    //     } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\n    //       rangeLiteral = range.slice(33);\n    //     } else {\n    //       rangeLiteral = range;\n    //     }\n    //     tempObj[\"task\"] = \"populateSameRange\";\n    //     tempObj[\"colIndex\"] = colIndex;\n    //     tempObj[\"range\"] = rangeLiteral;\n    //     // console.log(siblingNeighbour);\n    //     tempObj[\"siblingNeighbour\"] = siblingNeighbour;\n    //   }\n    //   // Else, if we have NOT found anything from the same range, we tell user that they can populate more columns\n    //   else {\n    //     tempObj[\"task\"] = \"afterPopulateColumn\";\n    //   }\n    // }\n    // // In this case, we tell users that they can populate more columns\n    // else {\n    //   tempObj[\"task\"] = \"afterPopulateColumn\";\n    // }\n    // // Support for undo: \n    // // Let's save the previous state in an object\n    // let lastAction = \"populateOtherColumn\";\n    // let prevState = \n    //   {\n    //     \"curActionInfo\":this.state.curActionInfo,\n    //     \"tableData\":this.state.tableData,\n    //   };\n\n    // this.setState({\n    //   curActionInfo: tempObj,\n    //   tableData: tableData,\n    //   lastAction: lastAction,\n    //   prevState: prevState,\n    // });\n  }\n\n  // This function is a helper function that takes in 9 parameters:\n  // Note: this function does not make any fetch requests, thus does NOT involve promises.\n\n  // 1) colIndex:          index of the column that we just filled (ex. 1, if we just filled in column 1)\n  // 2) neighbourArray:    an array of neighbour objects (two important attributes: value, type)\n  // 3) numCols:           number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\n  \n  // 4) keyColIndex:                 original key column index\n  // 5) tableHeader:                 original tableHeader\n  // 6) tableData:                   original tableData\n  // 7) optionsMap:                  original optionsMap\n  // 8) selectedClassAnnotation:     original selectedClassAnnotation\n\n  // 9) fillRecommendation:              When true, decrement requiredLength in code by 1.\n\n  // and returns an object with 5 values:\n  // 1) tableHeader:                tableHeader after modification\n  // 2) tableData:                  tableData after modification\n  // 3) optionsMap:                 optionsMap after modification\n  // 4) selectedClassAnnotation:    selectedClassAnnotation after modification\n  // 5) keyColIndex:                keyColIndex after modification\n\n  addAllNeighbour(\n    colIndex,\n    neighbourArray,\n    numCols,\n    keyColIndex,\n    tableHeader,\n    tableData,\n    optionsMap,\n    selectedClassAnnotation,\n    fillRecommendation\n  ) {\n    // Let's first check if all the variables are as expected\n\n    // console.log(\"Column index is: \"+colIndex);\n    // console.log(\"NeighbourArray is: \");\n    // console.log(neighbourArray);\n    // console.log(\"Number of columns to fill is: \"+numCols);\n    // console.log(\"Key column index \"+keyColIndex);\n    // console.log(\"Table header is: \");\n    // console.log(tableHeader);\n    // console.log(\"Table Data is: \");\n    // console.log(tableData);\n    // console.log(\"Options map is: \");\n    // console.log(optionsMap);\n    // console.log(\"selected class annotation is \");\n    // console.log(selectedClassAnnotation);\n    // console.log(\"End of attributes check\\n\\n\\n\\n\");\n\n    // First thing should be to insert \"numCols\" number of empty columns right after column with index \"colIndex\"\n    const rowNum = tableData.length;\n    const colNum = tableData[0].length;\n\n    // Let's check if we need to modify keyColIndex:\n    // if colIndex < keyColIndex, we need to increase keyColIndex by numCols\n    let keyColIndexUpdated = keyColIndex;\n    if (colIndex < keyColIndex) {\n      keyColIndexUpdated+=numCols;\n    }\n    // console.log(\"Updated key column index is \"+keyColIndexUpdated);\n\n    // We first take care of table data's (empty) additions\n    let tableDataUpdated = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(tableData[i][j]);\n      }\n      // we add in numCols number of empty columns\n      for (let j = 0; j < numCols; ++j) {\n        tempRow.push({ data: \"\", origin: [] });\n      }\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(tableData[i][k]);\n      }\n      tableDataUpdated.push(tempRow);\n    }\n    // console.log(\"Updated table data is \");\n    // console.log(tableDataUpdated);\n\n    // we now take care of table header's addition.\n    let tableHeaderUpdated = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      tableHeaderUpdated.push(tableHeader[j]);\n    }\n    // Now we decide what the newly pushed tableHeader should look like\n    let newTableHeader;\n    // If we are not populating new suggestions, we simply use tableHeader[colIndex]\n    if (fillRecommendation === false) {\n      newTableHeader = tableHeader[colIndex];\n    }\n    // else, it is an length one array of object. Object has 2 properties: value and label\n    else {\n      // We need to figure out what this label is\n      let keyColLabel = \"\";\n      for (let i = 0; i < tableHeader[keyColIndex].length; ++i) {\n        let labelToAdd = i > 0 ? \"&\" + tableHeader[keyColIndex][i].label : tableHeader[keyColIndex][i].label;\n        keyColLabel+=labelToAdd;\n      }\n      let ownLabel = neighbourArray[0].type === \"subject\" ? neighbourArray[0].value : \"is \" + neighbourArray[0].value + \" of\";\n      newTableHeader = [\n        {\n          \"value\" : neighbourArray[0].value,\n          \"label\" : ownLabel + \"--\" + keyColLabel,\n          \"type\"  : neighbourArray[0].type,\n        }\n      ]\n    }\n    for (let j = 0; j < numCols; ++j) {\n      tableHeaderUpdated.push(newTableHeader);\n    }\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      tableHeaderUpdated.push(tableHeader[k]);\n    }\n    // console.log(\"Updated table header is \");\n    // console.log(tableHeaderUpdated);\n\n    // We now take care of selectedClassAnnotation. For now, we just add some empty arrays to it\n    let selectedClassAnnotationUpdated = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[j]);\n    }\n    for (let j = 0; j < numCols; ++j) {\n      selectedClassAnnotationUpdated.push([]);\n    }\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[k]);\n    }\n    // console.log(\"Updated class annotation is \");\n    // console.log(selectedClassAnnotationUpdated);\n\n    // we now take care of optionMap's addition. We just need to add some empty arrays to it\n    let optionsMapUpdated = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      optionsMapUpdated.push(optionsMap[j]);\n    }\n    for (let j = 0; j < numCols; ++j) {\n      optionsMapUpdated.push([]);\n    }\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      optionsMapUpdated.push(optionsMap[k]);\n    }\n    // console.log(\"Updated options map is \");\n    // console.log(optionsMapUpdated);\n\n    // Finally, we fill in the actual data for tableData. We need to take care of both data and origin\n\n    // Outer loop loops over all rows in the table\n    for (let i = 0; i < tableData.length; ++i) {\n      // curColumnArray corresponds to the dataArray for each entry from the search column\n      let curColumnArray = [];\n      // we loop through the neighbourArray\n      for (let j = 0; j < neighbourArray.length; ++j) {\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\n        let curNeighbour = neighbourArray[j];\n        let firstDegNeighbours =\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n        // If yes, we want to concat those values with curColumnArray\n        if (curNeighbourData !== undefined) {\n          curColumnArray = curColumnArray.concat(curNeighbourData);\n        }\n      }\n      // console.log(curColumnArray);\n      for (let curCol = colIndex + 1; curCol < colIndex + 1 + numCols; ++curCol) {\n        // Starting value for requiredLength is 2\n        let requiredLength = fillRecommendation === true ? curCol - colIndex : curCol - colIndex + 1;\n        // If curColumnArray's length does not meet the required length, we simply set data to N/A\n        if (curColumnArray.length < requiredLength) {\n          tableDataUpdated[i][curCol].data = \"N/A\";\n        }\n        else {\n          // We first set the data of the cell\n          let value = curColumnArray[requiredLength - 1];\n          tableDataUpdated[i][curCol].data = value;\n          // We then set the origin of the cell\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + value;\n          let keyOrigin = tableDataUpdated[i][keyColIndexUpdated].origin.slice();\n          keyOrigin.push(originToAdd);\n          tableDataUpdated[i][curCol].origin = keyOrigin;\n        }\n      }\n    }\n\n    return {\n      tableHeader: tableHeaderUpdated,\n      tableData: tableDataUpdated,\n      optionsMap: optionsMapUpdated,\n      selectedClassAnnotation: selectedClassAnnotationUpdated,\n      keyColIndex: keyColIndexUpdated,\n    };\n  }\n\n  // This function populates all neighbour with the same names in different rows, if that neighbour has multiple occurences.\n  // It should modify both tableData and firstDegNeighbours, but not keyColNeighbours.\n  // This is because we are not removing, or adding anything new, to the search column.\n\n  sameNeighbourDiffRow(e,colIndex,neighbourArray) {\n\n    // First we take a look at the parameters passed in\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n    // console.log(this.state.tableData);\n\n    let tableDataUpdated = [];\n    let subjectNeighbours = [];\n    let objectNeighbours = [];\n    let tableData = _.cloneDeep(this.state.tableData);\n    let firstDegNeighbours = _.cloneDeep(this.state.firstDegNeighbours);\n\n    // The first loop deals with tableData's additions \n    for (let i = 0; i < tableData.length; ++i) {\n      // We first create a deep copy of the current row\n      let curRow = _.cloneDeep(tableData[i]);\n      // If the current cell in the selected column does NOT have dataArray attribute, we push it onto tableData as it is\n      if (curRow[colIndex].dataArray === undefined) {\n        tableDataUpdated.push(curRow);\n      }\n      // Else, we have to push on dataArray.length number of new rows onto tableData.\n      // We need to take care of the new cell's data, origin, and dataArray\n      else {\n        // First, we still need to push on curRow\n        tableDataUpdated.push(curRow);\n        // Then, we deal with rows that are not in the original table\n        for (let j = 0; j < curRow[colIndex].dataArray.length; ++j) {\n          let rowToAdd = _.cloneDeep(curRow);\n          // We set data\n          rowToAdd[colIndex].data = curRow[colIndex].dataArray[j];\n          // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\n          let originToAdd = createNeighbourText(neighbourArray) + \":\" + curRow[colIndex].dataArray[j];\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\n          keyOrigin.push(originToAdd);\n          rowToAdd[colIndex].origin = keyOrigin;\n          // Lastly, we remove the dataArray attribute from rowToAdd\n          delete rowToAdd[colIndex].dataArray;\n          tableDataUpdated.push(rowToAdd);\n        }\n      }\n    }\n\n    // The second loop deals with firstDegNeighbours's additions\n    for (let i = 0; i < tableData.length; ++i) {\n      // We first create a deep copy of the current row\n      let curRow = _.cloneDeep(tableData[i]);\n      // If the current cell in the selected column does NOT have dataArray attribute\n      // We push onto subjectNeighbours and objectNeighbours once\n      if (curRow[colIndex].dataArray === undefined) {\n        subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\n        objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\n      }\n      // Else, we have to push onto subject/objectNeighbours 1 + dataArray.length times.\n      else {\n        for (let j = 0; j < 1 + curRow[colIndex].dataArray.length; ++j) {\n          subjectNeighbours.push(firstDegNeighbours[\"subject\"][i]);\n          objectNeighbours.push(firstDegNeighbours[\"object\"][i]);\n        }\n      }\n    }\n    let firstDegNeighboursUpdated = \n      {\n        \"subject\":subjectNeighbours,\n        \"object\":objectNeighbours,\n      }\n    // We take a look at updated tableData and firstDegNeighbours\n    // console.log(tableDataUpdated);\n    // console.log(firstDegNeighboursUpdated);\n\n    // Now we set up the obj for Action Panel\n    // We check if the curActionInfo's task is sameNeighbourAndRecommendation or populateSameNeighbour\n    let tempObj = {};\n    let curActionInfo = _.cloneDeep(this.state.curActionInfo);\n\n    // If it is sameNeighbourAndRecommendation, we will turn it to populateRecommendation\n    if (curActionInfo.task === \"sameNeighbourAndRecommendation\") {\n      tempObj[\"task\"] = \"populateRecommendation\";\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \n    }\n    // Else, if it is sameNeighbourAndStartRecommend, we will turn it to showStartRecommend\n    else if (curActionInfo.task === \"sameNeighbourAndStartRecommend\") {\n      tempObj[\"task\"] = \"showStartRecommend\";\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \n    }\n    // Else, we turn the current action into afterPopulateColumn\n    else {\n      tempObj[\"task\"] = \"afterPopulateColumn\";\n    }\n\n    // Support for undo: \n    // Let's save the previous state in an object\n    let lastAction = \"sameNeighbourDiffRow\";\n    let prevState = \n      {\n        \"curActionInfo\":this.state.curActionInfo,\n        \"tableData\":this.state.tableData,\n        \"firstDegNeighbours\":this.state.firstDegNeighbours,\n      };\n\n    this.setState({\n      curActionInfo: tempObj,\n      tableData: tableDataUpdated,\n      firstDegNeighbours: firstDegNeighboursUpdated,\n      lastAction: lastAction,\n      prevState: prevState,\n    })\n  }\n\n  // This function populates all neighbour with the same names in the same columns, if that neighbour has multiple occurences.\n\n  sameNeighbourOneRow(e, colIndex, neighbourArray) {\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n    // console.log(numCols);\n\n    let tableData = _.cloneDeep(this.state.tableData);\n\n    // Outer loop loops over all rows in the table\n    for (let i = 0; i < tableData.length; ++i) {\n      // curColumnArray corresponds to the dataArray for each entry from the search column\n      let curColumnArray = [];\n      // we loop through the neighbourArray\n      for (let j = 0; j < neighbourArray.length; ++j) {\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\n        let curNeighbour = neighbourArray[j];\n        // console.log(curNeighbour.value);\n        let firstDegNeighbours =\n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n        // console.log(firstDegNeighbours);\n        // If yes, we want to concat those values with curColumnArray\n        if (curNeighbourData !== undefined) {\n          // console.log(curNeighbourData);\n          curColumnArray = curColumnArray.concat(curNeighbourData);\n        }\n      }\n      // console.log(curColumnArray);\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\n      if (curColumnArray.length === 0) {\n        tableData[i][colIndex].data = \"N/A\";\n      }\n      // Otherwise, we have found at least one value. And we want to set up the data and origin. \n      else {\n        // we first set the data for the cell using all values from curColumnArray (this is different from populateOtherColumn)\n        let curData = \"\";\n        for (let k = 0; k < curColumnArray.length; ++k) {\n          let dataToAdd = k > 0 ? \";\" + curColumnArray[k] : curColumnArray[k];\n          curData+=dataToAdd;\n          // console.log(\"Data to add is \"+dataToAdd);\n          // console.log(\"Current data is \"+curData);\n        }\n        tableData[i][colIndex].data = curData;\n        // we then set the origin for the cell\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curData;\n        let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\n        keyOrigin.push(originToAdd);\n        tableData[i][colIndex].origin = keyOrigin;\n      }\n    }\n\n    // Now we set up the obj for Action Panel\n    // We check if the curActionInfo's task is sameNeighbourAndRecommendation or populateSameNeighbour\n    let tempObj = {};\n    let curActionInfo = _.cloneDeep(this.state.curActionInfo);\n\n    // If it is sameNeighbourAndRecommendation, we will turn it to populateRecommendation\n    if (curActionInfo.task === \"sameNeighbourAndRecommendation\") {\n      tempObj[\"task\"] = \"populateRecommendation\";\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \n    }\n    // Else, if it is sameNeighbourAndStartRecommend, we will turn it to showStartRecommend\n    else if (curActionInfo.task === \"sameNeighbourAndStartRecommend\") {\n      tempObj[\"task\"] = \"showStartRecommend\";\n      tempObj[\"colIndex\"] = curActionInfo.colIndex;\n      tempObj[\"recommendArray\"] = curActionInfo.recommendArray; \n    }\n    // Else, we turn the current action into afterPopulateColumn\n    else {\n      tempObj[\"task\"] = \"afterPopulateColumn\";\n    }\n\n    // Support for undo: \n    let lastAction = \"sameNeighbourOneRow\";\n    let prevState = \n      {\n        \"curActionInfo\":this.state.curActionInfo,\n        \"tableData\":this.state.tableData,\n      };\n\n    this.setState({\n      curActionInfo: tempObj,\n      tableData: tableData,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n\n  // The following function populates one recommendation neighbour\n  populateRecommendation(e, colIndex, neighbourArray) {\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n\n    // First thing we need to do should be the same as contextAddColumn\n    const rowNum = this.state.tableData.length;\n    const colNum = this.state.tableData[0].length;\n\n    // we first take care of table data's addition\n    let tableData = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(this.state.tableData[i][j]);\n      }\n      // we add in one column of empty data\n      tempRow.push({ data: \"\", origin: [] });\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(this.state.tableData[i][k]);\n      }\n      tableData.push(tempRow);\n    }\n    // console.log(tableData);\n\n    // we now take care of tabler header, and selectedClassAnnotation's addition\n    let tableHeader = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      tableHeader.push(this.state.tableHeader[j]);\n    }\n    tableHeader.push([]);\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      tableHeader.push(this.state.tableHeader[k]);\n    }\n    // console.log(tableHeader);\n\n    // we now take care of selectedClassAnnotation\n    let selectedClassAnnotation = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\n    }\n    selectedClassAnnotation.push([]);\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\n    }\n    // console.log(selectedClassAnnotation);\n\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\n    let keyColIndex = this.state.keyColIndex;\n    if (colIndex < keyColIndex) {\n      ++keyColIndex;\n    }\n    // console.log(keyColIndex);\n\n    // Now, the part that's the same as contextAddColumn is over.\n    // The part below will be largely the same as populateOtherColumn.\n\n    // An important things for us to do how is to increment colIndex\n    ++colIndex;\n\n    // We use a boolean to keep track of if any cell contains multiple values\n    let hasMultiple = false;\n\n    for (let i = 0; i < tableData.length; ++i) {\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\n      let curColumnArray = [];\n      // We loop through the neighbourArray\n      for (let j = 0; j < neighbourArray.length; ++j) {\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\n        let curNeighbour = neighbourArray[j];\n        let firstDegNeighbours = \n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n        // console.log(firstDegNeighbours);\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\n        // If yes, we want to concat those values with curColumnArray\n        if (curNeighbourData !== undefined) {\n          curColumnArray = curColumnArray.concat(curNeighbourData);\n        }\n      }\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\n      if (curColumnArray.length === 0) {\n        tableData[i][colIndex].data = \"N/A\";\n      }\n      // Otherwise, we have found at least one value.\n      else {\n        // we first set the data for the cell using curColumnArray[0]\n        tableData[i][colIndex].data = curColumnArray[0];\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\n        keyOrigin.push(originToAdd);\n        tableData[i][colIndex].origin = keyOrigin;\n        // console.log(keyOrigin)\n\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\n        if (curColumnArray.length > 1) {\n          hasMultiple = true;\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\n        } \n      }\n    }\n    // Now, we are done with updating tableData.\n    // We want to update tableHeader as well.\n    tableHeader[colIndex] = neighbourArray;\n\n    // In the third part of the code, We start setting up the content for the Action Panel.\n\n    // First thing we want to do is to update the recommendArray: \n    // We want to remove the recommendation just added from the recommendArray\n    let recommendArray = _.cloneDeep(this.state.curActionInfo.recommendArray)\n    let curRecommendation = neighbourArray[0];\n    let sliceIndex = -1;\n\n    // This for loop checks which index we want to remove\n    for (let i = 0; i < recommendArray.length; ++i) {\n      if (recommendArray[i].value === curRecommendation.value && recommendArray[i].type === curRecommendation.type) {\n        sliceIndex = i;\n        break;\n      }\n    }\n\n    // console.log(sliceIndex);\n    // console.log(curRecommendation);\n    // console.log(recommendArray);\n    \n    // This if condition removes the found element\n    if (sliceIndex !== -1) {\n      recommendArray.splice(sliceIndex, 1);\n    }\n\n    // tempObj stores the information passed to ActionPanel\n    let tempObj = {};\n    // console.log(this.state.curActionInfo);\n    if (hasMultiple === true && recommendArray.length > 0) {\n      tempObj[\"task\"] = \"sameNeighbourAndRecommendation\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n      tempObj[\"recommendArray\"] = recommendArray;\n    }\n    else if (hasMultiple === false && recommendArray.length > 0) {\n      tempObj[\"task\"] = \"populateRecommendation\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"recommendArray\"] = recommendArray;\n    }\n    else if (hasMultiple === true) {\n      tempObj[\"task\"] = \"populateSameNeighbour\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n    }\n    else {\n      tempObj[\"task\"] = \"afterPopulateColumn\"\n    }\n\n    // console.log(tableData);\n    // console.log(tableHeader);\n    // console.log(selectedClassAnnotation);\n    // console.log(keyColIndex);\n    // console.log(tempObj);\n\n    // Lastly, we add support for undo, and set the states\n    let lastAction = \"populateRecommendation\";\n    let prevState =\n      {\n        \"tableData\": this.state.tableData,\n        \"tableHeader\": this.state.tableHeader,\n        \"curActionInfo\": this.state.curActionInfo,\n        \"keyColIndex\": this.state.keyColIndex,\n        \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n        \"tabIndex\": this.state.tabIndex,\n        \"previewColIndex\": this.state.previewColIndex,\n      } \n\n    this.setState({\n      tableData: tableData,\n      tableHeader: tableHeader,\n      selectedClassAnnotation: selectedClassAnnotation,\n      keyColIndex: keyColIndex,\n      curActionInfo: tempObj,\n      tabIndex: 0,\n      previewColIndex: -1,\n      prevState: prevState,\n      lastAction: lastAction,\n    })\n  }\n\n  // This function\n\n  createStartRecommend(keyColNeighbours) {\n    let recommendArray = [];\n    let numRecommend = Math.min(5, keyColNeighbours.length);\n    for (let i = 0; i < numRecommend; ++i) {\n      recommendArray.push(keyColNeighbours[i]);\n    }\n    return recommendArray;\n  }\n\n  // This function below should mostly be similar to populateRecommendation, with some small differences. \n\n  populateStartRecommend(e, colIndex, neighbourArray) {\n    // console.log(colIndex);\n    // console.log(neighbourArray);\n    // console.log(this.state.curActionInfo);\n\n    // First thing we need to do should be the same as contextAddColumn\n    const rowNum = this.state.tableData.length;\n    const colNum = this.state.tableData[0].length;\n\n    // we first take care of table data's addition\n    let tableData = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(this.state.tableData[i][j]);\n      }\n      // we add in one column of empty data\n      tempRow.push({ data: \"\", origin: [] });\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(this.state.tableData[i][k]);\n      }\n      tableData.push(tempRow);\n    }\n    // console.log(tableData);\n\n    // we now take care of tabler header, and selectedClassAnnotation's addition\n    let tableHeader = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      tableHeader.push(this.state.tableHeader[j]);\n    }\n    tableHeader.push([]);\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      tableHeader.push(this.state.tableHeader[k]);\n    }\n    // console.log(tableHeader);\n\n    // we now take care of selectedClassAnnotation\n    let selectedClassAnnotation = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\n    }\n    selectedClassAnnotation.push([]);\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\n    }\n    // console.log(selectedClassAnnotation);\n\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\n    let keyColIndex = this.state.keyColIndex;\n    if (colIndex < keyColIndex) {\n      ++keyColIndex;\n    }\n    // console.log(keyColIndex);\n\n    // Now, the part that's the same as contextAddColumn is over.\n    // The part below will be largely the same as populateOtherColumn.\n\n    // An important things for us to do how is to increment colIndex\n    ++colIndex;\n\n    // We use a boolean to keep track of if any cell contains multiple values\n    let hasMultiple = false;\n\n    for (let i = 0; i < tableData.length; ++i) {\n      // curColumnArray is the dataArray for each entry in search column, for all neighbours in neighbourArray.\n      let curColumnArray = [];\n      // We loop through the neighbourArray\n      for (let j = 0; j < neighbourArray.length; ++j) {\n        // For each neighbour in neighbourArray, we check to see if entries in search column have values for this neighbour\n        let curNeighbour = neighbourArray[j];\n        let firstDegNeighbours = \n          curNeighbour.type === \"subject\" ? this.state.firstDegNeighbours.subject : this.state.firstDegNeighbours.object;\n        // console.log(firstDegNeighbours);\n        let curNeighbourData = firstDegNeighbours[i][curNeighbour.value];\n        // console.log(\"Current neighbour data is \"+curNeighbourData);\n        // If yes, we want to concat those values with curColumnArray\n        if (curNeighbourData !== undefined) {\n          curColumnArray = curColumnArray.concat(curNeighbourData);\n        }\n      }\n      // If curColumnArray is empty, that means this entry in searchColumn do not have any of the attributes from neighbourArray\n      if (curColumnArray.length === 0) {\n        tableData[i][colIndex].data = \"N/A\";\n      }\n      // Otherwise, we have found at least one value.\n      else {\n        // we first set the data for the cell using curColumnArray[0]\n        tableData[i][colIndex].data = curColumnArray[0];\n        // we then set origin for the cell. Need to use neighbourArray to get the correct text for the origin\n        let originToAdd = createNeighbourText(neighbourArray) + \":\" + curColumnArray[0];\n        let keyOrigin = tableData[i][keyColIndex].origin.slice();\n        keyOrigin.push(originToAdd);\n        tableData[i][colIndex].origin = keyOrigin;\n        // console.log(keyOrigin)\n\n        // Now, if curColumnArray has length longer than one, we want to set hasMultiple to true\n        // We also create an extra attribute for the current tableData cell, called dataArray, whose max length is maxNeighbourCount.\n        if (curColumnArray.length > 1) {\n          hasMultiple = true;\n          let lastIndex = Math.min(curColumnArray.length, maxNeighbourCount);\n          tableData[i][colIndex].dataArray = curColumnArray.slice(1, lastIndex);\n        } \n      }\n    }\n    // Now, we are done with updating tableData.\n    // We want to update tableHeader as well.\n    tableHeader[colIndex] = neighbourArray;\n\n    // In the third part of the code, We start setting up the content for the Action Panel.\n\n    // First thing we want to do is to update the recommendArray: \n    // We want to remove the recommendation just added from the recommendArray\n    let recommendArray = _.cloneDeep(this.state.curActionInfo.recommendArray)\n    let curRecommendation = neighbourArray[0];\n    let sliceIndex = -1;\n\n    // This for loop checks which index we want to remove\n    for (let i = 0; i < recommendArray.length; ++i) {\n      if (recommendArray[i].value === curRecommendation.value && recommendArray[i].type === curRecommendation.type) {\n        sliceIndex = i;\n        break;\n      }\n    }\n\n    // console.log(sliceIndex);\n    // console.log(curRecommendation);\n    // console.log(recommendArray);\n    \n    // This if condition removes the found element\n    if (sliceIndex !== -1) {\n      recommendArray.splice(sliceIndex, 1);\n    }\n\n    // tempObj stores the information passed to ActionPanel\n    let tempObj = {};\n    // console.log(this.state.curActionInfo);\n    if (hasMultiple === true && recommendArray.length > 0) {\n      tempObj[\"task\"] = \"sameNeighbourAndStartRecommend\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n      tempObj[\"recommendArray\"] = recommendArray;\n    }\n    else if (hasMultiple === false && recommendArray.length > 0) {\n      tempObj[\"task\"] = \"showStartRecommend\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"recommendArray\"] = recommendArray;\n    }\n    else if (hasMultiple === true) {\n      tempObj[\"task\"] = \"populateSameNeighbour\";\n      tempObj[\"colIndex\"] = colIndex;\n      tempObj[\"neighbourArray\"] = neighbourArray;\n    }\n    else {\n      tempObj[\"task\"] = \"afterPopulateColumn\";\n    }\n\n    // console.log(tableData);\n    // console.log(tableHeader);\n    // console.log(selectedClassAnnotation);\n    // console.log(keyColIndex);\n    // console.log(tempObj);\n\n    // Lastly, we add support for undo, and set the states\n    let lastAction = \"populateStartRecommend\";\n    let prevState =\n      {\n        \"tableData\": this.state.tableData,\n        \"tableHeader\": this.state.tableHeader,\n        \"curActionInfo\": this.state.curActionInfo,\n        \"keyColIndex\": this.state.keyColIndex,\n        \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n        \"tabIndex\": this.state.tabIndex,\n        \"previewColIndex\": this.state.previewColIndex,\n      } \n\n    this.setState({\n      tableData: tableData,\n      tableHeader: tableHeader,\n      selectedClassAnnotation: selectedClassAnnotation,\n      keyColIndex: keyColIndex,\n      curActionInfo: tempObj,\n      tabIndex: 0,\n      previewColIndex: -1,\n      prevState: prevState,\n      lastAction: lastAction,\n    })\n  }\n\n  // The following function adds a new column to the table, to the right of the selected column.\n  // In here, let's also set tabIndex to 0.\n\n  contextAddColumn(e, colIndex) {\n    const rowNum = this.state.tableData.length;\n    const colNum = this.state.tableData[0].length;\n\n    // we first take care of table data's addition\n    let tableData = [];\n    for (let i = 0; i < rowNum; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < colIndex + 1; ++j) {\n        tempRow.push(this.state.tableData[i][j]);\n      }\n      // we add in one column of empty data\n      tempRow.push({ data: \"\", origin: [] });\n      for (let k = colIndex + 1; k < colNum; ++k) {\n        tempRow.push(this.state.tableData[i][k]);\n      }\n      tableData.push(tempRow);\n    }\n\n    // we now take care of tabler header, and selectedClassAnnotation's addition\n    let tableHeader = [];\n    for (let j = 0; j < colIndex + 1; ++j) {\n      tableHeader.push(this.state.tableHeader[j]);\n    }\n    tableHeader.push([]);\n    for (let k = colIndex + 1; k < colNum; ++k) {\n      tableHeader.push(this.state.tableHeader[k]);\n    }\n\n    // we now take care of selectedClassAnnotation\n    let selectedClassAnnotation = [];\n    for (let j = 0; j < colIndex; ++j) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\n    }\n    selectedClassAnnotation.push([]);\n    for (let k = colIndex; k < colNum-1; ++k) {\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\n    }\n\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\n    let keyColIndex = this.state.keyColIndex;\n    if (colIndex < keyColIndex) {\n      ++keyColIndex;\n    }\n\n    // console.log(this.state.selectedClassAnnotation);\n    // console.log(tableHeader);\n\n    // Support for undo: \n    let lastAction = \"contextAddColumn\";\n    let prevState = \n        {\n          \"tableData\": this.state.tableData,\n          \"tableHeader\": this.state.tableHeader,\n          \"curActionInfo\": this.state.curActionInfo,\n          \"keyColIndex\": this.state.keyColIndex,\n          \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n          \"tabIndex\": this.state.tabIndex,\n          \"previewColIndex\": this.state.previewColIndex,\n        };\n\n    this.setState({\n      tableData: tableData,\n      tableHeader: tableHeader,\n      curActionInfo: {\"task\":\"afterPopulateColumn\"},\n      keyColIndex: keyColIndex,\n      selectedClassAnnotation: selectedClassAnnotation,\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n      previewColIndex: -1, // we want to set the preview column index to -1\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n  \n  // The following function handles the deletion of a selected column.\n  // This function should be largely similar to contextAddColumn\n\n  contextDeleteColumn(e, colIndex) {\n    // console.log(\"This is the column we are trying to delete \"+colIndex);\n\n    // We disable the deletion of the search column\n    if (colIndex === this.state.keyColIndex) {\n      alert(\"The current column is the search column.\\n\\nPlease set another search column before deleting the current column.\");\n    }\n\n    // We also disable the deletion of the first column\n    else if (colIndex === 0) {\n      alert(\"Deleting the first column causes unexpected behavior.\\n\\nPlease do not delete the first column.\");\n    }\n\n    // Else, we can proceed to deletion.\n    else {\n      // We handle tableData, tableHeader, optionsMap, and selectedClassAnnotation's deletion\n      let tableData = _.cloneDeep(this.state.tableData);\n      let tableHeader = this.state.tableHeader.slice();\n      let optionsMap = this.state.optionsMap.slice();\n      let selectedClassAnnotation = this.state.selectedClassAnnotation.slice();\n\n      // tableData\n      for (let i = 0; i < tableData.length; ++i) {\n        tableData[i].splice(colIndex, 1);\n      }\n      // tableHeader, optionsMap, and selectedClassAnnotation\n      tableHeader.splice(colIndex, 1);\n      optionsMap.splice(colIndex, 1);\n      if (colIndex > 0) {\n        selectedClassAnnotation.splice(colIndex-1, 1);\n      }\n      // If colIndex is less than keyColIndex, we need to decrease keyColIndex by 1, if keyColIndex > 0\n      let keyColIndex = this.state.keyColIndex;\n      if (colIndex < keyColIndex) {\n        --keyColIndex;\n      }\n\n      // When we are deleting a column, we do not necessarily want to go to tab 0.\n      // However, if we are in tab 1, we want to toggle off all property neighbours\n      let propertyNeighbours = _.cloneDeep(this.state.propertyNeighbours);\n      if (this.state.tabIndex === 1) {\n        for (let i = 0; i < propertyNeighbours.length; ++i) {\n          propertyNeighbours[i].isOpen = false;\n        }\n      }\n\n      // Support for undo: \n      let lastAction = \"contextDeleteColumn\";\n      let prevState = \n          {\n            \"tableData\": this.state.tableData,\n            \"tableHeader\": this.state.tableHeader,\n            \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n            \"keyColIndex\": this.state.keyColIndex,\n            \"previewColIndex\": this.state.previewColIndex,\n            \"propertyNeighbours\": this.state.propertyNeighbours,\n            \"curActionInfo\": this.state.curActionInfo,\n          };\n\n      this.setState({\n        tableData: tableData,\n        tableHeader: tableHeader,\n        selectedClassAnnotation: selectedClassAnnotation,\n        keyColIndex: keyColIndex,\n        previewColIndex: -1, // we want to set the preview column index to -1\n        propertyNeighbours: propertyNeighbours,\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    }\n  }\n\n  // The following function handles the sorting of a column from context menu.\n  // It is a prototype. Needs to be refined in the future.\n\n  contextSortColumn(e, colIndex, order) {\n    // console.log(\"The column we are sorting is \"+colIndex);\n    document.body.classList.add('waiting');\n    let tableData = _.cloneDeep(this.state.tableData);\n\n    // We first loop through this column to determine if it's a numeric column or a string column\n    let numericCol = true;\n    for (let i = 0; i < tableData.length; ++i) {\n      // We only care about entries that are not N/A\n      if (tableData[i][colIndex].data !== \"N/A\") {\n        if (isNaN(Number(tableData[i][colIndex].data))) {\n          numericCol = false;\n          break;\n        }\n      }\n    }\n\n    // In this case we are sorting a numerical column\n    if (numericCol) {\n      tableData.sort(function (a, b) {\n        let aValue = a[colIndex].data;\n        let bValue = b[colIndex].data;\n        // We want to put all N/A's at the bottom\n        if (aValue === \"N/A\") {\n          return 1;\n        }\n        else if (bValue === \"N/A\") {\n          return -1;\n        } \n        // Else, we sort by the given order.\n        else {\n          if (order === \"ascending\") {\n            return Number(aValue) - Number(bValue);\n          }\n          else {\n            return Number(bValue) - Number(aValue);\n          }\n        }\n      });\n    }\n    // In this case we are sorting a string-based column\n    else {\n      tableData.sort(function (a, b) {\n        let aValue = a[colIndex].data;\n        let bValue = b[colIndex].data;\n        // We want to put all N/A's at the bottom\n        if (aValue === \"N/A\") {\n          return 1;\n        }\n        else if (bValue === \"N/A\") {\n          return -1;\n        } \n        // Else, we sort by the given order.\n        else {\n          if (order === \"ascending\") {\n            return aValue < bValue ? -1 : 1;\n          }\n          else {\n            return aValue < bValue ? 1 : -1;\n          }\n        }\n      });\n    }\n    // console.log(\"Table Data is: \");\n    // console.log(tableData);\n    // console.log(\"Search entry is \");\n    // console.log(searchEntry);\n\n    // console.log(\"Table Data is: \");\n    // console.log(tableData);\n    // console.log(\"Search entry is \");\n    // console.log(searchEntry);\n\n    // We need a bugfix here: since tableData is reordered, firstColSelection now do not have the correct data anymore.\n    // We have to update firstColSelection to include the correct data.\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      document.body.classList.remove('waiting');\n\n      // Support for undo: \n      let lastAction = \"contextSortColumn\";\n      let prevState = \n          {\n            \"tableData\": this.state.tableData,\n            \"firstDegNeighbours\": this.state.firstDegNeighbours,\n            \"previewColIndex\": this.state.previewColIndex,\n          };\n\n      this.setState({\n        tableData: tableData,\n        firstDegNeighbours: firstDegNeighbours,\n        previewColIndex: -1,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    })\n    })\n  }\n\n  // The following function dedups the selected column.\n  // Note: this function has to make modifications to both firstDegNeighbours and keyColNeighbours\n\n  contextDedupColumn(e, colIndex) {\n    document.body.classList.add('waiting');\n    let tableData = _.cloneDeep(this.state.tableData);\n    // console.log(colIndex);\n    // console.log(tableData);\n\n    // We simply dedup this column by calling the uniqBy function from the lodash library\n    tableData = _.uniqBy(tableData, function(x) {return x[colIndex].data;});\n    // console.log(this.state.tableData);\n    // console.log(tableData);\n\n    // Now we deal with firstDegNeighbours and keyColNeighbours' updates\n    // Since we are changing the number of rows, we need to call updateNeighbourInfo\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      document.body.classList.remove('waiting');\n\n      // Support for undo:\n      let lastAction = \"contextDedupColumn\";\n      let prevState = \n        {\n          \"tableData\": this.state.tableData,\n          \"keyColNeighbours\": this.state.keyColNeighbours,\n          \"firstDegNeighbours\": this.state.firstDegNeighbours,\n          \"curActionInfo\": this.state.curActionInfo,\n          \"tabIndex\": this.state.tabIndex,\n          \"previewColIndex\": this.state.previewColIndex,\n        }\n\n      this.setState({\n        tableData: tableData,\n        keyColNeighbours: keyColNeighbours,\n        firstDegNeighbours: firstDegNeighbours,\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\n        tabIndex: 0,\n        previewColIndex: -1,\n        lastAction: lastAction,\n        prevState: prevState,\n      })\n    })\n    })\n  }\n\n  // This function handles click event on the filter icon.\n  // We want to let the Action Panel display 4 different filtering methods:\n  // 1) Sort ascending\n  // 2) Sort descending\n  // 3) Filter\n  // 4) Dedup\n\n  showFilterMethods(e, colIndex) {\n    // console.log(\"Selected column is \"+colIndex);\n\n    // We just need to pass on the colIndex\n    let tempObj = {};\n    tempObj[\"task\"] = \"showFilterMethods\";\n    tempObj[\"colIndex\"] = colIndex;\n    \n    this.setState({\n      curActionInfo: tempObj,\n      tabIndex: 0, // we also want to set the currentlly active tab index to 0\n      previewColIndex: -1, // we also want to set preview column index to -1 (clear previews)\n    })\n  }\n\n  // The following functions sets the selected column to be the search column.\n\n  contextSetColumn(e, colIndex) {\n\n    // console.log(\"Col index of search cell is \"+colIndex);\n\n    // Let's do a preliminary check here to make sure that users do not set empty columns as search columns\n    let colEmpty = true;\n    for (let i = 0; i < this.state.tableData.length; ++i) {\n      if (this.state.tableData[i][colIndex].data !== \"\") {\n        colEmpty = false;\n        break;\n      }\n    }\n\n    // We give users an alert if they try to set an empty columns as the search column\n    if (colEmpty === true) {\n      alert(\"This column is currently empty. Try set the data for this column before setting it as the search column.\");\n    }\n    else {\n      document.body.classList.add('waiting');\n\n      // Code here should largely be similar to what we have in populateKeyColumn\n\n      let tableData = _.cloneDeep(this.state.tableData);\n\n      // We need to find neighbours of a column.\n      // We need to use tableData to ask more queries (number of queries is equal to tableData.length)\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", colIndex);\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", colIndex);\n\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n        // We call updateNeighbourInfo here because we are changing the rows\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n        document.body.classList.remove('waiting');\n\n        // Support for undo: \n        let lastAction = \"contextSetColumn\";\n        let prevState = \n            {\n              \"keyColIndex\": this.state.keyColIndex,\n              \"keyColNeighbours\": this.state.keyColNeighbours,\n              \"firstDegNeighbours\": this.state.firstDegNeighbours,\n              \"curActionInfo\": this.state.curActionInfo,\n              \"tabIndex\": this.state.tabIndex,\n              \"previewColIndex\": this.state.previewColIndex,\n            };\n\n        this.setState({\n          keyColIndex: colIndex,\n          keyColNeighbours: keyColNeighbours,\n          firstDegNeighbours: firstDegNeighbours,\n          curActionInfo: {\"task\":\"afterPopulateColumn\"},\n          tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n          previewColIndex: -1,\n          lastAction: lastAction,\n          prevState: prevState,\n        });\n      })\n      })\n    }\n  }\n\n  // // The following function displays the origin of a cell in the Action Panel.\n\n  // contextCellOrigin(e, rowIndex, colIndex) {\n  //   // To get the origin of a cell, we simply returns its \"origin field\"\n  //   // The trick is to set the origin field correctly in previous functions\n  //   // The place to do that should be in the two populating columns\n\n  //   let cellSelected = this.state.tableData[rowIndex][colIndex];\n\n  //   let originElement = [];\n  //   for (let i = 0; i < cellSelected.origin.length; ++i) {\n  //     originElement.push(<p>{niceRender(cellSelected.origin[i])}</p>);\n  //   }\n\n  //   // This origin literal correctly contains the cell Origin we want to display\n  //   // Now we just need to show it in the ActionPanel\n  //   let tempObj = {};\n  //   tempObj[\"task\"] = \"contextCellOrigin\";\n  //   tempObj[\"origin\"] = originElement;\n\n  //   // Support for undo: \n  //   let lastAction = \"contextCellOrigin\";\n  //   let prevState = \n  //       {\n  //         \"curActionInfo\": this.state.curActionInfo,\n  //         \"tabIndex\": this.state.tabIndex,\n  //       };\n    \n  //   this.setState({\n  //     curActionInfo: tempObj,\n  //     tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n  //     lastAction: lastAction,\n  //     prevState: prevState,\n  //   });\n  // }\n\n  // This function has three functionalities: \n  // Show the selected cell's origin, show the selected cell's preview, and update the bottom iframe's URL\n\n  originPreviewPage(e, rowIndex, colIndex) {\n    document.body.classList.add('waiting');\n    // console.log(\"Row index is \"+rowIndex);\n    // console.log(\"Col index is \"+colIndex);\n\n    // This first part deals with preview\n\n    // Let's first run queries to fetch the dbp neighbours and dbo neighbours for the selected cell (withe some filtering)\n    // In here, we need both the ?p and ?o. This is different from before.\n\n    let promiseArray = [];\n\n    // Below is the first query we will make. In here we are using the tableCell as SUBJECT\n\n    // select ?p ?value\n    // where {\n    // dbr:Barack_Obama ?p ?value.\n    // }\n\n    let prefixURLOne = \n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLOne = \n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyOne = \n      \"select+%3Fp+%3Fvalue%0D%0Awhere+%7B%0D%0Adbr%3A\" + \n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\n      \"+%3Fp+%3Fvalue.%0D%0A%7D&\";\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n    let otherColPromiseSubject = fetchJSON(queryURLOne);\n    promiseArray.push(otherColPromiseSubject);\n\n    // Below is the second query we will make. In here we are using the tableCell as OBJECT.\n\n    // select ?p ?value\n    // where {\n    // ?value ?p dbr:Barack_Obama.\n    // }\n\n    let prefixURLTwo = \n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLTwo = \n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyTwo =\n      \"select+%3Fp+%3Fvalue%0D%0Awhere+%7B%0D%0A%3Fvalue+%3Fp+dbr%3A\" +\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\n      \".%0D%0A%7D&\";\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n    let otherColPromiseObject = fetchJSON(queryURLTwo);\n    promiseArray.push(otherColPromiseObject);\n\n    allPromiseReady(promiseArray).then((values) => {\n      // console.log(values[0]);\n      // console.log(values[1]);\n      // let previewInfoArray = [];\n      let subjectInfoArray = \n        updatePreviewInfo(\n          values[0].results.bindings,\n          \"subject\"\n        );\n      let objectInfoArray = \n        updatePreviewInfo(\n          values[1].results.bindings,\n          \"object\"\n        );\n      // console.log(subjectInfoArray);\n      // console.log(objectInfoArray);\n      \n      // Here is where we make the modifications: instead of passing information to Action Panel, let's store them as states\n      let previewInfoArray = subjectInfoArray.concat(objectInfoArray);\n      let previewInfoExpanded = [];\n      for (let i = 0; i < previewInfoArray.length; ++i) {\n        previewInfoExpanded.push(false);\n      }\n      let selectedCell = _.cloneDeep(this.state.tableData[rowIndex][colIndex]);\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\n\n      let tempObj = {};\n      tempObj[\"task\"] = \"originPreviewPage\";\n      // // previewInfoArray correctly contains the cell preview we want to display\n      // // Now we just need to show it in the ActionPanel\n      // let tempObj = {};\n      // tempObj[\"task\"] = \"originPreviewPage\";\n      // tempObj[\"cellValue\"] = this.state.tableData[rowIndex][colIndex].data;\n      // tempObj[\"preview\"] = previewInfoArray;\n\n      // // Now, everything about cell preview has been completed. \n      // // Let's move on to deal with open link.\n      // let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\n\n      // // Lastly, let's deal with cell origin\n      // let cellSelected = this.state.tableData[rowIndex][colIndex];\n\n      // let originElement = [];\n      // for (let i = 0; i < cellSelected.origin.length; ++i) {\n      //   originElement.push(<p>{niceRender(cellSelected.origin[i])}</p>);\n      // }\n      // // We push this property to tempObj\n      // tempObj[\"origin\"] = originElement;\n\n      // Support for undo: \n      document.body.classList.remove('waiting');\n      let lastAction = \"originPreviewPage\";\n      let prevState = \n          {\n            \"curActionInfo\": this.state.curActionInfo,\n            \"tabIndex\": this.state.tabIndex,\n            \"pageHidden\": this.state.pageHidden,\n            \"iframeURL\": this.state.iframeURL,\n            \"previewInfoArray\": this.state.previewInfoArray,\n            \"previewInfoExpanded\": this.state.previewInfoExpanded,\n            \"selectedCell\": this.state.selectedCell,\n            \"previewColIndex\": this.state.previewColIndex,\n          };\n      \n      this.setState({\n        curActionInfo: tempObj,\n        tabIndex: 0, // we want to set the currently active tab to be wrangling actions\n        previewColIndex: -1,\n        pageHidden: false,\n        iframeURL: iframeURL,\n        previewInfoArray: previewInfoArray,\n        previewInfoExpanded: previewInfoExpanded,\n        selectedCell: selectedCell,\n        lastAction: lastAction,\n        prevState: prevState,\n      });\n    });\n  }\n\n  toggleTable(e, index) {\n    let tableOpenList = this.state.tableOpenList.slice();\n    tableOpenList[index] = !tableOpenList[index];\n    // When we toggle on one table, we want to close all other tables\n    for (let i = 0; i < tableOpenList.length; ++i) {\n      if (i !== index) {\n        tableOpenList[i] = false;\n      }\n    }\n    this.setState({\n      tableOpenList: tableOpenList,\n    });\n  }\n\n  // The following function is a helper function for handleStartTable.\n\n  // It takes in 2 parameters:\n  // 1) tableDataExplore\n  // 2) selectedClassAnnotation\n\n  // It returns a Promise of an object with 5 properties:\n  // 1) keyColIndex\n  // 2) tableHeader\n  // 3) tableData\n  // 4) keyColNeighbours\n  // 5) optionsMap.\n\n  // This object contains all the information we needed for the Excel-style table.\n\n  getTableStates(tableDataExplore, selectedClassAnnotation) {\n    // We need to take care of keyColIndex, tableHeader, tableData, optionsMap, and keyColNeighbours\n\n    // tableDataExplore contains all the information we need to set the five states listed above\n    // We just need to make use of the \"data\" and \"origin\" attributes. rowSpan and colSpan have no impact here.\n    // Also, since we are not modifying tableDataExplore, we do not need to make a copy of it.\n\n    // First, let's deal with keyColIndex. \n    // We will use the first column such that it's class annotation is not [] or [\"Number\"] or [\"originURL\"]\n    // If no such column exists, we default it to the first column\n\n    // console.log(selectedClassAnnotation);\n\n    let keyColIndex = -1;\n    for (let i=0;i<selectedClassAnnotation.length;++i) {\n      if (selectedClassAnnotation[i].length > 0 \n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"Number\")\n          && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"originURL\")\n        ) {\n        keyColIndex = i+1; \n        break;\n      }\n    }\n    if (keyColIndex === -1) {\n      keyColIndex = 0;\n    }\n    // console.log(\"Key Column Index is: \");\n    // console.log(keyColIndex);\n\n    // Now, let's deal with tableHeader. Note: these tableHeaders only have value and label, no range or type\n    // Also note that since table headers can be multi-selects, each tableHeader element is in the form of a length one array\n    let tableHeader = [];\n    for (let j=0;j<tableDataExplore[0].length;++j) {\n      tableHeader.push(\n        [\n          {\"value\":tableDataExplore[0][j].data\n          ,\"label\":tableDataExplore[0][j].data}\n        ]\n      )\n    }\n    // console.log(\"Table header is: \");\n    // console.log(tableHeader);\n\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\n    let tableData = [];\n    // console.log(tableDataExplore);\n    // This starts the loop for rows\n    for (let i=1;i<tableDataExplore.length;++i) {\n      let tempRow = [];\n      // This starts the loop for columns\n      for (let j=0;j<tableDataExplore[i].length;++j) {\n        // First set the data\n        let data = tableDataExplore[i][j].data;\n        // Then set the origin\n        let origin = [];\n        let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j][0].value+\": \"+tableDataExplore[i][j].data;\n        origin.push(originText);\n        tempRow.push({\"data\":data,\"origin\":origin});\n      }\n      tableData.push(tempRow);\n    }\n    // console.log(\"Table data is: \");\n    // console.log(tableData);\n\n    // Now, let's deal with keyColNeighbours and optionsMap\n    // Note: the following part should be similar to what we have in contextSetColumn\n\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", keyColIndex);\n    return allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    return allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n      \n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      return Promise.resolve(\n        {\n          \"keyColIndex\":keyColIndex,\n          \"tableHeader\":tableHeader,\n          \"tableData\":tableData,\n          \"keyColNeighbours\":keyColNeighbours,\n          \"firstDegNeighbours\":firstDegNeighbours,\n        }\n      )\n    })\n    })\n  }\n\n  // The following function handles the selection of table.\n\n  handleStartTable(e, tableIndex) {\n    document.body.classList.add('waiting');\n    \n    // We need to let table panel display the selected table\n    // And we need to update the Action Panel to display the first degree properties of the origigitnal page\n    // We do a fetch request here (Sixth Query). It gets the property neighbours of the original page that are links, as well as dct:subject\n    // Lastly, we need to set usecaseSelected to \"startSubject\"\n\n    // First query gets the property neighbours\n    let queryPromise = [];\n    let prefixURLOne =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLOne =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyOne =\n      \"SELECT+%3Fp+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n      urlReplace(this.state.urlPasted.slice(30)) +\n      \"+%3Fp+%3Fo.%0D%0A++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++FILTER%28isIRI%28%3Fo%29+%26%26+regex%28%3FpString%2C%22property%22%2C%22i%22%29+%26%26+%28%21regex%28%3FpString%2C%22text%22%2C%22i%22%29%29%29.%0D%0A%7D%0D%0A&\";\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\n    let queryOne = fetchJSON(queryURLOne);\n    queryPromise.push(queryOne);\n\n    // Second query gets the dct:subject neighbours\n    let prefixURLTwo =\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n    let suffixURLTwo =\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n    let queryBodyTwo =\n      \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n      urlReplace(this.state.urlPasted.slice(30)) +\n      \"+dct%3Asubject+%3Fo%0D%0A%7D&\";\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\n    // console.log(queryURLTwo);\n    let queryTwo = fetchJSON(queryURLTwo);\n    queryPromise.push(queryTwo);\n\n    // Third query here should get the class annotations\n    queryPromise.push(\n      findClassAnnotation(this.state.originTableArray[tableIndex])\n    );\n\n    // now we process the query results\n    allPromiseReady(queryPromise).then((queryResults) => {\n      // console.log(queryResults[0].results.bindings);\n      // console.log(queryResults[1].results.bindings);\n      // console.log(queryResults[2]);\n      let selectedClassAnnotation = queryResults[2];\n      console.log(selectedClassAnnotation);\n\n      // First we fetch the property neighbours\n      // Let's also do some prefetching at this stage: let's remove the propertyNeighbours with too many siblings (150)\n      // and remove the propertyNeighbours with only one child (aka the originally pasted page)\n\n      let propertyNeighboursPO = [];\n      let promiseArray = [];\n      let bindingArray = [];\n\n      // The part below deals with the property neighbours\n      bindingArray = queryResults[0].results.bindings;\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let predicate = bindingArray[i].p.value.slice(28);\n        // console.log(\"Predicate is \"+predicate);\n        let object = bindingArray[i].o.value.slice(28);\n        // console.log(\"Object is \"+object);\n        // If object includes some weird literal values, we replace it with \"NONEXISTING\"\n        if (object.includes(\"/\")) {\n          object = \"NONEXISTING\";\n        }\n        let prefixURL =\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n        let suffixURL =\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n        let queryBody =\n          \"SELECT+%3Fs+%0D%0AWHERE+%7B%0D%0A%09%3Fs+dbp%3A\" +\n          regexReplace(predicate) +\n          \"+dbr%3A\" +\n          regexReplace(object) +\n          \"%0D%0A%7D%0D%0A&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        let curPromise = fetchJSON(queryURL);\n        propertyNeighboursPO.push({ predicate: predicate, object: object });\n        promiseArray.push(curPromise);\n      }\n\n      // The part below deals with the dct:subject neighbours\n      bindingArray = queryResults[1].results.bindings;\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let object = bindingArray[i].o.value.slice(37);\n        let prefixURL =\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n        let suffixURL =\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n        let queryBody =\n          \"SELECT+%3Fs%0D%0AWHERE+%7B%0D%0A++++++%3Fs+dct%3Asubject+dbc%3A\" +\n          regexReplace(object) +\n          \"%0D%0A%7D&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        let curPromise = fetchJSON(queryURL);\n        propertyNeighboursPO.push({ predicate: \"subject\", object: object });\n        promiseArray.push(curPromise);\n      }\n\n      // The part below processes all the siblings and remove neighbours with too many or too few siblings\n\n      allPromiseReady(promiseArray).then((values) => {\n        let propertyNeighbours = [];\n        let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\n        // console.log(urlOrigin);\n        for (let i = 0; i < values.length; ++i) {\n          let curSiblingArray = values[i].results.bindings;\n          // Note, this 150 below should also be adjustable by users\n          if (curSiblingArray.length > 1 && curSiblingArray.length < 150) {\n            let siblingArray = [];\n            for (let i = 0; i < curSiblingArray.length; ++i) {\n              let siblingName = curSiblingArray[i].s.value.slice(28);\n              siblingArray.push({\n                isOpen: false,\n                name: siblingName,\n                tableArray: [],\n              });\n            }\n            // console.log(siblingArray);\n            propertyNeighbours.push({\n              predicate: propertyNeighboursPO[i].predicate,\n              object: propertyNeighboursPO[i].object,\n              isOpen: false,\n              siblingArray: siblingArray,\n            });\n          }\n        }\n        // we do a rudimentary ranking here: sort the property neighbours by the length of siblingArray\n        propertyNeighbours.sort((a, b) =>\n          a.siblingArray.length < b.siblingArray.length ? 1 : -1\n        );\n        // Then we call the parse table helper function to update the tableDataExplore\n        let selectedTableHTML = this.state.originTableArray[tableIndex];\n        // setTableFromHTML is the function that prepares the data for tableDataExplore\n        let tableDataExplore = setTableFromHTML(selectedTableHTML, urlOrigin);\n\n        // Modeless Change: We need to call the helper function this.getTableStates.\n        // By processing the tableDataExplore to get the right states for the Excel-style table.\n\n        // To do this, we need to call this.getTableStates here. We just need to pass in tableDataExplore and selectedClassAnnotation \n        let statePromise = [this.getTableStates(tableDataExplore, selectedClassAnnotation)];\n        allPromiseReady(statePromise).then((values) => {\n          let stateInfo = values[0];\n          // console.log(stateInfo);\n\n          // Lastly, we set up the information for the action panel\n          let tempObj = {};\n          tempObj[\"task\"] = \"showStartRecommend\";\n          tempObj[\"colIndex\"] = stateInfo.keyColIndex;\n          tempObj[\"recommendArray\"] = this.createStartRecommend(stateInfo.keyColNeighbours);\n\n          document.body.classList.remove('waiting');\n          // Support for undo: \n          let lastAction = \"handleStartTable\";\n          let prevState = \n              {\n                \"firstColFilled\": this.state.firstColFilled,\n                \"selectedTableIndex\": this.state.selectedTableIndex,\n                \"propertyNeighbours\": this.state.propertyNeighbours,\n                \"curActionInfo\": this.state.curActionInfo,\n                \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\n                \"keyColIndex\": this.state.keyColIndex,\n                \"keyColNeighbours\": this.state.keyColNeighbours,\n                \"firstDegNeighbours\": this.state.firstDegNeighbours,\n                \"tableData\": this.state.tableData,\n                \"tableHeader\": this.state.tableHeader,\n                \"usecaseSelected\": this.state.usecaseSelected,\n                \"tabIndex\": this.state.tabIndex,\n              };\n\n          this.setState({\n            firstColFilled: true,\n            selectedTableIndex: tableIndex,\n            propertyNeighbours: propertyNeighbours,\n            // curActionInfo: {\"task\":\"afterPopulateColumn\"},\n            curActionInfo: tempObj, // Changed on Aug 20th\n            selectedClassAnnotation: selectedClassAnnotation,\n            keyColIndex: stateInfo.keyColIndex,\n            keyColNeighbours: stateInfo.keyColNeighbours,\n            firstDegNeighbours: stateInfo.firstDegNeighbours,\n            tableData: stateInfo.tableData,\n            tableHeader: stateInfo.tableHeader,\n            usecaseSelected: \"startTable\",\n            tabIndex: 1,\n            lastAction: lastAction,\n            prevState: prevState,\n          });\n        })\n      });\n    });\n  }\n\n  togglePropertyNeighbours(e, index) {\n    document.body.classList.add('waiting');\n    \n    // First let's do the toggling task\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    propertyNeighbours[index].isOpen = !propertyNeighbours[index].isOpen;\n\n    // we want to loop through all siblings if we are toggling a propertyNeighbour on\n    if (propertyNeighbours[index].isOpen === true) {\n      let bindingArray = propertyNeighbours[index].siblingArray;\n      let siblingArray = [];\n      let siblingNameArray = []; // this array keeps track of the sibling names\n      let promiseArray = [];\n      for (let i = 0; i < bindingArray.length; ++i) {\n        let siblingName = bindingArray[i].name;\n        let siblingURL = \"https://en.wikipedia.org/wiki/\" + siblingName;\n        let curPromise = fetchText(siblingURL);\n        promiseArray.push(curPromise);\n        siblingNameArray.push(siblingName);\n      }\n\n      // Since we only want to display siblings with useful tables, we do some checking here\n      allPromiseReady(promiseArray).then((values) => {\n        // tableArrayPromise stores an array of promises that resolve to tableArray\n        let tableArrayPromise = [];\n        for (let i = 0; i < values.length; ++i) {\n          let pageHTML = values[i];\n          // This is a helper function that fetches useful tables from pageHTML\n          // console.log(\"The class annotation for the selected table is: \");\n          // console.log(this.state.selectedClassAnnotation);\n          tableArrayPromise.push(\n            findTableFromHTML(\n              this.state.tableHeader,\n              pageHTML,\n              this.state.selectedClassAnnotation,\n              this.state.semanticEnabled,\n              this.state.unionCutOff,\n              siblingNameArray[i]\n            )\n          );\n          // we potentially want to do something different here if urlOrigin === siblingNameArray[i]\n          // We only want to keep siblings that do have useful tables\n          // if (tableArray.length !== 0) {\n          // siblingArray.push({\"isOpen\":false,\"name\":siblingNameArray[i],\"tableArray\":tableArray});\n          // }\n        }\n        allPromiseReady(tableArrayPromise).then((tableArrayValues) => {\n          for (let i = 0; i < tableArrayValues.length; ++i) {\n            siblingArray.push({\n              isOpen: false,\n              name: siblingNameArray[i],\n              tableArray: tableArrayValues[i],\n            });\n          }\n          // This following line sorts the siblingArray\n          siblingArray.sort(function (a, b) {\n            let aTableLength = a.tableArray.length;\n            let bTableLength = b.tableArray.length;\n            let aName = a.name;\n            let bName = b.name;\n            if (aTableLength === bTableLength) {\n              return aName < bName ? -1 : aName > bName ? 1 : 0;\n            } else {\n              return aTableLength > bTableLength ? -1 : 1;\n            }\n          });\n          propertyNeighbours[index].siblingArray = siblingArray;\n          document.body.classList.remove('waiting');\n          this.setState({\n            propertyNeighbours: propertyNeighbours,\n          });\n        });\n      });\n    } else {\n      document.body.classList.remove('waiting');\n      this.setState({\n        propertyNeighbours: propertyNeighbours,\n      });\n    }\n  }\n\n  // The following function handles the toggling of a sibling URL\n\n  toggleSibling(e, firstIndex, secondIndex) {\n    // Handle the toggling task\n    // console.log(\"Here we start the sibling toggle\");\n    // console.log(\"The current property neighbour is \");\n    // console.log(\n    //   \"The current property neighbour is \",\n    //   this.state.propertyNeighbours.slice()\n    // );\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    // console.log(propertyNeighbours);\n    let selectedSibling =\n      propertyNeighbours[firstIndex].siblingArray[secondIndex];\n\n    // Note that if this sibling's tableArray is empty, we probably do not want to toggle it.\n    if (selectedSibling.tableArray.length === 0) {\n      // console.log(\"Selected sibling has no tables: \" + selectedSibling.name);\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\n      this.setState({\n        pageHidden: false,\n        iframeURL: iframeURL,\n      });\n    } else {\n      // if the sibling's tableArray is not empty, we want to toggle it\n      selectedSibling.isOpen = !selectedSibling.isOpen;\n      // console.log(\"Let's take a look at the current property neighbour\");\n      // console.log(propertyNeighbours[firstIndex]);\n      // if (propertyNeighbours[firstIndex].isOpen === false) {\n      // propertyNeighbours[firstIndex].isOpen = true;\n      // console.log(\"In here we should have fixed the problem.\");\n      // console.log(propertyNeighbours);\n      // }\n      // We also want to change the iframe displayed at the bottom if we are toggling a sibling open\n      if (selectedSibling.isOpen === true) {\n        // console.log(\"If we get here, then sibling page should be opened\");\n        let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\n        // console.log(propertyNeighbours[firstIndex].isOpen);\n        propertyNeighbours[firstIndex].isOpen = true;\n        // console.log(propertyNeighbours[firstIndex]);\n        // console.log(propertyNeighbours[firstIndex].isOpen);\n        // console.log(\"First index is: \" + firstIndex);\n        // console.log(\"In here we should have fixed the problem.\");\n        // console.log(\"This is the property neighbour we will pass in\");\n        // console.log(propertyNeighbours);\n        this.setState({\n          propertyNeighbours: propertyNeighbours,\n          iframeURL: iframeURL,\n        });\n      } else {\n        this.setState({\n          propertyNeighbours: propertyNeighbours,\n        });\n      }\n    }\n  }\n\n  // The following function handles the toggling of other table (that's the same as the selected table)\n\n  toggleOtherTable(e, firstIndex, secondIndex, thirdIndex) {\n    // First handle the toggling task\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    const selectedTable =\n      propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray[\n        thirdIndex\n      ];\n    // console.log(selectedTable.data);\n    selectedTable.isOpen = !selectedTable.isOpen;\n    this.setState({\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // The following funcion unions the table that user has selected to the table in the TablePanel\n  // by changing tableDataExplore\n\n  unionTable(firstIndex, secondIndex, otherTableHTML, colMapping) {\n    document.body.classList.add('waiting');\n    // First we create a copy of the current tableData\n    let tableData = _.cloneDeep(this.state.tableData);\n    // console.log(tableData);\n\n    // Then we get the clean data and set the origin for the other table.\n    // We do so by calling setTableFromHTML, and setUnionData.\n    let otherTableOrigin = this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\n    otherTableData = setUnionData(otherTableData);\n    // console.log(otherTableData);\n\n    // console.log(colMapping);\n\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\n    let tempMapping = colMapping.slice();\n    tableData = tableConcat(\n      tableData,\n      otherTableData,\n      tempMapping\n    );\n\n    // console.log(tableData);\n\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      document.body.classList.remove('waiting');\n      // Suppport for undo.\n      let lastAction = \"unionTable\";\n      let prevState = \n          {\n            \"tableData\":this.state.tableData,\n            \"keyColNeighbours\":this.state.keyColNeighbours,\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\n            \"previewColIndex\": this.state.previewColIndex,\n          };\n      \n      this.setState({\n        tableData: tableData,\n        keyColNeighbours: keyColNeighbours,\n        firstDegNeighbours: firstDegNeighbours,\n        previewColIndex: -1,\n        lastAction: lastAction,\n        prevState: prevState,\n      })\n    })\n    })\n  }\n\n  // The following function unions all similar tables found under a sibling page with the selected table\n  unionPage(firstIndex, secondIndex) {\n    document.body.classList.add('waiting');\n    // First we create a copy of the current tableDataExplore\n    let tableData = _.cloneDeep(this.state.tableData);\n    // We get the tableArray and name of the current sibling page\n    let tableArray = \n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray;\n    let otherTableOrigin = \n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\n\n    for (let i = 0; i < tableArray.length; ++i) {\n      // We get the clean data for the current \"other table\"\n      let otherTableData = setTableFromHTML(\n        tableArray[i].data,\n        otherTableOrigin\n      );\n      // We fetch the header row now\n      let headerRow = otherTableData[0];\n      otherTableData = setUnionData(otherTableData);\n      // console.log(headerRow);\n      // console.log(this.state.tableHeader);\n\n      // Let's do some checking here: we do not want to union the same table with itself\n      let sameTable = false;\n      if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\n        let diffColFound = false;\n        for (let m=0; m<headerRow.length; ++m) {\n          if (headerRow[m].data !== this.state.tableHeader[m].value) {\n            diffColFound = true;\n            break;\n          }\n        }\n        if (diffColFound === false) {\n          sameTable = true;\n        }\n      }\n      // We create a copy of the colMapping of the current \"other table\"\n      let tempMapping = tableArray[i].colMapping.slice();\n\n      // if sameTable is false, we can safely union the data\n      if (sameTable === false) {\n        tableData = tableConcat(\n          tableData,\n          otherTableData,\n          tempMapping\n        );\n      }\n    }\n    // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\n    // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\n    let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      document.body.classList.remove('waiting');\n      // Suppport for undo.\n      let lastAction = \"unionPage\";\n      let prevState = \n          {\n            \"tableData\":this.state.tableData,\n            \"keyColNeighbours\":this.state.keyColNeighbours,\n            \"firstDegNeighbours\":this.state.firstDegNeighbours,\n            \"previewColIndex\": this.state.previewColIndex,\n          };\n      \n      this.setState({\n        tableData: tableData,\n        keyColNeighbours: keyColNeighbours,\n        firstDegNeighbours: firstDegNeighbours,\n        previewColIndex: -1,\n        lastAction: lastAction,\n        prevState: prevState,\n      })\n    })\n    })\n  }\n\n  // The following function unions all similar tables found under a property(parent) neighbour with the selected table\n  // This is the highest level of union.\n\n  unionProperty(firstIndex) {\n    // First we create a copy of the current tableDataExplore\n    let tableData = _.cloneDeep(this.state.tableData);\n\n    // we get the siblingArray of the current property neighbour\n    let siblingArray = this.state.propertyNeighbours[firstIndex].siblingArray;\n\n    for (let i = 0; i < siblingArray.length; ++i) {\n      // We get the tableArray and name of the current sibling page\n      let tableArray = siblingArray[i].tableArray;\n      let otherTableOrigin = siblingArray[i].name;\n      // console.log(otherTableOrigin);\n      // If the current sibling has no tables that are unionable, we break out of the loop.\n      // Because siblingArray is sorted by the length of their tableArray\n      if (tableArray.length === 0) {\n        break;\n      }\n      // Else, we want to union all unionable tables from the current sibling page\n      else {\n        for (let j = 0; j < tableArray.length; ++j) {\n          // We get the clean data for the current \"other table\"\n          let otherTableData = setTableFromHTML(\n            tableArray[j].data,\n            otherTableOrigin\n          );\n          // We fetch the column header row\n          let headerRow = otherTableData[0];\n          otherTableData = setUnionData(otherTableData);\n          // Let's do some checking here: we do not want to union the same table with itself\n          let sameTable = false;\n          if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\n            let diffColFound = false;\n            for (let m=0; m<headerRow.length; ++m) {\n              if (headerRow[m].data !== this.state.tableHeader[m].value) {\n                diffColFound = true;\n                break;\n              }\n            }\n            if (diffColFound === false) {\n              sameTable = true;\n            }\n          }\n          // We create a copy of the colMapping of the current \"oother table\"\n          let tempMapping = tableArray[j].colMapping.slice();\n\n          // if sameTable is false, we can safely union the data\n          if (sameTable === false) {\n            tableData = tableConcat(\n              tableData,\n              otherTableData,\n              tempMapping\n            );\n          }\n        }\n      }\n    }\n\n    // Support for undo: \n    let lastAction = \"unionProperty\";\n    let prevState = \n        {\n          \"tableData\":this.state.tableData,\n        };\n\n    this.setState({\n      tableData: tableData,\n      lastAction: lastAction,\n      prevState: prevState,\n    });\n  }\n\n  // This function handles the change of \"semanticEnabled\" setting\n\n  toggleSemantic(e) {\n    // we want to toggle off all the property neighbours in the action panel\n    // because changing semanticEnabled changes our search criteria\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      propertyNeighbours[i].isOpen = false;\n    }\n\n    this.setState({\n      semanticEnabled: e.target.value,\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // This function handles the change of the unionCutoff percentage\n\n  unionCutOffChange(e) {\n    // we want to toggle off all the property neighbours in the action panel\n    // because changing union cutoff changes our search criteria\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\n      propertyNeighbours[i].isOpen = false;\n    }\n    this.setState({\n      unionCutOff: e.target.value,\n      propertyNeighbours: propertyNeighbours,\n    });\n  }\n\n  // This function handles opening the filter for a particular column\n\n  openFilter(e, colIndex) {\n    // In this function, we want to set showFilter to true, and update dataAndChecked based on colIndex\n\n    let dataArray = [];\n    for (let i = 0; i < this.state.tableData.length; ++i) {\n      dataArray.push(this.state.tableData[i][colIndex].data);\n    }\n    dataArray = [...new Set(dataArray)];\n    // Let's sort this dataArray a bit: we put N/A at the beginning of the array\n    dataArray.sort(\n      function(a,b) { \n        return a === \"N/A\" ? -1 : b === \"N/A\" ? 1 : 0; \n      }\n    );\n\n    let dataAndChecked = [];\n    for (let i=0;i<dataArray.length;++i) {\n      dataAndChecked.push(\n        {\n          \"data\":dataArray[i],\n          \"checked\":true\n        }\n      )\n    }\n    // console.log(dataAndChecked);\n\n    this.setState({\n      dataAndChecked: dataAndChecked,\n      showFilter: true,\n      checkAll: true,   // we want to set checkAll to true whenever we open the filter modal\n      curFilterIndex: colIndex,\n    })\n  }\n\n  // This function handles cancelling the filter (so we close it).\n\n  cancelFilter(e) {\n    this.setState({\n      dataAndChecked: [],\n      showFilter: false,\n      curFilterIndex: -1,\n    })\n  }\n  \n\n  // This function handles toggling the data checkboxes in filter modal.\n\n  toggleChecked(e, checkIndex) {\n    let dataAndChecked = this.state.dataAndChecked;\n    dataAndChecked[checkIndex].checked = !dataAndChecked[checkIndex].checked;\n    this.setState({\n      dataAndChecked:dataAndChecked,\n    })\n  }\n\n  // This function handles toggling the Check/Uncheck all checkbox in filter modal.\n\n  toggleAll(e) {\n    let checkAll = this.state.checkAll;\n    let dataAndChecked = this.state.dataAndChecked;\n    checkAll = !checkAll;\n    // Now we loop through dataAndChecked to set all the checked attribute\n    for (let i = 0; i < dataAndChecked.length; ++i) {\n      dataAndChecked[i].checked = checkAll;\n    }\n    this.setState({\n      checkAll: checkAll,\n      dataAndChecked: dataAndChecked,\n    })\n  }\n\n  // This function handles applying the filter to tableData, based on dataAndChecked\n\n  applyFilter(e) {\n    // console.log(this.state.dataAndChecked);\n    // console.log(this.state.curFilterIndex);\n\n    // The following part are added for debugging purposes\n    let allFalse = true;\n    for (let i = 0; i < this.state.dataAndChecked.length; ++i) {\n      if (this.state.dataAndChecked[i].checked === true) {\n        allFalse = false;\n        break;\n      }\n    }\n\n    // We do not want users to toggle every value off\n    if (allFalse === true) {\n      alert(\"Please do not remove every value from the table!\");\n    }\n\n    // This else clause contains the original function body\n    else {\n      let valuesToKeep = [];\n      for (let i=0;i<this.state.dataAndChecked.length;++i) {\n        if (this.state.dataAndChecked[i].checked === true) {\n          valuesToKeep.push(this.state.dataAndChecked[i].data);\n        }\n      }\n      let tableData = _.cloneDeep(this.state.tableData);\n      for (let i=0;i<tableData.length;++i) {\n        if (!valuesToKeep.includes(tableData[i][this.state.curFilterIndex].data)) {\n          tableData.splice(i,1);\n          --i;\n        }\n      }\n\n      // Now, since we are changing the number of rows, we need to call updateNeighbourInfo\n      // Note: the colIndex we give to getNeighbourPromise should be this.state.keyColIndex\n      let promiseArrayOne = this.getNeighbourPromise(tableData, \"subject\", this.state.keyColIndex);\n      let promiseArrayTwo = this.getNeighbourPromise(tableData, \"object\", this.state.keyColIndex);\n      allPromiseReady(promiseArrayOne).then((valuesOne) => {\n      allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n        // We call updateNeighbourInfo here because we are changing the rows\n        let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n        let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n        let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n        // Suppport for undo.\n        let lastAction = \"applyFilter\";\n        let prevState = \n            {\n              \"tableData\":this.state.tableData,\n              \"curActionInfo\":this.state.curActionInfo,\n              \"keyColNeighbours\":this.state.keyColNeighbours,\n              \"firstDegNeighbours\":this.state.firstDegNeighbours,\n              \"previewColIndex\": this.state.previewColIndex,\n            };\n        \n        this.setState({\n          dataAndChecked: [],\n          showFilter: false,\n          curFilterIndex: -1,\n          tableData: tableData,\n          keyColNeighbours: keyColNeighbours,\n          firstDegNeighbours: firstDegNeighbours,\n          previewColIndex: -1,\n          lastAction: lastAction,\n          prevState: prevState,\n        })\n      })\n      })\n    }\n  }\n\n  // This function hanles switching tabs\n\n  handleTabSwitch(index) {\n    // If we are switching to \"Union Table\" tab from \"Wrangling Actions\" tab, we want to toggle off all the property neighbours.\n    // Since we might have potentially changed the table in table panel, thus changed the search criteria as well\n    if (index === 1) {\n      let propertyNeighbours = this.state.propertyNeighbours.slice();\n      for (let i = 0; i < propertyNeighbours.length; ++i) {\n        propertyNeighbours[i].isOpen = false;\n      }\n      this.setState({\n        propertyNeighbours: propertyNeighbours,\n        tabIndex: index,\n      });\n    }\n    else {\n      this.setState({\n        tabIndex: index,\n      })\n    }\n  }\n\n  // This function undos the previous change that user has made to the result table in table panel\n\n  undoPreviousStep() {\n    // We first get which action we need to undo\n    let lastAction = this.state.lastAction;\n    // Then we fetch the previous state\n    let prevState = this.state.prevState;\n    // console.log(lastAction);\n    // console.log(prevState);\n\n    // Note, since we are allowing one step undo only, we set lastAction to \"\" everytime we run this function\n\n    // Case 1: Undo the ULR Paste. \n    // In this case we need to restore urlPasted, iframeURL, originTableArray, and tableOpenList\n    if (lastAction === \"handleURLPaste\") {\n      this.setState({\n        urlPasted: prevState.urlPasted,\n        iframeURL: prevState.iframeURL,\n        originTableArray: prevState.originTableArray,\n        tableOpenList: prevState.tableOpenList,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 2: Undo the selection of the task: startSubject.\n    // In this case we need to restore usecaseSelected, tableData, firstColSelection, firstColChecked, tabIndex, and curActionInfo\n\n    else if (lastAction === \"handleStartSubject\") {\n      this.setState({\n        usecaseSelected: prevState.usecaseSelected,\n        tableData: prevState.tableData,\n        firstColSelection: prevState.firstColSelection,\n        firstColChecked: prevState.firstColChecked,\n        tabIndex: prevState.tabIndex,\n        curActionInfo: prevState.curActionInfo,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 3: Undo the selection of the task: startTable.\n    // In this case we need to restore many states. See code below.\n\n    else if (lastAction === \"handleStartTable\") {\n      this.setState({\n        firstColFilled: prevState.firstColFilled,\n        selectedTableIndex: prevState.selectedTableIndex,\n        propertyNeighbours: prevState.propertyNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        keyColIndex: prevState.keyColIndex,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        usecaseSelected: prevState.usecaseSelected,\n        tabIndex: prevState.tabIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 4: Undo the population of key column.\n    // In this case we need to restore keyColIndex, keyColNeighbours, firstDegNeighbours, firstColFilled, \n    //                                 curActionInfo, tableData, tableHeader\n\n    else if (lastAction === \"populateKeyColumn\") {\n      this.setState({\n        keyColIndex: prevState.keyColIndex,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        firstColFilled: prevState.firstColFilled,\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 5: Undo the population of a new column.\n    // In this case we need to restore curActionInfo, tableData.\n    else if (lastAction === \"populateOtherColumn\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 6: Undo the population of same neighbour in different columns.\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap.\n    else if (lastAction === \"sameNeighbourDiffRow\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 7: Undo the population of same neighbour in the same column.\n    // In this case we need to restore the curActionInfo, tableData.\n    else if (lastAction === \"sameNeighbourOneRow\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 9: Undo the union of tables.\n    // In this case we need to restore tableData\n    else if (lastAction === \"unionTable\" || lastAction === \"unionPage\" || lastAction === \"unionProperty\") {\n      this.setState({\n        tableData: prevState.tableData,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 10: Undo the addition of a new column\n    else if (lastAction === \"contextAddColumn\") {\n      this.setState({\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        curActionInfo: prevState.curActionInfo,\n        keyColIndex: prevState.keyColIndex,\n        previewColIndex: prevState.previewColIndex,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        tabIndex: prevState.tabIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 11: Undo the set of search cell.\n    else if (lastAction === \"contextSetColumn\") {\n      this.setState({\n        keyColIndex: prevState.keyColIndex,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        tabIndex: prevState.tabIndex,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // // Case 12: Undo the showing of cell origin.\n    // else if (lastAction === \"contextCellOrigin\") {\n    //   this.setState({\n    //     curActionInfo: prevState.curActionInfo,\n    //     tabIndex: prevState.tabIndex,\n    //     lastAction: \"\",\n    //   })\n    // }\n\n    // Case 12: Undo the showing of cell preview.\n    else if (lastAction === \"originPreviewPage\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tabIndex: prevState.tabIndex,\n        pageHidden: prevState.pageHidden,\n        iframeURL: prevState.iframeURL,\n        previewInfoArray: prevState.previewInfoArray,\n        previewInfoExpanded: prevState.previewInfoExpanded,\n        selectedCell: prevState.selectedCell,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 13: Undo the deletion of column.\n    else if (lastAction === \"contextDeleteColumn\") {\n      this.setState({\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        keyColIndex: prevState.keyColIndex,\n        previewColIndex: prevState.previewColIndex,\n        propertyNeighbours: prevState.propertyNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 14: Undo the sorting of a column.\n    else if (lastAction === \"contextSortColumn\") {\n      this.setState({\n        tableData: prevState.tableData,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 14: Undo the deduping of a column.\n    else if (lastAction === \"contextDedupColumn\") {\n      this.setState({\n        tableData: prevState.tableData,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        tabIndex: prevState.tabIndex,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 15: Undo the row filtering based on column filters.\n    else if (lastAction === \"applyFilter\") {\n      this.setState({\n        tableData: prevState.tableData,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        curActionInfo: prevState.curActionInfo,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // Case 16: Undo the joining of two tables.\n    else if (lastAction === \"runJoin\") {\n      this.setState({\n        curActionInfo: prevState.curActionInfo,\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        keyColNeighbours: prevState.keyColNeighbours,\n        previewColIndex: prevState.previewColIndex,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        lastAction: \"\",\n      })\n    }\n\n    else if (lastAction === \"confirmAddFirstCol\") {\n      this.setState({\n        tableData: prevState.tableData,\n        firstDegNeighbours: prevState.firstDegNeighbours,\n        keyColNeighbours: prevState.keyColNeighbours,\n        firstColHeaderInfo: prevState.firstColHeaderInfo,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    else if (lastAction === \"toggleOtherNeighbour\") {\n      this.setState({\n        tableData: prevState.tableData,\n        previewColIndex: prevState.previewColIndex,\n        otherColChecked: prevState.otherColChecked,\n        otherColCheckedIndex: prevState.otherColCheckedIndex,\n        lastAction: \"\",\n      })\n    }\n\n    else if (lastAction === \"populateRecommendation\") {\n      this.setState({\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        keyColIndex: prevState.keyColIndex,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        curActionInfo: prevState.curActionInfo,\n        tabIndex: prevState.tabIndex,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    else if (lastAction === \"populateStartRecommend\") {\n      this.setState({\n        tableData: prevState.tableData,\n        tableHeader: prevState.tableHeader,\n        keyColIndex: prevState.keyColIndex,\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\n        curActionInfo: prevState.curActionInfo,\n        tabIndex: prevState.tabIndex,\n        previewColIndex: prevState.previewColIndex,\n        lastAction: \"\",\n      })\n    }\n\n    // This is an empty else clause.\n    else {\n\n    }\n  }\n\n  // The two following functions opens/closes the modal for union table settings.\n\n  openModal() {\n    this.setState({\n      showSetting: true,\n    })\n  }\n\n  closeModal() {\n    this.setState({\n      showSetting: false,\n    })\n  }\n\n  // The following function toggles this.state.showTableSelection.\n\n  toggleTableSelection() {\n    let showTableSelection = !this.state.showTableSelection;\n    this.setState({\n      showTableSelection: showTableSelection,\n    })\n  }\n\n  // The following function handles the toggling of \"show unionable tables\" and \"show joinable tables\".\n  // based on whether the string passed in is \"union\" or \"join\"\n\n  toggleUnionJoin(e, str) {\n    // In this case we are toggling on/off unionable tables \n    if (str === \"union\") {\n      this.setState({\n        showUnionTables: !this.state.showUnionTables,\n        showJoinTables: false,\n      })\n    }\n    // In this case we are toggling on/off joinable tables \n    else {\n      // Note: every time before we toggle on joinable tables, let's set all this.state.tableOpenList to false\n      let tableOpenList = this.state.tableOpenList.slice();\n      for (let i = 0; i < tableOpenList.length; ++i) {\n        tableOpenList[i] = false;\n      }\n      this.setState({\n        showUnionTables: false,\n        showJoinTables: !this.state.showJoinTables,\n        tableOpenList: tableOpenList,\n      })\n    }\n  }\n\n  // The following function handles the join of a selected table with the table in tablePanel.\n\n  handleJoinTable(e, i) {\n    // We need to get two arrays of column headers. One for the table panel table, one for the selected table to join.\n    let tableHeader = _.cloneDeep(this.state.tableHeader);\n    let originTableHeader = [];\n    let joinTableHeader = [];\n\n    // Note: both originTableHeader and joinTableHeader are array of objects with three properties: label, value, and index\n\n    // First we get the header for the origin table\n    // console.log(tableHeader);\n    // Let's loop through this tableHeader to fill the originTableHeader\n    for (let i = 0; i < tableHeader.length; ++i) {\n      // If the current element in table header has length of 0, it means it's empty\n      if (tableHeader[i].length === 0) {\n        break;\n      }\n      else {\n        // We loop through the tableHeader[i]\n        let value = \"\";\n        for (let j = 0; j < tableHeader[i].length; ++j) {\n          let valueToAdd = j > 0 ? \"&\" + tableHeader[i][j].value : tableHeader[i][j].value;\n          value+=valueToAdd;\n        }\n        originTableHeader.push(\n          {\n            \"value\":value,\n            \"label\":value,\n            \"index\":i\n          }\n        )\n      }\n    }\n    // console.log(originTableHeader);\n\n    // Now that we have originTableHeader working correctly, let's get the joinTableHeader\n    let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\n    let joinTableData = setTableFromHTML(this.state.originTableArray[i], urlOrigin);\n    // console.log(joinTable);\n\n    // We start the index from 1, because 0 index corresponds to OriginURL\n    for (let i = 0; i < joinTableData[0].length; ++i) {\n      joinTableHeader.push(\n        {\n          \"value\":joinTableData[0][i].data,\n          \"label\":joinTableData[0][i].data,\n          \"index\":i\n        }\n      )\n    }\n\n    // Now we take a look at originTableHeader, joinTableHeader, and joinTable\n    // console.log(originTableHeader);\n    // console.log(joinTableHeader);\n    // console.log(joinTableData);\n\n    // It seems like we have fetched the right values. \n    // Now we use these to update states, so that jon modal can display the right content.\n\n    // Bugfix here: if either tableHeader is empty, we want to show an alert message\n    if (originTableHeader.length === 0 || joinTableHeader.length === 0) {\n      alert(\"One of the join tables have no data. Join cannot be performed.\");\n    }\n    else {\n      this.setState({\n        showJoinModal: true,\n        joinTableIndex: i,\n        joinTableData: joinTableData,\n        originColOptions: originTableHeader,\n        joinColOptions: joinTableHeader,\n      })\n    }\n  }\n\n  // The following function handles cancelling the join operation.\n\n  cancelJoin(e) {\n    this.setState({\n      showJoinModal: false,\n    })\n  }\n\n  // The following function handles the selection of join columns.\n  // It updates either originJoinIndex, or joinJoinIndex, based on the second parameter passed in\n\n  selectJoinColumn(e, table) {\n    // console.log(e.index);\n    if (table === \"originTable\") {\n      this.setState({\n        originJoinIndex: e.index,\n      })\n    }\n    else {\n      this.setState({\n        joinJoinIndex: e.index,\n      })\n    }\n  }\n\n  // The function handles the actual join of two selected tables. \n  // Currently, the only join type supported is left join\n\n  // Since join is equal to column addition, we need to update tableData, tableHeader, optionsMap, and selectedClassAnnotation\n  runJoin(e) {\n    // First check all the info that we needed\n    let joinTableData = this.state.joinTableData.slice();\n    let originJoinIndex = this.state.originJoinIndex;\n    let joinJoinIndex = this.state.joinJoinIndex;\n    // console.log(joinTableData);\n    // console.log(originJoinIndex);\n    // console.log(joinJoinIndex);\n    \n    // If the join table has n columns, then we are adding n-1 new columns to the table in table panel.\n    // Since we only allow join of one column from each table.\n\n    // Let's deal with tableHeader, optionsMap, and selectedCalssAnnotation, before we move on to tableData.\n    let tableHeaderUpdated = this.state.tableHeader.slice();\n    let optionsMapUpdated = this.state.optionsMap.slice();\n    let selectedClassAnnotationUpdated = this.state.selectedClassAnnotation.slice();\n\n    // First we handle tableHeader's addition.\n    // We first loop through tableHeader to remove all the empty ones\n    for (let i = 0; i < tableHeaderUpdated.length; ++i) {\n      if (tableHeaderUpdated[i] === \"\") {\n        tableHeaderUpdated.splice(i,1);\n        --i;\n      }\n    }\n    // Now we push on the new columns. Note that it has to be in the form of an array\n    for (let i = 0; i < joinTableData[0].length; ++i) {\n      if (i !== joinJoinIndex) {\n        tableHeaderUpdated.push(\n          [\n            {\n              \"value\":joinTableData[0][i].data,\n              \"label\":joinTableData[0][i].data\n            }\n          ]\n        )\n      }\n    }\n    // console.log(tableHeaderUpdated); \n\n    // Then we handle optionsMap's addition. We do not need to do much here.\n    // We start the index from 1, because we only add in n-1 new columns.\n    for (let i = 1; i < joinTableData[0].length; ++i) {\n      optionsMapUpdated.push([]);\n    }\n    // console.log(optionsMapUpdated);\n\n    // Then we handle selectedClassAnnotation's addition.\n    let queryPromise = [findClassAnnotation(this.state.originTableArray[this.state.joinTableIndex])];\n    allPromiseReady(queryPromise).then((values) => {\n    // Note, we need to push on an empty [] to values here, corresponding to the originURL column's class annotation\n    values[0].splice(0, 0, []);\n    for (let i = 0; i < values[0].length; ++i) {\n      if (i !== joinJoinIndex) {\n        selectedClassAnnotationUpdated.push(values[0][i]);\n      }\n    }\n    console.log(selectedClassAnnotationUpdated);\n    \n    // Lastly, and most importantly, we want to handle tableData's change.\n    // Let's start with an empty tableDataUpdated. Loop through tableData. \n    // Use a bool to keep track of if tableData[i][originJoinIndex] is in join table. For every yes, we push one element onto tableDataUpdated.\n    // If at the end, the bool is still no, we push on tableData[i] with a bunch of N/A's at the position of the newly added columns.\n    let tableData = _.cloneDeep(this.state.tableData);\n    let tableDataUpdated = [];\n    // Let's first run some code to process joinTableData, so that it shares the same format as tableData\n    // Now, let's deal with tableData. Wee need to handle both data and origin.\n    let joinTableHeader = [];\n    for (let j=0;j<joinTableData[0].length;++j) {\n      joinTableHeader.push(\n        {\"value\":joinTableData[0][j].data\n        ,\"label\":joinTableData[0][j].data}\n      )\n    }\n    let joinTableDataUpdated = [];\n    // console.log(tableDataExplore);\n    // This starts the loop for rows\n    for (let i=1;i<joinTableData.length;++i) {\n      let tempRow = [];\n      // This starts the loop for columns\n      for (let j=0;j<joinTableData[i].length;++j) {\n        // First set the data\n        let data = joinTableData[i][j].data;\n        // Then set the origin\n        let origin = [];\n        let originText = joinTableData[i][j].origin+\": \"+joinTableHeader[j].value+\": \"+joinTableData[i][j].data;\n        origin.push(originText);\n        tempRow.push({\"data\":data,\"origin\":origin});\n      }\n      joinTableDataUpdated.push(tempRow);\n    }\n\n    // Take a look at tableData, and joinTableDataUpdated\n    // console.log(tableData);\n    // console.log(joinTableDataUpdated);\n\n    // Now we can finally start the join operator\n    for (let i = 0; i < tableData.length; ++i) {\n      let curJoinEntry = tableData[i][originJoinIndex].data;\n      console.log(\"Current entry to join is \"+curJoinEntry);\n      let curEntryFound = false;\n      // We start the index from 1 because the first column in joinTableData is the header\n      for (let j = 0; j < joinTableDataUpdated.length; ++j) {\n        if (joinTableDataUpdated[j][joinJoinIndex].data === curJoinEntry) {\n          // console.log(\"A match has been found at index \"+j);\n          // Let's create the tempRow that we want to push onto tableDataUpdated\n\n          let tempRow = _.cloneDeep(tableData[i]);\n          for (let k = 0; k < joinTableDataUpdated[j].length; ++k) {\n            if (k !== joinJoinIndex) {\n              tempRow.push(joinTableDataUpdated[j][k]);\n            }\n          }\n          tableDataUpdated.push(tempRow);\n          curEntryFound = true;\n        }\n      }\n      // If this current entry does NOT have a corresponding entry in the join table,\n      // We push it directly onto tableDataUpdated, with the addtion of some N/A's.\n      if (curEntryFound === false) {\n        // Let's create the tempRow that we want to push onto tableDataUpdated\n\n        // Code Placeholder\n        let tempRow = _.cloneDeep(tableData[i]);\n        for (let k = 0; k < joinTableDataUpdated[0].length; ++k) {\n          if (k !== joinJoinIndex) {\n            tempRow.push(\n              {\n                \"data\":\"N/A\",\n                \"origin\":[]\n              }\n            );\n          }\n        }\n        tableDataUpdated.push(tempRow);\n      }\n    }\n    // console.log(tableDataUpdated);\n\n    // Now, we have correctly got everything we needed: tableDataUpdated, tableHeaderUpdated, optionsMapUpdated, selectedClassAnnotationUpdated\n    // Let's add some support for undo, and do not forget to close the joinModal\n\n    // Bugfix: since this function potentially changes the number of rows too, we need to update firstDegNeighbours and keyColNeighbours\n    let promiseArrayOne = this.getNeighbourPromise(tableDataUpdated, \"subject\", this.state.keyColIndex);\n    let promiseArrayTwo = this.getNeighbourPromise(tableDataUpdated, \"object\", this.state.keyColIndex);\n    allPromiseReady(promiseArrayOne).then((valuesOne) => {\n    allPromiseReady(promiseArrayTwo).then((valuesTwo) => {\n\n      // We call updateNeighbourInfo here because we are changing the rows\n      let updatedNeighbours = updateNeighbourInfo(valuesOne, valuesTwo);\n      let keyColNeighbours = updatedNeighbours.keyColNeighbours;\n      let firstDegNeighbours = updatedNeighbours.firstDegNeighbours;\n\n      // Support for undo: \n      let lastAction = \"runJoin\";\n      let prevState = \n        {\n          \"curActionInfo\":this.state.curActionInfo,\n          \"tableData\":this.state.tableData,\n          \"tableHeader\":this.state.tableHeader,\n          \"keyColNeighbours\":this.state.keyColNeighbours,\n          \"firstDegNeighbours\":this.state.firstDegNeighbours,\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\n          \"previewColIndex\": this.state.previewColIndex,\n        };\n\n      this.setState({\n        curActionInfo:{\"task\":\"afterPopulateColumn\"},\n        tableData:tableDataUpdated,\n        tableHeader:tableHeaderUpdated,\n        keyColNeighbours:keyColNeighbours,\n        firstDegNeighbours:firstDegNeighbours,\n        selectedClassAnnotation:selectedClassAnnotationUpdated,\n        showJoinModal: false,\n        previewColIndex: -1,\n        lastAction:lastAction,\n        prevState:prevState,\n      })\n    })\n    })\n    })\n  }\n\n  // This function handles the expansion/collapse of an attribute in cell preview and origin\n  togglePreviewElement(e, i) {\n    let previewInfoExpanded = this.state.previewInfoExpanded.slice();\n    previewInfoExpanded[i] = !previewInfoExpanded[i];\n    this.setState({\n      previewInfoExpanded: previewInfoExpanded,\n    })\n  }\n\n  render() {\n    let bodyEle;\n    let bottomContentClass = \" bottom-content\";\n    let topContentClass = \"row top-content\";\n    if (this.state.pageHidden) {\n      bottomContentClass = \" bottom-content-hidden\";\n      topContentClass = \"row top-content-large\";\n    }\n    // If user has not pasted the URL, we want to display the landing page\n    if (this.state.urlPasted === \"\") {\n      bodyEle = \n        <LandingPage \n          handleURLPaste={this.handleURLPaste} \n        />;\n    }\n    // Else, we show the three panels: TablePanel, ActionPanel, and PagePanel\n    else {\n      bodyEle = (\n        <div>\n          <div className=\"header\">\n            <Header \n              // Following states are passed for general purposes\n              copyTable={this.copyTable}\n              undoPreviousStep={this.undoPreviousStep}\n              openModal = {this.openModal}\n            />\n          </div> \n          <div className=\"mainbody\">\n            <div className=\"\">\n              <div className={topContentClass}>\n                <div className=\"col-md-7 small-padding table-panel\">\n                  <TablePanel\n                    urlPasted={this.state.urlPasted}\n                    usecaseSelected={this.state.usecaseSelected}\n                    // Following states are passed to \"startSubject\"\n                    tableHeader={this.state.tableHeader}\n                    tableData={this.state.tableData}\n                    keyColIndex={this.state.keyColIndex}\n                    onCellChange={this.cellChange}\n                    selectColHeader={this.selectColHeader}\n                    getKeyOptions={this.getKeyOptions}\n                    optionsMap={this.state.optionsMap}\n                    contextAddColumn={this.contextAddColumn}\n                    contextDeleteColumn={this.contextDeleteColumn}\n                    contextSetColumn={this.contextSetColumn}\n                    originPreviewPage={this.originPreviewPage}\n                    showFilterMethods={this.showFilterMethods}\n                    // Following states control the render of first column header\n                    firstColFilled={this.state.firstColFilled}\n                    handlePlusClick={this.handlePlusClick}\n                    firstColHeaderInfo={this.state.firstColHeaderInfo}\n                    // Following states control the render of other column header\n                    getOtherOptions={this.getOtherOptions}\n                    // Following states control the render of column preview\n                    previewColIndex={this.state.previewColIndex}\n                  />\n                </div>\n                <div className=\"col-md-5 small-padding action-panel\">\n                  <ActionPanel\n                    \n                    urlPasted={this.state.urlPasted}\n                    usecaseSelected={this.state.usecaseSelected}\n                    curActionInfo={this.state.curActionInfo}\n                    handleStartSubject={this.handleStartSubject}\n                    populateKeyColumn={this.populateKeyColumn}\n                    populateOtherColumn={this.populateOtherColumn}\n                    sameNeighbourDiffRow={this.sameNeighbourDiffRow}\n                    sameNeighbourOneRow={this.sameNeighbourOneRow}\n                    populateRecommendation={this.populateRecommendation}\n                    populateStartRecommend={this.populateStartRecommend}\n                    // Folloiwng states are passed to \"startTable\"\n                    handleStartTable={this.handleStartTable}\n                    propertyNeighbours={this.state.propertyNeighbours}\n                    togglePropertyNeighbours={this.togglePropertyNeighbours}\n                    toggleSibling={this.toggleSibling}\n                    toggleOtherTable={this.toggleOtherTable}\n                    unionTable={this.unionTable}\n                    unionPage={this.unionPage}\n                    unionProperty={this.unionProperty}\n                    // Follow state handles tab switch\n                    tabIndex={this.state.tabIndex}\n                    handleTabSwitch={this.handleTabSwitch}\n                    // Following states are passed during start up\n                    showTableSelection={this.state.showTableSelection}\n                    toggleTableSelection={this.toggleTableSelection}\n                    originTableArray={this.state.originTableArray}\n                    tableOpenList={this.state.tableOpenList}\n                    toggleTable={this.toggleTable}\n                    selectedTableIndex={this.state.selectedTableIndex}\n                    // Following states are for union/join tables\n                    showUnionTables={this.state.showUnionTables}\n                    showJoinTables={this.state.showJoinTables}\n                    toggleUnionJoin={this.toggleUnionJoin}\n                    handleJoinTable={this.handleJoinTable}\n                    // Following states are for first column's header selection\n                    firstColSelection={this.state.firstColSelection}\n                    firstColChecked={this.state.firstColChecked}\n                    firstColFilled={this.state.firstColFilled}\n                    keyColIndex={this.state.keyColIndex}\n                    toggleFirstNeighbour={this.toggleFirstNeighbour}\n                    tableHeader={this.state.tableHeader}\n                    keyCheckedIndex={this.state.keyCheckedIndex}\n                    addToFirstCol={this.addToFirstCol}\n                    confirmAddFirstCol={this.confirmAddFirstCol}\n                    // Following states are for other column's header selection\n                    otherColSelection={this.state.otherColSelection}\n                    otherColChecked={this.state.otherColChecked}\n                    otherCheckedIndex={this.state.otherCheckedIndex}\n                    toggleOtherNeighbour={this.toggleOtherNeighbour}\n                    // Following states are for column's processing methods\n                    contextSortColumn={this.contextSortColumn}\n                    contextDedupColumn={this.contextDedupColumn}\n                    openFilter={this.openFilter}\n                    // Following states are for displaying cell's preview and origin\n                    previewInfoArray={this.state.previewInfoArray}\n                    previewInfoExpanded={this.state.previewInfoExpanded}\n                    selectedCell={this.state.selectedCell}\n                    togglePreviewElement={this.togglePreviewElement}\n                    // Following states are for showStartRecommend\n                    keyColNeighbours={this.state.keyColNeighbours}\n                  />\n                </div>\n              </div>\n              <div className={bottomContentClass}>\n                <div>\n                  <PagePanel\n                    pageHidden={this.state.pageHidden}\n                    iframeURL={this.state.iframeURL}\n                    toggleWikiPage={this.toggleWikiPage}\n                  />\n                </div>\n              </div>\n              <div>\n                <SettingModal \n                  showSetting={this.state.showSetting}\n                  closeModal={this.closeModal}\n                  semanticEnabled={this.state.semanticEnabled}\n                  toggleSemantic={this.toggleSemantic}\n                  unionCutOff={this.state.unionCutOff}\n                  unionCutOffChange={this.unionCutOffChange}\n                />\n              </div>\n              <div>\n                <FilterModal\n                  showFilter={this.state.showFilter}\n                  dataAndChecked={this.state.dataAndChecked}\n                  checkAll={this.state.checkAll}\n                  applyFilter={this.applyFilter}\n                  cancelFilter={this.cancelFilter}\n                  toggleChecked={this.toggleChecked}\n                  toggleAll={this.toggleAll}\n                />\n              </div>\n              <div>\n                <JoinModal \n                  showJoin={this.state.showJoinModal}\n                  cancelJoin={this.cancelJoin}\n                  originColOptions={this.state.originColOptions}\n                  joinColOptions={this.state.joinColOptions}\n                  originJoinIndex={this.state.originJoinIndex}\n                  joinJoinIndex={this.state.joinJoinIndex}\n                  selectJoinColumn={this.selectJoinColumn}\n                  runJoin={this.runJoin}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"footer\">\n            <Footer />\n          </div> \n        </div>\n      );\n    }\n    return <div>{bodyEle}</div>;\n  }\n}\n\nexport default MainBody;\n\n// This function takes in a queryURL and returns its JSON format\nfunction fetchJSON(url) {\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\n  return fetch(urlCORS)\n        .then(function (response) {\n          if (!response.ok) {\n            throw Error(1);\n          }\n          return response;\n        })\n        .then(function (response) {\n          return response.json();\n        })\n        .catch(function (error) {\n          document.body.classList.remove('waiting');\n          // alert(\"Some error occured when accessing SPARQL public endpoint. If semantic mapping is enabled, disable it and try again.\");\n          return 1;\n        })\n}\n\n// This function takes in a queryURL and returns its Text format\nfunction fetchText(url) {\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\n  return fetch(urlCORS).then((response) => response.text());\n}\n\n// This function ensures that all promises in promiseArray are ready\nfunction allPromiseReady(promiseArray) {\n  return Promise.all(promiseArray);\n}\n\n// This function replaces string so that the result can be used in queryURL.\n// It currently replaces \"(\", \")\", \"'\", \"-\", \" \", \"&\", \".\", \"\"\",and \"/\"\nfunction regexReplace(str) {\n  return str\n    .replace(/\\$/g, \"%5Cu0024\")\n    .replace(/%/g, \"%5Cu0025\")\n    .replace(/!/g, \"%5Cu0021\")\n    .replace(/\"/g, \"%5Cu0022\")\n    .replace(/#/g, \"%5Cu0023\")\n    .replace(/&/g, \"%5Cu0026\")\n    .replace(/'/g, \"%5Cu0027\")\n    .replace(/\\(/g, \"%5Cu0028\")\n    .replace(/\\)/g, \"%5Cu0029\")\n    .replace(/\\*/g, \"%5Cu002A\")\n    .replace(/\\+/g, \"%5Cu002B\")\n    .replace(/-/g, \"%5Cu002D\")\n    .replace(/;/g, \"%5Cu003B\")\n    .replace(/</g, \"%5Cu003C\")\n    .replace(/=/g, \"%5Cu003D\")\n    .replace(/>/g, \"%5Cu003E\")\n    .replace(/\\?/g, \"%5Cu003F\")\n    .replace(/\\./g, \"%5Cu002E\")\n    .replace(/\\//g, \"%5Cu002F\")\n    .replace(/,/g, \"%5Cu002C\")\n    .replace(/\\s/g, \"_\")\n    .replace(/@/g, \"%5Cu0040\")\n    .replace(/\\^/g, \"%5Cu005E\")\n    .replace(/~/g, \"%5Cu007E\")\n    .replace(/`/g, \"%5Cu0060\")\n    .replace(/\\|/g, \"%5Cu007C\")\n    .replace(/\\[/g, \"%5Cu005B\")\n    .replace(/\\\\/g, \"%5Cu005C\")\n    .replace(/\\]/g, \"%5Cu005D\")\n    .replace(/\\{/g, \"%5Cu007B\")\n    .replace(/\\}/g, \"%5Cu007D\");\n}\n\n// This function replaces the URL pasted\nfunction urlReplace(str) {\n  return str\n    .replace(/%E2%80%93/g, \"%5Cu2013\")\n    .replace(/\\$/g, \"%5Cu0024\")\n    .replace(/!/g, \"%5Cu0021\")\n    .replace(/\"/g, \"%5Cu0022\")\n    .replace(/#/g, \"%5Cu0023\")\n    .replace(/&/g, \"%5Cu0026\")\n    .replace(/'/g, \"%5Cu0027\")\n    .replace(/\\(/g, \"%5Cu0028\")\n    .replace(/\\)/g, \"%5Cu0029\")\n    .replace(/\\*/g, \"%5Cu002A\")\n    .replace(/\\+/g, \"%5Cu002B\")\n    .replace(/-/g, \"%5Cu002D\")\n    .replace(/;/g, \"%5Cu003B\")\n    .replace(/</g, \"%5Cu003C\")\n    .replace(/=/g, \"%5Cu003D\")\n    .replace(/>/g, \"%5Cu003E\")\n    .replace(/\\?/g, \"%5Cu003F\")\n    .replace(/\\./g, \"%5Cu002E\")\n    .replace(/\\//g, \"%5Cu002F\")\n    .replace(/,/g, \"%5Cu002C\")\n    .replace(/\\s/g, \"_\")\n    .replace(/@/g, \"%5Cu0040\")\n    .replace(/\\^/g, \"%5Cu005E\")\n    .replace(/~/g, \"%5Cu007E\")\n    .replace(/`/g, \"%5Cu0060\")\n    .replace(/\\|/g, \"%5Cu007C\")\n    .replace(/\\[/g, \"%5Cu005B\")\n    .replace(/\\\\/g, \"%5Cu005C\")\n    .replace(/\\]/g, \"%5Cu005D\")\n    .replace(/\\{/g, \"%5Cu007B\")\n    .replace(/\\}/g, \"%5Cu007D\");\n}\n\n// This function removes the prefix \"http://dbpedia.org/resource/\" from query results, if it includes one\n\nfunction removePrefix(str) {\n  let prefixToRemove = \"http://dbpedia.org/resource/\";\n  // If dbResult contains prefix of \"http://dbpedia.org/resource/\", we want to remove it\n  if (str.includes(prefixToRemove) === true) {\n     str = str.slice(28);\n  }\n  return str;\n}\n\n// This function updates the key column's neighbours for ONE entry from the search column.\n\n// It taks three parameters:\n//  1) array \"keyColNeighbour\" storing list of neighbours for the key column\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\n//  3) string \"type\", either \"subject\" or \"object\"\n\n// It returns the updated keyColNeighbours\nfunction updateKeyColNeighbours(keyColNeighbours, resultsBinding, type) {\n\n  // we first filter out those in resultsBinding according to three criterias\n\n  // 1) p.value.slice(28).length must > 1\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\n\n  let processedBinding = resultsBinding.filter(\n    a => a.p.value.slice(28).length > 1 &&\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\n         !(a.p.value.includes(\"wikiPage\") \n         || a.p.value.includes(\"align\") \n         || a.p.value.includes(\"abstract\") \n         || a.p.value.includes(\"caption\") \n         || a.p.value.includes(\"image\") \n         || a.p.value.includes(\"width\") \n         || a.p.value.includes(\"thumbnail\") \n         || a.p.value.includes(\"blank\")\n         || a.p.value.includes(\"fec\")\n         || a.p.value.includes(\"viaf\")\n         || a.p.value.includes(\"soundRecording\")\n         || a.p.value.includes(\"votesmart\")\n         || a.p.value.includes(\"wordnet\")\n         || a.p.value.includes(\"float\")\n         || a.p.value.includes(\"bbr\")\n         || a.p.value === \"http://dbpedia.org/property/alt\"\n         || a.p.value === \"http://dbpedia.org/property/by\"\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\n         || a.p.value === \"http://dbpedia.org/property/signature\"\n         || a.p.value === \"http://dbpedia.org/property/video\"\n         || a.p.value === \"http://dbpedia.org/property/logo\"\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\n         || a.p.value === \"http://dbpedia.org/property/body\"\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\n         || a.p.value === \"http://dbpedia.org/property/nba\"\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\n         )\n  );\n\n  // We then do some filtering based on subPropertyOf.\n  // Because of our observation, we only want to keep entries whose subPropertyOf attribute is from the DUL dataset.\n  // processedBinding = processedBinding.filter(a => a.subPropertyOf === undefined || a.subPropertyOf.value.includes(\"DUL.owl\"));\n  processedBinding = processedBinding.filter(function(a) {\n    if (a.subPropertyOf !== undefined) {\n      return a.subPropertyOf.value.includes(\"DUL.owl\");\n    }\n    return true;\n  })\n\n  // we then sort the resultsBinding by p.value.slice(28)\n  processedBinding = processedBinding.sort((a, b) =>\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\n  );\n\n  // we take a look at processedBinding at this stage\n  // console.log(processedBinding);\n\n  // Let's only start the loop is processedBinding is non-empty\n  if (processedBinding.length > 0) {\n    // We set count of neighbour ready to be added\n    let neighbourCount = 1;  \n\n    // We set literal of neighbour ready to be added.\n    // Morever, we get the value of the neighbour ready to be added, depending on type.\n    // Initialized with the first neighbour.\n\n    let neighbourToAdd = processedBinding[0].p.value.slice(28); \n    let valuesToAdd = [];\n    valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[0].o.value) : removePrefix(processedBinding[0].s.value))\n\n    // we set range of neighbour ready to be added. \"\" if doesn't exist.\n    let neighbourRange = processedBinding[0].range !== undefined ? processedBinding[0].range.value : \"\";\n\n    // we the subPropertyOf of neighbour ready to be added. \"\" if doesn't exist.\n    let neighbourSubPropertyOf = processedBinding[0].subPropertyOf !== undefined ? processedBinding[0].subPropertyOf.value : \"\";\n    \n    // We loop over processedBinding\n    for (let i = 1; i < processedBinding.length; ++i) {\n      let curNeighbour = processedBinding[i].p.value.slice(28);\n      // If the current neighbour is equal to neighbourToAdd, we increment the count, and push onto valuesToAdd\n      if (curNeighbour === neighbourToAdd) {\n        ++neighbourCount;\n        valuesToAdd.push(type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value))\n      }\n      // else, we push neighbourToAdd to keyColNeighbours. \n      else {\n        // set value.\n        let objValue = neighbourToAdd;\n        // set label. We want to change the neighbour label if type === \"object\".\n        let objLabel = neighbourToAdd;\n        if (type === \"object\") {\n          objLabel = \"is \" + objLabel + \" of\";\n        }\n        // set type\n        let objType = type;\n        // set count\n        let objCount = neighbourCount;\n        // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\n        let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\n        // set range\n        let objRange = neighbourRange;\n        // set subPropertyOf\n        let objSubPropertyOf = neighbourSubPropertyOf;\n\n        // Set object from all its attributes\n        let tempObj = {\n          \"value\":objValue, \n          \"label\":objLabel, \n          \"type\":objType, \n          \"count\":objCount, \n          \"filledCount\":1, \n          \"data\":objData,\n          \"range\":objRange,\n          \"subPropertyOf\":objSubPropertyOf\n        };\n        // We push this tempObj onto keyColNeighbours\n        keyColNeighbours.push(tempObj)\n\n        // We now need to reset neighbourCount, neighbourToAdd, neighbourRange, neighbourSubPropertyOf, and valuesToAdd\n        neighbourCount = 1;\n        neighbourToAdd = curNeighbour;\n        valuesToAdd = [type === \"subject\" ? removePrefix(processedBinding[i].o.value) : removePrefix(processedBinding[i].s.value)];\n        neighbourRange = processedBinding[i].range !== undefined ? processedBinding[i].range.value : \"\";\n        neighbourSubPropertyOf = processedBinding[i].subPropertyOf !== undefined ? processedBinding[i].subPropertyOf.value : \"\";\n      }\n    }\n    // Now, after the loop is done, we need to do one more iteration to determine how we want to add the last neighbour.\n    \n    // set value.\n    let objValue = neighbourToAdd;\n    // set label. We want to change the neighbour label if type === \"object\".\n    let objLabel = neighbourToAdd;\n    if (type === \"object\") {\n      objLabel = \"is \" + objLabel + \" of\";\n    }\n    // set type\n    let objType = type;\n    // set count\n    let objCount = neighbourCount;\n    // set data. Let's do some processing here: we want to ensure that valuesToAdd has a max length of maxNeighbourCount\n    let objData = valuesToAdd.length <= maxNeighbourCount ? valuesToAdd : valuesToAdd.slice(0, maxNeighbourCount);\n    // set range\n    let objRange = neighbourRange;\n    // set subPropertyOf\n    let objSubPropertyOf = neighbourSubPropertyOf;\n\n    // Set object from all its attributes\n    let tempObj = {\n        \"value\":objValue, \n        \"label\":objLabel, \n        \"type\":objType, \n        \"count\":objCount, \n        \"filledCount\":1, \n        \"data\":objData,\n        \"range\":objRange,\n        \"subPropertyOf\":objSubPropertyOf\n      };\n    // we push this tempObj onto keyColNeighbours\n    keyColNeighbours.push(tempObj)\n  }\n\n  // console.log(keyColNeighbours);\n  // console.log(processedBinding);\n\n  return keyColNeighbours;\n}\n\n// This helper function is designed to process the result bindings passed from contextCellPreview.\n// It should share some similarity with updateKeyColNeighbours\n\n// It takes two parameters:\n//  1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\n//  2) string \"type\", either \"subject\" or \"object\"\n\n// It returns previewInfoArray, a list of objects used to display a cell's preview info\n// This object has two properties:\n// 1) key: a string\n// 2) value: an array of strings\nfunction updatePreviewInfo(resultsBinding, type) {\n  // console.log(previewInfoArray);\n  // console.log(resultsBinding);\n  // console.log(type);\n\n  // Let's do some preprocessing of resultsBinding. We want to do sorting, deduping, and some filtering.\n\n  // we first filter out those in resultsBinding according to three criterias\n\n  // 1) p.value.slice(28).length must > 1\n  // 2) p.value must include \"ontology\" or \"property\" (so it is one of dbo:XXXX or dbp:XXXX)\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\n\n  let processedBinding = resultsBinding.filter(\n    a => a.p.value.slice(28).length > 1 &&\n         (a.p.value.includes(\"ontology\") || a.p.value.includes(\"property\")) &&\n         !(a.p.value.includes(\"wikiPage\") \n         || a.p.value.includes(\"align\") \n         || a.p.value.includes(\"abstract\") \n         || a.p.value.includes(\"caption\") \n         || a.p.value.includes(\"image\") \n         || a.p.value.includes(\"width\") \n         || a.p.value.includes(\"thumbnail\") \n         || a.p.value.includes(\"blank\")\n         || a.p.value.includes(\"fec\")\n         || a.p.value.includes(\"viaf\")\n         || a.p.value.includes(\"soundRecording\")\n         || a.p.value.includes(\"votesmart\")\n         || a.p.value.includes(\"wordnet\")\n         || a.p.value.includes(\"float\")\n         || a.p.value.includes(\"bbr\")\n         || a.p.value === \"http://dbpedia.org/property/alt\"\n         || a.p.value === \"http://dbpedia.org/property/by\"\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\n         || a.p.value === \"http://dbpedia.org/property/signature\"\n         || a.p.value === \"http://dbpedia.org/property/video\"\n         || a.p.value === \"http://dbpedia.org/property/logo\"\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\n         || a.p.value === \"http://dbpedia.org/property/body\"\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\n         || a.p.value === \"http://dbpedia.org/property/nba\"\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\n         )\n  );\n\n\n  // we then sort the resultsBinding by p.value.slice(28)\n  processedBinding = processedBinding.sort((a, b) =>\n    a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\n  );\n\n  // Now let's create the previewInfoArray based on processedBinding\n  // console.log(processedBinding);\n\n  let previewInfoArray = [];\n\n  if (processedBinding.length > 1) {\n    // We first push on the first element from processedBinding\n\n    previewInfoArray.push(\n      {\n        \"key\": type === \"subject\" ? processedBinding[0].p.value.slice(28) : \"is \"+processedBinding[0].p.value.slice(28)+\" of\",\n        \"value\": [removePrefix(processedBinding[0].value.value)],\n      }\n    )\n    let curIndex = 0;\n    for (let i = 1; i < processedBinding.length; ++i) {\n      let curNeighbour = processedBinding[i].p.value.slice(28);\n      let prevNeighbour = processedBinding[i-1].p.value.slice(28);\n      // console.log(curNeighbour);\n      // console.log(prevNeighbour);\n\n      // If this neighbour is the same as the previous one, we want to append this neighbour's value\n      // to the element's value array in previewInfoArray at curIndex\n      if (curNeighbour === prevNeighbour) {\n        // Note, we dont want each element in previewInfoArray to contain too many elements (5), so we do a check here.\n        if (previewInfoArray[curIndex].value.length < maxNeighbourCount) {\n          previewInfoArray[curIndex].value.push(removePrefix(processedBinding[i].value.value));\n        }\n      }\n      // Else, we push a fresh element onto previewInforArray, and update curIndex\n      else {\n        previewInfoArray.push(\n          {\n            \"key\": type === \"subject\" ? processedBinding[i].p.value.slice(28) : \"is \"+processedBinding[i].p.value.slice(28)+\" of\",\n            \"value\":[removePrefix(processedBinding[i].value.value)],\n          }\n        )\n        ++curIndex;\n      }\n    }\n  }\n\n  // At the current stage, previewInfoArray contains all the dbo and dbp neighbours. \n  // Let's also add support for the DB categories, so that those can be displayed in cell preview as well.\n  let categoryPreviewInfoArray = [];\n  if (type === \"subject\") {\n    let categoryBinding = resultsBinding.filter(\n      a => a.p.value.includes(\"dc/terms/subject\")\n    ) \n    // console.log(categoryBinding);\n    if (categoryBinding.length > 0) {\n      categoryPreviewInfoArray.push(\n        {\n          \"key\": \"Category\",\n          \"value\": [categoryBinding[0].value.value.slice(37)]\n        }\n      );\n      for (let i = 1; i < categoryBinding.length; ++i) {\n        categoryPreviewInfoArray[0].value.push(categoryBinding[i].value.value.slice(37));\n      }\n    }\n  }\n  // We concat categoryPreviewInfoArray with previewInfoArray.\n  previewInfoArray = categoryPreviewInfoArray.concat(previewInfoArray);\n  // console.log(previewInfoArray);\n\n  return previewInfoArray;\n}\n\n// This function processes the resultsBinding passed from handleStartSubject, to create the info needed for Action Panel.\n// It should share some similarity with updatePreviewInfo\n\n// It takes one parameter:\n// 1) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\n// Note: \"type\" parameter is not needed, since we are not dealing with object neighbours\n\nfunction updateFirstColSelection(resultsBinding) {\n\n  // we first filter out those in resultsBinding according to three criterias\n  // Note: the second criteria is a bit different from updateKeyColNeighbours and updatePreviewInfo\n\n  // 1) p.value.slice(28).length must > 1\n  // 2) p.value must include \"ontology\", \"property\", or \"dc/terms/subject\" (so it is one of dbo:XXXX, dbp:XXXX, or dct:subject)\n  // 3) p.value must not include certain strings (which likely correspond to meaningless attributes)\n\n  let processedBinding = resultsBinding.filter(\n    a => a.p.value.slice(28).length > 1 \n         &&\n         (a.p.value.includes(\"ontology\") \n         || a.p.value.includes(\"property\")\n         || a.p.value.includes(\"dc/terms/subject\")\n         ) \n         &&\n         !(a.p.value.includes(\"wikiPage\") \n         || a.p.value.includes(\"align\") \n         || a.p.value.includes(\"abstract\") \n         || a.p.value.includes(\"caption\") \n         || a.p.value.includes(\"image\") \n         || a.p.value.includes(\"width\") \n         || a.p.value.includes(\"thumbnail\") \n         || a.p.value.includes(\"blank\")\n         || a.p.value.includes(\"fec\")\n         || a.p.value.includes(\"viaf\")\n         || a.p.value.includes(\"soundRecording\")\n         || a.p.value.includes(\"votesmart\")\n         || a.p.value.includes(\"wordnet\")\n         || a.p.value.includes(\"float\")\n         || a.p.value.includes(\"bbr\")\n         || a.p.value === \"http://dbpedia.org/property/alt\"\n         || a.p.value === \"http://dbpedia.org/property/by\"\n         || a.p.value === \"http://dbpedia.org/property/onlinebooks\"\n         || a.p.value === \"http://dbpedia.org/property/signature\"\n         || a.p.value === \"http://dbpedia.org/property/video\"\n         || a.p.value === \"http://dbpedia.org/property/logo\"\n         || a.p.value === \"http://dbpedia.org/property/shorts\"\n         || a.p.value === \"http://dbpedia.org/property/patternS\"\n         || a.p.value === \"http://dbpedia.org/property/patternB\"\n         || a.p.value === \"http://dbpedia.org/property/body\"\n         || a.p.value === \"http://dbpedia.org/property/hShorts\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/hPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/hBody\"\n         || a.p.value === \"http://dbpedia.org/property/aShorts\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternS\"\n         || a.p.value === \"http://dbpedia.org/property/aPatternB\"\n         || a.p.value === \"http://dbpedia.org/property/aBody\"\n         || a.p.value === \"http://dbpedia.org/property/3Shorts\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternS\"\n         || a.p.value === \"http://dbpedia.org/property/3PatternB\"\n         || a.p.value === \"http://dbpedia.org/property/3Body\"\n         || a.p.value === \"http://dbpedia.org/property/nba\"\n         || a.p.value === \"http://dbpedia.org/ontology/termPeriod\"\n         )\n  );\n  \n  // We then sort the processedBinding by some criterias.\n\n  // First Criteria: dct:subjects should show up at the top of the list, sorted by o.value.slice(37).\n\n  // Since a customized sort is a bit hard to write, let's break this array into two, sort each one, then concat them back together\n  let dctArray = [];\n  let dbopArray = [];\n  for (let i = 0; i < processedBinding.length; ++i) {\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\n      dctArray.push(processedBinding[i]);\n    }\n    else {\n      dbopArray.push(processedBinding[i]);\n    }\n  }\n\n  // We first sort the dctArray by o.value.slice(37).\n\n  dctArray.sort((a, b) => (a.o.value.slice(37) < b.o.value.slice(37) ? -1 : 1));\n\n  // We then sort dbop array by the following rules:\n  // Those that are dbr (so without a datatype) shows up higher\n  // Then those with a smaller count shows up higher\n  // Then alphabetical order.\n\n  // The following code gets the count for each property(or neighbour)\n  dbopArray.sort((a, b) => (a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1));\n  if (dbopArray.length > 0) {\n    dbopArray[0].p.count = getPCount(dbopArray[0].p.value, dbopArray);\n  }\n  for (let i = 1; i < dbopArray.length; ++i) {\n    let prevNeighbour = dbopArray[i-1];\n    let curNeighbour = dbopArray[i];\n    if (prevNeighbour.p.value === curNeighbour.p.value) {\n      curNeighbour.p.count = prevNeighbour.p.count;\n    }\n    else {\n      curNeighbour.p.count = getPCount(dbopArray[i].p.value, dbopArray);\n    }\n  }\n\n  // The following code sorts the array\n  dbopArray.sort(function (a, b) {\n    if (a.o.datatype === undefined && b.o.datatype !== undefined) {\n      return -1;\n    }\n    else if (b.o.datatype === undefined && a.o.datatype !== undefined) {\n      return 1;\n    }\n    else {\n      if (a.p.count === b.p.count) {\n        return a.p.value.slice(28) < b.p.value.slice(28) ? -1 : 1;\n      }\n      else {\n        return a.p.count < b.p.count ? -1 : 1;\n      }\n    }\n  });\n  // console.log(dbopArray);\n\n  // At this stage, we have finished sorting both dctArray and dbopArray. Let's put them back together.\n  processedBinding = dctArray.concat(dbopArray);\n\n  // console.log(processedBinding);\n\n  // Now we need to loop over the processedBinding, and create an array of objects. \n  // This array should have length equal to processedBinding.length.\n  // Each object should have 6 attributes.\n  // 1) pValue: value of predicate\n  // 2) pDataset: which dataset does this predicate belong to (one of dbo, dbp, and dct)\n  // 3) oValue: value of object\n  // 4) oType: datatype of object, such as \"http://www.w3.org/2001/XMLSchema#date\". This can be empty.\n\n  // 5) value: same as pValue: historical code\n  // 6) label: same as pValue: historical code\n\n  let firstColSelection = [];\n\n  for (let i = 0; i < processedBinding.length; ++i) {\n    // First case: current neighbour is from dct:subject\n    if (processedBinding[i].p.value === \"http://purl.org/dc/terms/subject\") {\n      firstColSelection.push(\n        {\n          \"pValue\":\"category\",\n          \"pDataset\":\"dct\",\n          \"oValue\":processedBinding[i].o.value.slice(37),\n          \"oType\":\"\",\n          \"value\":\"category\",\n          \"label\":processedBinding[i].o.value.slice(37),\n        }\n      )\n    }\n    // Second case: current neighbour is from dbo or dbp\n    else {\n      firstColSelection.push(\n        {\n          \"pValue\":processedBinding[i].p.value.slice(28),\n          \"pDataset\":processedBinding[i].p.value.includes(\"property\") ? \"dbp\" : \"dbo\",\n          \"oValue\":removePrefix(processedBinding[i].o.value),\n          \"oType\":processedBinding[i].o.datatype === undefined ? \"\" : processedBinding[i].o.datatype,\n          \"value\":processedBinding[i].p.value.slice(28),\n          \"label\":processedBinding[i].p.value.slice(28)+\":\"+removePrefix(processedBinding[i].o.value),\n        }\n      )\n    }\n  }\n  return firstColSelection;\n}\n\n\n// This function takes in the clean data for the first table, clean data for the second table, and colMapping between these two tables\n// And returns the unioned clean data for the first table\n\nfunction tableConcat(tableData, otherTableData, tempMapping) {\n  // We want to correctly modify tableDataExplore, based on colMapping.\n  // If colMapping is null for some column, we want to set the data as \"N/A\"\n  // console.log(tableDataExplore);\n\n  // We first make some small modifications to colMapping, as we have inserted a new column into otherTableData and tableDataExplore\n  for (let j = 0; j < tempMapping.length; ++j) {\n    if (tempMapping[j] !== \"null\") {\n      tempMapping[j]++;\n    }\n  }\n  tempMapping.splice(0, 0, 0); // insert element 0 at the first position of colMapping, deleting 0 elements\n\n  // Now we insert the data into dataToAdd. dataToAdd will be concatenated with tableDataExplore\n  let dataToAdd = [];\n  for (let i = 0; i < otherTableData.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < tempMapping.length; ++j) {\n      let colInNew = tempMapping[j];\n      if (colInNew !== \"null\") {\n        tempRow.push(otherTableData[i][colInNew]);\n      } else {\n        tempRow.push({ data: \"N/A\" });\n      }\n    }\n    dataToAdd.push(tempRow);\n  }\n  return tableData.concat(dataToAdd);\n}\n\nfunction HTMLCleanCell(str) {\n  // Note that this function also removes leading and trailing whitespaces\n  if (str[str.length - 1] === \"\\n\") {\n    return str.slice(0, -1).trim().split(\"[\")[0];\n  } else {\n    return str.trim().split(\"[\")[0];\n  }\n}\n\n// This function returns an array of table objects that are unionable with the selected table.\n\n// It taks two parameters:\n//  1) HTML \"tableHTML\" storing the HTML of the selected table\n//  2) HTML \"pageHTML\", storing the HTML of a sibling page\n\n// Table object has four attributes: isOpen, data, unionScore, colMapping\n\n// Once semantic mapping feature is added, the colMapping will be updated\n\nfunction findTableFromHTML(\n  tableHeader,\n  pageHTML,\n  selectedClassAnnotation,\n  semanticEnabled,\n  unionCutOff,\n  pageName\n) {\n  // We first get the column names of the table in the table panel, using this.state.tableHeader.\n  // Note: the index starts from 1 because we don't care about the originURL column (column 0). ***\n  let originCols = [];\n  // BUGFIX needs to be applied here. (Seems to be fixed)\n  // console.log(tableHeader);\n  for (let j = 1; j < tableHeader.length; ++j) {\n    let curValue = \"\"\n    for (let k = 0; k < tableHeader[j].length; ++k) {\n      curValue+=tableHeader[j][k].value;\n    }\n    originCols.push(curValue);\n  }\n\n  // We now fetch all the tables from pageHTML (the current sibling page)\n  let doc = new DOMParser().parseFromString(pageHTML, \"text/html\");\n  let wikiTablesFound = doc.getElementsByClassName(\"wikitable\");\n  let tablesFound = [];\n  for (let i = 0; i < wikiTablesFound.length; ++i) {\n    if (wikiTablesFound[i].tagName !== \"TH\") {\n      tablesFound.push(wikiTablesFound[i]);\n    }\n  }\n\n  // console.log(tablesFound);\n\n  // This is the array we will return.\n  let tableArray = [];\n\n  // We now loop through all the tables found on this sibling page, and see if they are unionable with the selected table\n  let tablePromise = [];\n  for (let i = 0; i < tablesFound.length; ++i) {\n    tablePromise.push(\n      findTableFromTable(\n        tablesFound[i],\n        originCols,\n        selectedClassAnnotation,\n        semanticEnabled,\n        unionCutOff,\n        pageName\n      )\n    );\n  }\n\n  return allPromiseReady(tablePromise).then((values) => {\n    for (let i = 0; i < values.length; ++i) {\n      tableArray.push(values[i]);\n    }\n    // we filter the tableArray here by removing those tables that do not have a high enough unionScore\n    // Note: In the unfiltered table array, we are using -1 to represent tables with a low unionScore\n    tableArray = tableArray.filter(function (x) {\n      return x !== -1;\n    });\n    // console.log(tableArray);\n    // We sort the tableArray here by unionScore\n    tableArray.sort((a, b) => (a.unionScore < b.unionScore ? 1 : -1));\n    return Promise.resolve(tableArray);\n  });\n}\n\n// This function takes in four parameters:\n\n// 1) a tableHTML\n// 2) originCols (denoting the columns names of the selected table)\n// 3) class annotation of the selected table\n// 4) whether semantic mapping is enabled or not\n\n// and return a table Object with properties: isOpen, unionScore, colMapping, and data\nfunction findTableFromTable(\n  tableHTML,\n  originCols,\n  selectedClassAnnotation,\n  semanticEnabled,\n  unionCutOff,\n  pageName\n) {\n  // Define some constants\n  const ontologySize = 780;\n  const matchCutOff = 0.999;\n\n  // We first fetch the cleaned column names of the current table\n  let curHeaderCells = tableHTML.rows[0].cells;\n  let newCols = []; // stores the cleaned column names of the this table. Let's consider using this value for display as well.\n  let remainCols = []; // stores an array of the indices of the columns of the current table that are not yet mapped\n  let searchCols = []; // stores an array of the indices of the columns from the selected table that are not yet mapped\n\n  // We potentially need to resort to semantic mapping. So let's create a promiseArray.\n  // This promiseArray will only contain one element\n  let promiseArray = [];\n\n  for (let j = 0; j < curHeaderCells.length; ++j) {\n    let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\n    newCols.push(headerName);\n    remainCols.push(j);\n  }\n\n  // we want to make sure that newTable has more than half of the columns of the selectedTable\n  // because we require a >50% unionScore\n  // If it does not, we ignore this table automatically\n\n  if (newCols.length >= originCols.length * unionCutOff) {\n    // We use the proposed algo here.\n    // First we set the union score and column Mapping\n    let unionScore = 0;\n    let colMapping = [];\n    // We loop through the column headers in originCol, and see if they exist in newCols.\n    for (let k = 0; k < originCols.length; ++k) {\n      let curIndex = newCols.indexOf(originCols[k]);\n      if (curIndex !== -1) {\n        // This means the new table also contains column k from the selected table\n        // Thus we have found a mapping. We push it onto colMapping.\n        colMapping.push(curIndex);\n        unionScore += 1 / originCols.length;\n      } else {\n        colMapping.push(\"null\");\n      }\n    }\n    // In here we do a bit of string matching\n    // Chances are: tables from sibling pages with the same number of columns as the selected table, with structual invariability,\n    // is likely to be the \"same\" table as the selected on, we give it a chance for string matching\n    if (newCols.length === originCols.length) {\n      let sameStructure = true;\n      for (let i = 0; i < colMapping.length; ++i) {\n        if (colMapping[i] !== \"null\" && colMapping[i] !== i) {\n          sameStructure = false;\n          break;\n        }\n      }\n      if (sameStructure === true) {\n        for (let i = 0; i < colMapping.length; ++i) {\n          if (colMapping[i] === \"null\") {\n            if (\n              newCols[i].includes(originCols[i]) ||\n              originCols[i].includes(newCols[i])\n            ) {\n              colMapping[i] = i;\n              unionScore += 1 / originCols.length;\n            }\n          }\n        }\n      }\n      // console.log(colMapping);\n      // If unionScore is 1, and newCols.length is equal to originCols.length, we want to reward it with 0.01 unionScore\n      // This helps us to rank the tables with the exact same column headers a bit higher\n      if (unionScore === 1) {\n        unionScore += 0.01;\n      }\n    }\n\n    // We proceed differently based on whether semantic mapping is enabled or not\n\n    // Case 1: semantic mapping is enabled\n\n    if (semanticEnabled === \"enabled\") {\n      // If we are not finding a perfect match, we want to do use semantic mapping here to see if it's possible to map the unmapped columns\n      // Note: this part is expected to take quite some time. Now it's implemented just for testing purposes\n      if (unionScore < 0.999) {\n        // We want to remove from remainCols the columns that are already mapped\n        // The remaining will be the columns that we can still use from the current table\n        remainCols = remainCols.filter(function (x) {\n          return colMapping.indexOf(x) < 0;\n        });\n        for (let i = 0; i < colMapping.length; ++i) {\n          if (colMapping[i] === \"null\") {\n            searchCols.push(i);\n          }\n        }\n        // if (newCols[1] === \"Scorer\") {\n        // console.log(\"We still need to find these columns from the original table: \"+searchCols);\n        // console.log(\"These columns are still available for use: \"+remainCols);\n        // console.log(\"The current column mappings are \"+colMapping);\n        // console.log(\"Here are the class annotations of the search columns: \")\n        // for (let i=0;i<searchCols.length;++i) {\n        //   console.log(selectedClassAnnotation[searchCols[i]]);\n        // }\n        // }\n\n        // Now, searchCols stores the columns from the selected table that have not been mapped yet\n        // and remainCols stores the columns from the current table that can still be used for mapping\n        // Let's ask a query to find the class annotations for the remainCols\n        // if (remainCols.length > 0) {\n        promiseArray.push(findClassAnnotation(tableHTML, remainCols, pageName));\n        // }\n      }\n\n      // Because the return statement is here, it may be possible that we are pushing nothing onto the promiseArray!!!\n      // There is no need to worry about it.\n      return allPromiseReady(promiseArray).then((values) => {\n        // First, if we are in the perfect match case, we want to retrun straight away\n        if (unionScore >= 0.999) {\n          return Promise.resolve({\n            isOpen: false,\n            unionScore: unionScore,\n            colMapping: colMapping,\n            data: tableHTML,\n            title: newCols,\n          });\n        }\n        // Else, we want to look for semantic mapping opportunities\n        else {\n          // create a copy of values\n\n          // Note!!!! Sometimes the tableHTML only has one row, so values[0] would have a length of zero, in which case our algo breaks down\n          // Let's prevent it from happening\n          let remainClassAnnotation = values[0].slice();\n          if (remainClassAnnotation.length > 0) {\n            // let remainColsCopy = remainCols.slice();\n            // let remainClassAnnotationCopy = remainClassAnnotation.slice();\n            for (let i = 0; i < searchCols.length; ++i) {\n              let curSearchIndex = searchCols[i];\n              // console.log(curSearchIndex);\n              // console.log(selectedClassAnnotation[curSearchIndex]);\n\n              // If the class annotation for this column is empty, we skip it because there's no hope for semantic match.\n              // Otherwise we can work with it\n              if (selectedClassAnnotation[curSearchIndex].length > 0) {\n                // console.log(\"Current column being searched has index: \"+curSearchIndex);\n                // console.log(selectedClassAnnotation[curSearchIndex]);\n\n                // we loop through the remain cols and check their class annotations\n                for (let j = 0; j < remainCols.length; ++j) {\n                  // Let make sure this column does have a class annotation. Otherwise we skip it\n                  // console.log(remainClassAnnotation[j]);\n                  // Note: sometimes remainClassAnnotation[j] is undefined, which causes an error\n                  // if (remainClassAnnotation[j] === undefined) {\n                  //   console.log(\"This case is causing an error\");\n                  //   console.log(\"Remain cols are \"+remainCols);\n                  //   console.log(\"Remain class annotations are \"+remainClassAnnotation);\n                  //   console.log(\"Original remain cols are \"+remainColsCopy);\n                  //   console.log(\"original remain class annotations are \"+remainClassAnnotationCopy);\n                  //   console.log(\"Table HTML is \");\n                  //   console.log(tableHTML);\n                  //   console.log(values[0]);\n                  // }\n                  if (remainClassAnnotation[j].length > 0) {\n                    // console.log(\"Remain column index is \"+remainCols[j]);\n                    // console.log(\"Its class annotation is \"+remainClassAnnotation[j]);\n                    // Let make special cases when the any of search column class and current column class is [Number]\n                    // If they are both [Number], we will give it a match\n                    // Else it's not a match\n                    if (\n                      selectedClassAnnotation[curSearchIndex][0] === \"Number\" ||\n                      remainClassAnnotation[j][0] === \"Number\"\n                    ) {\n                      // This case we have a match\n                      if (\n                        selectedClassAnnotation[curSearchIndex][0] ===\n                        remainClassAnnotation[j][0]\n                      ) {\n                        // We need to update the colMapping and unionScore\n                        colMapping[curSearchIndex] = remainCols[j];\n                        unionScore += 1 / originCols.length;\n                        // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\n                        remainCols.splice(j, 1);\n                        remainClassAnnotation.splice(j, 1);\n                        // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\n                        // j to go back to the correct posiition\n                        --j;\n                        // Also we need to call break to prevent further looping: we are done with this search column\n                        break;\n                      }\n                      // Else there is no match. We simply ignore it.\n                    }\n                    // If neither of them is [Number], we need to use the test statistic\n                    else {\n                      // Let's first find the array intersection of selectedClassAnnotation[curSearchIndex] and remainClassAnnotation[j]\n                      let intersection = selectedClassAnnotation[\n                        curSearchIndex\n                      ].filter(function (x) {\n                        return remainClassAnnotation[j].indexOf(x) >= 0;\n                      });\n                      // console.log(\"Intersection is \"+intersection);\n                      // We only want to consider two column unionable if they at least have some intersections.\n                      if (intersection.length > 0) {\n                        let totalSuccess =\n                          selectedClassAnnotation[curSearchIndex].length;\n                        let numTrial = remainClassAnnotation[j].length;\n                        let numSuccess = intersection.length;\n                        let testStat = hyperCDF(\n                          numSuccess,\n                          ontologySize,\n                          totalSuccess,\n                          numTrial\n                        );\n                        // If testStat is larger than matchCutOff, we consider it a match\n                        if (testStat > matchCutOff) {\n                          // We need to update the colMapping and unionScore\n                          colMapping[curSearchIndex] = remainCols[j];\n                          unionScore += 1 / originCols.length;\n                          // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\n                          remainCols.splice(j, 1);\n                          remainClassAnnotation.splice(j, 1);\n                          // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\n                          // j to go back to the correct posiition\n                          --j;\n                          // Also we need to call break to prevent further looping: we are done with this search column\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          // console.log(\"Remain columns are \"+)\n          // console.log(\"Here is table HTML\");\n          // console.log(tableHTML);\n          // console.log(\"Here are the class annotations for columns that still need mapping\");\n          // for (let i=0;i<searchCols.length;++i) {\n          //   console.log(selectedClassAnnotation[searchCols[i]]);\n          // }\n          // console.log(\"The remain columns are \"+remainCols);\n          // console.log(\"Here are the class annotations for the remaining columns\");\n          // console.log(values);\n          // console.log(\"This is column mapping \"+colMapping);\n          // console.log(\"Union score is \"+unionScore);\n\n          // We need to loop through the searchCols\n\n          // We push on tables with unionScore > unionCutOff\n          if (unionScore >= unionCutOff) {\n            // console.log(\"This table is unionable!\");\n            // console.log(\"Table is \"+tableHTML);\n            // console.log(\"Union Score is \"+unionScore);\n            // console.log(\"Column mapping is \"+colMapping);\n            // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\n            // console.log(colMapping);\n            return Promise.resolve({\n              isOpen: false,\n              unionScore: unionScore,\n              colMapping: colMapping,\n              data: tableHTML,\n              title: newCols,\n            });\n          } else {\n            return Promise.resolve(-1);\n          }\n        }\n      });\n    }\n\n    // Case 2: semantic mapping is disabled.\n    // In this case we check if the unionScore is high enough directly, without going through the semantic mapping process\n    else {\n      // We push on tables with unionScore > unionCutOff\n      if (unionScore >= unionCutOff) {\n        // console.log(\"This table is unionable!\");\n        // console.log(\"Table is \"+tableHTML);\n        // console.log(\"Union Score is \"+unionScore);\n        // console.log(\"Column mapping is \"+colMapping);\n        // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\n        // console.log(colMapping);\n        return Promise.resolve({\n          isOpen: false,\n          unionScore: unionScore,\n          colMapping: colMapping,\n          data: tableHTML,\n          title: newCols,\n        });\n      } else {\n        return Promise.resolve(-1);\n      }\n    }\n  }\n  // This else clause means that this table does not even have enough number of columns.\n  // So we know right away it cannot be a match. So we return -1 (failure)\n  else {\n    return Promise.resolve(-1);\n  }\n}\n\n// This function takes in the HTML of a table, and returns a Promise that resolves to the class annotation for all the columns of the table\nfunction findClassAnnotation(tableHTML, remainCols, pageName) {\n  // console.log(\"Page Name is: \"+pageName);\n  // console.log(\"Table HTML is: \");\n  // console.log(tableHTML);\n  // console.log(remainCols);\n  let selectedTable = tableHTML;\n  let tempTable = [];\n\n  // We first fetch the plain, unprocessed version of the table.\n  // Note: this function potentially needs to be modified.\n  // Instead of using innerText for cell data, if its href exists, we should use its href instead\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\n\n      // Note: We want to use the href as data for the first column (if such href exists) instead of its innerText.\n      if (i === 1) {\n        // We get all the links from this current cell (there may be more than one)\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\n          \"a\"\n        );\n        // we want to use the first valid link as the search element for this cell\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\n        //                            and it is not a citation (so [0] is not \"[\")\n        for (let k = 0; k < anchorArray.length; ++k) {\n          if (\n            anchorArray[k].innerText !== \"\" &&\n            anchorArray[k].innerText[0] !== \"[\"\n          ) {\n            let hrefArray = anchorArray[k].href.split(\"/\");\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\n            curCellText = hrefArray[hrefArray.length - 1];\n            // if (curCellText.includes(\"UEFA\")) {\n            // console.log(curCellText);\n            // }\n          }\n        }\n      }\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\n      // console.log(curColSpan);\n      tempRow.push({\n        data: curCellText,\n        rowSpan: curRowSpan,\n        colSpan: curColSpan,\n      });\n    }\n    tempTable.push(tempRow);\n  }\n\n  // We first deal with colspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].colSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\n          tempTable[i].splice(j + 1, 0, {\n            data: curCellText,\n            rowSpan: 1,\n            colSpan: 1,\n          });\n        }\n      }\n    }\n  }\n\n  // We now deal with rowspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].rowSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\n          if (i + k < tempTable.length) {\n            tempTable[i + k].splice(j, 0, {\n              data: curCellText,\n              rowSpan: 1,\n              colSpan: 1,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // console.log(\"Table data is: \");\n  // console.log(tempTable);\n\n  // Now tempTable contains the clean data we can use\n  let promiseArray = [];\n  // We take the minimum of (1, tempTable.length-1) number of values from each column to determine its class annotation\n  // Note!! This -1 here is important. It excludes the row corresponding to the column headers\n  let remainEntries = Math.min(1, tempTable.length - 1);\n\n  // This is a placeholder array to solve the 2D problem. It's a 1D array containing remainEntries number of -1's\n  // let placeHolderArray = [];\n  // let notFoundArray = [];\n  // for (let i=0;i<remainEntries;++i) {\n  //   placeHolderArray.push(-1);\n  //   notFoundArray.push(\"null\");\n  // }\n\n  // Let's loop through the table to ask our queries.\n  // If remainCols are undefined, we take every columns from the tempTable;\n  if (remainCols === undefined) {\n    remainCols = [];\n    for (let j = 0; j < tempTable[0].length; ++j) {\n      remainCols.push(j);\n    }\n  }\n\n  // console.log(\"Remain columns are: \"+remainCols);\n  for (let j = 0; j < remainCols.length; ++j) {\n    // console.log(\"We are taking this number of entries from this table: \"+remainEntries);\n    // Find the current column index\n    let curColIndex = remainCols[j];\n    // console.log(\"Current column index is: \"+curColIndex);\n\n    // Loop through the first three (or one) entries from this column\n    for (let i = 1; i <= remainEntries; ++i) {\n      // Here we make the query\n      let prefixURL =\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n      let suffixURL =\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n      // console.log(tempTable[i][j].data);\n      // console.log(regexReplace(tempTable[i][j].data));\n      // console.log(tempTable[i][curColIndex]);\n      let curEntry =\n        tempTable[i][curColIndex] === undefined\n          ? \"NONEXISTING\"\n          : regexReplace(tempTable[i][curColIndex].data);\n      // console.log(curEntry);\n      // console.log(regexReplace(tempTable[i][curColIndex].data));\n      // console.log(!isNaN(Number(curEntry)));\n      // console.log(\"Replaced data is \"+curEntry);\n      // console.log(curEntry === \"\");\n\n      // If we found out that the current entry is a number, we do not want to send a query.\n      // Note: Number(\"\") will show up as a number!! This was one of the bugs that we fixed\n      if (!isNaN(Number(curEntry)) && curEntry !== \"\") {\n        promiseArray.push(Promise.resolve([\"Number\"]));\n      }\n      // Else if we find the curEntry is too long, it will likely not exist in DBPedia\n      else if (curEntry.length > 40) {\n        promiseArray.push(Promise.resolve([\"Null\"]));\n      }\n      // Else we construct the query\n      else {\n        // console.log(\"Cur Entry is \"+curEntry);\n        if (curEntry === undefined || curEntry === \"\") {\n          curEntry = \"NONEXISTING\";\n        }\n        // if (curEntry === \"Sergio_Agero\") {\n        //   console.log(\"We have another problem here\");\n        // }\n        // console.log(curEntry);\n        // console.log(tempTable[i][curColIndex].data);\n        // console.log(regexReplace(tempTable[i][curColIndex].data));\n        let queryBody =\n          \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\n          curEntry +\n          \"+rdf%3Atype+%3Fo.%0D%0A++++++BIND%28STR%28%3Fo%29+AS+%3FoString+%29.%0D%0A++++++FILTER%28regex%28%3FoString%2C%22dbpedia.org%2Fontology%2F%22%2C%22i%22%29%29%0D%0A%7D%0D%0A&\";\n        let queryURL = prefixURL + queryBody + suffixURL;\n        // if (curEntry === \"Bangor_City_F%5Cu002EC%5Cu002E\") {\n        //   console.log(\"There is something wrong with this entry\")\n        //   console.log(queryURL);\n        // }\n        // console.log(\"Query is constructed!\");\n        // if (queryURL === \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\") {\n        //   console.log(\"Here is where the problem occurs\");\n        // }\n        // console.log(queryURL);\n        promiseArray.push(fetchJSON(queryURL));\n        // console.log(\"Query pushed successfully. This is queryBody: \");\n        // console.log(queryBody);\n      }\n    }\n  }\n  return allPromiseReady(promiseArray).then((values) => {\n    // console.log(values);\n    // for (let i=0;i<values.length;++i) {\n    //   console.log(values[i]);\n    // }\n    // console.log(\"Query results from Virtuoso are:\");\n    // console.log(values);\n    let classAnnotation = [];\n    for (let j = 0; j < remainCols.length; ++j) {\n      // console.log(\"Number of remain cols is \"+remainCols.length);\n      let curColumnClass = [];\n      // If we are dealing with number results, we just want to push on an array with one element \"Number\"\n      if (values[remainEntries * j] !== undefined) {\n        if (values[remainEntries * j][0] !== undefined) {\n          if (values[remainEntries * j][0] === \"Number\") {\n            classAnnotation.push([\"Number\"]);\n          }\n          // If we are dealing with invalid results, we just want to push on an empty array\n          else if (values[remainEntries * j][0] === \"Null\") {\n            classAnnotation.push([]);\n          }\n        }\n        // if (values[remainEntries*j][0] === -1) {\n        //   classAnnotation.push([\"Number\"]);\n        // }\n        // // If we are dealing with invalid results, we just want to push on an empty array\n        // else if (values[remainEntries*j][0] === \"null\") {\n        //   classAnnotation.push([]);\n        // }\n        // Else, we find its class annotation from query results\n        else {\n          for (let i = 0; i < remainEntries; ++i) {\n            let curCellClass = [];\n            // console.log(remainEntries*j+i);\n            let bindingArray = values[remainEntries * j + i].results.bindings;\n            for (let k = 0; k < bindingArray.length; ++k) {\n              curCellClass.push(bindingArray[k].o.value.slice(28));\n            }\n            curColumnClass = [...new Set([...curColumnClass, ...curCellClass])];\n          }\n          classAnnotation.push(curColumnClass);\n        }\n      }\n    }\n    // return classAnnotation;\n    // console.log(\"Current class annotation is \");\n    // if (pageName === \"200910_Premier_League\") {\n    //   console.log(\"TableData is \");\n    //   console.log(tempTable);\n    //   console.log(classAnnotation);\n    // }\n    // console.log(classAnnotation);\n\n    return Promise.resolve(classAnnotation);\n  });\n}\n\n// This function returns a 2D array of objects representing the data for tableDataExplore.\n\n// It taks two parameters:\n//  1) HTML \"selectedTableHTML\" storing the HTML of a table\n//  2) string \"urlOrigin\", storing which page this table is from\n\n// It returns a 2D array of objects representing the data for tableDataExplore.\nfunction setTableFromHTML(selecteTableHTML, urlOrigin) {\n  let selectedTable = selecteTableHTML;\n  let tempTable = [];\n\n  // We first fetch the plain, unprocessed version of the table.\n  // This is the part where we make the modification: use links instead of cell literals\n\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\n    let tempRow = [];\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\n      // Note: We want to use the href as data (if such href exists) instead of its innerText.\n      if (i > 0) {\n        // We get all the links from this current cell (there may be more than one)\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\n          \"a\"\n        );\n        // we want to use the first valid link as the search element for this cell\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\n        //                            and it is not a citation (so [0] is not \"[\")\n        for (let k = 0; k < anchorArray.length; ++k) {\n          if (\n            anchorArray[k].innerText !== \"\" &&\n            anchorArray[k].innerText[0] !== \"[\"\n          ) {\n            let hrefArray = anchorArray[k].href.split(\"/\");\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\n            curCellText = decodeURIComponent(hrefArray[hrefArray.length - 1]);\n            // if (curCellText.includes(\"UEFA\")) {\n            // console.log(curCellText);\n            // }\n          }\n        }\n      }\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\n      // console.log(curColSpan);\n      tempRow.push({\n        data: curCellText,\n        origin: urlOrigin,\n        rowSpan: curRowSpan,\n        colSpan: curColSpan,\n      });\n    }\n    tempTable.push(tempRow);\n  }\n\n  // We first deal with colspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].colSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\n          tempTable[i].splice(j + 1, 0, {\n            data: curCellText,\n            origin: urlOrigin,\n            rowSpan: tempTable[i][j].rowSpan,\n            colSpan: 1,\n          });\n        }\n      }\n    }\n  }\n\n  // We now deal with rowspans.\n  for (let i = 0; i < tempTable.length; ++i) {\n    for (let j = 0; j < tempTable[i].length; ++j) {\n      let curCellText = tempTable[i][j].data;\n      if (tempTable[i][j].rowSpan > 1) {\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\n          if (i + k < tempTable.length) {\n            tempTable[i + k].splice(j, 0, {\n              data: curCellText,\n              origin: urlOrigin,\n              rowSpan: 1,\n              colSpan: 1,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // We now add in an additional column: the originURL of the page\n  tempTable[0].splice(0, 0, {\n    data: \"OriginURL\",\n    origin: urlOrigin,\n    rowSpan: 1,\n    colSpan: 1,\n  });\n  for (let i = 1; i < tempTable.length; ++i) {\n    tempTable[i].splice(0, 0, {\n      data: urlOrigin,\n      origin: \"null\",\n      rowSpan: 1,\n      colSpan: 1,\n    });\n  }\n  return tempTable; // tempTable is a 2D array of objects storing the table data. Object has two fields: data(string) and origin(string).\n}\n\n// This function takes in 1 parameter\n// 1) tableDataExplore, returned from setTableFromHTML.\n\n// And returns tableData (with no header rows) that can be unioned with the selected table.\n\nfunction setUnionData(tableDataExplore) {\n\n  // We first need to set the tableHeader, so that cells have the correct origins\n  let tableHeader = [];\n  for (let j=0;j<tableDataExplore[0].length;++j) {\n    tableHeader.push(\n      {\"value\":tableDataExplore[0][j].data\n      ,\"label\":tableDataExplore[0][j].data}\n    )\n  }\n  // We then need to handle both data and origin.\n  let tableData = [];\n  // console.log(tableDataExplore);\n  // This starts the loop for rows\n  for (let i=1;i<tableDataExplore.length;++i) {\n    let tempRow = [];\n    // This starts the loop for columns\n    for (let j=0;j<tableDataExplore[i].length;++j) {\n      // First set the data\n      let data = tableDataExplore[i][j].data;\n      // Then set the origin\n      let origin = [];\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\n      origin.push(originText);\n      tempRow.push({\"data\":data,\"origin\":origin});\n    }\n    tableData.push(tempRow);\n  }\n  return tableData;\n}\n\n// This function takes in four parameters and return the CDF for hypergeometric distribution, for x\n// N: total number of elements (780 in our case)\n// K: total number of successful elements (length of selected column's class annotation)\n// n: number of trials (length of test column's class annotation)\n// x: (length of intersection of selected column and test column)\n\nfunction hyperCDF(x, N, K, n) {\n  let count = 0;\n  // console.log(combinations(5,2));\n  let denom = combinations(N, n);\n  for (let i = 0; i <= x; ++i) {\n    count += (combinations(K, i) * combinations(N - K, n - i)) / denom;\n  }\n  return count;\n}\n\n// This function renders this.props.tableData[i][j].data in a nicer way. \n// It changes\"_\" to \" \", and removes everything after the first occurence of (\n\nfunction niceRender(str) {\n  let resultStr = str;\n  let bracketIndex = str.indexOf(\"(\");\n  // If ( is present in a string, we want to remove it\n  // We include the -1 because usually ( is preceeded by _\n  if (bracketIndex !== -1) {\n    resultStr = resultStr.slice(0, bracketIndex-1);\n  }\n  // now we turn all \"_\" into \" \"\n  return resultStr.replace(/_/g, \" \");\n}\n\n// This function takes in four parameters: \n// 1) resultsBinding: an array of JSON values representing entities satisfying the first column\n// 2) tableData:      the tableData before update\n// 3) tableHeader:    this.state.tableHeader\n// 4) colIndex:       which column usersa are filling (usually 0)\n\n// and returns the updated tableData, after updates have been made to the first column.\n\nfunction setFirstColumnData(resultsBinding, tableData, tableHeader, colIndex) {\n  // First we get the correct number of rows, which is equal to min(values[0].results.bindings.length, initialRowNum)\n  let updatedRowCount = Math.min(resultsBinding.length, initialRowNum);\n  // console.log(\"Original length is \"+values[0].results.bindings.length);\n  // console.log(\"Row Count is: \"+updatedRowCount);\n\n  // If tableData currently has too many rows, we slice it.\n  if (tableData.length > updatedRowCount) {\n    tableData = tableData.slice(0,updatedRowCount);\n  }\n  // Else, if tableData currently has too few rows, we need to add some empty rows.\n  else if (tableData.length < updatedRowCount) {\n    let rowsToAdd = updatedRowCount - tableData.length;\n    for (let i = 0; i < rowsToAdd; ++i) {\n      let tempRow = [];\n      for (let j = 0; j < initialColNum; ++j) {\n        tempRow.push({ data: \"\", origin: [] });\n      }\n      tableData.push(tempRow);\n    }\n  }\n\n  let rowNum = tableData.length;\n  // console.log(\"Number of rows is \"+rowNum);\n\n  // We do not want to overwrite entries that users have filled in.\n  // Let's calculate how many entries we want to fill in.\n  let emptyEntryCount = rowNum;\n  for (let i = 0; i < rowNum; ++i) {\n    if (tableData[i][colIndex].data !== \"\") {\n      emptyEntryCount--;\n    } else {\n      break;\n    }\n  }\n  // console.log(\"number of empty entries is \"+emptyEntryCount);\n\n  let startingIndex = rowNum - emptyEntryCount;\n  // console.log(\"Starting index is\"+startingIndex);\n\n  for (let i = 0; i < emptyEntryCount; ++i) {\n    tableData[i + startingIndex][colIndex].data = \n      resultsBinding[i].somevar.value.slice(28);\n  }\n\n  // second part sets the origin for each cell\n  for (let i = 0; i < rowNum; ++i) {\n    // For the first column, let's just use its data as the origin\n    let tempOrigin = tableData[i][colIndex].data;\n    tableData[i][colIndex].origin.push(tempOrigin);\n  }\n\n  // Now we dedup by tableData by tableData[i][0].data\n  tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\n\n  // console.log(tableData);\n  return tableData;\n}\n\n// The following function takes in 2D array recording information of neighbours for the search column\n\n// It return a desired oneD keyColNeighbours that we can give to selection Headers.\n\nfunction processAllNeighbours(allNeighboursArray) {\n  let keyColNeighbours = [];\n  // console.log(allNeighboursArray);\n  let allNeighboursArrayCopy = _.cloneDeep(allNeighboursArray);\n\n  for (let i = 0; i < allNeighboursArrayCopy.length; ++i) {\n    keyColNeighbours = keyColNeighbours.concat(allNeighboursArrayCopy[i]);\n  }\n\n  // Now we sort keyColNeighbours based on value\n  keyColNeighbours.sort((a,b) => a.value < b.value ? -1 : 1);\n  // console.log(keyColNeighbours);\n\n  // Now, we run a loop to remove duplicates, and update count and filledCount\n  if (keyColNeighbours.length > 0) {\n    for (let i = 1; i < keyColNeighbours.length; ++i) {\n      let prevEntry = keyColNeighbours[i-1];\n      let curEntry = keyColNeighbours[i];\n\n      // If the current entry's data is equal to the previous entry's data, we want to \n      // 1) delete curEntry\n      // 2) (maybe) update prevEntry's count\n      // 3) increment prevEntry's filledCount\n      if (prevEntry.value === curEntry.value) {\n        keyColNeighbours[i-1].filledCount = keyColNeighbours[i-1].filledCount + 1;\n        keyColNeighbours[i-1].count = Math.max(prevEntry.count, curEntry.count);\n        keyColNeighbours.splice(i,1);\n        --i;\n      }\n    }\n  }\n  // Now we want to sort (and potentially filter) keyColNeighbours, by filledCount \n  keyColNeighbours.sort((a,b) => a.filledCount < b.filledCount ? 1 : -1);\n\n  // Before we return, let's change the label to include filledCount\n  for (let i = 0; i < keyColNeighbours.length; ++i) {\n    let filledPercent = Math.round(keyColNeighbours[i].filledCount/allNeighboursArrayCopy.length * 100) / 100;\n    keyColNeighbours[i].filledPercent = filledPercent;\n    keyColNeighbours[i].label = keyColNeighbours[i].label + \" (\" + filledPercent + \")\";\n  }\n\n  // Take a look at keyColNeighbours\n  // console.log(keyColNeighbours);\n\n  return keyColNeighbours;\n}\n\n// The following function stores both predicate and object array for all entries in search column.\n// Its return value is an array, length is tableData.length\n\nfunction storeFirstDeg(neighbourArray) {\n  // console.log(neighbourArray);\n  let firstDegNeighbours = [];\n  let neighbourArrayCopy = _.cloneDeep(neighbourArray);\n  for (let i = 0; i < neighbourArrayCopy.length; ++i) {\n    let tempObj = {};\n    for (let j = 0; j < neighbourArrayCopy[i].length; ++j) {\n      // The following line creates a deduped version of neighbourArrayCopy[i][j].data, since some bug seems to exist in DBpedia\n      let dedupedData = _.uniq(neighbourArrayCopy[i][j].data.slice())\n      tempObj[neighbourArrayCopy[i][j].value] = dedupedData;\n      // console.log(neighbourArrayCopy[i][j].data.slice());\n      // console.log(_.uniq(neighbourArrayCopy[i][j].data.slice()));\n      // tempObj[neighbourArrayCopy[i][j].value] = neighbourArrayCopy[i][j].data;\n    }\n    firstDegNeighbours.push(tempObj);\n  } \n  // console.log(firstDegNeighbours);\n  return firstDegNeighbours;\n}\n\n// This function creates neighbourArrayText from neighbourArray\n\nfunction createNeighbourText(neighbourArray) {\n  let neighbourArrayText = \"\";\n  for (let i = 0; i < neighbourArray.length; ++i) {\n    if (i > 0) {\n      neighbourArrayText+=\" OR \";\n    }\n    let curNeighbourText = neighbourArray[i].type === \"object\" ? \"is \" + neighbourArray[i].value + \" of\" : neighbourArray[i].value ;\n    neighbourArrayText+=curNeighbourText;\n  }\n  return neighbourArrayText;\n}\n\n// This function add in the recommendNeighbours to objects in processedNeighbours.\n// It takes in processedSubject(object)Neighbours, and returns the updated version.\n\n// For each element from processedNeighbours, we want to add an attribute called recommendNeighbours\n// recommendNeighbours is an array of objects with three attributes\n// 1) value:        value of the recommend attribute\n// 2) type:         type of the recommend attribute\n// 3) relation:     how the recommend attribute is related to the original attribute: string, or semantic\n\nfunction addRecommendNeighbours(processedNeighboursCopy) {\n  // console.log(processedNeighbours);\n  let processedNeighbours = _.cloneDeep(processedNeighboursCopy);\n\n  // To do this, we need to a double loop over the processedNeighbours\n  for (let i = 0; i < processedNeighbours.length; ++i) {\n\n    // Initialize the recommendNeighbours array\n    let recommendNeighbours = [];\n    \n    for (let j = 0; j < processedNeighbours.length; ++j) {\n      // We only look at cases where i !== j\n      if (i !== j) {\n        // We consider three types of matching\n\n        // 1st type is String Similarity: if X is a substring of Y, or Y is a substring of X \n        let upperStrOne = processedNeighbours[i].value.toUpperCase();\n        let upperStrTwo = processedNeighbours[j].value.toUpperCase();\n        if (upperStrOne.includes(upperStrTwo) || upperStrTwo.includes(upperStrOne)) {\n          recommendNeighbours.push(\n            {\n              \"value\": processedNeighbours[j].value,\n              \"type\": processedNeighbours[j].type,\n              \"relation\": \"string\"\n            }\n          )\n        }\n\n        // 2nd type is semantic: if X and Y has the same range, or same subPropertyOf \n        if ((processedNeighbours[i].range === processedNeighbours[j].range && processedNeighbours[i].range !== \"\") ||\n            (processedNeighbours[i].subPropertyOf === processedNeighbours[j].subPropertyOf && processedNeighbours[i].subPropertyOf !== \"\")) {\n          recommendNeighbours.push(\n            {\n              \"value\": processedNeighbours[j].value,\n              \"type\": processedNeighbours[j].type,\n              \"relation\": \"semantic\"\n            }\n          )\n        }\n      }\n    }\n    // We take a look at the recommendNeighbours\n    // console.log(\"Current neighbour is \"+processedNeighbours[i].value);\n    // if (recommendNeighbours.length > 0) {console.log(recommendNeighbours);}\n\n    // Now, we create the recommendNeighbours attributes for the current element in processedNeighbours\n    processedNeighbours[i][\"recommendNeighbours\"] = recommendNeighbours;\n  }\n  // console.log(processedNeighbours);\n  return processedNeighbours;\n}\n\n// The following function creates the list of recommend attributes passed to the ActionPanel.\n\n// It takes in one parameter: neighbourArray\n// returns an array: recommendArray\n\nfunction createRecommendArray(neighbourArray, keyColNeighbours) {\n  // We create the recommendArray variable using a simple rule:\n  // It should be union of recommendNeighbours of all neighbours from neighbourArray, minus the neighbours from neighbourArray\n  let recommendArray = [];\n\n  // First we run a loop to take the union of recommendNeighbours\n  for (let i = 0; i < neighbourArray.length; ++i) {\n    recommendArray = recommendArray.concat(neighbourArray[i].recommendNeighbours);\n  }\n\n  // console.log(neighbourArray);\n  // console.log(recommendArray);\n\n  // We then remove recommendations that are completely duplicated\n  recommendArray = _.uniqBy(recommendArray, function(x) {\n    return x.value || x.type || x.relation;\n  });\n  // We then remove recommendations that are already in neighbourArray\n  recommendArray = _.differenceBy(recommendArray, neighbourArray, function(x) {\n    return x.value || x.type;\n  });\n\n  // We want to do one more thing here: get the filledPercentage for the recommendation attributes\n\n  // console.log(recommendArray);\n  // console.log(keyColNeighbours);\n\n  for (let i = 0; i < recommendArray.length; ++i) {\n    for (let j = 0; j < keyColNeighbours.length; ++j) {\n      if (recommendArray[i].value === keyColNeighbours[j].value && recommendArray[i].type === keyColNeighbours[j].type) {\n        recommendArray[i][\"label\"] = keyColNeighbours[j].label;\n        recommendArray[i][\"filledPercent\"] = keyColNeighbours[j].filledPercent;\n        break;\n      }\n    }\n  }\n  // We now sort the recommendArray by filledPercent attribute\n  recommendArray.sort((a, b) =>\n    a.filledPercent < b.filledPercent ? 1 : -1\n  );\n  // console.log(recommendArray);\n\n  return recommendArray;\n}\n\n// The following function is a helper function for sorting used in updateFirstColSelection.\n\nfunction getPCount(str, myArray) {\n  let count = 0;\n  for (let i = 0; i < myArray.length; ++i) {\n    if (myArray[i].p.value === str) {\n      ++count\n    }\n  }\n  return count;\n}\n\n// The following function scans through a string, and changes all \" \" to \"+\"\n\nfunction blankToPlus(str) {\n  return str.replace(/\\s/g, \"+\");\n}\n\n// The following function generates queryURL needed for Virtuoso, using information from neighbourArray (or tableHeader[0])\n\nfunction keyQueryGen(neighbourArray) {\n\n  // Following boolean is for error detection\n  let error = false;\n\n  // Following is a complete query.\n\n  // select ?somevar\n  // where {\n  // ?somevar dct:subject dbc:Obama_family.\n  // ?somevar dbp:district \"13\"^^<http://www.w3.org/2001/XMLSchema#integer>.\n  // ?somevar dbo:birthPlace dbr:Hawaii.\n  // ?somevar dbp:name \"Barack Obama\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#langString>.\n  // ?somevar dbo:activeYearsEndDate \"2004-11-04\"^^<http://www.w3.org/2001/XMLSchema#date>.\n  // }\n\n  let prefixURL = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\n  let suffixURL = \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\n  let queryBody = \"select+%3Fsomevar%0D%0Awhere+%7B\";\n  for (let i = 0; i < neighbourArray.length; ++i) {\n    // There are 5 cases that we have to deal with in total\n    let textToAdd = \"\"\n    // Case 1: dct (%0D%0A%3Fsomevar+dct%3Asubject+dbc%3AObama_family.)\n    if (neighbourArray[i].pDataset === \"dct\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+dct%3Asubject+dbc%3A\" \n        + regexReplace(neighbourArray[i].oValue) \n        + \".\";\n    }\n    // Case 2: oType is date (%0D%0A%3Fsomevar+dbo%3AactiveYearsEndDate+%222004-11-04%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.)\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#date\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+\" \n        + neighbourArray[i].pDataset\n        + \"%3A\"\n        + regexReplace(neighbourArray[i].pValue)\n        + \"+%22\"\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23date%3E.\";\n    }\n    // Case 3: oType is integer (%0D%0A%3Fsomevar+dbp%3Adistrict+%2213%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.)\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#integer\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+\"\n        + neighbourArray[i].pDataset\n        + \"%3A\"\n        + regexReplace(neighbourArray[i].pValue)\n        + \"+%22\"\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23integer%3E.\";\n    }\n    // Case 4: oType is string literal (%0D%0A%3Fsomevar+dbp%3Aname+%22Barack+Obama%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.)\n    else if (neighbourArray[i].oType === \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+\"\n        + neighbourArray[i].pDataset\n        + \"%3A\"\n        + regexReplace(neighbourArray[i].pValue)\n        + \"+%22\"\n        + blankToPlus(neighbourArray[i].oValue) // Note no regexReplace here, but blankToPlus is needed\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23langString%3E.\";\n    }\n    // Case 5: oType is nonnegative integer\n    else if (neighbourArray[i].oType === \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+\"\n        + neighbourArray[i].pDataset\n        + \"%3A\"\n        + regexReplace(neighbourArray[i].pValue)\n        + \"+%22\"\n        + neighbourArray[i].oValue // Note no regexReplace here because it's in quotes\n        + \"%22%5E%5E%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23nonNegativeInteger%3E.\";\n    }\n    // Case 6: oType is \"\", in this case the object value is some dbr\n    else if (neighbourArray[i].oType === \"\") {\n      textToAdd = \n        \"%0D%0A%3Fsomevar+\"\n        + neighbourArray[i].pDataset\n        + \"%3A\"\n        + regexReplace(neighbourArray[i].pValue)\n        + \"+dbr%3A\"\n        + regexReplace(neighbourArray[i].oValue)\n        + \".\";\n    }\n    // Otherwise, we have run into some error potentially\n    else {\n      console.log(neighbourArray[i].oType);\n      error = true;\n    }\n    queryBody+=textToAdd;\n  }\n  // Finally we add in the last bit of text to queryBody\n  queryBody+=\"%0D%0A%7D%0D%0A&\";\n\n  // Create the queryURL and take a look\n  let queryURL = prefixURL + queryBody + suffixURL;\n  \n  // We now return. If error is true, we return error, else, we return queryURL\n  if (error === true) {\n    return \"ERROR\";\n  }\n  else {\n    return queryURL;\n  }\n}\n\n// The following is a helper function used to update firstDegNeighbours and keyColNeighbours.\n// It makes use of two query result arrays.\n\n// It return an object with two attributes: firstDegNeighbours and keyColNeighbours\n\n// This function should be called whenever number of rows are changed.\n\nfunction updateNeighbourInfo(valuesOne, valuesTwo) {\n  // console.log(valuesOne);\n  // console.log(valuesTwo);\n\n  // To support the firstDegNeighbours prefetching, let's store the first degree neighbours in state firstDegNeighbours\n  let firstDegNeighbours = {};\n\n  // First we deal with subject neighbours, so valuesOne\n  let subjectNeighbourArray = [];\n  for (let i = 0; i < valuesOne.length; ++i) {\n    let temp = updateKeyColNeighbours(\n      [],\n      valuesOne[i].results.bindings,\n      \"subject\"\n    )\n    subjectNeighbourArray.push(temp);\n  }\n  firstDegNeighbours[\"subject\"] = storeFirstDeg(subjectNeighbourArray);\n  let processedSubjectNeighbours = processAllNeighbours(subjectNeighbourArray);\n  processedSubjectNeighbours = addRecommendNeighbours(processedSubjectNeighbours);\n\n  // Then we deal with object neighbours, so valuesTwo\n  let objectNeighbourArray = [];\n  for (let i = 0; i < valuesTwo.length; ++i) {\n    let temp = updateKeyColNeighbours(\n      [],\n      valuesTwo[i].results.bindings,\n      \"object\"\n    )\n    objectNeighbourArray.push(temp);\n  }\n  firstDegNeighbours[\"object\"] = storeFirstDeg(objectNeighbourArray);\n  let processedObjectNeighbours = processAllNeighbours(objectNeighbourArray);\n  processedObjectNeighbours = addRecommendNeighbours(processedObjectNeighbours);\n\n  // we now concat subjectNeighbours and objectNeighbours together\n  let keyColNeighbours = processedSubjectNeighbours.concat(processedObjectNeighbours);\n\n  // console.log(keyColNeighbours);\n  // console.log(firstDegNeighbours);\n  return {\n    \"firstDegNeighbours\":firstDegNeighbours,\n    \"keyColNeighbours\":keyColNeighbours,\n  }\n}\n\n","// import { Route, Switch, Link } from \"react-router-dom\";\nimport React, { Component } from \"react\";\n// import Header from \"../components/Header\";\n// import Footer from \"../components/Footer\";\nimport MainBody from \"../components/MainBody\";\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"wrapper \">\n        <div className=\"font-body\">\n          {/* <div className=\"header\">\n            <Header />\n          </div> */}\n          <div>\n            <MainBody />\n          </div>\n          {/* <div className=\"footer\">\n            <Footer />\n          </div> */}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n\n\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"./assets/custom.css\";\nimport \"./assets/layout.css\";\n// import \"./assets/font-awesome.min.css\";\nimport App from \"./layouts/App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}