{"version":3,"sources":["components/Header.jsx","components/Footer.jsx","components/SettingModal.jsx","components/FilterModal.jsx","components/URLForm.jsx","components/LandingPage.jsx","components/TablePanel.jsx","components/TableSelection.jsx","components/TaskMenu.jsx","components/ActionPanel.jsx","components/PagePanel.jsx","components/MainBody.jsx","layouts/App.jsx","index.js"],"names":["Header","state","className","href","class","title","onClick","props","copyTable","openModal","undoPreviousStep","Component","Footer","SettingModal","isOpen","this","showSetting","onChange","e","toggleSemantic","type","value","checked","semanticEnabled","unionCutOff","unionCutOffChange","min","max","step","closeModal","FilterModal","optionsEle","i","push","dataAndChecked","toggleChecked","data","length","showFilter","applyFilter","cancelFilter","URLForm","handleURLPaste","bind","preventDefault","urlPasted","clipboardData","window","getData","placeholder","onPaste","LandingPage","TablePanel","createSuperTable","createSelectedTableView","rowNum","tableData","colNum","table","tempRow","colIndex","tempHeader","keyColIndex","multiAllowed","getKeyOptions","tableHeader","selectColHeader","options","optionsMap","isMulti","openFilter","getOtherOptions","rows","j","tempID","cellColor","keyEntryIndex","backgroundColor","style","id","niceRender","onCellChange","tableDataExplore","tableHeaderRow","tableRows","tableEle","menuArray","contextAddColumn","divider","contextDeleteColumn","contextSortColumn","contextSetCell","contextCellOrigin","contextCellPreview","contextOpenLink","border","str","replace","TableSelection","createButtonArray","originTableArray","buttonArray","buttonText","headerCells","cells","headerData","removeNewLine","innerText","slice","tableContent","dangerouslySetInnerHTML","__html","outerHTML","selectButton","tableOpenList","handleStartTable","toggleTable","Collapse","originTableArrayEle","TaskMenu","subject","resultStr","bracketIndex","indexOf","handleStartSubject","decodeURIComponent","toggleTableSelection","showTableSelection","CardBody","Card","selectedTableIndex","ActionPanel","createPropertyArray","createSiblingArray","createTableArray","firstIndex","secondIndex","tableArray","propertyNeighbours","siblingArray","tableElement","thirdIndex","tableTitleText","Button","toggleOtherTable","unionTable","colMapping","siblingElement","zeroDividerSet","tooltipText","name","listClassSib","toggleSibling","unionPage","propertyElement","predicate","object","propertyText","listClass","togglePropertyNeighbours","unionProperty","actionEle","wrapperEle","titleEle","usecaseSelected","curActionInfo","actionInfo","task","neighbourArrayText","neighbourArray","label","populateKeyColumn","neighbourText","neighbour","populateOtherColumn","neighbourIndex","range","sameNeighbourOneCol","numCols","sameNeighbourDiffCol","siblingText","plural","siblingNeighbour","populateSameRange","origin","cellValue","previewInfoArray","console","log","infoEle","keyLiteral","key","valLiteral","renderPreview","preview","curIndex","tabIndex","selectedIndex","onSelect","index","handleTabSwitch","PagePanel","pageEle","wikiPageClass","iframeURL","buttonhideShow","toggleWikiPage","aria-hidden","pageHidden","src","MainBody","tablePasted","lastAction","prevState","keyColNeighbours","selectedClassAnnotation","curFilterIndex","handleTablePaste","cellChange","getOtherColPromise","addAllNeighbour","document","body","classList","add","includes","promiseArray","fetchText","allPromiseReady","then","values","htmlText","DOMParser","parseFromString","getElementsByClassName","remove","setState","alert","textArea","createElement","copiedText","curText","undefined","appendChild","select","execCommand","removeChild","taskSelected","_","cloneDeep","target","allSubject","regexReplace","queryBody","queryURL","fetchJSON","myJson","keyColOptions","results","bindings","curValue","somevar","tempObj","colEmpty","colFilled","nonEmptyInfo","otherColOptions","selectedOptions","evalue","elabel","keyColLabel","queryBodyOne","dataset","keyColPromise","otherColPromiseSubject","otherColPromiseObject","updatedRowCount","Math","rowsToAdd","emptyEntryCount","startingIndex","labelText","tempOrigin","uniqBy","x","updateKeyColNeighbours","curPromise","requiredLength","dbResult","removePrefix","originToAdd","keyOrigin","remainNeighbourCount","rangeLiteral","keyColIndexUpdated","tableDataUpdated","k","tableHeaderUpdated","curLabel","selectedClassAnnotationUpdated","optionsMapUpdated","curCol","newState","updatedOrigin","promiseArrayTwoD","curPromiseArray","tempData","tempOptions","tempAnnotation","tempKeyColIndex","curColIndex","curValueArray","count","splice","order","numericCol","isNaN","Number","searchEntry","sort","a","b","aValue","bValue","matchFound","rowIndex","cellSelected","originElement","subjectInfoArray","updatePreviewInfo","objectInfoArray","concat","tableIndex","queryPromise","queryOne","urlReplace","queryTwo","findClassAnnotation","queryResults","propertyNeighboursPO","bindingArray","p","o","urlOrigin","curSiblingArray","siblingName","s","getTableStates","setTableFromHTML","stateInfo","siblingNameArray","tableArrayPromise","pageHTML","findTableFromHTML","tableArrayValues","aTableLength","bTableLength","aName","bName","selectedSibling","selectedTable","otherTableHTML","otherTableData","tableConcat","setUnionData","otherTableOrigin","headerRow","sameTable","diffColFound","m","tempMapping","dataArray","Set","checkIndex","valuesToKeep","bodyEle","bottomContentClass","topContentClass","url","fetch","response","json","text","Promise","all","resultsBinding","processedBinding","filter","neighbourCount","neighbourToAdd","neighbourRange","curNeighbour","objLabel","dataToAdd","colInNew","HTMLCleanCell","trim","split","pageName","originCols","wikiTablesFound","tablesFound","tagName","tablePromise","findTableFromTable","unionScore","resolve","tableHTML","curHeaderCells","newCols","remainCols","searchCols","headerName","sameStructure","remainClassAnnotation","curSearchIndex","intersection","totalSuccess","numTrial","hyperCDF","tempTable","curCellText","anchorArray","getElementsByTagName","hrefArray","curRowSpan","rowSpan","curColSpan","colSpan","remainEntries","curEntry","classAnnotation","curColumnClass","curCellClass","selecteTableHTML","originText","N","K","n","denom","combinations","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.b6026638.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport { FaCopy, FaUndo } from \"react-icons/fa\";\r\nimport { FiSettings } from \"react-icons/fi\";\r\n\r\nclass Header extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"row header-body\">\r\n          <div className=\"col-md-8\">\r\n            <a href=\"index.html\" class=\"logo\">\r\n              <b>\r\n                <span>KG</span>Wrangler\r\n              </b>\r\n            </a>\r\n          </div>\r\n          <div className=\"offset-md-2 col-md-2 row\">\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"copy table to csv\"\r\n                onClick={() => this.props.copyTable()}\r\n              >\r\n                <FaCopy className=\"logo-left-color\" />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"Union Table Settings\"\r\n              >\r\n                <FiSettings\r\n                  className=\"logo-left-color\"\r\n                  onClick={() => this.props.openModal()}\r\n                />\r\n              </button>\r\n            </div>\r\n            <div className=\"col-md-4\">\r\n              <button\r\n                className=\"btn btn-default\"\r\n                title=\"undo previous action\"\r\n                onClick={() => this.props.undoPreviousStep()}\r\n              >\r\n                <FaUndo className=\"color-wrangler\" />\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <hr class=\"header-hr\"></hr>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","import React, { Component } from \"react\";\r\nclass Footer extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        {/* <hr className=\"m-0\"></hr> */}\r\n        <div className=\"text-center text-sm\">\r\n          <small>University of Waterloo, 2020</small>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Footer;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\n// The two following lines are for range sliders\r\nimport RangeSlider from \"react-bootstrap-range-slider\";\r\nimport \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\n\r\nclass SettingModal extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showSetting}\r\n          className=\"setting-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div className=\"row\">\r\n              <div className=\"col-md-6 offset-md-3\">\r\n                <h4>Table Union Search Settings</h4>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Semantic Mapping:</div>\r\n              <div className=\"col-md-6\">\r\n                <div onChange={(e) => this.props.toggleSemantic(e)}>\r\n                  <input\r\n                  type=\"radio\"\r\n                  value=\"enabled\"\r\n                  checked={this.props.semanticEnabled === \"enabled\"}\r\n                  />{\" \"}\r\n                  Enabled\r\n                  <input\r\n                    type=\"radio\"\r\n                    value=\"disabled\"\r\n                    checked={this.props.semanticEnabled === \"disabled\"}\r\n                  />{\" \"}\r\n                  Disabled\r\n                </div>\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4\">Percentage of Columns to Union:</div>\r\n              <div className=\"col-md-6\">\r\n                <RangeSlider\r\n                  value={this.props.unionCutOff}\r\n                  onChange={(e) => this.props.unionCutOffChange(e)}\r\n                  min={0}\r\n                  max={1}\r\n                  step={0.05}\r\n                />\r\n              </div>\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-4 offset-md-4\">\r\n                <button onClick={() => this.props.closeModal()}>Confirm Settings</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SettingModal;\r\n","import React, { Component } from \"react\";\r\nimport Modal from 'react-modal';\r\n\r\nclass FilterModal extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n\r\n    let optionsEle = [];\r\n    for (let i=0;i<this.props.dataAndChecked.length;++i) {\r\n      optionsEle.push(\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            checked={this.props.dataAndChecked[i].checked}\r\n            onChange={(e) => this.props.toggleChecked(e, i)}\r\n          />\r\n          {this.props.dataAndChecked[i].data}\r\n        </div>\r\n      )\r\n    }\r\n    // console.log(optionsEle);\r\n\r\n    return (\r\n      <div>\r\n        <Modal \r\n          isOpen={this.props.showFilter}\r\n          className=\"filter-modal\"\r\n        >\r\n          <div className=\"container\">\r\n            <div>\r\n              Here is the list of data to filter from selected column.\r\n            </div>\r\n            <br />\r\n            <div className=\"checkbox-list\">\r\n              {optionsEle}\r\n            </div>\r\n            <br />\r\n            <div className=\"row\">\r\n              <div className=\"col-md-1 offset-md-9\">\r\n                <button onClick={(e) => this.props.applyFilter(e)}>OK</button>\r\n              </div>\r\n              <div className=\"col-md-2\">\r\n                <button onClick={(e) => this.props.cancelFilter(e)}>Cancel</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </Modal>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FilterModal;\r\n","import React, { Component } from \"react\";\r\n\r\nclass URLForm extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n  }\r\n\r\n  handleURLPaste(e) {\r\n    e.preventDefault();\r\n    let urlPasted = (e.clipboardData || window.clipboardData).getData(\"text\");\r\n    this.props.handleURLPaste(urlPasted);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"row text-center\">\r\n          <div className=\"col-md-6 offset-md-3\">\r\n            <input\r\n              placeholder=\"e.g., https://en.wikipedia.org/wiki/Canada\"\r\n              onPaste={this.handleURLPaste}\r\n              className=\" form-control\"\r\n            ></input>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default URLForm;\r\n","import React, { Component } from \"react\";\r\nimport URLForm from \"../components/URLForm\";\r\n\r\nclass LandingPage extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div class=\"landing-page\">\r\n          <div class=\" row text-center\">\r\n            <div class=\"white-form col-md-5\">\r\n              <h1 class=\"\"> Welcome!</h1>\r\n              <hr className=\"header-hr\"></hr>\r\n              <h4>Enter the URL of a Wikipedia page and start wrangling!</h4>\r\n              <URLForm handleURLPaste={this.props.handleURLPaste} />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default LandingPage;\r\n","import React, { Component } from \"react\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// import Tooltip from '@atlaskit/tooltip';\r\nimport Select from \"react-select\";\r\nimport { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\r\nimport { FaFilter } from \"react-icons/fa\";\r\n\r\nclass TablePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createSuperTable = this.createSuperTable.bind(this);\r\n    this.createSelectedTableView = this.createSelectedTableView.bind(this);\r\n  }\r\n\r\n  // This function takes the states tableData, keyColIndex, keyEntryIndex, tableHeader, optionsMap\r\n  // And convert them into HTML for the super table\r\n\r\n  createSuperTable() {\r\n    // console.log(this.props.tableData);\r\n    const rowNum = this.props.tableData.length;\r\n    const colNum = this.props.tableData[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n    let tempRow = [];\r\n    for (let colIndex = 0; colIndex < colNum; ++colIndex) {\r\n      let tempHeader;\r\n      // This part deals with the key column headers\r\n      if (colIndex === this.props.keyColIndex) {\r\n        let multiAllowed = colIndex === 0 ? true : false;\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            <div\r\n              onClick={(e) => this.props.getKeyOptions(e, colIndex)}\r\n              className=\"super-header-div\"\r\n            >\r\n              <Select\r\n                className=\"selection-header\"\r\n                value={this.props.tableHeader[colIndex]}\r\n                onChange={(e) => this.props.selectColHeader(e, colIndex)}\r\n                placeholder={\"Choose header\"}\r\n                options={this.props.optionsMap[this.props.keyColIndex]}\r\n                isMulti={multiAllowed}\r\n              />\r\n              <FaFilter\r\n                className=\"search-icon\"\r\n                title={\"Set as key column\"}\r\n                onClick={(e) => this.props.openFilter(e, colIndex)}\r\n              />\r\n            </div>\r\n          </th>\r\n        );\r\n      }\r\n      // This part deals with the non-key column headers\r\n      else {\r\n        // console.log(\"Current column index is \"+colIndex);\r\n        // console.log(this.props.optionsMap);\r\n        tempHeader = (\r\n          <th className=\"table-head\">\r\n            <div\r\n              onClick={(e) => this.props.getOtherOptions(e, colIndex)}\r\n              className=\"super-header-div\"\r\n            >\r\n              <Select\r\n                className=\"selection-header\"\r\n                value={this.props.tableHeader[colIndex]}\r\n                onChange={(e) => this.props.selectColHeader(e, colIndex)}\r\n                placeholder={\"Choose header\"}\r\n                options={this.props.optionsMap[colIndex]}\r\n                isMulti={false}\r\n              />\r\n              <FaFilter\r\n                className=\"search-icon\"\r\n                title={\"Set as key column\"}\r\n                onClick={(e) => this.props.openFilter(e, colIndex)}\r\n              />\r\n            </div>\r\n          </th>\r\n        );\r\n      }\r\n      tempRow.push(tempHeader);\r\n    }\r\n    table.push(\r\n      <thead className=\"table-head\">\r\n        <tr>{tempRow}</tr>\r\n      </thead>\r\n    );\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n\r\n    // We are adding an ID for each cell for contextmenu\r\n    let rows = [];\r\n    for (let i = 0; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      //Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // Create the each cell\r\n        let tempID = \"cellRow\" + i + \"Col\" + j;\r\n        let cellColor;\r\n        if (j === this.props.keyColIndex) {\r\n          if (i === this.props.keyEntryIndex) {\r\n            cellColor = { backgroundColor: \"Yellow\" };\r\n          } else {\r\n            cellColor = { backgroundColor: \"LightBlue\" };\r\n          }\r\n        } else {\r\n          cellColor = { backgroundColor: \"White\" };\r\n        }\r\n        // console.log(\"Current data is \"+this.props.tableData[i][j]);\r\n        tempRow.push(\r\n          <td style={cellColor}>\r\n            <ContextMenuTrigger id={tempID}>\r\n              <input\r\n                className=\"twenty-vw\"\r\n                type=\"text\"\r\n                value={niceRender(this.props.tableData[i][j].data)}\r\n                title={niceRender(this.props.tableData[i][j].data)}\r\n                // onClick={() => {alert(\"hmm\");}}\r\n                onChange={(e) => this.props.onCellChange(e, i, j)}\r\n                // onClick={() => alert(\"hmm\")} something like this could work\r\n              />\r\n            </ContextMenuTrigger>\r\n          </td>\r\n        );\r\n      }\r\n      //Create the parent and add the children\r\n      rows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{rows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  // This function makes no modification of the data at all.\r\n  // It takes all the data from this.props.tableDataExplore, and convert them into HTML\r\n  createSelectedTableView() {\r\n    // console.log(rowNum);\r\n    // console.log(colNum);\r\n    // console.log(this.props.tableDataExplore[0][0].data);\r\n    // console.log(this.props.tableDataExplore[0][0].origin);\r\n    const rowNum = this.props.tableDataExplore.length;\r\n    const colNum = this.props.tableDataExplore[0].length;\r\n\r\n    let table = [];\r\n\r\n    // This part creates the table header row\r\n    let tempRow = [];\r\n    for (let j = 0; j < colNum; ++j) {\r\n      let tempHeader = (\r\n        <th className=\"table-head table-col\">\r\n          {this.props.tableDataExplore[0][j].data}\r\n        </th>\r\n      );\r\n      tempRow.push(tempHeader);\r\n    }\r\n    let tableHeaderRow = <tr className=\"table-head table-col\">{tempRow}</tr>;\r\n    table.push(<thead>{tableHeaderRow}</thead>);\r\n\r\n    // i corresponds to the row number, j corresponds to the column number\r\n    let tableRows = [];\r\n    for (let i = 1; i < rowNum; i++) {\r\n      let tempRow = [];\r\n      //Inner loop to create each cell of the row\r\n      for (let j = 0; j < colNum; j++) {\r\n        // Create the each cell\r\n        tempRow.push(\r\n          <td className=\"table-col\">\r\n            {this.props.tableDataExplore[i][j].data}\r\n          </td>\r\n        );\r\n      }\r\n      //Create the parent and add the children\r\n      tableRows.push(<tr>{tempRow}</tr>);\r\n    }\r\n    table.push(<tbody>{tableRows}</tbody>);\r\n    return table;\r\n  }\r\n\r\n  render() {\r\n    let tableEle = null;\r\n\r\n    // In all cases, once we have pasted the URL. We want to display the super table in the table panel.\r\n    let menuArray = [];\r\n    for (let i = 0; i < this.props.tableData.length; ++i) {\r\n      for (let j = 0; j < this.props.tableData[0].length; ++j) {\r\n        let tempID = \"cellRow\" + i + \"Col\" + j;\r\n        menuArray.push(\r\n          <ContextMenu id={tempID}>\r\n            <MenuItem onClick={(e) => this.props.contextAddColumn(e, j)}>\r\n              Add Column to the Right\r\n            </MenuItem>\r\n            <MenuItem divider />\r\n            <MenuItem onClick={(e) => this.props.contextDeleteColumn(e, j)}>\r\n              Delete this column\r\n            </MenuItem>\r\n            <MenuItem divider />\r\n            <MenuItem onClick={(e) => this.props.contextSortColumn(e, j, \"ascending\")}>\r\n              Sort ascending\r\n            </MenuItem>\r\n            <MenuItem onClick={(e) => this.props.contextSortColumn(e, j, \"descending\")}>\r\n              Sort descending\r\n            </MenuItem>\r\n            <MenuItem divider />\r\n            <MenuItem onClick={(e) => this.props.contextSetCell(e, i, j)}>\r\n              Set as Search Cell\r\n            </MenuItem>\r\n            <MenuItem divider />\r\n            <MenuItem onClick={(e) => this.props.contextCellOrigin(e, i, j)}>\r\n              Show Origin of Cell\r\n            </MenuItem>\r\n            <MenuItem onClick={(e) => this.props.contextCellPreview(e, i, j)}>\r\n              Show Preview of Cell\r\n            </MenuItem>\r\n            <MenuItem onClick={(e) => this.props.contextOpenLink(e, i, j)}>\r\n              Open Wikipage for Cell\r\n            </MenuItem>\r\n          </ContextMenu>\r\n        );\r\n      }\r\n    }\r\n    tableEle = (\r\n      // class table-fixed helps with sticky column headers\r\n      <div>\r\n        <table class border=\"1\" className=\"table table-sm table-bordered\">\r\n          {this.createSuperTable()}\r\n        </table>\r\n        {menuArray}\r\n      </div>\r\n    );\r\n    return <div>{tableEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TablePanel;\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Collapse } from \"reactstrap\";\r\nimport { FaTable } from \"react-icons/fa\";\r\n\r\nclass TableSelection extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createButtonArray = this.createButtonArray.bind(this);\r\n  }\r\n\r\n  createButtonArray() {\r\n    const originTableArray = this.props.originTableArray;\r\n    let buttonArray = [];\r\n    for (let i = 0; i < originTableArray.length; ++i) {\r\n      // This first part create the buttons with text: table index plus column names\r\n      // It also removes some newline characters\r\n      let buttonText = \"Table \" + i + \": \";\r\n      let headerCells = originTableArray[i].rows[0].cells;\r\n      for (let j = 0; j < headerCells.length; ++j) {\r\n        let headerData = removeNewLine(headerCells[j].innerText);\r\n        if (headerData[headerData.length - 1] === \"\\n\") {\r\n          headerData = headerData.slice(0, -1);\r\n        }\r\n        buttonText = buttonText + headerData + \"| \";\r\n      }\r\n      // Now let's update the table content\r\n      let tableContent = (\r\n        <div\r\n          dangerouslySetInnerHTML={{\r\n            __html: this.props.originTableArray[i].outerHTML,\r\n          }}\r\n        />\r\n      );\r\n      let selectButton;\r\n      if (this.props.tableOpenList[i] === true) {\r\n        selectButton = \r\n          <button\r\n            onClick={(e) => this.props.handleStartTable(e, i)}\r\n          >\r\n            Select\r\n          </button>\r\n      }\r\n      buttonArray.push(\r\n        <li\r\n          className=\"list-group-item\"\r\n          // onClick={(e) => this.props.toggleTable(e, i)}\r\n        >\r\n        <span \r\n          onClick={(e) => this.props.toggleTable(e, i)}\r\n        >\r\n          {buttonText} {}\r\n          <FaTable />\r\n        </span>\r\n        {selectButton}\r\n          <Collapse isOpen={this.props.tableOpenList[i]}>\r\n            <div>{tableContent}</div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">{buttonArray}</ul>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const numTables = this.props.originTableArray.length;\r\n    let originTableArrayEle = null;\r\n    if (numTables !== 0) {\r\n      originTableArrayEle = <div>{this.createButtonArray()}</div>;\r\n    }\r\n    return <div>{originTableArrayEle}</div>;\r\n  }\r\n}\r\n\r\nexport default TableSelection;\r\n\r\nfunction removeNewLine(str) {\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1);\r\n  } else {\r\n    return str;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Collapse, CardBody, Card } from \"reactstrap\";\r\nimport { FaList } from \"react-icons/fa\";\r\nimport TableSelection from \"../components/TableSelection\";\r\n\r\nclass TaskMenu extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const subject = niceRender(reverseReplace(this.props.urlPasted.slice(30)));\r\n    return (\r\n      <div>\r\n        <ul class=\"list-group list-css list-group-flush\">\r\n          <hr className=\"m-0\"></hr>\r\n          <li\r\n            className=\"list-group-item\"\r\n            onClick={(e) => this.props.handleStartSubject(e, \"startSubject\")}\r\n          >\r\n            Start creating a table about {decodeURIComponent(subject)}\r\n          </li>\r\n          <li\r\n            className=\"list-group-item\"\r\n          >\r\n            <span \r\n              onClick={() => this.props.toggleTableSelection()}\r\n            >\r\n              Start with an existing table from page <FaList />\r\n            </span>\r\n\r\n            <Collapse isOpen={this.props.showTableSelection}>\r\n              <CardBody>\r\n                <Card>\r\n                  <div>\r\n                    <TableSelection\r\n                      originTableArray={this.props.originTableArray}\r\n                      tableOpenList={this.props.tableOpenList}\r\n                      toggleTable={this.props.toggleTable}\r\n                      selectedTableIndex={this.props.selectedTableIndex}\r\n                      handleStartTable={this.props.handleStartTable}\r\n                    />\r\n                  </div>\r\n                </Card>\r\n              </CardBody>\r\n            </Collapse>\r\n          </li>\r\n          <hr className=\"m-0\"></hr>\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TaskMenu;\r\n\r\n// This function changes the copied text \"%E2%80%93\" to \"-\" when we copy a URL from google. \r\n\r\nfunction reverseReplace(str) {\r\n  return str.replace(/%E2%80%93/, \"\");\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\n  function niceRender(str) {\r\n    let resultStr = str;\r\n    let bracketIndex = str.indexOf(\"(\");\r\n    // If ( is present in a string, we want to remove it\r\n    // We include the -1 because usually ( is preceeded by _\r\n    if (bracketIndex !== -1) {\r\n      resultStr = resultStr.slice(0, bracketIndex-1);\r\n    }\r\n    // now we turn all \"_\" into \" \"\r\n    return resultStr.replace(/_/g, \" \");\r\n  }\r\n","import React, { Component } from \"react\";\r\nimport TaskMenu from \"../components/TaskMenu\";\r\nimport { Collapse, Button, CardBody, Card } from \"reactstrap\";\r\nimport { FaList, FaTable } from \"react-icons/fa\";\r\n// import TableSelection from \"../components/TableSelection\";\r\n// The two following lines are for tabs\r\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\r\nimport \"react-tabs/style/react-tabs.css\";\r\n// The two following lines are for range sliders\r\n// import RangeSlider from \"react-bootstrap-range-slider\";\r\n// import \"react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css\";\r\n\r\nclass ActionPanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.createPropertyArray = this.createPropertyArray.bind(this);\r\n    this.createSiblingArray = this.createSiblingArray.bind(this);\r\n    this.createTableArray = this.createTableArray.bind(this);\r\n  }\r\n\r\n  createTableArray(firstIndex, secondIndex) {\r\n    const tableArray = this.props.propertyNeighbours[firstIndex].siblingArray[\r\n      secondIndex\r\n    ].tableArray;\r\n    let tableElement = [];\r\n    for (let thirdIndex = 0; thirdIndex < tableArray.length; ++thirdIndex) {\r\n      // console.log(\"Hello\");\r\n      // console.log(tableArray[thirdIndex].title);\r\n      let tableTitleText = \"Table \" + thirdIndex + \": \";\r\n      for (let i = 0; i < tableArray[thirdIndex].title.length; ++i) {\r\n        tableTitleText = tableTitleText + tableArray[thirdIndex].title[i] + \"|\";\r\n      }\r\n      tableElement.push(\r\n        <div>\r\n          <Button\r\n            onClick={(e) =>\r\n              this.props.toggleOtherTable(\r\n                e,\r\n                firstIndex,\r\n                secondIndex,\r\n                thirdIndex\r\n              )\r\n            }\r\n          >\r\n            {tableTitleText}\r\n            <FaTable />\r\n          </Button>\r\n          <Collapse isOpen={tableArray[thirdIndex].isOpen}>\r\n            <Card>\r\n              <CardBody>\r\n                <div>\r\n                  <ul className=\"list-group list-css\">\r\n                    <li\r\n                      className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                      onClick={(e) =>\r\n                        this.props.unionTable(\r\n                          firstIndex,\r\n                          secondIndex,\r\n                          tableArray[thirdIndex].data,\r\n                          tableArray[thirdIndex].colMapping\r\n                        )}\r\n                    >\r\n                      Union table\r\n                    </li>\r\n                  </ul>\r\n                  <div\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: tableArray[thirdIndex].data.outerHTML,\r\n                    }}\r\n                  ></div>\r\n                </div>\r\n              </CardBody>\r\n            </Card>\r\n          </Collapse>\r\n        </div>\r\n      );\r\n    }\r\n    return tableElement;\r\n  }\r\n\r\n  createSiblingArray(firstIndex) {\r\n    const siblingArray = this.props.propertyNeighbours[firstIndex].siblingArray;\r\n    let siblingElement = [];\r\n    let zeroDividerSet = false;\r\n    for (\r\n      let secondIndex = 0;\r\n      secondIndex < siblingArray.length;\r\n      ++secondIndex\r\n    ) {\r\n      let tooltipText =\r\n        \"Examine tables on page \" + siblingArray[secondIndex].name;\r\n      // let divider = null;\r\n      let listClassSib = \"list-group-item\";\r\n      if (siblingArray[secondIndex].isOpen) {\r\n        listClassSib = \"list-group-item list-with-background\";\r\n      }\r\n      if (\r\n        zeroDividerSet === false &&\r\n        siblingArray[secondIndex].tableArray.length === 0\r\n      ) {\r\n        zeroDividerSet = true;\r\n        // divider = (\r\n        //   <li>\r\n        //     <h5>\r\n        //       Below are sibling pages on which no similar tables are found:\r\n        //     </h5>\r\n        //     <hr />\r\n        //   </li>\r\n        // );\r\n        siblingElement.push(\r\n          <li className=\"list-group-item\">\r\n            <hr />\r\n            <h5>\r\n              Below are sibling pages on which no similar tables are found:\r\n            </h5>\r\n            <hr />\r\n          </li>\r\n        );\r\n      }\r\n\r\n      siblingElement.push(\r\n        <li \r\n          className={listClassSib} \r\n          title={tooltipText}\r\n          // onClick={(e) =>\r\n          //   this.props.toggleSibling(e, firstIndex, secondIndex)\r\n          // }\r\n        >\r\n          <span\r\n            onClick={(e) =>\r\n              this.props.toggleSibling(e, firstIndex, secondIndex)\r\n            }\r\n          >\r\n            {siblingArray[secondIndex].name + \" \"}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={siblingArray[secondIndex].isOpen}>\r\n            <div>\r\n              <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button\"\r\n                  onClick={(e) => this.props.unionPage(firstIndex, secondIndex)}\r\n                >\r\n                  Union from page\r\n                </li>\r\n              </ul>\r\n              {this.createTableArray(firstIndex, secondIndex)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {\" \"}\r\n        {siblingElement}{\" \"}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  createPropertyArray() {\r\n    // console.log(\"Getting here meaning we are recreating the property array\");\r\n    const propertyNeighbours = this.props.propertyNeighbours;\r\n    // console.log(propertyNeighbours);\r\n    let propertyElement = [];\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      // We create the text for property buttons: table index plus column names\r\n      const predicate = propertyNeighbours[i].predicate;\r\n      const object = propertyNeighbours[i].object;\r\n      let propertyText = predicate + \": \" + object + \" \";\r\n      let tooltipText = \"Show other pages with \" + predicate + \": \" + object;\r\n\r\n      let listClass = \"list-group-item\";\r\n      if (this.props.propertyNeighbours[i].isOpen) {\r\n        listClass = \"list-group-item list-with-background\";\r\n      }\r\n\r\n      propertyElement.push(\r\n        <li class={listClass} title={tooltipText}>\r\n          <span onClick={(e) => this.props.togglePropertyNeighbours(e, i)}>\r\n            {propertyText}\r\n            <FaList />\r\n          </span>\r\n\r\n          <Collapse isOpen={this.props.propertyNeighbours[i].isOpen}>\r\n            <div>\r\n              <hr />\r\n              <ul className=\"list-group list-css\">\r\n                <li\r\n                  className=\"col-md-4 list-group-item list-button list-button-backgound-pink\"\r\n                  onClick={(e) => this.props.unionProperty(i)}\r\n                >\r\n                  Union from all pages\r\n                </li>\r\n              </ul>\r\n              {this.createSiblingArray(i)}\r\n            </div>\r\n          </Collapse>\r\n        </li>\r\n      );\r\n    }\r\n    return (\r\n      <ul className=\"list-group list-css list-group-flush\">\r\n        {propertyElement}\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    let actionEle;  // contains either wrangling actions or unionable tables for the action panel\r\n    let wrapperEle; // wrapper element for actionEle. This is what we will render in the HTML.\r\n    let titleEle;   // contains what we will display as the title for the action panel\r\n\r\n    // We first decide the content for the titleElement\r\n    if (\r\n      this.props.usecaseSelected === \"\" \r\n      // ||\r\n      // (this.props.usecaseSelected === \"startTable\" &&\r\n      //   this.props.selectedTableIndex === -1)\r\n    ) {\r\n      titleEle = (\r\n        <div className=\"row\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              ACTIONS\r\n              <span> </span>\r\n              <span className=\"logo-right-color xsmall\">\r\n                Select your starting action\r\n              </span>\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    } \r\n    else {\r\n      titleEle = (\r\n        <div className=\"row action-header\">\r\n          <div className=\"col-md-8\">\r\n            <h4 className=\"logo-left-color\">\r\n              ACTIONS\r\n              <span> </span>\r\n              <span className=\"logo-right-color xsmall\">\r\n                Select your next action\r\n              </span>\r\n            </h4>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // We now decide the content for the actionElement\r\n    // Case 1: URL has been pasted, but task has not been selected. User needs to select task.\r\n    if (this.props.usecaseSelected === \"\") {\r\n      wrapperEle = \r\n        <TaskMenu \r\n          handleStartSubject={this.props.handleStartSubject} \r\n          urlPasted={this.props.urlPasted}\r\n          showTableSelection={this.props.showTableSelection}\r\n          toggleTableSelection={this.props.toggleTableSelection}\r\n          originTableArray={this.props.originTableArray}\r\n          tableOpenList={this.props.tableOpenList}\r\n          toggleTable={this.props.toggleTable}\r\n          selectedTableIndex={this.props.selectedTableIndex}\r\n          handleStartTable={this.props.handleStartTable}\r\n        />;\r\n    }\r\n    // Case 2: Task has been selected. curActionInfo is not null, meaning we have to display some task in ActionPanel\r\n    else if (this.props.curActionInfo !== null) {\r\n      const actionInfo = this.props.curActionInfo;\r\n      // In this case we ask users to select a column header for the first column\r\n      if (actionInfo.task === \"afterStartSubject\") {\r\n        actionEle = (\r\n          <div>\r\n            <p className=\"suggestion-text\">\r\n              Fill the <b>first column header</b> by choosing from its <b>dropdown menu</b>\r\n            </p>\r\n            <br />\r\n            <p>\r\n              (If multiple categories are selected from the dropdown menu, <br />\r\n              the first column will be filled by entities belonging to the <b>intersection</b> of all categories.)  \r\n            </p>\r\n          </div>\r\n        )\r\n      }\r\n      // In this case, we tell users they can keep wrangling by selecting column header for empty columns\r\n      else if (actionInfo.task === \"afterPopulateColumn\") {\r\n        // start here\r\n        actionEle = (\r\n          <div>\r\n            Fill an <b>empty column header</b> by choosing from its <b>dropdown menu</b>\r\n          </div>\r\n        )\r\n      }\r\n      // In this case we give user a button to allow the population of first column\r\n      else if (actionInfo.task === \"populateKeyColumn\") {\r\n        let neighbourArrayText = \"\";\r\n        for (let i = 0; i < actionInfo.neighbourArray.length; ++i) {\r\n          if (i > 0) {\r\n            neighbourArrayText += \" & \";\r\n          }\r\n          neighbourArrayText += actionInfo.neighbourArray[i].label;\r\n        }\r\n        if (neighbourArrayText !== \"\") {\r\n          actionEle = (\r\n            <div>\r\n              <p>Fill this column with:</p>\r\n              <p><b>{neighbourArrayText}</b> ?</p>\r\n              <button\r\n                onClick={(e) =>\r\n                  this.props.populateKeyColumn(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    actionInfo.neighbourArray\r\n                  )\r\n                }\r\n              >\r\n                OK\r\n              </button>\r\n            </div>\r\n          );\r\n        }\r\n        else {\r\n          actionEle = (\r\n            <div>\r\n              <p className=\"suggestion-text\">\r\n                Fill the <b>first column header</b> by choosing from its <b>dropdown menu</b>\r\n              </p>\r\n            </div>\r\n          );\r\n        }\r\n      } \r\n      // In this case we give user a button to allow the population of a new column\r\n      else if (actionInfo.task === \"populateOtherColumn\") {\r\n        let neighbourText =\r\n          actionInfo.type === \"subject\"\r\n            ? actionInfo.neighbour\r\n            : \"is \" + actionInfo.neighbour + \" of\";\r\n        actionEle = (\r\n          <div>\r\n            <p>Fill this column with:</p>\r\n            <p><b>{neighbourText}</b> ?</p>\r\n            <button\r\n              onClick={(e) =>\r\n                this.props.populateOtherColumn(\r\n                  e,\r\n                  actionInfo.colIndex,\r\n                  actionInfo.neighbour,\r\n                  actionInfo.neighbourIndex,\r\n                  actionInfo.type,\r\n                  actionInfo.range\r\n                )\r\n              }\r\n            >\r\n              OK\r\n            </button>\r\n          </div>\r\n        );\r\n      } \r\n      // In this case we give user a button to allow the population of same neighbour\r\n      else if (actionInfo.task === \"populateSameNeighbour\") {\r\n        let neighbourText =\r\n          actionInfo.type === \"subject\"\r\n            ? actionInfo.neighbour\r\n            : \"is \" + actionInfo.neighbour + \" of\";\r\n        actionEle = (\r\n          <div>\r\n            <p>Add all other properties with name:</p>\r\n            <p><b>{neighbourText}</b> ?</p>\r\n            <div className=\"row\">\r\n              <button\r\n                className=\"col-md-4\"\r\n                onClick={(e) =>\r\n                  this.props.sameNeighbourOneCol(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    actionInfo.neighbour,\r\n                    actionInfo.neighbourIndex,\r\n                    actionInfo.type,\r\n                    actionInfo.numCols\r\n                  )\r\n                }\r\n              >\r\n                In One Column\r\n              </button>\r\n              <button\r\n                className=\"offset-md-1 col-md-4\"\r\n                onClick={(e) =>\r\n                  this.props.sameNeighbourDiffCol(\r\n                    e,\r\n                    actionInfo.colIndex,\r\n                    actionInfo.neighbour,\r\n                    actionInfo.neighbourIndex,\r\n                    actionInfo.type,\r\n                    actionInfo.numCols,\r\n                    actionInfo.range\r\n                  )\r\n                }\r\n              >\r\n                In Separate Columns\r\n              </button>\r\n            </div>\r\n          </div>\r\n        );\r\n      } \r\n      // In this case we give user a button to allow the population of all neighbours from the same range\r\n      else if (actionInfo.task === \"populateSameRange\") {\r\n        let siblingText = \"\";\r\n        let plural = \"\";\r\n        for (let i = 0; i < actionInfo.siblingNeighbour.length; ++i) {\r\n          if (i > 0) {\r\n            siblingText += \", \";\r\n            plural = \"s\";\r\n          }\r\n          siblingText += actionInfo.siblingNeighbour[i].value;\r\n        }\r\n        actionEle = (\r\n          <div>\r\n            <p>Add column{plural}: <b>{siblingText}</b></p>\r\n            <p>that also has type: {actionInfo.range} ?</p>\r\n            <button\r\n              onClick={(e) =>\r\n                this.props.populateSameRange(\r\n                  e,\r\n                  actionInfo.colIndex,\r\n                  actionInfo.range,\r\n                  actionInfo.siblingNeighbour\r\n                )\r\n              }\r\n            >\r\n              OK\r\n            </button>\r\n          </div>\r\n        );\r\n      } \r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"contextCellOrigin\") {\r\n        actionEle = (\r\n          <div>\r\n            <p>Origin of selected cell is:</p>\r\n            <div>{actionInfo.origin}</div>\r\n          </div>\r\n        );\r\n      }\r\n      // In this case we display the origin of selected cell\r\n      else if (actionInfo.task === \"contextCellPreview\") {\r\n      actionEle = (\r\n        <div>\r\n          <p>Preview of <b>{niceRender(actionInfo.cellValue)}</b> is:</p>\r\n          <div>\r\n            {renderPreview(actionInfo.preview)}\r\n          </div>\r\n        </div>\r\n        );\r\n      }  \r\n    } \r\n    // This is an empty else clause\r\n    else {\r\n    }\r\n\r\n    // Now we have to determine whether we are rendering one tab or two tabs.\r\n    // One tab for startSubject. Two tabs for startTable.\r\n    // console.log(this.props.usecaseSelected);\r\n    // In the startSubject case, we will have one tab: wrangling actions\r\n\r\n    if (this.props.usecaseSelected === \"startSubject\") {\r\n      let curIndex = this.props.tabIndex;\r\n      wrapperEle = (\r\n        <div>\r\n          <Tabs\r\n            selectedIndex={curIndex}\r\n            onSelect={(index) => this.props.handleTabSwitch(index)}\r\n          >\r\n            <TabList>\r\n              <Tab>Wrangling Actions</Tab>\r\n            </TabList>\r\n            <TabPanel>\r\n              <div className=\"wrangling-actions\">\r\n                {actionEle}\r\n              </div>\r\n              {/* <div className=\"table-list\">\r\n                <ul class=\"list-group list-css list-group-flush\">\r\n                  <hr className=\"m-0\"></hr>\r\n                  <li\r\n                    className=\"list-group-item\"\r\n                  >\r\n                    <span \r\n                      onClick={() => this.props.toggleTableSelection()}\r\n                    >\r\n                      Restart with an existing table from page <FaList />\r\n                    </span>\r\n\r\n                    <Collapse isOpen={this.props.showTableSelection}>\r\n                      <CardBody>\r\n                        <Card>\r\n                          <div>\r\n                            <TableSelection\r\n                              originTableArray={this.props.originTableArray}\r\n                              tableOpenList={this.props.tableOpenList}\r\n                              toggleTable={this.props.toggleTable}\r\n                              selectedTableIndex={this.props.selectedTableIndex}\r\n                              handleStartTable={this.props.handleStartTable}\r\n                            />\r\n                          </div>\r\n                        </Card>\r\n                      </CardBody>\r\n                    </Collapse>\r\n                  </li>\r\n                </ul>\r\n              </div> */}\r\n            </TabPanel>\r\n          </Tabs>\r\n        </div>\r\n      );\r\n    }\r\n    else if (this.props.usecaseSelected === \"startTable\") {\r\n      // If we have not selected a table, we show both tabs, as we are fully ready.\r\n      if (this.props.selectedTableIndex !== -1) {\r\n        let curIndex = this.props.tabIndex;\r\n        wrapperEle = (\r\n          <div>\r\n            <Tabs \r\n              selectedIndex={curIndex}\r\n              onSelect={(index) => this.props.handleTabSwitch(index)}\r\n            >\r\n              <TabList>\r\n                <Tab>Wrangling Actions</Tab>\r\n                <Tab>Union Tables</Tab>\r\n              </TabList>\r\n              <TabPanel>\r\n                {actionEle}\r\n              </TabPanel>\r\n              <TabPanel>\r\n                <small>\r\n                  Explore relations below to look for other pages with similar\r\n                  tables:\r\n                </small>{\" \"}\r\n                <br></br>\r\n                {this.createPropertyArray()}\r\n              </TabPanel>\r\n            </Tabs>\r\n          </div>\r\n        )\r\n      }\r\n      // Else, we have not selected a table yet. In this case, wrapperEle should be equal to actionEle\r\n      else {  \r\n        wrapperEle = actionEle;\r\n      }\r\n    }\r\n    return (\r\n      <div>\r\n        {titleEle}\r\n        {wrapperEle}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ActionPanel;\r\n\r\n// The following helper function creates HTML elements from previewInfoArray, \r\n// an array of key-val pairs containing the info for a cell's preview.\r\n\r\n// It also makes use of niceRender, so that preview looks clean.\r\n\r\nfunction renderPreview(previewInfoArray) {\r\n  console.log(previewInfoArray);\r\n  let infoEle = [];\r\n  for (let i = 0; i < previewInfoArray.length; ++i) {\r\n    let keyLiteral = previewInfoArray[i].key;\r\n    // We get the first element from value Array\r\n    let valLiteral = niceRender(previewInfoArray[i].value[0]);\r\n    // Since we have already included thte first element, we start the index from 1\r\n    for (let j = 1; j < previewInfoArray[i].value.length; ++j) {\r\n      valLiteral = valLiteral + \"; \"+niceRender(previewInfoArray[i].value[j]);\r\n    }\r\n    infoEle.push(\r\n      <p><b>{keyLiteral}</b>{\":\"}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{'\\u00A0'}{valLiteral}</p>\r\n    )\r\n  }\r\n  return infoEle;\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It removes all occurence of (...), and changes all \"_\" to \" \".\r\n\r\nfunction niceRender(str) {\r\n  return str.replace(/_\\(.*?\\)/g, \"\")\r\n            .replace(/_/g, \" \");\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nclass PagePanel extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    let pageEle = null;\r\n    let wikiPageClass = \"small-padding wiki-page-hidden\";\r\n    let buttonClass = \"btn btn-sm btn-info toggle-button\";\r\n    if (this.props.iframeURL !== \"\") {\r\n      let buttonhideShow = (\r\n        <button\r\n          className={buttonClass}\r\n          onClick={() => this.props.toggleWikiPage()}\r\n        >\r\n          <i class=\"fa fa-chevron-up\" aria-hidden=\"true\"></i>\r\n          Show\r\n        </button>\r\n      );\r\n      if (!this.props.pageHidden) {\r\n        wikiPageClass = \"small-padding wiki-page\";\r\n        buttonhideShow = (\r\n          <div>\r\n            <hr className=\"m-1\"></hr>\r\n            <button\r\n              className={buttonClass}\r\n              onClick={() => this.props.toggleWikiPage()}\r\n            >\r\n              <i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i>\r\n              Hide\r\n            </button>\r\n          </div>\r\n        );\r\n      }\r\n      pageEle = (\r\n        <div className=\"page-panel text-right\">\r\n          {buttonhideShow}\r\n          <div className={wikiPageClass}>\r\n            <iframe\r\n              id=\"iframe\"\r\n              title=\"URLPage\"\r\n              src={this.props.iframeURL}\r\n              className=\"iframe-cls\"\r\n            ></iframe>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n    return <div>{pageEle}</div>;\r\n  }\r\n}\r\n\r\nexport default PagePanel;\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\nimport { combinations } from \"mathjs\";\r\nimport Header from \"../components/Header\";\r\nimport Footer from \"../components/Footer\";\r\nimport SettingModal from \"../components/SettingModal\";\r\nimport FilterModal from \"../components/FilterModal\";\r\nimport LandingPage from \"../components/LandingPage\";\r\nimport TablePanel from \"../components/TablePanel\";\r\nimport ActionPanel from \"../components/ActionPanel\";\r\nimport PagePanel from \"../components/PagePanel\";\r\nimport _ from \"lodash\";\r\n\r\nconst maxNeighbourCount = 50;\r\nconst initialColNum = 4;\r\nconst initialRowNum = 30;\r\n\r\nclass MainBody extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    let tableData = [];\r\n    let tableHeader = [];\r\n    let optionsMap = [];\r\n    for (let i = 0; i < initialRowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < initialColNum; ++j) {\r\n        // Initially, cell has no data or origin\r\n        // data field is a string\r\n        // origin field is an array of strings\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n    for (let j = 0; j < initialColNum; ++j) {\r\n      let emptyOptions = [];\r\n      optionsMap.push(emptyOptions);\r\n      tableHeader.push(\"\");\r\n    }\r\n    this.state = {\r\n      // states below are general states used throughout the app\r\n      urlPasted: \"\",  \r\n      tablePasted: \"\",\r\n      usecaseSelected: \"\",\r\n      pageHidden: false,\r\n      iframeURL: \"\",\r\n      curActionInfo: null, // object storing the current action that should be displayed in ActionPanel. Initially null.\r\n      lastAction: \"\",      // string storing the last action that has modified the result table in the table panel\r\n      prevState: \"\",       // objects storing the information needed to undo the last step. Information stored depends on lastAction\r\n      showSetting: false,    // boolean storing whether setting modal is shown or not. Default to false.\r\n      showTableSelection: false,    // boolean storing whether the list of tables from page is shown. Default to false.\r\n      tabIndex: 1,         // integer storing the index of the tab currently displaying. Default to 1.\r\n\r\n      // states below are useful for startSubject\r\n      keyColIndex: 0,   // number storing the index of the search column. initially the key column is the first column\r\n      keyEntryIndex: 0, // number storing the index of the search entry in the search column. initially 0. (the first entry in the search column)\r\n      // 1D array of objects with four properties storing the table headers. This array is used to create the column headers in table panel\r\n      // 1) label:  string storing the label of an option (ex: spouse)\r\n      // 2) value:  string storing the value of an option (ex: spouse)\r\n      // 3) type:   string that's either \"subject\" or \"object\". Storing whether the current option is ?s or ?o with respect to key column. Can be empty.\r\n      // 4) range:  string storing the rdfs:range of the current option.\r\n      tableHeader: tableHeader,\r\n      tableData: tableData, // 2D array of objects storing the table data (not including the table headers).\r\n      optionsMap: optionsMap, // 2D array storing the options map\r\n      keyColNeighbours: [], // 1D array storing the neighbours of the key column\r\n\r\n      // startes below are useful for startTable\r\n      originTableArray: [], // 1D array storing all tables found on pasted URL\r\n      tableOpenList: [], // 1D array storing whether each table in originTableArray has been toggled open or not\r\n      selectedTableIndex: -1, // index of table selected by user. If it's -1, take user to table selection. Else, show the table in Table Panel.\r\n      selectedClassAnnotation: [], // semantic class annotation for each column of selected table\r\n      // 2D arary of objects with three properties, which store the table data from explore table task. Similar to tableData above. \r\n      // Three properties: data, origin, rowSpan, colSpan.\r\n      tableDataExplore: [], \r\n      // array of objects with four properties storing the status/content for each property neighbour\r\n      // 1) predicate: string storing the predicate (ex. dbp:league)\r\n      // 2) object: string storing the object (ex. dbo:NBA)\r\n      // 3) isOpen: boolean storing whether the current property neighbour is toggled on or not\r\n      // 4) siblingArary: array of objects with two properties storing the staus/content for each sibling URL\r\n      //    4.1) isOpen:      boolean storing whether the current sibling is toggled on or not\r\n      //    4.2) tableArray:  array of objects storing the status/content for each \"same\" table on the sibling URL\r\n      //         4.2.1) isOepn:        boolean storing whether the current table is toggled on or not\r\n      //         4.2.2) unionScore:    number storing teh union score of the current table (how \"similar\" it is to the original table)\r\n      //         4.2.3) colMapping:    array of numbers storing the column mapping between the current table and the selected table\r\n      //         4.2.4) data:          HTML of a table\r\n      //         4.2.5) title:         array of strings storing the column headers of the current table\r\n      propertyNeighbours: [],\r\n      semanticEnabled: \"disabled\", // boolean value indicating whether semantic mapping is enabled or not. Default to true\r\n      unionCutOff: 0.75, // number representing the union percentage a table must have to be considered unionable (>=)\r\n\r\n      // states below are for column filter\r\n      showFilter: false,        // boolean storing whether we want to show column filter or not. Initially false.\r\n      curFilterIndex: -1,       // number storing the index of the column on which we apply the filter. Initially -1 (no filter.)\r\n      dataAndChecked: [],       // array of [data, checked] pairs storing which data are in the filter column, and whether we should keep them.\r\n    };\r\n\r\n    // functions below are useful during start up\r\n    this.handleURLPaste = this.handleURLPaste.bind(this);\r\n    this.handleTablePaste = this.handleTablePaste.bind(this);\r\n    this.handleStartSubject = this.handleStartSubject.bind(this);\r\n    this.handleStartTable = this.handleStartTable.bind(this);\r\n\r\n    // functions below are useful for startSubject\r\n    this.cellChange = this.cellChange.bind(this);\r\n    this.selectColHeader = this.selectColHeader.bind(this);\r\n    this.getKeyOptions = this.getKeyOptions.bind(this);\r\n    this.getOtherOptions = this.getOtherOptions.bind(this);\r\n    this.populateKeyColumn = this.populateKeyColumn.bind(this);\r\n    this.getOtherColPromise = this.getOtherColPromise.bind(this);\r\n    // this.getOtherColPromiseTwo = this.getOtherColPromiseTwo.bind(this);\r\n    this.populateOtherColumn = this.populateOtherColumn.bind(this);\r\n    this.addAllNeighbour = this.addAllNeighbour.bind(this);\r\n    this.sameNeighbourDiffCol = this.sameNeighbourDiffCol.bind(this);\r\n    this.sameNeighbourOneCol = this.sameNeighbourOneCol.bind(this);\r\n    this.populateSameRange = this.populateSameRange.bind(this);\r\n    this.contextAddColumn = this.contextAddColumn.bind(this);\r\n    this.contextDeleteColumn = this.contextDeleteColumn.bind(this);\r\n    this.contextSetCell = this.contextSetCell.bind(this);\r\n    this.contextCellOrigin = this.contextCellOrigin.bind(this);\r\n    this.contextCellPreview = this.contextCellPreview.bind(this);\r\n    this.contextOpenLink = this.contextOpenLink.bind(this);\r\n    this.contextSortColumn = this.contextSortColumn.bind(this);\r\n\r\n    // functions below are useful for startTable\r\n    this.toggleTable = this.toggleTable.bind(this);\r\n    this.togglePropertyNeighbours = this.togglePropertyNeighbours.bind(this);\r\n    this.toggleSibling = this.toggleSibling.bind(this);\r\n    this.toggleOtherTable = this.toggleOtherTable.bind(this);\r\n    this.unionTable = this.unionTable.bind(this);\r\n    this.unionPage = this.unionPage.bind(this);\r\n    this.unionProperty = this.unionProperty.bind(this);\r\n    this.toggleSemantic = this.toggleSemantic.bind(this);\r\n    this.unionCutOffChange = this.unionCutOffChange.bind(this);\r\n\r\n    // functions below are generally usefull\r\n    this.copyTable = this.copyTable.bind(this);\r\n    this.toggleWikiPage = this.toggleWikiPage.bind(this);\r\n    this.undoPreviousStep = this.undoPreviousStep.bind(this);\r\n    this.handleTabSwitch = this.handleTabSwitch.bind(this);\r\n    this.openModal = this.openModal.bind(this);\r\n    this.closeModal = this.closeModal.bind(this);\r\n    this.toggleTableSelection = this.toggleTableSelection.bind(this);\r\n\r\n    // functions below are for column filter\r\n    this.openFilter = this.openFilter.bind(this);\r\n    this.cancelFilter = this.cancelFilter.bind(this);\r\n    this.toggleChecked = this.toggleChecked.bind(this);\r\n    this.applyFilter = this.applyFilter.bind(this);\r\n  }\r\n\r\n  handleURLPaste(urlPasted) {\r\n    document.body.classList.add('waiting');\r\n    // As soon as the URL has been pasted, we want to fetch all tables from the pasted URL.\r\n    // We then update the originTableArray, which stores all the tables found on the pasted URL\r\n    // We also initialize tableOpenList to all false\r\n\r\n    // Lastly, we updated the urlPasted and iframeURL\r\n\r\n    if (!urlPasted.includes(\"https://en.wikipedia.org/wiki/\")) {\r\n      alert(\"Please paste a valid Wikipedia link.\");\r\n    }\r\n    else {\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchText(urlPasted));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // We first parse the pasted URL and store the list of tables from the pasted URL\r\n        let htmlText = values[0];\r\n        let doc = new DOMParser().parseFromString(htmlText, \"text/html\");\r\n        let originTableArray = doc.getElementsByClassName(\"wikitable\");\r\n        let tableOpenList = [];\r\n        for (let i = 0; i < originTableArray.length; ++i) {\r\n          tableOpenList.push(false);\r\n        }\r\n\r\n        // Adding support for undo:\r\n\r\n        document.body.classList.remove('waiting');\r\n        let lastAction = \"handleURLPaste\";\r\n        let prevState = \r\n          {\r\n            \"urlPasted\":\"\",\r\n            \"iframeURL\":\"\",\r\n            \"originTableArray\":[],\r\n            \"tableOpenList\":[],\r\n          };\r\n\r\n        this.setState({\r\n          originTableArray: originTableArray,\r\n          tableOpenList: tableOpenList,\r\n          urlPasted: urlPasted,\r\n          iframeURL: urlPasted,\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  handleTablePaste(tablePasted) {\r\n    this.setState({\r\n      tablePasted: tablePasted,\r\n    });\r\n  }\r\n\r\n  // This function copies the table content to clipboard\r\n\r\n  copyTable() {\r\n    const textArea = document.createElement(\"textarea\"); // this line allows the use of select() function\r\n    let copiedText = \"\";\r\n    // // We handle the case for startTable and startSubject differently\r\n\r\n    // // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\r\n    // if (this.state.usecaseSelected === \"startTable\") {\r\n    //   // This case handles the copy table for explore table. We fetch data directly from tableDataExplore\r\n    //   const rowNum = this.state.tableDataExplore.length;\r\n    //   const colNum = this.state.tableDataExplore[0].length;\r\n    //   for (let i = 0; i < rowNum; ++i) {\r\n    //     for (let j = 0; j < colNum - 1; ++j) {\r\n    //       copiedText =\r\n    //         copiedText + this.state.tableDataExplore[i][j].data + \"\\t\";\r\n    //     }\r\n    //     copiedText =\r\n    //       copiedText + this.state.tableDataExplore[i][colNum - 1].data + \"\\n\";\r\n    //   }\r\n    // }\r\n\r\n    // This case handles the copy table for start subject\r\n    if (this.state.usecaseSelected === \"startSubject\" || this.state.usecaseSelected === \"startTable\") {\r\n      // We first push on the text for column headers (using the labels)\r\n      let tableHeader = this.state.tableHeader;\r\n      for (let i = 0; i < tableHeader.length; ++i) {\r\n        let curText = tableHeader[i].label;\r\n        // console.log(curText);\r\n        if (curText === undefined && tableHeader[i].length > 0) {\r\n          curText = \"\";\r\n          for (let j = 0; j < tableHeader[i].length; ++j) {\r\n            if (j > 0) {\r\n              curText += \"&\";\r\n            }\r\n            curText += tableHeader[i][j].label;\r\n          }\r\n        }\r\n        if (curText !== undefined && curText !== \"\") {\r\n          copiedText = copiedText + curText + \"\\t\";\r\n        }\r\n      }\r\n      copiedText += \"\\n\";\r\n      // Now we need to fetch the rows that are not column headers\r\n      let tableData = this.state.tableData;\r\n      const rowNum = tableData.length;\r\n      const colNum = tableData[0].length;\r\n      for (let i = 0; i < rowNum; ++i) {\r\n        for (let j = 0; j < colNum; ++j) {\r\n          let curText = niceRender(tableData[i][j].data);\r\n          if (curText !== undefined && curText !== \"\") {\r\n            copiedText = copiedText + curText + \"\\t\";\r\n          }\r\n        }\r\n        copiedText += \"\\n\";\r\n      }\r\n    } else {\r\n    }\r\n    textArea.value = copiedText;\r\n    document.body.appendChild(textArea);\r\n    textArea.select();\r\n    document.execCommand(\"copy\");\r\n    document.body.removeChild(textArea);\r\n    alert(\"Table content has been pasted!\");\r\n  }\r\n\r\n  // This function handles the toggling of the WikiPage at bottom\r\n\r\n  toggleWikiPage() {\r\n    let pageHidden = this.state.pageHidden;\r\n    this.setState({\r\n      pageHidden: !pageHidden,\r\n    });\r\n  }\r\n\r\n  // This function handles the selection of the starting task \"startSubject\"\r\n\r\n  handleStartSubject(e, taskSelected) {\r\n\r\n    if (taskSelected === \"startSubject\") {\r\n      // Since the starting task is\"startSubject\", we set the URL to be the first cell in the table\r\n      const subject = decodeURIComponent(this.state.urlPasted.slice(30)); // add a decodeURIComponent here\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      tableData[0][0].data = subject;\r\n\r\n      // Adding support for undo:\r\n      let lastAction = \"handleStartSubject\";\r\n      let prevState = \r\n        {\r\n          \"usecaseSelected\":this.state.usecaseSelected,\r\n          \"tableData\":this.state.tableData,\r\n          \"tabIndex\":this.state.tabIndex,\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n        };\r\n\r\n      this.setState({\r\n        usecaseSelected: taskSelected,\r\n        tableData: tableData,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n        curActionInfo: {\"task\":\"afterStartSubject\"},\r\n        tabIndex: 0,\r\n      });\r\n    } \r\n  }\r\n\r\n  // This function handles manually changing cell in a table\r\n\r\n  cellChange(e, i, j) {\r\n    e.preventDefault();\r\n    let tableData = this.state.tableData.slice();\r\n    tableData[i][j].data = e.target.value;\r\n    this.setState({\r\n      tableData: tableData,\r\n    });\r\n  }\r\n\r\n  // This function updates the options for selections when we click on selection for a key column\r\n  // based on cells already filled in this column\r\n\r\n  getKeyOptions(e, colIndex) {\r\n    if (colIndex === this.state.keyColIndex) {\r\n      \r\n      // We first get all the non-empty values from the key column\r\n      let allSubject = [];\r\n      for (let i = 0; i < this.state.tableData.length; ++i) {\r\n        if (this.state.tableData[i][colIndex].data === \"\") {\r\n          break;\r\n        } else {\r\n          allSubject.push(regexReplace(this.state.tableData[i][colIndex].data));\r\n        }\r\n      }\r\n\r\n      // In here we fetch the options for first column's selection\r\n      // It uses the common dct:subject of all cells entered in the key column\r\n\r\n      // Modification: let's also find the common rdf:type dbo:xxx of cells filled.\r\n\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n      for (let i = 0; i < allSubject.length; ++i) {\r\n        queryBody +=\r\n          \"%0D%0A++++++++dbr%3A\" + allSubject[i] + \"+%28dct%3Asubject%7Crdf%3Atype%29+%3Fsomevar.\";\r\n      }\r\n      let suffixURL =\r\n        \"%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let promiseArray = [];\r\n      promiseArray.push(fetchJSON(queryURL));\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let myJson = values[0];\r\n        let keyColOptions = [];\r\n        // We loop through the result bindings. \r\n        // If it's from dct:subject, or rdf:type dbo:xxxx, we push it onto keyColOptions\r\n        for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n          let curValue = myJson.results.bindings[i].somevar.value;\r\n          // This clause deals with dct:subject\r\n          if (curValue.includes(\"dbpedia.org/resource/Category:\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(37);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"dct\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n          // This clause deals with rdf:type dbo:xxxx\r\n          else if (curValue.includes(\"dbpedia.org/ontology/\") && !curValue.includes(\"Wikidata\")) {\r\n            let tempObj = {};\r\n            let neighbour = curValue.slice(28);\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"dataset\"] = \"rdf\";\r\n            keyColOptions.push(tempObj);\r\n          }\r\n        }\r\n        // Take a look at keyColOptions\r\n        // console.log(keyColOptions);\r\n        // We create a copy of the optionsMap.\r\n        // Then change the entry in the optionsMap corresponding to the key column to what we have just fetched: keyColOptions.\r\n        let optionsMap = this.state.optionsMap.slice();\r\n        optionsMap[this.state.keyColIndex] = keyColOptions;\r\n        this.setState({\r\n          optionsMap: optionsMap,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function updates the options for selections when we click on selection for non-key column\r\n  // based on cells already filled in this column, and the cells in the key column\r\n  // aka: Michelle Obama is Barack Obama' wife\r\n\r\n  // If no cells is filled in this column, this function doesn't do anything.\r\n  // If this column is completely filled, this function doesn't do anything either.\r\n\r\n  getOtherOptions(e, colIndex) {\r\n\r\n    if (colIndex !== this.state.keyColIndex) {\r\n      // first we want to check if this column is all-empty, or all filled\r\n      let colEmpty = true;\r\n      let colFilled = true;\r\n      let nonEmptyInfo = [];\r\n      for (let i = 0; i < this.state.tableData.length; ++i) {\r\n        // If some data is not \"\", that means this column is not empty\r\n        if (this.state.tableData[i][colIndex].data !== \"\") {\r\n          colEmpty = false;\r\n          nonEmptyInfo.push([i, this.state.tableData[i][colIndex].data]);\r\n        }\r\n        // If some data is \"\", that means this column is not filled\r\n        else {\r\n          colFilled = false;\r\n        }\r\n      }\r\n      // We only want to update the options if the column is non-empty, and not completely filled.\r\n      // Make sure to modify this relation here to include only dbo and dbp\r\n      if (colEmpty === false && colFilled === false) {\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"%0D%0A%7D%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody = \"SELECT+%3Fsomevar%0D%0AWHERE+%7B\";\r\n        for (let i = 0; i < nonEmptyInfo.length; ++i) {\r\n          let curKeySubject = regexReplace(\r\n            this.state.tableData[nonEmptyInfo[i][0]][this.state.keyColIndex]\r\n              .data\r\n          );\r\n          let curEnteredSubject = regexReplace(nonEmptyInfo[i][1]);\r\n          queryBody +=\r\n            \"%0D%0A++++++++dbr%3A\" +\r\n            curKeySubject +\r\n            \"+%3Fsomevar+dbr%3A\" +\r\n            curEnteredSubject +\r\n            \".\";\r\n        }\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let promiseArray = [];\r\n        promiseArray.push(fetchJSON(queryURL));\r\n        allPromiseReady(promiseArray).then((values) => {\r\n          let myJson = values[0];\r\n          let otherColOptions = [];\r\n          for (let i = 0; i < myJson.results.bindings.length; ++i) {\r\n            let tempObj = {};\r\n            let neighbour = myJson.results.bindings[i].somevar.value.slice(\r\n              28\r\n            );\r\n            tempObj[\"label\"] = neighbour;\r\n            tempObj[\"value\"] = neighbour;\r\n            tempObj[\"type\"] = \"subject\"; // for now we only allow the subject search\r\n            otherColOptions.push(tempObj);\r\n          }\r\n          let optionsMap = this.state.optionsMap.slice();\r\n          optionsMap[colIndex] = otherColOptions;\r\n          this.setState({\r\n            optionsMap: optionsMap,\r\n          });\r\n        });\r\n      } \r\n      // If this non-key column is empty or filled completely, we just use keyColNeighbours for the list of options\r\n      else {\r\n        let optionsMap = this.state.optionsMap.slice();\r\n        optionsMap[colIndex] = this.state.keyColNeighbours;\r\n        this.setState({\r\n          optionsMap: optionsMap,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // This function handles the the selection of a column header.\r\n  // Note: we want to deal with the selection of key column header vs non key column header differently\r\n\r\n  selectColHeader(e, colIndex) {\r\n    // console.log(\"Check table header here\");\r\n    // console.log(this.state.tableHeader);\r\n    //  We first create a copy of the existing table headers\r\n    let tableHeader = this.state.tableHeader.slice();\r\n\r\n    // This part deals with the selection of key column header\r\n    if (colIndex === this.state.keyColIndex) {\r\n      // We create a copy of the selected option\r\n      if (e !== null) {\r\n        let selectedOptions = e.slice();\r\n        // console.log(selectedOptions);\r\n        tableHeader[colIndex] = selectedOptions;\r\n        let tempObj = {};\r\n        tempObj[\"task\"] = \"populateKeyColumn\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbourArray\"] = [];\r\n        // Modification here: instead of simplying passing the value, we want to pass the selectedOptions as a whole\r\n        // Because we need its \"dataset\" attribute\r\n        for (let i = 0; i < selectedOptions.length; ++i) {\r\n          tempObj.neighbourArray.push(selectedOptions[i]);\r\n        }\r\n        // console.log(tempObj);\r\n        this.setState({\r\n          tableHeader: tableHeader,\r\n          curActionInfo: tempObj,\r\n        });\r\n      }\r\n    }\r\n    // This part deals with the selection of non key column header\r\n    else {\r\n      // The first few lines fix some pass by reference problems\r\n      let evalue = e.value;\r\n      let elabel = e.label;\r\n      tableHeader[colIndex] = { value: evalue, label: elabel };\r\n      // We want to change the label of non-key column headers with respect to the label of key column\r\n      // We first create the label text for the key column\r\n      let keyColLabel = \"\";\r\n      if (this.state.keyColIndex === 0) {\r\n        for (let i = 0; i < tableHeader[this.state.keyColIndex].length; ++i) {\r\n          if (i > 0) {\r\n            keyColLabel += \"&\";\r\n          }\r\n          keyColLabel += tableHeader[this.state.keyColIndex][i].label;\r\n        }\r\n      } else {\r\n        keyColLabel = tableHeader[this.state.keyColIndex].label;\r\n      }\r\n      // Bugfix for Go Table Creation: if at this stage, keyColLable is still \"\", that means we came from the tabel union task first.\r\n      // In this case, tableHeader[keyColIndex] is an object, not an array. \r\n      // So we just set keyColLabel as tableHeader[this.state.keyColIndex].label\r\n      if (keyColLabel === \"\") {\r\n        keyColLabel = tableHeader[this.state.keyColIndex].label;\r\n      }\r\n      // We then append the current column's label to it\r\n      // console.log(keyColLabel);\r\n      tableHeader[colIndex].label =\r\n        tableHeader[colIndex].label + \"--\" + keyColLabel;\r\n      // After we have selected the column header, not only do we want to fill in the name of the column, we also want to\r\n      // ask in ActionPanel whether user wants to populate the column based on the chosen column name\r\n      let tempObj = {};\r\n      tempObj[\"task\"] = \"populateOtherColumn\";\r\n      tempObj[\"colIndex\"] = colIndex;\r\n      tempObj[\"neighbour\"] = e.value;\r\n      tempObj[\"type\"] = e.type;\r\n      // We want to deal with duplicate neighbour names since we are selecting column headers for non-key columns\r\n      // let arr = elabel.split(\"-\");\r\n      // if (arr.length > 1 && !isNaN(Number(arr[1]) - 1)) {\r\n      //   // arr[1] stores the index of the neighbour with duplicate names\r\n      //   tempObj[\"neighbourIndex\"] = Number(arr[1]) - 1;\r\n      // } else {\r\n      //   // If neighbourIndex is equal to -1, that means this property has no duplicate names\r\n      //   tempObj[\"neighbourIndex\"] = -1;\r\n      // }\r\n      if (elabel.includes(\"*\")) {\r\n        tempObj[\"neighbourIndex\"] = 0;\r\n      }\r\n      else {\r\n        tempObj[\"neighbourIndex\"] = -1;\r\n      }\r\n\r\n      // If type is subject, let's check if this neighbour also has a \"range\" (rdfs:range)\r\n      if (e.type === \"subject\" && e.range !== undefined) {\r\n        tempObj[\"range\"] = e.range;\r\n      }\r\n      // console.log(tempObj);\r\n\r\n      this.setState({\r\n        tableHeader: tableHeader,\r\n        curActionInfo: tempObj,\r\n      });\r\n    }\r\n  }\r\n\r\n  // This function populates the key column\r\n  // It also fetches the neighbours of the key column (based on the first cell in the table)\r\n  // as well as setting the origins of cells in the key column\r\n\r\n  // Note: we need to do some modification here. Instead of having a fixed number of entries in the key column,\r\n  // Let's make it more flexible. (but also pose a limit, so we don't get way too many entries)\r\n\r\n  populateKeyColumn(e, colIndex, neighbour) {\r\n    document.body.classList.add('waiting');\r\n    // Let's first take a look at neighbour passed in\r\n    // console.log(neighbour);\r\n    // We will populate this column based on query: ?p dct:subject dbc:Presidents_of_United_States\r\n    // We also need to fetch the neighbours of this key column, both using the key column entries as subject and object\r\n\r\n    // Since we need to make multiple (three) queries, we make a promise array\r\n    let promiseArray = [];\r\n\r\n    // Below is the first query we will make.\r\n    // This query populates the first columns.\r\n    // Note: since neighbour is now an array instead of a single value (as we are allowing multiselects), we need to adjust our query\r\n    // let prefixURLOne = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    // let suffixURLOne = \"%0D%0A%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    // let queryBodyOne = \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A%09%3Fsomevar+dct%3Asubject+dbc%3A\"\r\n    //                     +regexReplace(neighbour)\r\n    //                     +\".%0D%0A%7D%0D%0ALIMIT+\"+emptyEntryCount;\r\n    let prefixURLOne =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    // let suffixURLOne =\r\n    //   \"%0D%0A%7D+%0D%0Alimit+\" +\r\n    //   emptyEntryCount +\r\n    //   \"&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let suffixURLOne =\r\n      \"%0D%0A%7D+%0D%0A\" +\r\n      \"&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne = \"select+%3Fsomevar%0D%0Awhere+%7B\";\r\n    // We are using a loop here because multi-select is possible\r\n    for (let i = 0; i < neighbour.length; ++i) {\r\n      // We need to adjust the appending text, based on whether we are adding a dct neighbour or rdf neighbour\r\n      if (neighbour[i].dataset === \"dct\") {\r\n        queryBodyOne =\r\n          queryBodyOne +\r\n          \"%0D%0A+++++++%3Fsomevar+dct%3Asubject+dbc%3A\" +\r\n          regexReplace(neighbour[i].value) +\r\n          \".\";\r\n      }\r\n      else if (neighbour[i].dataset === \"rdf\") {\r\n        queryBodyOne =\r\n          queryBodyOne +\r\n          \"%0D%0A+++++++%3Fsomevar+rdf%3Atype+dbo%3A\" +\r\n          regexReplace(neighbour[i].value) +\r\n          \".\";\r\n      }\r\n    }\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let keyColPromise = fetchJSON(queryURLOne);\r\n    promiseArray.push(keyColPromise);\r\n\r\n    // Below is the second query we will make.\r\n    // This query fetches the neighbours for tableData[0][colIndex], so the first cell in column with index colIndex\r\n    // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\r\n\r\n    // SELECT ?p\r\n    // WHERE {\r\n    //         dbr:Barack_Obama ?p ?o.\r\n    //         BIND(STR(?p) AS ?pString ).\r\n    //         FILTER(\r\n    //               !(regex(?pString,\"abstract|wikiPage|align|caption|image|width|thumbnail|blank\",\"i\"))\r\n    //               && regex(?pString, \"ontology|property\", \"i\")\r\n    //               )\r\n    // }\r\n\r\n    // Let's modify the query below to support the \"populate from same range feature\"\r\n\r\n    // let prefixURLTwo = \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    // let suffixURLTwo = \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    // let queryBodyTwo =\r\n    //   \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\"\r\n    //   +regexReplace(this.state.tableData[0][colIndex].data)\r\n    //   +\"+%3Fp+%3Fo.%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22abstract%7CwikiPage%7Calign%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A%0D%0A&\";\r\n    let prefixURLTwo =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\r\n      regexReplace(this.state.tableData[0][colIndex].data) +\r\n      \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    let otherColPromiseSubject = fetchJSON(queryURLTwo);\r\n    promiseArray.push(otherColPromiseSubject);\r\n\r\n    // Below is the third query we will make.\r\n    // Difference with the previous query is that we are using tableData[0][colIndex] as OBJECT\r\n    let prefixURLThree =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLThree =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyThree =\r\n      \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\r\n      regexReplace(this.state.tableData[0][colIndex].data) +\r\n      \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\r\n    let queryURLThree = prefixURLThree + queryBodyThree + suffixURLThree;\r\n    let otherColPromiseObject = fetchJSON(queryURLThree);\r\n    promiseArray.push(otherColPromiseObject);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      // let's first work with the first promise result: fill in table data with the entities we have fetched\r\n\r\n      // This part sets the data for each cell\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n      // First we get the correct number of rows, which is equal to min(values[0].results.bindings.length, initialRowNum)\r\n      let updatedRowCount = Math.min(values[0].results.bindings.length, initialRowNum);\r\n      // console.log(\"Original length is \"+values[0].results.bindings.length);\r\n      // console.log(\"Row Count is: \"+updatedRowCount);\r\n\r\n      // If tableData currently has too many rows, we slice it.\r\n      if (tableData.length > updatedRowCount) {\r\n        tableData = tableData.slice(0,updatedRowCount);\r\n      }\r\n      // Else, if tableData currently has too few rows, we need to add some empty rows.\r\n      else if (tableData.length < updatedRowCount) {\r\n        let rowsToAdd = updatedRowCount - tableData.length;\r\n        for (let i = 0; i < rowsToAdd; ++i) {\r\n          let tempRow = [];\r\n          for (let j = 0; j < initialColNum; ++j) {\r\n            tempRow.push({ data: \"\", origin: [] });\r\n          }\r\n          tableData.push(tempRow);\r\n        }\r\n      }\r\n\r\n      let rowNum = tableData.length;\r\n      // console.log(\"Number of rows is \"+rowNum);\r\n\r\n      // We do not want to overwrite entries that users have filled in.\r\n      // Let's calculate how many entries we want to fill in.\r\n      let emptyEntryCount = rowNum;\r\n      for (let i = 0; i < rowNum; ++i) {\r\n        if (tableData[i][colIndex].data !== \"\") {\r\n          emptyEntryCount--;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      // console.log(\"number of empty entries is \"+emptyEntryCount);\r\n\r\n      let startingIndex = rowNum - emptyEntryCount;\r\n      // console.log(\"Starting index is\"+startingIndex);\r\n\r\n      for (let i = 0; i < emptyEntryCount; ++i) {\r\n        tableData[i + startingIndex][colIndex].data = \r\n          values[0].results.bindings[i].somevar.value.slice(28);\r\n      }\r\n\r\n      // second part sets the origin for each cell\r\n      for (let i = 0; i < rowNum; ++i) {\r\n        // We need to process the tableHeader[colIndex] array to get the correct text for origin\r\n        let labelText = \"\";\r\n        for (let j = 0; j < this.state.tableHeader[colIndex].length; ++j) {\r\n          if (j > 0) {\r\n            labelText += \"&\";\r\n          }\r\n          labelText += this.state.tableHeader[colIndex][j].value;\r\n        }\r\n        let tempOrigin = labelText + \":\" + tableData[i][colIndex].data;\r\n        tableData[i][colIndex].origin.push(tempOrigin);\r\n      }\r\n\r\n      // Now we dedup by tableData by tableData[i][0].data\r\n      tableData = _.uniqBy(tableData, function(x) {return x[0].data;});\r\n\r\n      // let's now work with the second and third promise result: update the selection options for non-key columns\r\n\r\n      let keyColNeighbours = [];\r\n\r\n      keyColNeighbours = updateKeyColNeighbours(\r\n        keyColNeighbours,\r\n        values[1].results.bindings,\r\n        \"subject\"\r\n      );\r\n      keyColNeighbours = updateKeyColNeighbours(\r\n        keyColNeighbours,\r\n        values[2].results.bindings,\r\n        \"object\"\r\n      );\r\n      // console.log(keyColNeighbours);\r\n\r\n      let optionsMap = this.state.optionsMap.slice();\r\n      for (let i = 0; i < optionsMap.length; ++i) {\r\n        if (i !== colIndex) {\r\n          optionsMap[i] = keyColNeighbours;\r\n        }\r\n      }\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo: \r\n      // Let's save the previous state in an object\r\n      let lastAction = \"populateKeyColumn\";\r\n      let prevState = \r\n        {\r\n          \"keyColIndex\":this.state.keyColIndex,\r\n          \"keyColNeighbours\":this.state.keyColNeighbours,\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n          \"optionsMap\":this.state.optionsMap\r\n        };\r\n\r\n\r\n      this.setState({\r\n        keyColIndex: colIndex,\r\n        keyColNeighbours: keyColNeighbours,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        tableData: tableData,\r\n        optionsMap: optionsMap,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n  }\r\n\r\n  // TEST FUNCTION----------------------------------------------------\r\n\r\n  // getOtherColPromiseTwo(neighbour, type) {\r\n  //   let promiseArray = [];\r\n  //   // The following is the query we will make\r\n\r\n  //   // SELECT ?key ?val\r\n  //   // WHERE{\r\n  //   //       ?key (dbo:spouse|dbp:spouse) ?val.\r\n  //   //       VALUES ?key {dbr:Barack_Obama dbr:Ronald_Reagan dbr:Donald_Trump }\r\n  //   // }\r\n\r\n\r\n  //   let prefixURL = \r\n  //     \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  //   let suffixURL = \r\n  //     \"%7D%0D%0A%7D%0D%0A&format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=300000&debug=on&run=+Run+Query+\";\r\n  //   let queryBody;\r\n  //   // This clause handles the case of \"Obama -> property -> object\"\r\n  //   if (type === \"subject\") {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fkey+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fval.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   } \r\n  //   // This clause handles the case of \"subject -> property -> Obama\"\r\n  //   else {\r\n  //     queryBody = \r\n  //       \"SELECT+%3Fkey+%3Fval%0D%0AWHERE%7B%0D%0A++++++%3Fval+%28dbo%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%7Cdbp%3A\" +\r\n  //       regexReplace(neighbour) +\r\n  //       \"%29+%3Fkey.%0D%0A++++++VALUES+%3Fkey+%7B\";\r\n  //   }\r\n  //   for (let i = 0; i < this.state.tableData.length; ++i) {\r\n  //     let cellValue = regexReplace(\r\n  //       this.state.tableData[i][this.state.keyColIndex].data\r\n  //     );\r\n  //     // N/A's will block the search, let's replace it with some string that does not block the search\r\n  //     if (cellValue === \"N/A\") {\r\n  //       cellValue = \"NONEXISTINGSTRING\";\r\n  //     }\r\n  //     let curQueryText = \"dbr%3A\"+cellValue+\"+\";\r\n  //     queryBody+=curQueryText;\r\n  //   }\r\n  //   let queryURL = prefixURL + queryBody + suffixURL;\r\n  //   // console.log(queryURL);\r\n  //   promiseArray.push(fetchJSON(queryURL));\r\n  //   return promiseArray;\r\n  // }\r\n\r\n  // The following function serves as a helper function for \"populateOtherColumn\" and \"populateSameNeighbour\"\r\n  // It makes an array of querie, which may affect the performance of our system. Let's change it now.\r\n\r\n  getOtherColPromise(neighbour, type) {\r\n    let promiseArray = [];\r\n    let prefixURL =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURL =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      let cellValue = regexReplace(\r\n        this.state.tableData[i][this.state.keyColIndex].data\r\n      );\r\n      // N/A's will block the search, let's replace it with some string that does not block the search\r\n      if (cellValue === \"N/A\") {\r\n        cellValue = \"NONEXISTINGSTRING\";\r\n      }\r\n      let queryBody;\r\n      if (type === \"subject\") {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar%0D%0AWHERE+%7B%0D%0A++++++++dbr%3A\" +\r\n          cellValue +\r\n          \"+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+%3Fsomevar.%0D%0A%7D%0D%0A%0D%0A&\";\r\n      } else {\r\n        queryBody =\r\n          \"SELECT+%3Fsomevar+%0D%0AWHERE+%7B%0D%0A++++++++%3Fsomevar+%28dbo%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%7Cdbp%3A\" +\r\n          regexReplace(neighbour) +\r\n          \"%29+dbr%3A\" +\r\n          cellValue +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n      }\r\n      let queryURL = prefixURL + queryBody + suffixURL;\r\n      let curPromise = fetchJSON(queryURL);\r\n      promiseArray.push(curPromise);\r\n    }\r\n    return promiseArray;\r\n  }\r\n\r\n  populateOtherColumn(e, colIndex, neighbour, neighbourIndex, type, range) {\r\n    document.body.classList.add('waiting');\r\n\r\n    // console.log(neighbourIndex);\r\n\r\n    // Support for \"populateSameRange\":\r\n\r\n    // When the range is not equal to undefined, we want to ask user if they want to populate all other attributes from this range\r\n    // console.log(range);\r\n\r\n    // we need to make a number of queries in the form of: dbr:somekeycolumnentry dbp:neighbour|dbo:neighbour somevar\r\n    // let promiseArrayTwo = this.getOtherColPromiseTwo(neighbour, type); // this is for testing\r\n    let promiseArray = this.getOtherColPromise(neighbour, type);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n    // allPromiseReady(promiseArrayTwo).then((testValues) => {\r\n\r\n      // // Now we need to process the testValues\r\n\r\n      // let pairArray = [];\r\n\r\n      // // First we removed the prefixes from resultArray\r\n      // for (let i=0; i<testValues[0].results.bindings.length; ++i) {\r\n      //   pairArray.push(\r\n      //     {\r\n      //       \"key\":removePrefix(testValues[0].results.bindings[i].key.value),\r\n      //       \"value\":removePrefix(testValues[0].results.bindings[i].val.value)\r\n      //     }\r\n      //   )\r\n      // }\r\n      // console.log(pairArray);\r\n\r\n      // // Then we create a keyArray\r\n      // let keyArray = [];\r\n\r\n      // for (let i=0; i<this.state.tableData.length; ++i) {\r\n      //   keyArray.push(this.state.tableData[i][this.state.keyColIndex].data);\r\n      // }\r\n      // console.log(keyArray);\r\n\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      let requiredLength = neighbourIndex === -1 ? 1 : neighbourIndex + 1;\r\n      for (let i = 0; i < values.length; ++i) {\r\n        if (values[i].results.bindings.length < requiredLength) {\r\n          // this means results is not found\r\n          // or if there is not enough results, in duplicate neighbour name case\r\n          if (tableData[i][this.state.keyColIndex].data === \"\") {\r\n            tableData[i][colIndex].data = \"\";\r\n          } else {\r\n            tableData[i][colIndex].data = \"N/A\";\r\n          }\r\n        } else {\r\n          // let's determine if we need to truncate\r\n          // Note: In here we are fetching the first value from the binding array. But sometimes there will be more than 1.\r\n          // Think about what to do when there are duplicates\r\n          // console.log(\"Current value is \");\r\n          // console.log(values[])\r\n          let dbResult =\r\n            values[i].results.bindings[requiredLength - 1].somevar.value;\r\n          dbResult = removePrefix(dbResult);\r\n          // We first set the data of the cell\r\n          tableData[i][colIndex].data = dbResult;\r\n          // We then set the origin of the cell\r\n          // This origin depends on whether type is \"subject\" or \"object\"\r\n          let originToAdd;\r\n          // console.log(type);\r\n          if (type === \"subject\") {\r\n            originToAdd = neighbour + \":\" + dbResult;\r\n          } else {\r\n            originToAdd = \"is \" + neighbour + \" of:\" + dbResult;\r\n          }\r\n          // console.log(originToAdd);\r\n          let keyOrigin = tableData[i][this.state.keyColIndex].origin.slice();\r\n          // console.log(keyOrigin);\r\n          keyOrigin.push(originToAdd);\r\n          // console.log(keyOrigin);\r\n          tableData[i][colIndex].origin = keyOrigin;\r\n        }\r\n      }\r\n\r\n      // If we just populated a column with duplicate names, we want to give users an option to \"populate all other columns of this name\"\r\n\r\n      // Note: the index we use in the values array has to be this.state.keyEntryIndex, because that one is the entry currently in effect\r\n      let maxCount = Math.min(\r\n        values[this.state.keyEntryIndex].results.bindings.length,\r\n        maxNeighbourCount\r\n      );\r\n      // console.log(\"neighbour index is \"+neighbourIndex);\r\n      // console.log(\"max count is \"+maxCount);\r\n      let remainNeighbourCount = maxCount - neighbourIndex - 1;\r\n      // console.log(\"remain neighbour count is \"+remainNeighbourCount);\r\n      let tempObj = {};\r\n      \r\n      // Now we need to determine what we want to show in the Action Panel.\r\n\r\n      // In this case, we give users option to populate duplicate neighbours\r\n      if (neighbourIndex !== -1 && remainNeighbourCount > 0) {\r\n        tempObj[\"task\"] = \"populateSameNeighbour\";\r\n        tempObj[\"colIndex\"] = colIndex;\r\n        tempObj[\"neighbour\"] = neighbour;\r\n        tempObj[\"neighbourIndex\"] = neighbourIndex;\r\n        tempObj[\"type\"] = type;\r\n        tempObj[\"numCols\"] = remainNeighbourCount;\r\n        // Note that if we populateSameNeighbour in different columns, we may also need this range attribute\r\n        if (range !== undefined) {\r\n          tempObj[\"range\"] = range;\r\n        }\r\n      }\r\n      // In this case, users are not populating a column with duplicate names, but it has a range, \r\n      // we may need to ask user if they want to populate other columns from the same range\r\n      else if (range !== undefined) {\r\n        let siblingNeighbour = [];\r\n        // console.log(\"Range is \"+range);\r\n        // console.log(this.state.keyColNeighbours);\r\n        for (let i = 0; i < this.state.keyColNeighbours.length; ++i) {\r\n          if (\r\n            this.state.keyColNeighbours[i].range === range &&\r\n            this.state.keyColNeighbours[i].value !== neighbour\r\n          ) {\r\n            siblingNeighbour.push(this.state.keyColNeighbours[i]);\r\n          }\r\n        }\r\n        // If we have found columns from the same range (other than the current neighbour),\r\n        // we give user the option to populate other columns from the same range.\r\n        if (siblingNeighbour.length > 0) {\r\n          // Let's do some string processing to improve UI clarity\r\n          let rangeLiteral = \"\";\r\n          if (range.includes(\"http://dbpedia.org/ontology/\")) {\r\n            rangeLiteral = range.slice(28);\r\n          } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\r\n            rangeLiteral = range.slice(33);\r\n          } else {\r\n            rangeLiteral = range;\r\n          }\r\n          tempObj[\"task\"] = \"populateSameRange\";\r\n          tempObj[\"colIndex\"] = colIndex;\r\n          tempObj[\"range\"] = rangeLiteral;\r\n          // console.log(siblingNeighbour);\r\n          tempObj[\"siblingNeighbour\"] = siblingNeighbour;\r\n        }\r\n        // If we have NOT found columns from the same range, we tell user that they can populate more columns\r\n        else {\r\n          tempObj[\"task\"] = \"afterPopulateColumn\";\r\n        }\r\n      }\r\n      // In this case, we tell user that they can populate more columns\r\n      else {\r\n        tempObj[\"task\"] = \"afterPopulateColumn\";\r\n      }\r\n      // console.log(tempObj);\r\n\r\n      document.body.classList.remove('waiting');\r\n      // Support for undo: \r\n      // Let's save the previous state in an object\r\n      let lastAction = \"populateOtherColumn\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo: tempObj,\r\n        tableData: tableData,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n    // });\r\n  }\r\n\r\n  // This function is a helper function that takes in 10 parameters:\r\n  // Note: this function does not make any fetch requests, thus does NOT involve promises.\r\n\r\n  // 1) colIndex:        index of the column that we just filled     (ex. 1, if we just filled in column 1)\r\n  // 2) neighbour:       attribute name of the column we just filled (ex. almaMater)\r\n  // 3) neighbourIndex:  index of the attribute we just filled       (ex. 0, if we have filled in almaMater-1)\r\n  // 4) type:            type of the attribute. Either \"subject\" or \"object\"\r\n  // 5) numCols:         number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\r\n  // 6) values:          query results that are passed in\r\n\r\n  // 7) tableHeader:                 original tableHeader\r\n  // 8) tableData:                   original tableData\r\n  // 9) optionsMap:                  original optionsMap\r\n  // 10) selectedClassAnnotation:    original selectedClassAnnotation\r\n\r\n  // and returns an object with 5 values:\r\n  // 1) tableHeader:                tableHeader after modification\r\n  // 2) tableData:                  tableData after modification\r\n  // 3) optionsMap:                 optionsMap after modification\r\n  // 4) selectedClassAnnotation:    selectedClassAnnotation after modification\r\n  // 5) keyColIndex:                keyColIndex after modification\r\n\r\n  addAllNeighbour(\r\n    colIndex,\r\n    neighbour,\r\n    neighbourIndex,\r\n    type,\r\n    numCols,\r\n    values,\r\n    tableHeader,\r\n    tableData,\r\n    optionsMap,\r\n    selectedClassAnnotation,\r\n    keyColIndex,\r\n  ) {\r\n    // Let's first check if all the variables are as expected\r\n\r\n    // console.log(\"Column index is: \"+colIndex);\r\n    // console.log(\"Neighbour is: \"+neighbour);\r\n    // console.log(\"Neighbour index is: \"+neighbourIndex);\r\n    // console.log(\"Type is: \"+type);\r\n    // console.log(\"Number of columns to fill is: \"+numCols);\r\n    // console.log(\"Table header is: \");\r\n    // console.log(tableHeader);\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Options map is: \");\r\n    // console.log(optionsMap);\r\n    // console.log(values);\r\n\r\n    // Now we need to write the body for this function\r\n\r\n    // First thing should be to insert \"numCols\" number of empty columns right after column with index \"colIndex\"\r\n    const rowNum = tableData.length;\r\n    const colNum = tableData[0].length;\r\n\r\n    // Let's check if we need to modify keyColIndex:\r\n    // if colIndex < keyColIndex, we need to increase keyColIndex by numCols\r\n    let keyColIndexUpdated = keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      keyColIndexUpdated+=numCols;\r\n    }\r\n\r\n    // We first take care of table data's (empty) additions\r\n    let tableDataUpdated = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(tableData[i][j]);\r\n      }\r\n      // we add in numCols number of empty columns\r\n      for (let j = 0; j < numCols; ++j) {\r\n        tempRow.push({ data: \"\", origin: [] });\r\n      }\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(tableData[i][k]);\r\n      }\r\n      tableDataUpdated.push(tempRow);\r\n    }\r\n\r\n    // we now take care of table header's addition.\r\n    let tableHeaderUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      tableHeaderUpdated.push(tableHeader[j]);\r\n    }\r\n    // some modification needs to be made here\r\n    let labelText = \"\";\r\n    if (keyColIndex === 0) {\r\n      for (\r\n        let i = 0;\r\n        i < tableHeader[0].length;\r\n        ++i\r\n      ) {\r\n        if (i > 0) {\r\n          labelText += \"&\";\r\n        }\r\n        labelText += tableHeader[0][i].value;\r\n      }\r\n    } else {\r\n      // there's a bug somewhere here. Needs to fix it later.\r\n      labelText = tableHeader[keyColIndex].label;\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      let curLabel = \"\";\r\n      // First case is for type \"subject\"\r\n      if (type === \"subject\") {\r\n        curLabel =\r\n          curLabel +\r\n          neighbour +\r\n          \"-\" +\r\n          (neighbourIndex + 2 + j) +\r\n          \"--\" +\r\n          labelText;\r\n      }\r\n      // Second case is for type \"object\"\r\n      else {\r\n        curLabel =\r\n          curLabel +\r\n          \"is \" +\r\n          neighbour +\r\n          \" of-\" +\r\n          (neighbourIndex + 2 + j) +\r\n          \"--\" +\r\n          labelText;\r\n      }\r\n      tableHeaderUpdated.push({ value: neighbour, label: curLabel });\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      tableHeaderUpdated.push(tableHeader[k]);\r\n    }\r\n\r\n    // We now take care of selectedClassAnnotation. For now, we just add some empty arrays to it\r\n    let selectedClassAnnotationUpdated = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      selectedClassAnnotationUpdated.push([]);\r\n    }\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotationUpdated.push(selectedClassAnnotation[k]);\r\n    }\r\n\r\n    // we now take care of optionMap's addition. We just need to add some empty arrays to it\r\n    let optionsMapUpdated = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      optionsMapUpdated.push(optionsMap[j]);\r\n    }\r\n    for (let j = 0; j < numCols; ++j) {\r\n      optionsMapUpdated.push([]);\r\n    }\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      optionsMapUpdated.push(optionsMap[k]);\r\n    }\r\n\r\n    // Finally, we fill in the actual data for tableData. We need to take care of both data and origin\r\n    // for (let i=0;i<values.length;++i) {\r\n    //   console.log(values[i].results.bindings);\r\n    // }\r\n    for (let curCol = colIndex + 1; curCol < colIndex + 1 + numCols; ++curCol) {\r\n      // curNeighbourIndex represents the required length\r\n      let requiredLength = neighbourIndex + curCol - colIndex + 1;\r\n      for (let i = 0; i < values.length; ++i) {\r\n        // Firt case: result is not found, or there is not enough results (in duplicate neighbour case)\r\n        // console.log(values[i]);\r\n        if (values[i].results.bindings.length < requiredLength) {\r\n          tableDataUpdated[i][curCol].data = \"N/A\";\r\n        }\r\n        // Second case: result is found. We need to process them.\r\n        else {\r\n          // let's determine if we need to truncate\r\n          // Note: In here we are fetching the first value from the binding array. But sometimes there will be more than 1.\r\n          // Think about what to do when there are duplicates\r\n          let dbResult =\r\n            values[i].results.bindings[requiredLength - 1].somevar.value;\r\n          dbResult = removePrefix(dbResult);\r\n          // We first set the data of the cell\r\n          tableDataUpdated[i][curCol].data = dbResult;\r\n          // We then set the origin of the cell\r\n          // This origin depends on whether type is \"subject\" or \"object\"\r\n          let originToAdd;\r\n          // console.log(type);\r\n          if (type === \"subject\") {\r\n            originToAdd = neighbour + \":\" + dbResult;\r\n          } else {\r\n            originToAdd = \"is \" + neighbour + \" of:\" + dbResult;\r\n          }\r\n          // console.log(originToAdd);\r\n          let keyOrigin = tableDataUpdated[i][\r\n            keyColIndexUpdated\r\n          ].origin.slice();\r\n          // console.log(keyOrigin);\r\n          keyOrigin.push(originToAdd);\r\n          // console.log(keyOrigin);\r\n          tableDataUpdated[i][curCol].origin = keyOrigin;\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      tableHeader: tableHeaderUpdated,\r\n      tableData: tableDataUpdated,\r\n      optionsMap: optionsMapUpdated,\r\n      selectedClassAnnotation: selectedClassAnnotationUpdated,\r\n      keyColIndex: keyColIndexUpdated,\r\n    };\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in different columns, if that neighbour has multiple occurences.\r\n\r\n  // It takes in 6 parameters:\r\n  // 1) colIndex:        index of the column that we just filled     (ex. 1, if we just filled in column 1)\r\n  // 2) neighbour:       attribute name of the column we just filled (ex. almaMater)\r\n  // 3) neighbourIndex:  index of the attribute we just filled       (ex. 0, if we have filled in almaMater-1)\r\n  // 4) type:            type of the attribute. Either \"subject\" or \"object\"\r\n  // 5) numCols:         number of columns that we need to fill with the duplicated neighbour. (ex. 2, if we have filled in one almaMater, but there are three in total)\r\n  // 6) range:           range for the neighbour to be filled (ex: Person for vicePresident)\r\n  \r\n  // Note: currently it only populates \"later\" neighbour with same name.\r\n\r\n  sameNeighbourDiffCol(e,colIndex,neighbour,neighbourIndex,type,numCols,range) {\r\n\r\n    // The following is testing for 2D Promise arrays. Turns out it works!\r\n    // let promiseArrayOne = this.getOtherColPromise(neighbour,type);\r\n    // let promiseArrayTwo = this.getOtherColPromise(neighbour,type);\r\n    // let twoD = [promiseArrayOne,promiseArrayTwo];\r\n    // allPromiseReady(twoD).then((values) => {\r\n    //   console.log(values);\r\n    // })\r\n\r\n    // console.log(neighbourIndex);\r\n    // console.log(range);\r\n\r\n    let promiseArray = this.getOtherColPromise(neighbour,type);\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      let newState = this.addAllNeighbour(colIndex,\r\n                                        neighbour,\r\n                                        neighbourIndex,\r\n                                        type,\r\n                                        numCols,\r\n                                        values,\r\n                                        this.state.tableHeader,\r\n                                        this.state.tableData,\r\n                                        this.state.optionsMap,\r\n                                        this.state.selectedClassAnnotation,\r\n                                        this.state.keyColIndex);\r\n      // Let's also create the object we need for populateSameRange\r\n      // Note: the following code is identical to what we have in populateOtherColumn\r\n      let tempObj = {};\r\n      let siblingNeighbour = [];\r\n      // console.log(\"Range is \"+range);\r\n      // console.log(this.state.keyColNeighbours);\r\n      for (let i=0;i<this.state.keyColNeighbours.length;++i) {\r\n        if (range !== undefined\r\n            &&this.state.keyColNeighbours[i].range === range \r\n            && this.state.keyColNeighbours[i].value !== neighbour) {\r\n          siblingNeighbour.push(this.state.keyColNeighbours[i]);\r\n        }\r\n      }\r\n      \r\n      // Now we need to determine what goes in the Action Panel\r\n\r\n      // If we have found columns from the same range (other than the current neighbour), \r\n      // we give user the option to populate other columns from the same range.\r\n      if (siblingNeighbour.length > 0) {\r\n        // Let's do some string processing to improve UI clarity\r\n        let rangeLiteral = \"\";\r\n        if (range.includes(\"http://dbpedia.org/ontology/\")) {\r\n          rangeLiteral = range.slice(28);\r\n        } else if (range.includes(\"http://www.w3.org/2001/XMLSchema#\")) {\r\n          rangeLiteral = range.slice(33);\r\n        } else {\r\n          rangeLiteral = range;\r\n        }\r\n        tempObj[\"task\"] = \"populateSameRange\";\r\n        tempObj[\"colIndex\"] = colIndex+numCols;  // Small change here: we need to adjust the position of the column index\r\n        tempObj[\"range\"] = rangeLiteral;\r\n        console.log(siblingNeighbour);\r\n        tempObj[\"siblingNeighbour\"] = siblingNeighbour;\r\n      }\r\n      // In this case, we tell user that they can populate more columns\r\n      else {\r\n        tempObj[\"task\"] = \"afterPopulateColumn\";\r\n      }\r\n\r\n      // Support for undo: \r\n      // Let's save the previous state in an object\r\n      let lastAction = \"sameNeighbourDiffCol\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n          \"tableHeader\":this.state.tableHeader,\r\n          \"optionsMap\":this.state.optionsMap,\r\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\r\n          \"keyColIndex\":this.state.keyColIndex,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo:tempObj,\r\n        tableData:newState.tableData,\r\n        tableHeader:newState.tableHeader,\r\n        optionsMap:newState.optionsMap,\r\n        selectedClassAnnotation:newState.selectedClassAnnotation,\r\n        keyColIndex:newState.keyColIndex,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      })\r\n    })\r\n  }\r\n\r\n  // This function populates all neighbour with the same names in the same columns, if that neighbour has multiple occurences.\r\n\r\n  sameNeighbourOneCol(e, colIndex, neighbour, neighbourIndex, type, numCols) {\r\n    // console.log(colIndex);\r\n    // console.log(neighbour);\r\n    // console.log(neighbourIndex);\r\n    // console.log(type);\r\n    // console.log(numCols);\r\n\r\n    // In this option, we just need to change data in column \"ColIndex\", by putting \"numCols\" numbers of new values into it\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    let promiseArray = this.getOtherColPromise(neighbour, type);\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      for (\r\n        let requiredLength = neighbourIndex + 2;\r\n        requiredLength < neighbourIndex + numCols + 2;\r\n        ++requiredLength\r\n      ) {\r\n        for (let i = 0; i < values.length; ++i) {\r\n          if (values[i].results.bindings.length >= requiredLength) {\r\n            let dbResult =\r\n              values[i].results.bindings[requiredLength - 1].somevar.value;\r\n            dbResult = removePrefix(dbResult);\r\n            tableData[i][colIndex].data =\r\n              tableData[i][colIndex].data + \";\" + dbResult;\r\n            let updatedOrigin = tableData[i][colIndex].origin.slice();\r\n            updatedOrigin[updatedOrigin.length - 1] =\r\n              updatedOrigin[updatedOrigin.length - 1] + \";\" + dbResult;\r\n            tableData[i][colIndex].origin = updatedOrigin;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Support for undo: \r\n      let lastAction = \"sameNeighbourOneCol\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        tableData: tableData,\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n  }\r\n\r\n  // The following function populates all neighbour from the same range (ex. all neighbours with rdfs:range Person)\r\n  // This function should use addAllNeighbour as a helper function\r\n  populateSameRange(e, colIndex, range, siblingNeighbour) {\r\n    document.body.classList.add('waiting');\r\n\r\n    // console.log(\"Column index is \"+colIndex);\r\n    // console.log(\"Range is \"+range);\r\n    // console.log(\"Sibling neighbours are: \");\r\n    // console.log(siblingNeighbour);\r\n    // for (let i=0;i<siblingNeighbour.length;++i) {\r\n    //   console.log(\"Neighbour name is: \"+siblingNeighbour[i].name);\r\n    //   console.log(\"Count is: \"+siblingNeighbour[i].count);\r\n    // }\r\n    let promiseArrayTwoD = [];\r\n    for (let i=0;i<siblingNeighbour.length;++i) {\r\n      let curPromiseArray = this.getOtherColPromise(siblingNeighbour[i].value,\"subject\");\r\n      for (let j=0;j<curPromiseArray.length;++j) {\r\n        promiseArrayTwoD.push(curPromiseArray[j]);\r\n      }\r\n      // promiseArrayTwoD.push(this.getOtherColPromise(siblingNeighbour[i].name,\"subject\"));\r\n    } \r\n    allPromiseReady(promiseArrayTwoD).then((values) => {\r\n\r\n      // for (let i=0;i<values.length;++i) {\r\n      //   console.log(values[i]);\r\n      // }\r\n\r\n      // first we fetch the initial state of tableHeader, tableData, optionsMap, and selectedClassAnnotation\r\n      let tempHeader = this.state.tableHeader;\r\n      let tempData = this.state.tableData;\r\n      let tempOptions = this.state.optionsMap;\r\n      let tempAnnotation = this.state.selectedClassAnnotation;\r\n      let tempKeyColIndex = this.state.keyColIndex;\r\n      let curColIndex = colIndex;\r\n      for (let i=0;i<siblingNeighbour.length;++i) {\r\n        let curValueArray = [];\r\n        for (let j=0;j<tempData.length;++j) {\r\n          curValueArray.push(values[tempData.length*i+j]) // since working with 2D promise array is not figured out yet, we need to manipulate index\r\n        }\r\n        let newState = this.addAllNeighbour(curColIndex,\r\n                                            siblingNeighbour[i].value,    // this is name of the neighbour\r\n                                            -1,                          // this is neighbour index. -1 indicates that we have not populated any neighbour of this name\r\n                                            \"subject\",                   // for now, type can only be subject\r\n                                            siblingNeighbour[i].count,   // we need to populate this number of columns for this neighbour\r\n                                            curValueArray,               // This is the fetched data\r\n                                            tempHeader,\r\n                                            tempData,\r\n                                            tempOptions,\r\n                                            tempAnnotation,\r\n                                            tempKeyColIndex);\r\n        curColIndex+=siblingNeighbour[i].count;\r\n        tempHeader = newState.tableHeader;\r\n        tempData = newState.tableData;\r\n        tempOptions = newState.optionsMap;\r\n        tempAnnotation = newState.selectedClassAnnotation;\r\n        tempKeyColIndex = newState.keyColIndex;\r\n      }\r\n\r\n      document.body.classList.remove('waiting');\r\n\r\n      // Support for undo: \r\n      let lastAction = \"populateSameRange\";\r\n      let prevState = \r\n        {\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n          \"tableData\":this.state.tableData,\r\n          \"tableHeader\":this.state.tableHeader,\r\n          \"optionsMap\":this.state.optionsMap,\r\n          \"selectedClassAnnotation\":this.state.selectedClassAnnotation,\r\n          \"keyColIndex\":this.state.keyColIndex,\r\n        };\r\n\r\n      this.setState({\r\n        curActionInfo:{\"task\":\"afterPopulateColumn\"},\r\n        tableData:tempData,\r\n        tableHeader:tempHeader,\r\n        optionsMap:tempOptions,\r\n        selectedClassAnnotation:tempAnnotation,\r\n        keyColIndex:tempKeyColIndex,\r\n        lastAction:lastAction,\r\n        prevState:prevState,\r\n      })\r\n    })\r\n  }\r\n\r\n  // The following function adds a new column to the table, to the right of the context-menu clicked column.\r\n  // In here, let's also set tabIndex to 0.\r\n\r\n  contextAddColumn(e, colIndex) {\r\n    const rowNum = this.state.tableData.length;\r\n    const colNum = this.state.tableData[0].length;\r\n\r\n    // we first take care of table data's addition\r\n    let tableData = [];\r\n    for (let i = 0; i < rowNum; ++i) {\r\n      let tempRow = [];\r\n      for (let j = 0; j < colIndex + 1; ++j) {\r\n        tempRow.push(this.state.tableData[i][j]);\r\n      }\r\n      // we add in one column of empty data\r\n      tempRow.push({ data: \"\", origin: [] });\r\n      for (let k = colIndex + 1; k < colNum; ++k) {\r\n        tempRow.push(this.state.tableData[i][k]);\r\n      }\r\n      tableData.push(tempRow);\r\n    }\r\n\r\n    // we now take care of tabler header, optionMap, and selectedClassAnnotation's addition\r\n    // This added column will have options equal to the neighbours of the key column\r\n    let optionsMap = [];\r\n    let tableHeader = [];\r\n    for (let j = 0; j < colIndex + 1; ++j) {\r\n      optionsMap.push(this.state.optionsMap[j]);\r\n      tableHeader.push(this.state.tableHeader[j]);\r\n    }\r\n    optionsMap.push(this.state.keyColNeighbours);\r\n    tableHeader.push(\"\");\r\n    for (let k = colIndex + 1; k < colNum; ++k) {\r\n      optionsMap.push(this.state.optionsMap[k]);\r\n      tableHeader.push(this.state.tableHeader[k]);\r\n    }\r\n\r\n    // we now take care of selectedClassAnnotation\r\n    let selectedClassAnnotation = [];\r\n    for (let j = 0; j < colIndex; ++j) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[j]);\r\n    }\r\n    selectedClassAnnotation.push([]);\r\n    for (let k = colIndex; k < colNum-1; ++k) {\r\n      selectedClassAnnotation.push(this.state.selectedClassAnnotation[k]);\r\n    }\r\n\r\n    // If colIndex is less than keyColIndex, we need to increase keyColIndex by 1\r\n    let keyColIndex = this.state.keyColIndex;\r\n    if (colIndex < keyColIndex) {\r\n      ++keyColIndex;\r\n    }\r\n\r\n    // console.log(this.state.selectedClassAnnotation);\r\n    // console.log(tableHeader);\r\n\r\n    // Support for undo: \r\n    let lastAction = \"contextAddColumn\";\r\n    let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"tableHeader\": this.state.tableHeader,\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n          \"optionsMap\": this.state.optionsMap,\r\n          \"keyColIndex\": this.state.keyColIndex,\r\n          \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n          \"tabIndex\": this.state.tabIndex,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      tableHeader: tableHeader,\r\n      curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n      optionsMap: optionsMap,\r\n      keyColIndex: keyColIndex,\r\n      selectedClassAnnotation: selectedClassAnnotation,\r\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n  \r\n  // The following function handles the deletion of a column from context menu.\r\n  // This function should be largely similar to contextAddColumn\r\n\r\n  contextDeleteColumn(e, colIndex) {\r\n    // console.log(\"This is the column we are trying to delete \"+colIndex);\r\n\r\n    // We disable the deletion of the search column\r\n    if (colIndex === this.state.keyColIndex) {\r\n      alert(\"The current column is the search column.\\n\\nPlease set another search column before deleting the current column.\");\r\n    }\r\n\r\n    // We also disable the deletion of the first column\r\n    else if (colIndex === 0) {\r\n      alert(\"Deleting the first column causes unexpected behavior.\\n\\nPlease do not delete the first column.\");\r\n    }\r\n\r\n    // Else, we can proceed to deletion.\r\n    else {\r\n      // We handle tableData, tableHeader, optionsMap, and selectedClassAnnotation's deletion\r\n      let tableData = _.cloneDeep(this.state.tableData);\r\n      let tableHeader = this.state.tableHeader.slice();\r\n      let optionsMap = this.state.optionsMap.slice();\r\n      let selectedClassAnnotation = this.state.selectedClassAnnotation.slice();\r\n\r\n      // tableData\r\n      for (let i = 0; i < tableData.length; ++i) {\r\n        tableData[i].splice(colIndex, 1);\r\n      }\r\n      // tableHeader, optionsMap, and selectedClassAnnotation\r\n      tableHeader.splice(colIndex, 1);\r\n      optionsMap.splice(colIndex, 1);\r\n      if (colIndex > 0) {\r\n        selectedClassAnnotation.splice(colIndex-1, 1);\r\n      }\r\n      // If colIndex is less than keyColIndex, we need to decrease keyColIndex by 1, if keyColIndex > 0\r\n      let keyColIndex = this.state.keyColIndex;\r\n      if (colIndex < keyColIndex) {\r\n        --keyColIndex;\r\n      }\r\n\r\n      // When we are deleting a column, we do not necessarily want to go to tab 0.\r\n      // However, if we are in tab 1, we want to toggle off all property neighbours\r\n      let propertyNeighbours = _.cloneDeep(this.state.propertyNeighbours);\r\n      if (this.state.tabIndex === 1) {\r\n        for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n          propertyNeighbours[i].isOpen = false;\r\n        }\r\n      }\r\n\r\n      // Support for undo: \r\n      let lastAction = \"contextDeleteColumn\";\r\n      let prevState = \r\n          {\r\n            \"tableData\": this.state.tableData,\r\n            \"tableHeader\": this.state.tableHeader,\r\n            \"optionsMap\": this.state.optionsMap,\r\n            \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n            \"keyColIndex\": this.state.keyColIndex,\r\n            \"propertyNeighbours\": this.state.propertyNeighbours,\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n          };\r\n\r\n      this.setState({\r\n        tableData: tableData,\r\n        tableHeader: tableHeader,\r\n        optionsMap: optionsMap,\r\n        selectedClassAnnotation: selectedClassAnnotation,\r\n        keyColIndex: keyColIndex,\r\n        propertyNeighbours: propertyNeighbours,\r\n        curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the sorting of a column from context menu.\r\n  // It is a prototype. Needs to be refined in the future.\r\n\r\n  contextSortColumn(e, colIndex, order) {\r\n    // console.log(\"The column we are sorting is \"+colIndex);\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // We first loop through this column to determine if it's a numeric column or a string column\r\n    let numericCol = true;\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      // We only care about entries that are not N/A\r\n      if (tableData[i][colIndex].data !== \"N/A\") {\r\n        if (isNaN(Number(tableData[i][colIndex].data))) {\r\n          numericCol = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Let's also make a copy of the entry (row) containing the current search cell\r\n    let searchEntry = tableData[this.state.keyEntryIndex].slice();\r\n\r\n    // In this case we are sorting a numerical column\r\n    if (numericCol) {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return Number(aValue) - Number(bValue);\r\n          }\r\n          else {\r\n            return Number(bValue) - Number(aValue);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // In this case we are sorting a string-based column\r\n    else {\r\n      tableData.sort(function (a, b) {\r\n        let aValue = a[colIndex].data;\r\n        let bValue = b[colIndex].data;\r\n        // We want to put all N/A's at the bottom\r\n        if (aValue === \"N/A\") {\r\n          return 1;\r\n        }\r\n        else if (bValue === \"N/A\") {\r\n          return -1;\r\n        } \r\n        // Else, we sort by the given order.\r\n        else {\r\n          if (order === \"ascending\") {\r\n            return aValue < bValue ? -1 : 1;\r\n          }\r\n          else {\r\n            return aValue < bValue ? 1 : -1;\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n\r\n    // Note: keyColIndex does not change with a sort. But keyEntryIndex may. \r\n    // Let's figure out what the updated keyEntryIndex should be.\r\n    let keyEntryIndex;\r\n    for (let i = 0; i < tableData.length; ++i) {\r\n      let matchFound = true;\r\n      for (let j = 0; j < searchEntry.length; ++j) {\r\n        if (searchEntry[j].data !== tableData[i][j].data) {\r\n          matchFound = false;\r\n          break;\r\n        }\r\n      }\r\n      if (matchFound === true) {\r\n        keyEntryIndex = i;\r\n        break;\r\n      }\r\n    }\r\n    // console.log(\"Table Data is: \");\r\n    // console.log(tableData);\r\n    // console.log(\"Search entry is \");\r\n    // console.log(searchEntry);\r\n    // console.log(\"New key entry index is \"+keyEntryIndex);\r\n\r\n    // Support for undo: \r\n    let lastAction = \"contextSortColumn\";\r\n    let prevState = \r\n        {\r\n          \"tableData\": this.state.tableData,\r\n          \"keyEntryIndex\": this.state.keyEntryIndex,\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      keyEntryIndex: keyEntryIndex,\r\n      curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following functions sets the selected cell to be the search cell.\r\n  // As a result, the column of the cell needs to be set as the search column as well.\r\n\r\n  contextSetCell(e, rowIndex, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    // console.log(\"Row index of search cell is \"+rowIndex);\r\n    // console.log(\"Col index of search cell is \"+colIndex);\r\n\r\n    // Let's first do a check. We don't want users to set N/A's as search cells.\r\n    if (this.state.tableData[rowIndex][colIndex].data === \"N/A\") {\r\n      alert(\"N/A should not be set as search cell.\");\r\n    }\r\n\r\n    else {\r\n      // This is the function that we need to fill out\r\n      let promiseArray = [];\r\n      // Below is the first query we will make.\r\n      // This query fetches the neighbours for tableData[rowIndex][colIndex]. So the search cell in the search column.\r\n      // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\r\n\r\n      // Note: we need to modify this query so it looks for ranges of certain attributes as well\r\n      let prefixURLOne =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURLOne =\r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBodyOne =\r\n        \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\r\n        regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n        \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\r\n      let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n      let otherColPromiseSubject = fetchJSON(queryURLOne);\r\n      promiseArray.push(otherColPromiseSubject);\r\n\r\n      // Below is the second query we will make.\r\n      // Difference with the previous query is that we are using tableData[rowIndex][colIndex] as OBJECT\r\n      let prefixURLTwo =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURLTwo =\r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      let queryBodyTwo =\r\n        \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\r\n        regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n        \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\r\n      let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n      let otherColPromiseObject = fetchJSON(queryURLTwo);\r\n      promiseArray.push(otherColPromiseObject);\r\n\r\n      // continue from here\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        console.log(values[0]);\r\n        console.log(values[1]);\r\n        let keyColNeighbours = [];\r\n        keyColNeighbours = updateKeyColNeighbours(\r\n          keyColNeighbours,\r\n          values[0].results.bindings,\r\n          \"subject\"\r\n        );\r\n        keyColNeighbours = updateKeyColNeighbours(\r\n          keyColNeighbours,\r\n          values[1].results.bindings,\r\n          \"object\"\r\n        );\r\n        // console.log(keyColNeighbours);\r\n        let optionsMap = this.state.optionsMap.slice();\r\n        for (let i = 0; i < optionsMap.length; ++i) {\r\n          if (i !== colIndex) {\r\n            optionsMap[i] = keyColNeighbours;\r\n          }\r\n        }\r\n        // console.log(keyColNeighbours);\r\n\r\n        document.body.classList.remove('waiting');\r\n        // Support for undo: \r\n        let lastAction = \"contextSetCell\";\r\n        let prevState = \r\n            {\r\n              \"keyEntryIndex\": this.state.keyEntryIndex,\r\n              \"keyColIndex\": this.state.keyColIndex,\r\n              \"keyColNeighbours\": this.state.keyColNeighbours,\r\n              \"curActionInfo\": this.state.curActionInfo,\r\n              \"optionsMap\": this.state.optionsMap,\r\n              \"tabIndex\": this.state.tabIndex,\r\n            };\r\n\r\n        this.setState({\r\n          keyEntryIndex: rowIndex,\r\n          keyColIndex: colIndex,\r\n          keyColNeighbours: keyColNeighbours,\r\n          curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n          optionsMap: optionsMap,\r\n          tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n          lastAction: lastAction,\r\n          prevState: prevState,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function displays the origin of a cell in the Action Panel.\r\n\r\n  contextCellOrigin(e, rowIndex, colIndex) {\r\n    // To get the origin of a cell, we simply returns its \"origin field\"\r\n    // The trick is to set the origin field correctly in previous functions\r\n    // The place to do that should be in the two populating columns\r\n\r\n    let cellSelected = this.state.tableData[rowIndex][colIndex];\r\n\r\n    let originElement = [];\r\n    for (let i = 0; i < cellSelected.origin.length; ++i) {\r\n      if (i === 0) {\r\n        originElement.push(<p>{cellSelected.origin[i]}</p>);\r\n      } else {\r\n        originElement.push(<p>{cellSelected.origin[i]}</p>);\r\n      }\r\n    }\r\n\r\n    // This origin literal correctly contains the cell Origin we want to display\r\n    // Now we just need to show it in the ActionPanel\r\n    let tempObj = {};\r\n    tempObj[\"task\"] = \"contextCellOrigin\";\r\n    tempObj[\"origin\"] = originElement;\r\n\r\n    // Support for undo: \r\n    let lastAction = \"contextCellOrigin\";\r\n    let prevState = \r\n        {\r\n          \"curActionInfo\": this.state.curActionInfo,\r\n          \"tabIndex\": this.state.tabIndex,\r\n        };\r\n    \r\n    this.setState({\r\n      curActionInfo: tempObj,\r\n      tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following function displays the preview of a cell in the Action Panel.\r\n  // Note: currently it will not have any N/A's\r\n\r\n  contextCellPreview(e, rowIndex, colIndex) {\r\n    document.body.classList.add('waiting');\r\n    // console.log(\"Row index is \"+rowIndex);\r\n    // console.log(\"Col index is \"+colIndex);\r\n\r\n    // Let's first run queries to fetch the dbp neighbours and dbo neighbours for the selected cell (withe some filtering)\r\n    // In here, we need both the ?p and ?o. This is different from before.\r\n\r\n    let promiseArray = [];\r\n\r\n    // Below is the first query we will make. In here we are using the tableCell as SUBJECT\r\n\r\n    // SELECT ?p ?value\r\n    // WHERE {\r\n    //       dbr:Barack_Obama ?p ?value.\r\n    //       BIND(STR(?p) AS ?pString ).\r\n    //       FILTER(\r\n    //               !(regex(?pString,\"wikiPage|align|caption|image|width|thumbnail|blank\",\"i\"))\r\n    //               && regex(?pString, \"ontology|property\", \"i\")\r\n    //       )\r\n    // }\r\n\r\n    let prefixURLOne = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne = \r\n      \"SELECT+%3Fp+%3Fvalue%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" + \r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \"+%3Fp+%3Fvalue.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++%29%0D%0A%7D&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let otherColPromiseSubject = fetchJSON(queryURLOne);\r\n    promiseArray.push(otherColPromiseSubject);\r\n\r\n    // Below is the second query we will make. In here we are using the tableCell as OBJECT.\r\n\r\n    // SELECT ?p ?value\r\n    // WHERE {\r\n    //       ?value ?p dbr:Barack_Obama.\r\n    //       BIND(STR(?p) AS ?pString ).\r\n    //       FILTER(\r\n    //               !(regex(?pString,\"wikiPage|align|caption|image|width|thumbnail|blank\",\"i\"))\r\n    //               && regex(?pString, \"ontology|property\", \"i\")\r\n    //       )\r\n    // } \r\n\r\n    let prefixURLTwo = \r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo = \r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"SELECT+%3Fp+%3Fvalue%0D%0AWHERE+%7B%0D%0A+++++++%3Fvalue+%3Fp+dbr%3A\" +\r\n      regexReplace(this.state.tableData[rowIndex][colIndex].data) +\r\n      \".%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++%29%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    let otherColPromiseObject = fetchJSON(queryURLTwo);\r\n    promiseArray.push(otherColPromiseObject);\r\n\r\n    allPromiseReady(promiseArray).then((values) => {\r\n      // console.log(values[0]);\r\n      // console.log(values[1]);\r\n      // let previewInfoArray = [];\r\n      let subjectInfoArray = \r\n        updatePreviewInfo(\r\n          values[0].results.bindings,\r\n          \"subject\"\r\n        );\r\n      let objectInfoArray = \r\n        updatePreviewInfo(\r\n          values[1].results.bindings,\r\n          \"object\"\r\n        );\r\n      // console.log(subjectInfoArray);\r\n      // console.log(objectInfoArray);\r\n      // Pick up from here tomorrow.\r\n      let previewInfoArray = subjectInfoArray.concat(objectInfoArray);\r\n\r\n      // previewInfoArray correctly contains the cell preview we want to display\r\n      // Now we just need to show it in the ActionPanel\r\n      let tempObj = {};\r\n      tempObj[\"task\"] = \"contextCellPreview\";\r\n      tempObj[\"cellValue\"] = this.state.tableData[rowIndex][colIndex].data;\r\n      tempObj[\"preview\"] = previewInfoArray;\r\n\r\n      // Support for undo: \r\n      document.body.classList.remove('waiting');\r\n      let lastAction = \"contextCellPreview\";\r\n      let prevState = \r\n          {\r\n            \"curActionInfo\": this.state.curActionInfo,\r\n            \"tabIndex\": this.state.tabIndex,\r\n          };\r\n      \r\n      this.setState({\r\n        curActionInfo: tempObj,\r\n        tabIndex: 0, // we want to set the currently active tab to be wrangling actions\r\n        lastAction: lastAction,\r\n        prevState: prevState,\r\n      });\r\n    });\r\n  }\r\n\r\n  // The following function sets the bottom page URL to the Wikipage of selected cell.\r\n\r\n  contextOpenLink(e, rowIndex, colIndex) {\r\n    let iframeURL = \"https://en.wikipedia.org/wiki/\" + this.state.tableData[rowIndex][colIndex].data;\r\n    this.setState({\r\n      pageHidden: false,\r\n      iframeURL: iframeURL,\r\n      // curActionInfo: {\"task\":\"afterPopulateColumn\"},\r\n    });\r\n  }\r\n\r\n  toggleTable(e, index) {\r\n    let tableOpenList = this.state.tableOpenList.slice();\r\n    tableOpenList[index] = !tableOpenList[index];\r\n    // When we toggle on one table, we want to close all other tables\r\n    for (let i = 0; i < tableOpenList.length; ++i) {\r\n      if (i !== index) {\r\n        tableOpenList[i] = false;\r\n      }\r\n    }\r\n    // We should change the Action Panel here, if we just toggled open a table\r\n    if (tableOpenList[index] === true) {\r\n      this.setState({\r\n        tableOpenList: tableOpenList,\r\n        curActionInfo: { task: \"selectTableIndex\", tableIndex: index },\r\n      });\r\n    } else {\r\n      this.setState({\r\n        tableOpenList: tableOpenList,\r\n        curActionInfo: null,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the selection of table.\r\n\r\n  handleStartTable(e, tableIndex) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // We need to let table panel display the selected table\r\n    // And we need to update the Action Panel to display the first degree properties of the origigitnal page\r\n    // We do a fetch request here (Sixth Query). It gets the property neighbours of the original page that are links, as well as dct:subject\r\n    // Lastly, we need to set usecaseSelected to \"startSubject\"\r\n\r\n    // First query gets the property neighbours\r\n    let queryPromise = [];\r\n    let prefixURLOne =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLOne =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyOne =\r\n      \"SELECT+%3Fp+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(this.state.urlPasted.slice(30)) +\r\n      \"+%3Fp+%3Fo.%0D%0A++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++FILTER%28isIRI%28%3Fo%29+%26%26+regex%28%3FpString%2C%22property%22%2C%22i%22%29+%26%26+%28%21regex%28%3FpString%2C%22text%22%2C%22i%22%29%29%29.%0D%0A%7D%0D%0A&\";\r\n    let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n    let queryOne = fetchJSON(queryURLOne);\r\n    queryPromise.push(queryOne);\r\n\r\n    // Second query gets the dct:subject neighbours\r\n    let prefixURLTwo =\r\n      \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n    let suffixURLTwo =\r\n      \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n    let queryBodyTwo =\r\n      \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n      urlReplace(this.state.urlPasted.slice(30)) +\r\n      \"+dct%3Asubject+%3Fo%0D%0A%7D&\";\r\n    let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n    // console.log(queryURLTwo);\r\n    let queryTwo = fetchJSON(queryURLTwo);\r\n    queryPromise.push(queryTwo);\r\n\r\n    // Third query here should get the class annotations\r\n    queryPromise.push(\r\n      findClassAnnotation(this.state.originTableArray[tableIndex])\r\n    );\r\n\r\n    // now we process the query results\r\n    allPromiseReady(queryPromise).then((queryResults) => {\r\n      // console.log(queryResults[0].results.bindings);\r\n      // console.log(queryResults[1].results.bindings);\r\n      // console.log(queryResults[2]);\r\n      let selectedClassAnnotation = queryResults[2];\r\n      // console.log(selectedClassAnnotation);\r\n\r\n      // First we fetch the property neighbours\r\n      // Let's also do some prefetching at this stage: let's remove the propertyNeighbours with too many siblings (150)\r\n      // and remove the propertyNeighbours with only one child (aka the originally pasted page)\r\n\r\n      let propertyNeighboursPO = [];\r\n      let promiseArray = [];\r\n      let bindingArray = [];\r\n\r\n      // The part below deals with the property neighbours\r\n      bindingArray = queryResults[0].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let predicate = bindingArray[i].p.value.slice(28);\r\n        // console.log(\"Predicate is \"+predicate);\r\n        let object = bindingArray[i].o.value.slice(28);\r\n        // console.log(\"Object is \"+object);\r\n        // If object includes some weird literal values, we replace it with \"NONEXISTING\"\r\n        if (object.includes(\"/\")) {\r\n          object = \"NONEXISTING\";\r\n        }\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs+%0D%0AWHERE+%7B%0D%0A%09%3Fs+dbp%3A\" +\r\n          regexReplace(predicate) +\r\n          \"+dbr%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: predicate, object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below deals with the dct:subject neighbours\r\n      bindingArray = queryResults[1].results.bindings;\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let object = bindingArray[i].o.value.slice(37);\r\n        let prefixURL =\r\n          \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n        let suffixURL =\r\n          \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n        let queryBody =\r\n          \"SELECT+%3Fs%0D%0AWHERE+%7B%0D%0A++++++%3Fs+dct%3Asubject+dbc%3A\" +\r\n          regexReplace(object) +\r\n          \"%0D%0A%7D&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        let curPromise = fetchJSON(queryURL);\r\n        propertyNeighboursPO.push({ predicate: \"subject\", object: object });\r\n        promiseArray.push(curPromise);\r\n      }\r\n\r\n      // The part below processes all the siblings and remove neighbours with too many or too few siblings\r\n\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        let propertyNeighbours = [];\r\n        let urlOrigin = decodeURIComponent(this.state.urlPasted.slice(30));\r\n        // console.log(urlOrigin);\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let curSiblingArray = values[i].results.bindings;\r\n          // Note, this 150 below should also be adjustable by users\r\n          if (curSiblingArray.length > 1 && curSiblingArray.length < 150) {\r\n            let siblingArray = [];\r\n            for (let i = 0; i < curSiblingArray.length; ++i) {\r\n              let siblingName = curSiblingArray[i].s.value.slice(28);\r\n              siblingArray.push({\r\n                isOpen: false,\r\n                name: siblingName,\r\n                tableArray: [],\r\n              });\r\n            }\r\n            // console.log(siblingArray);\r\n            propertyNeighbours.push({\r\n              predicate: propertyNeighboursPO[i].predicate,\r\n              object: propertyNeighboursPO[i].object,\r\n              isOpen: false,\r\n              siblingArray: siblingArray,\r\n            });\r\n          }\r\n        }\r\n        // we do a rudimentary ranking here: sort the property neighbours by the length of siblingArray\r\n        propertyNeighbours.sort((a, b) =>\r\n          a.siblingArray.length < b.siblingArray.length ? 1 : -1\r\n        );\r\n        // Then we update the action in Action Panel\r\n        let curActionInfo = { task: \"showPropertyNeighbours\" };\r\n        // Then we call the parse table helper function to update the tableDataExplore\r\n        let selectedTableHTML = this.state.originTableArray[tableIndex];\r\n        // setTableFromHTML is the function that prepares the data for tableDataExplore\r\n        let tableDataExplore = setTableFromHTML(selectedTableHTML, urlOrigin);\r\n\r\n        // Modeless Change: We need to call the helper function getTableStates.\r\n        // By processing the tableDataExplore to get the right states for the Excel-style table.\r\n\r\n        // To do this, we need to call getTableStates here. We just need to pass in tableDataExplore and selectedClassAnnotation \r\n        let statePromise = [getTableStates(tableDataExplore, selectedClassAnnotation)];\r\n        allPromiseReady(statePromise).then((values) => {\r\n          let stateInfo = values[0];\r\n          // console.log(stateInfo);\r\n\r\n          document.body.classList.remove('waiting');\r\n          // Support for undo: \r\n          let lastAction = \"handleStartTable\";\r\n          let prevState = \r\n              {\r\n                \"selectedTableIndex\": this.state.selectedTableIndex,\r\n                \"propertyNeighbours\": this.state.propertyNeighbours,\r\n                \"curActionInfo\": this.state.curActionInfo,\r\n                \"selectedClassAnnotation\": this.state.selectedClassAnnotation,\r\n                \"keyColIndex\": this.state.keyColIndex,\r\n                \"keyColNeighbours\": this.state.keyColNeighbours,\r\n                \"tableData\": this.state.tableData,\r\n                \"tableHeader\": this.state.tableHeader,\r\n                \"optionsMap\": this.state.optionsMap,\r\n                \"usecaseSelected\": this.state.usecaseSelected,\r\n                \"tabIndex\": this.state.tabIndex,\r\n              };\r\n\r\n          this.setState({\r\n            selectedTableIndex: tableIndex,\r\n            propertyNeighbours: propertyNeighbours,\r\n            curActionInfo: curActionInfo,\r\n            selectedClassAnnotation: selectedClassAnnotation,\r\n            keyColIndex: stateInfo.keyColIndex,\r\n            keyColNeighbours: stateInfo.keyColNeighbours,\r\n            tableData: stateInfo.tableData,\r\n            tableHeader: stateInfo.tableHeader,\r\n            optionsMap: stateInfo.optionsMap,\r\n            usecaseSelected: \"startTable\",\r\n            tabIndex: 1,\r\n            lastAction: lastAction,\r\n            prevState: prevState,\r\n          });\r\n          // this.handleTabSwitch(1);\r\n        })\r\n      });\r\n    });\r\n  }\r\n\r\n  togglePropertyNeighbours(e, index) {\r\n    document.body.classList.add('waiting');\r\n    \r\n    // First let's do the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    propertyNeighbours[index].isOpen = !propertyNeighbours[index].isOpen;\r\n\r\n    // we want to loop through all siblings if we are toggling a propertyNeighbour on\r\n    if (propertyNeighbours[index].isOpen === true) {\r\n      let bindingArray = propertyNeighbours[index].siblingArray;\r\n      let siblingArray = [];\r\n      let siblingNameArray = []; // this array keeps track of the sibling names\r\n      let promiseArray = [];\r\n      for (let i = 0; i < bindingArray.length; ++i) {\r\n        let siblingName = bindingArray[i].name;\r\n        let siblingURL = \"https://en.wikipedia.org/wiki/\" + siblingName;\r\n        let curPromise = fetchText(siblingURL);\r\n        promiseArray.push(curPromise);\r\n        siblingNameArray.push(siblingName);\r\n      }\r\n\r\n      // Since we only want to display siblings with useful tables, we do some checking here\r\n      allPromiseReady(promiseArray).then((values) => {\r\n        // tableArrayPromise stores an array of promises that resolve to tableArray\r\n        let tableArrayPromise = [];\r\n        for (let i = 0; i < values.length; ++i) {\r\n          let pageHTML = values[i];\r\n          // This is a helper function that fetches useful tables from pageHTML\r\n          // console.log(\"The class annotation for the selected table is: \");\r\n          // console.log(this.state.selectedClassAnnotation);\r\n          tableArrayPromise.push(\r\n            findTableFromHTML(\r\n              this.state.tableHeader,\r\n              pageHTML,\r\n              this.state.selectedClassAnnotation,\r\n              this.state.semanticEnabled,\r\n              this.state.unionCutOff,\r\n              siblingNameArray[i]\r\n            )\r\n          );\r\n          // we potentially want to do something different here if urlOrigin === siblingNameArray[i]\r\n          // We only want to keep siblings that do have useful tables\r\n          // if (tableArray.length !== 0) {\r\n          // siblingArray.push({\"isOpen\":false,\"name\":siblingNameArray[i],\"tableArray\":tableArray});\r\n          // }\r\n        }\r\n        allPromiseReady(tableArrayPromise).then((tableArrayValues) => {\r\n          for (let i = 0; i < tableArrayValues.length; ++i) {\r\n            siblingArray.push({\r\n              isOpen: false,\r\n              name: siblingNameArray[i],\r\n              tableArray: tableArrayValues[i],\r\n            });\r\n          }\r\n          // This following line sorts the siblingArray\r\n          siblingArray.sort(function (a, b) {\r\n            let aTableLength = a.tableArray.length;\r\n            let bTableLength = b.tableArray.length;\r\n            let aName = a.name;\r\n            let bName = b.name;\r\n            if (aTableLength === bTableLength) {\r\n              return aName < bName ? -1 : aName > bName ? 1 : 0;\r\n            } else {\r\n              return aTableLength > bTableLength ? -1 : 1;\r\n            }\r\n          });\r\n          propertyNeighbours[index].siblingArray = siblingArray;\r\n          document.body.classList.remove('waiting');\r\n          this.setState({\r\n            propertyNeighbours: propertyNeighbours,\r\n          });\r\n        });\r\n      });\r\n    } else {\r\n      document.body.classList.remove('waiting');\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n      });\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of a sibling URL\r\n\r\n  toggleSibling(e, firstIndex, secondIndex) {\r\n    // Handle the toggling task\r\n    // console.log(\"Here we start the sibling toggle\");\r\n    // console.log(\"The current property neighbour is \");\r\n    // console.log(\r\n    //   \"The current property neighbour is \",\r\n    //   this.state.propertyNeighbours.slice()\r\n    // );\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    // console.log(propertyNeighbours);\r\n    let selectedSibling =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex];\r\n\r\n    // Note that if this sibling's tableArray is empty, we probably do not want to toggle it.\r\n    if (selectedSibling.tableArray.length === 0) {\r\n      // console.log(\"Selected sibling has no tables: \" + selectedSibling.name);\r\n      let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n      this.setState({\r\n        pageHidden: false,\r\n        iframeURL: iframeURL,\r\n      });\r\n    } else {\r\n      // if the sibling's tableArray is not empty, we want to toggle it\r\n      selectedSibling.isOpen = !selectedSibling.isOpen;\r\n      // console.log(\"Let's take a look at the current property neighbour\");\r\n      // console.log(propertyNeighbours[firstIndex]);\r\n      // if (propertyNeighbours[firstIndex].isOpen === false) {\r\n      // propertyNeighbours[firstIndex].isOpen = true;\r\n      // console.log(\"In here we should have fixed the problem.\");\r\n      // console.log(propertyNeighbours);\r\n      // }\r\n      // We also want to change the iframe displayed at the bottom if we are toggling a sibling open\r\n      if (selectedSibling.isOpen === true) {\r\n        // console.log(\"If we get here, then sibling page should be opened\");\r\n        let iframeURL = \"https://en.wikipedia.org/wiki/\" + selectedSibling.name;\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        propertyNeighbours[firstIndex].isOpen = true;\r\n        // console.log(propertyNeighbours[firstIndex]);\r\n        // console.log(propertyNeighbours[firstIndex].isOpen);\r\n        // console.log(\"First index is: \" + firstIndex);\r\n        // console.log(\"In here we should have fixed the problem.\");\r\n        // console.log(\"This is the property neighbour we will pass in\");\r\n        // console.log(propertyNeighbours);\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n          iframeURL: iframeURL,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          propertyNeighbours: propertyNeighbours,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // The following function handles the toggling of other table (that's the same as the selected table)\r\n\r\n  toggleOtherTable(e, firstIndex, secondIndex, thirdIndex) {\r\n    // First handle the toggling task\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    const selectedTable =\r\n      propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray[\r\n        thirdIndex\r\n      ];\r\n    // console.log(selectedTable.data);\r\n    selectedTable.isOpen = !selectedTable.isOpen;\r\n    this.setState({\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // The following funcion unions the table that user has selected to the table in the TablePanel\r\n  // by changing tableDataExplore\r\n\r\n  unionTable(firstIndex, secondIndex, otherTableHTML, colMapping) {\r\n    // First we create a copy of the current tableData\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // console.log(tableData);\r\n\r\n    // Then we get the clean data and set the origin for the other table.\r\n    // We do so by calling setTableFromHTML, and setUnionData.\r\n    let otherTableOrigin = this.state.propertyNeighbours[firstIndex]\r\n      .siblingArray[secondIndex].name;\r\n    let otherTableData = setTableFromHTML(otherTableHTML, otherTableOrigin);\r\n    otherTableData = setUnionData(otherTableData);\r\n    // console.log(otherTableData);\r\n\r\n    // Start from here. We just need to modify function tableConcat\r\n    // console.log(colMapping);\r\n\r\n    // Note: we have to create a copy of colMapping, otherwise we are modifying the reference\r\n    let tempMapping = colMapping.slice();\r\n    tableData = tableConcat(\r\n      tableData,\r\n      otherTableData,\r\n      tempMapping\r\n    );\r\n\r\n    // console.log(tableData);\r\n\r\n    // Support for undo: \r\n    let lastAction = \"unionTable\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following function unions all similar tables found under a sibling page with the selected table\r\n  unionPage(firstIndex, secondIndex) {\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    // We get the tableArray and name of the current sibling page\r\n    let tableArray = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].tableArray;\r\n    let otherTableOrigin = \r\n      this.state.propertyNeighbours[firstIndex].siblingArray[secondIndex].name;\r\n\r\n    for (let i = 0; i < tableArray.length; ++i) {\r\n      // We get the clean data for the current \"other table\"\r\n      let otherTableData = setTableFromHTML(\r\n        tableArray[i].data,\r\n        otherTableOrigin\r\n      );\r\n      // We fetch the header row now\r\n      let headerRow = otherTableData[0];\r\n      otherTableData = setUnionData(otherTableData);\r\n      // console.log(headerRow);\r\n      // console.log(this.state.tableHeader);\r\n\r\n      // Let's do some checking here: we do not want to union the same table with itself\r\n      let sameTable = false;\r\n      if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n        let diffColFound = false;\r\n        for (let m=0; m<headerRow.length; ++m) {\r\n          if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n            diffColFound = true;\r\n            break;\r\n          }\r\n        }\r\n        if (diffColFound === false) {\r\n          sameTable = true;\r\n        }\r\n      }\r\n      // We create a copy of the colMapping of the current \"other table\"\r\n      let tempMapping = tableArray[i].colMapping.slice();\r\n\r\n      // if sameTable is false, we can safely union the data\r\n      if (sameTable === false) {\r\n        tableData = tableConcat(\r\n          tableData,\r\n          otherTableData,\r\n          tempMapping\r\n        );\r\n      }\r\n    }\r\n    // Support for undo: \r\n    let lastAction = \"unionPage\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // The following function unions all similar tables found under a property(parent) neighbour with the selected table\r\n  // This is the highest level of union.\r\n\r\n  unionProperty(firstIndex) {\r\n    // First we create a copy of the current tableDataExplore\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n\r\n    // we get the siblingArray of the current property neighbour\r\n    let siblingArray = this.state.propertyNeighbours[firstIndex].siblingArray;\r\n\r\n    for (let i = 0; i < siblingArray.length; ++i) {\r\n      // We get the tableArray and name of the current sibling page\r\n      let tableArray = siblingArray[i].tableArray;\r\n      let otherTableOrigin = siblingArray[i].name;\r\n      // console.log(otherTableOrigin);\r\n      // If the current sibling has no tables that are unionable, we break out of the loop.\r\n      // Because siblingArray is sorted by the length of their tableArray\r\n      if (tableArray.length === 0) {\r\n        break;\r\n      }\r\n      // Else, we want to union all unionable tables from the current sibling page\r\n      else {\r\n        for (let j = 0; j < tableArray.length; ++j) {\r\n          // We get the clean data for the current \"other table\"\r\n          let otherTableData = setTableFromHTML(\r\n            tableArray[j].data,\r\n            otherTableOrigin\r\n          );\r\n          // We fetch the column header row\r\n          let headerRow = otherTableData[0];\r\n          otherTableData = setUnionData(otherTableData);\r\n          // Let's do some checking here: we do not want to union the same table with itself\r\n          let sameTable = false;\r\n          if (otherTableOrigin === decodeURIComponent(this.state.urlPasted.slice(30)) && headerRow.length === tableData[0].length) {\r\n            let diffColFound = false;\r\n            for (let m=0; m<headerRow.length; ++m) {\r\n              if (headerRow[m].data !== this.state.tableHeader[m].value) {\r\n                diffColFound = true;\r\n                break;\r\n              }\r\n            }\r\n            if (diffColFound === false) {\r\n              sameTable = true;\r\n            }\r\n          }\r\n          // We create a copy of the colMapping of the current \"oother table\"\r\n          let tempMapping = tableArray[j].colMapping.slice();\r\n\r\n          // if sameTable is false, we can safely union the data\r\n          if (sameTable === false) {\r\n            tableData = tableConcat(\r\n              tableData,\r\n              otherTableData,\r\n              tempMapping\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Support for undo: \r\n    let lastAction = \"unionProperty\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n        };\r\n\r\n    this.setState({\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of \"semanticEnabled\" setting\r\n\r\n  toggleSemantic(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing semanticEnabled changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n\r\n    this.setState({\r\n      semanticEnabled: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles the change of the unionCutoff percentage\r\n\r\n  unionCutOffChange(e) {\r\n    // we want to toggle off all the property neighbours in the action panel\r\n    // because changing union cutoff changes our search criteria\r\n    let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n    for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n      propertyNeighbours[i].isOpen = false;\r\n    }\r\n    this.setState({\r\n      unionCutOff: e.target.value,\r\n      propertyNeighbours: propertyNeighbours,\r\n    });\r\n  }\r\n\r\n  // This function handles opening the filter for a particular column\r\n\r\n  openFilter(e, colIndex) {\r\n    // In this function, we want to set showFilter to true, and update dataAndChecked based on colIndex\r\n\r\n    let dataArray = [];\r\n    for (let i = 0; i < this.state.tableData.length; ++i) {\r\n      dataArray.push(this.state.tableData[i][colIndex].data);\r\n    }\r\n    dataArray = [...new Set(dataArray)];\r\n    // Let's sort this dataArray a bit: we put N/A at the beginning of the array\r\n    dataArray.sort(\r\n      function(a,b) { \r\n        return a === \"N/A\" ? -1 : b === \"N/A\" ? 1 : 0; \r\n      }\r\n    );\r\n\r\n    let dataAndChecked = [];\r\n    for (let i=0;i<dataArray.length;++i) {\r\n      dataAndChecked.push(\r\n        {\r\n          \"data\":dataArray[i],\r\n          \"checked\":true\r\n        }\r\n      )\r\n    }\r\n    // console.log(dataAndChecked);\r\n\r\n    this.setState({\r\n      dataAndChecked: dataAndChecked,\r\n      showFilter: true,\r\n      curFilterIndex: colIndex,\r\n    })\r\n  }\r\n\r\n  // This function handles cancelling the filter (so we close it).\r\n\r\n  cancelFilter(e) {\r\n    this.setState({\r\n      dataAndChecked: [],\r\n      showFilter: false,\r\n      curFilterIndex: -1,\r\n    })\r\n  }\r\n\r\n  // This function handles toggling the data checkboxes in filter modal.\r\n\r\n  toggleChecked(e, checkIndex) {\r\n    let dataAndChecked = this.state.dataAndChecked;\r\n    dataAndChecked[checkIndex].checked = !dataAndChecked[checkIndex].checked;\r\n    this.setState({\r\n      dataAndChecked:dataAndChecked,\r\n    })\r\n  }\r\n\r\n  // This function handles applying the filter to tableData, based on dataAndChecked\r\n\r\n  applyFilter(e) {\r\n    // console.log(this.state.dataAndChecked);\r\n    // console.log(this.state.curFilterIndex);\r\n\r\n    let valuesToKeep = [];\r\n    for (let i=0;i<this.state.dataAndChecked.length;++i) {\r\n      if (this.state.dataAndChecked[i].checked === true) {\r\n        valuesToKeep.push(this.state.dataAndChecked[i].data);\r\n      }\r\n    }\r\n    let tableData = _.cloneDeep(this.state.tableData);\r\n    for (let i=0;i<tableData.length;++i) {\r\n      if (!valuesToKeep.includes(tableData[i][this.state.curFilterIndex].data)) {\r\n        tableData.splice(i,1);\r\n        --i;\r\n      }\r\n    }\r\n    // console.log(tableData);\r\n\r\n    // Before we use tableData to update this.state.tableData, we need to add suppport for undo.\r\n    let lastAction = \"applyFilter\";\r\n    let prevState = \r\n        {\r\n          \"tableData\":this.state.tableData,\r\n          \"curActionInfo\":this.state.curActionInfo,\r\n        };\r\n    \r\n    this.setState({\r\n      dataAndChecked: [],\r\n      showFilter: false,\r\n      curFilterIndex: -1,\r\n      tableData: tableData,\r\n      lastAction: lastAction,\r\n      prevState: prevState,\r\n    })\r\n  }\r\n\r\n  // This function hanles switching tabs\r\n\r\n  handleTabSwitch(index) {\r\n    // If we are switching to \"Union Table\" tab from \"Wrangling Actions\" tab, we want to toggle off all the property neighbours.\r\n    // Since we might have potentially changed the table in table panel, thus changed the search criteria as well\r\n    if (index === 1) {\r\n      let propertyNeighbours = this.state.propertyNeighbours.slice();\r\n      for (let i = 0; i < propertyNeighbours.length; ++i) {\r\n        propertyNeighbours[i].isOpen = false;\r\n      }\r\n      this.setState({\r\n        propertyNeighbours: propertyNeighbours,\r\n        tabIndex: index,\r\n      });\r\n    }\r\n    else {\r\n      this.setState({\r\n        tabIndex: index,\r\n      })\r\n    }\r\n  }\r\n\r\n  // This function undos the previous change that user has made to the result table in table panel\r\n\r\n  undoPreviousStep() {\r\n    // We first get which action we need to undo\r\n    let lastAction = this.state.lastAction;\r\n    // Then we fetch the previous state\r\n    let prevState = this.state.prevState;\r\n    // console.log(lastAction);\r\n    // console.log(prevState);\r\n\r\n    // Note, since we are allowing one step undo only, we set lastAction to \"\" everytime we run this function\r\n\r\n    // Case 1: Undo the ULR Paste. \r\n    // In this case we need to restore urlPasted, iframeURL, originTableArray, and tableOpenList\r\n    if (lastAction === \"handleURLPaste\") {\r\n      this.setState({\r\n        urlPasted: prevState.urlPasted,\r\n        iframeURL: prevState.iframeURL,\r\n        originTableArray: prevState.originTableArray,\r\n        tableOpenList: prevState.tableOpenList,\r\n      })\r\n    }\r\n\r\n    // Case 2: Undo the selection of the task: startSubject.\r\n    // In this case we need to restore usecaseSelected, and tableData\r\n\r\n    else if (lastAction === \"handleStartSubject\") {\r\n      this.setState({\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tableData: prevState.tableData,\r\n        tabIndex: prevState.tabIndex,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 3: Undo the selection of the task: startTable.\r\n    // In this case we need to restore many states. See code below.\r\n\r\n    else if (lastAction === \"handleStartTable\") {\r\n      this.setState({\r\n        selectedTableIndex: prevState.selectedTableIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        optionsMap: prevState.optionsMap,\r\n        usecaseSelected: prevState.usecaseSelected,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 4: Undo the population of key column.\r\n    // In this case we need to restore keyColIndex, keyColNeighbours, curActionInfo, tableData, optionsMap\r\n    else if (lastAction === \"populateKeyColumn\") {\r\n      this.setState({\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        optionsMap: prevState.optionsMap,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 5: Undo the population of a new column.\r\n    // In this case we need to restore curActionInfo, tableData.\r\n    else if (lastAction === \"populateOtherColumn\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 6: Undo the population of same neighbour in different columns.\r\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap.\r\n    else if (lastAction === \"sameNeighbourDiffCol\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        optionsMap: prevState.optionsMap,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 7: Undo the population of same neighbour in the same column.\r\n    // In this case we need to restore the curActionInfo, tableData.\r\n    else if (lastAction === \"sameNeighbourOneCol\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 8: Undo the population of neighbours from the same range.\r\n    // In this case we need to restore curActionInfo, tableData, tableHeader, optionsMap\r\n    else if (lastAction === \"populateSameRange\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        optionsMap: prevState.optionsMap,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 9: Undo the union of tables.\r\n    // In this case we need to restore tableData\r\n    else if (lastAction === \"unionTable\" || lastAction === \"unionPage\" || lastAction === \"unionProperty\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 10: Undo the addition of a new column\r\n    else if (lastAction === \"contextAddColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        curActionInfo: prevState.curActionInfo,\r\n        optionsMap: prevState.optionsMap,\r\n        keyColIndex: prevState.keyColIndex,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 11: Undo the set of search cell.\r\n    else if (lastAction === \"contextSetCell\") {\r\n      this.setState({\r\n        keyEntryIndex: prevState.keyEntryIndex,\r\n        keyColIndex: prevState.keyColIndex,\r\n        keyColNeighbours: prevState.keyColNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        optionsMap: prevState.optionsMap,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 12: Undo the showing of cell origin.\r\n    else if (lastAction === \"contextCellOrigin\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 12: Undo the showing of cell preview.\r\n    else if (lastAction === \"contextCellPreview\") {\r\n      this.setState({\r\n        curActionInfo: prevState.curActionInfo,\r\n        tabIndex: prevState.tabIndex,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 13: Undo the deletion of column.\r\n    else if (lastAction === \"contextDeleteColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        tableHeader: prevState.tableHeader,\r\n        optionsMap: prevState.optionsMap,\r\n        selectedClassAnnotation: prevState.selectedClassAnnotation,\r\n        keyColIndex: prevState.keyColIndex,\r\n        propertyNeighbours: prevState.propertyNeighbours,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 14: Undo the sorting of a column.\r\n    else if (lastAction === \"contextSortColumn\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        keyEntryIndex: prevState.keyEntryIndex,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // Case 15: Undo the row filtering based on column filters.\r\n    else if (lastAction === \"applyFilter\") {\r\n      this.setState({\r\n        tableData: prevState.tableData,\r\n        curActionInfo: prevState.curActionInfo,\r\n        lastAction: \"\",\r\n      })\r\n    }\r\n\r\n    // This is an empty else clause.\r\n    else {\r\n\r\n    }\r\n  }\r\n\r\n  // The two following functions opens/closes the modal for union table settings.\r\n\r\n  openModal() {\r\n    this.setState({\r\n      showSetting: true,\r\n    })\r\n  }\r\n\r\n  closeModal() {\r\n    this.setState({\r\n      showSetting: false,\r\n    })\r\n  }\r\n\r\n  // The following function toggles this.state.showTableSelection.\r\n\r\n  toggleTableSelection() {\r\n    let showTableSelection = !this.state.showTableSelection;\r\n    this.setState({\r\n      showTableSelection: showTableSelection,\r\n    })\r\n  }\r\n\r\n  render() {\r\n    let bodyEle;\r\n    let bottomContentClass = \" bottom-content\";\r\n    let topContentClass = \"row top-content\";\r\n    if (this.state.pageHidden) {\r\n      bottomContentClass = \" bottom-content-hidden\";\r\n      topContentClass = \"row top-content-large\";\r\n    }\r\n    // If user has not pasted the URL, we want to display the landing page\r\n    if (this.state.urlPasted === \"\") {\r\n      bodyEle = \r\n        <LandingPage \r\n          handleURLPaste={this.handleURLPaste} \r\n        />;\r\n    }\r\n    // Else, we show the three panels: TablePanel, ActionPanel, and PagePanel\r\n    else {\r\n      bodyEle = (\r\n        <div>\r\n          <div className=\"header\">\r\n            <Header \r\n              // Following states are passed for general purposes\r\n              copyTable={this.copyTable}\r\n              undoPreviousStep={this.undoPreviousStep}\r\n              openModal = {this.openModal}\r\n            />\r\n          </div> \r\n          <div className=\"mainbody\">\r\n            <div className=\"\">\r\n              <div className={topContentClass}>\r\n                <div className=\"col-md-7 small-padding  table-panel\">\r\n                  <TablePanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    // Following states are passed to \"startSubject\"\r\n                    tableHeader={this.state.tableHeader}\r\n                    tableData={this.state.tableData}\r\n                    keyColIndex={this.state.keyColIndex}\r\n                    keyEntryIndex={this.state.keyEntryIndex}\r\n                    onCellChange={this.cellChange}\r\n                    selectColHeader={this.selectColHeader}\r\n                    getKeyOptions={this.getKeyOptions}\r\n                    getOtherOptions={this.getOtherOptions}\r\n                    optionsMap={this.state.optionsMap}\r\n                    contextAddColumn={this.contextAddColumn}\r\n                    contextDeleteColumn={this.contextDeleteColumn}\r\n                    contextSetCell={this.contextSetCell}\r\n                    contextCellOrigin={this.contextCellOrigin}\r\n                    contextCellPreview={this.contextCellPreview}\r\n                    contextOpenLink={this.contextOpenLink}\r\n                    contextSortColumn={this.contextSortColumn}\r\n                    // Folloiwng states are useful for column filter\r\n                    openFilter={this.openFilter}\r\n                  />\r\n                </div>\r\n                <div className=\"col-md-5 small-padding action-panel\">\r\n                  <ActionPanel\r\n                    urlPasted={this.state.urlPasted}\r\n                    usecaseSelected={this.state.usecaseSelected}\r\n                    curActionInfo={this.state.curActionInfo}\r\n                    handleStartSubject={this.handleStartSubject}\r\n                    populateKeyColumn={this.populateKeyColumn}\r\n                    populateOtherColumn={this.populateOtherColumn}\r\n                    sameNeighbourDiffCol={this.sameNeighbourDiffCol}\r\n                    sameNeighbourOneCol={this.sameNeighbourOneCol}\r\n                    populateSameRange={this.populateSameRange}\r\n                    // Folloiwng states are passed to \"startTable\"\r\n                    handleStartTable={this.handleStartTable}\r\n                    propertyNeighbours={this.state.propertyNeighbours}\r\n                    togglePropertyNeighbours={this.togglePropertyNeighbours}\r\n                    toggleSibling={this.toggleSibling}\r\n                    toggleOtherTable={this.toggleOtherTable}\r\n                    unionTable={this.unionTable}\r\n                    unionPage={this.unionPage}\r\n                    unionProperty={this.unionProperty}\r\n                    // Follow state handles tab switch\r\n                    tabIndex={this.state.tabIndex}\r\n                    handleTabSwitch={this.handleTabSwitch}\r\n                    // Following states are passed during start up\r\n                    showTableSelection={this.state.showTableSelection}\r\n                    toggleTableSelection={this.toggleTableSelection}\r\n                    originTableArray={this.state.originTableArray}\r\n                    tableOpenList={this.state.tableOpenList}\r\n                    toggleTable={this.toggleTable}\r\n                    selectedTableIndex={this.state.selectedTableIndex}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div className={bottomContentClass}>\r\n                <div>\r\n                  <PagePanel\r\n                    pageHidden={this.state.pageHidden}\r\n                    iframeURL={this.state.iframeURL}\r\n                    toggleWikiPage={this.toggleWikiPage}\r\n                  />\r\n                </div>\r\n              </div>\r\n              <div>\r\n                <SettingModal \r\n                  showSetting={this.state.showSetting}\r\n                  closeModal={this.closeModal}\r\n                  semanticEnabled={this.state.semanticEnabled}\r\n                  toggleSemantic={this.toggleSemantic}\r\n                  unionCutOff={this.state.unionCutOff}\r\n                  unionCutOffChange={this.unionCutOffChange}\r\n                />\r\n              </div>\r\n              <div>\r\n                <FilterModal\r\n                  showFilter={this.state.showFilter}\r\n                  dataAndChecked={this.state.dataAndChecked}\r\n                  applyFilter={this.applyFilter}\r\n                  cancelFilter={this.cancelFilter}\r\n                  toggleChecked={this.toggleChecked}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"footer\">\r\n            <Footer />\r\n          </div> \r\n        </div>\r\n      );\r\n    }\r\n    return <div>{bodyEle}</div>;\r\n  }\r\n}\r\n\r\nexport default MainBody;\r\n\r\n// This function takes in a queryURL and returns its JSON format\r\nfunction fetchJSON(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS).then((response) => response.json());\r\n}\r\n\r\n// This function takes in a queryURL and returns its Text format\r\nfunction fetchText(url) {\r\n  let urlCORS = \"https://mysterious-ridge-15861.herokuapp.com/\"+url;\r\n  return fetch(urlCORS).then((response) => response.text());\r\n}\r\n\r\n// This function ensures that all promises in promiseArray are ready\r\nfunction allPromiseReady(promiseArray) {\r\n  return Promise.all(promiseArray);\r\n}\r\n\r\n// This function replaces string so that the result can be used in queryURL.\r\n// It currently replaces \"(\", \")\", \"'\", \"-\", \" \", \"&\", \".\", \"\"\",and \"/\"\r\nfunction regexReplace(str) {\r\n  return str\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/%/g, \"%5Cu0025\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\");\r\n}\r\n\r\n// This function replaces the URL pasted\r\nfunction urlReplace(str) {\r\n  return str\r\n    .replace(/%E2%80%93/g, \"%5Cu2013\")\r\n    .replace(/\\$/g, \"%5Cu0024\")\r\n    .replace(/!/g, \"%5Cu0021\")\r\n    .replace(/\"/g, \"%5Cu0022\")\r\n    .replace(/#/g, \"%5Cu0023\")\r\n    .replace(/&/g, \"%5Cu0026\")\r\n    .replace(/'/g, \"%5Cu0027\")\r\n    .replace(/\\(/g, \"%5Cu0028\")\r\n    .replace(/\\)/g, \"%5Cu0029\")\r\n    .replace(/\\*/g, \"%5Cu002A\")\r\n    .replace(/\\+/g, \"%5Cu002B\")\r\n    .replace(/-/g, \"%5Cu002D\")\r\n    .replace(/;/g, \"%5Cu003B\")\r\n    .replace(/=/g, \"%5Cu003D\")\r\n    .replace(/\\?/g, \"%5Cu003F\")\r\n    .replace(/\\./g, \"%5Cu002E\")\r\n    .replace(/\\//g, \"%5Cu002F\")\r\n    .replace(/,/g, \"%5Cu002C\")\r\n    .replace(/\\s/g, \"_\");\r\n}\r\n\r\n// This function removes the prefix \"http://dbpedia.org/resource/\" from query results, if it includes one\r\n\r\nfunction removePrefix(str) {\r\n  let prefixToRemove = \"http://dbpedia.org/resource/\";\r\n  // If dbResult contains prefix of \"http://dbpedia.org/resource/\", we want to remove it\r\n  if (str.includes(prefixToRemove) === true) {\r\n     str = str.slice(28);\r\n  }\r\n  return str;\r\n}\r\n\r\n// This function updates the key column's neighbours.\r\n\r\n// It taks three parameters:\r\n//  1) array \"keyColNeighbour\" storing list of neighbours for the key column\r\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  3) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns the updated keyColNeighbours\r\nfunction updateKeyColNeighbours(keyColNeighbours, resultsBinding, type) {\r\n\r\n  // we first sort the resultsBinding by p.value.slice(28)\r\n  let processedBinding = \r\n    resultsBinding.sort((a, b) =>\r\n      a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n    );\r\n\r\n  // we then filter out those in resultsBinding with p.value.slice(28).length equal to 1\r\n  processedBinding = processedBinding.filter(a => a.p.value.slice(28).length > 1);\r\n\r\n  // Let's only start the loop is processedBinding is non-empty\r\n  if (processedBinding.length > 0) {\r\n    // We set count of neighbour ready to be added\r\n    let neighbourCount = 1;  \r\n    // We set literal of neighbour ready to be added.\r\n    // Initialized with the first neighbour.\r\n    let neighbourToAdd = processedBinding[0].p.value.slice(28); \r\n    // we set range of neighbour ready to be added. \"\" if doesn't exist.\r\n    let neighbourRange = \"\";\r\n    if (processedBinding[0].range !== undefined) {\r\n      neighbourRange = processedBinding[0].range.value;\r\n    } \r\n    \r\n    // We loop over processedBinding\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      // If the current neighbour is equal to neighbourToAdd, we just increment the count\r\n      if (curNeighbour === neighbourToAdd) {\r\n        ++neighbourCount;\r\n      }\r\n      // else, we decide if we want to push neighbourToAdd to keyColNeighbours. \r\n      // We push if neighbourCount is <= maxNeighbourCount\r\n      else {\r\n        // First determine if we wnat to push\r\n        if (neighbourCount <= maxNeighbourCount) {\r\n          // set value.\r\n          let objValue = neighbourToAdd;\r\n          // set label. We want to change the neighbour label if type === \"object\".\r\n          let objLabel = neighbourToAdd;\r\n          if (type === \"object\") {\r\n            objLabel = \"is \" + objLabel + \" of\";\r\n          }\r\n          if (neighbourCount > 1) {\r\n            objLabel+=\" *\";\r\n          }\r\n          // set type\r\n          let objType = type;\r\n          // set count\r\n          let objCount = neighbourCount;\r\n          let tempObj = {\"value\":objValue, \"label\":objLabel, \"type\":objType, \"count\":objCount};\r\n          // Lastly, if the current type is \"subject\", we want to see if this neighbour has a range\r\n          if (type === \"subject\" && neighbourRange !== \"\") {\r\n            tempObj[\"range\"] = neighbourRange;\r\n          }\r\n          // we push this tempObj onto keyColNeighbours\r\n          keyColNeighbours.push(tempObj)\r\n        }\r\n        // Regardless of pushing or not, we now need to reset neighbourCount, neighbourToAdd, and neighbourRange\r\n        neighbourCount = 1;\r\n        neighbourToAdd = curNeighbour;\r\n        neighbourRange = \"\";\r\n        if (processedBinding[i].range !== undefined) {\r\n          neighbourRange = processedBinding[i].range.value;\r\n        }\r\n      }\r\n    }\r\n    // Now, after the loop is done, we need to do one more iteration to determine whether we want to add the last neighbour.\r\n    if (neighbourCount <= maxNeighbourCount) {\r\n      // set value.\r\n      let objValue = neighbourToAdd;\r\n      // set label. We want to change the neighbour label if type === \"object\".\r\n      let objLabel = neighbourToAdd;\r\n      if (type === \"object\") {\r\n        objLabel = \"is \" + objLabel + \" of\";\r\n      }\r\n      if (neighbourCount > 1) {\r\n        objLabel+=\" *\";\r\n      }\r\n      // set type\r\n      let objType = type;\r\n      // set count\r\n      let objCount = neighbourCount;\r\n      let tempObj = {\"value\":objValue, \"label\":objLabel, \"type\":objType, \"count\":objCount};\r\n      // Lastly, if the current type is \"subject\", we want to see if this neighbour has a range\r\n      if (type === \"subject\" && neighbourRange !== \"\") {\r\n        tempObj[\"range\"] = neighbourRange;\r\n      }\r\n      // we push this tempObj onto keyColNeighbours\r\n      keyColNeighbours.push(tempObj)\r\n    }\r\n  }\r\n  return keyColNeighbours;\r\n  \r\n  // console.log(keyColNeighbours);\r\n  // console.log(processedBinding);\r\n}\r\n\r\n// This helper function is designed to process the result bindings passed from contextCellPreview.\r\n// It should share some similarity with updateKeyColNeighbours\r\n\r\n// It taks two parameters:\r\n//  2) array \"resultsBinding\", storing the returned result of queryURL from Virtuoso\r\n//  3) string \"type\", either \"subject\" or \"object\"\r\n\r\n// It returns previewInfoArray, a list of objects used to display a cell's preview info\r\n// This object has two properties:\r\n// 1) key: a string\r\n// 2) value: an array of strings\r\nfunction updatePreviewInfo(resultsBinding, type) {\r\n  // console.log(previewInfoArray);\r\n  // console.log(resultsBinding);\r\n  // console.log(type);\r\n\r\n  // Let's do some preprocessing of resultsBinding. We want to do sorting, deduping, and some filtering.\r\n\r\n  // We first sort the resultsBinding by p.value.slice(28)\r\n  let processedBinding = \r\n    resultsBinding.sort((a, b) =>\r\n      a.p.value.slice(28) > b.p.value.slice(28) ? 1 : -1\r\n    );\r\n\r\n  // We then filter out those in resultsBinding with p.value.slice(28).length equal to 1\r\n  processedBinding = processedBinding.filter(a => a.p.value.slice(28).length > 1);\r\n\r\n  // Now let's create the previewInfoArray based on processedBinding\r\n  // console.log(processedBinding);\r\n\r\n  let previewInfoArray = [];\r\n\r\n  if (processedBinding.length > 1) {\r\n    // We first push on the first element from processedBinding\r\n\r\n    previewInfoArray.push(\r\n      {\r\n        \"key\": type === \"subject\" ? processedBinding[0].p.value.slice(28) : \"is \"+processedBinding[0].p.value.slice(28)+\" of\",\r\n        \"value\": [removePrefix(processedBinding[0].value.value)],\r\n      }\r\n    )\r\n    let curIndex = 0;\r\n    for (let i = 1; i < processedBinding.length; ++i) {\r\n      let curNeighbour = processedBinding[i].p.value.slice(28);\r\n      let prevNeighbour = processedBinding[i-1].p.value.slice(28);\r\n      // console.log(curNeighbour);\r\n      // console.log(prevNeighbour);\r\n\r\n      // If this neighbour is the same as the previous one, we want to append this neighbour's value\r\n      // to the element's value array in previewInfoArray at curIndex\r\n      if (curNeighbour === prevNeighbour) {\r\n        // Note, we dont want each element in previewInfoArray to contain too many elements (5), so we do a check here.\r\n        if (previewInfoArray[curIndex].value.length < 5) {\r\n          previewInfoArray[curIndex].value.push(removePrefix(processedBinding[i].value.value));\r\n        }\r\n      }\r\n      // Else, we push a fresh element onto previewInforArray, and update curIndex\r\n      else {\r\n        previewInfoArray.push(\r\n          {\r\n            \"key\": type === \"subject\" ? processedBinding[i].p.value.slice(28) : \"is \"+processedBinding[i].p.value.slice(28)+\" of\",\r\n            \"value\":[removePrefix(processedBinding[i].value.value)],\r\n          }\r\n        )\r\n        ++curIndex;\r\n      }\r\n    }\r\n    // console.log(previewInfoArray);\r\n  }\r\n  return previewInfoArray;\r\n}\r\n\r\n// This function takes in the clean data for the first table, clean data for the second table, and colMapping between these two tables\r\n// And returns the unioned clean data for the first table\r\n\r\nfunction tableConcat(tableData, otherTableData, tempMapping) {\r\n  // We want to correctly modify tableDataExplore, based on colMapping.\r\n  // If colMapping is null for some column, we want to set the data as \"N/A\"\r\n  // console.log(tableDataExplore);\r\n\r\n  // We first make some small modifications to colMapping, as we have inserted a new column into otherTableData and tableDataExplore\r\n  for (let j = 0; j < tempMapping.length; ++j) {\r\n    if (tempMapping[j] !== \"null\") {\r\n      tempMapping[j]++;\r\n    }\r\n  }\r\n  tempMapping.splice(0, 0, 0); // insert element 0 at the first position of colMapping, deleting 0 elements\r\n\r\n  // Now we insert the data into dataToAdd. dataToAdd will be concatenated with tableDataExplore\r\n  let dataToAdd = [];\r\n  for (let i = 0; i < otherTableData.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < tempMapping.length; ++j) {\r\n      let colInNew = tempMapping[j];\r\n      if (colInNew !== \"null\") {\r\n        tempRow.push(otherTableData[i][colInNew]);\r\n      } else {\r\n        tempRow.push({ data: \"N/A\" });\r\n      }\r\n    }\r\n    dataToAdd.push(tempRow);\r\n  }\r\n  return tableData.concat(dataToAdd);\r\n}\r\n\r\nfunction HTMLCleanCell(str) {\r\n  // Note that this function also removes leading and trailing whitespaces\r\n  if (str[str.length - 1] === \"\\n\") {\r\n    return str.slice(0, -1).trim().split(\"[\")[0];\r\n  } else {\r\n    return str.trim().split(\"[\")[0];\r\n  }\r\n}\r\n\r\n// This function returns an array of table objects that are unionable with the selected table.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"tableHTML\" storing the HTML of the selected table\r\n//  2) HTML \"pageHTML\", storing the HTML of a sibling page\r\n\r\n// Table object has four attributes: isOpen, data, unionScore, colMapping\r\n\r\n// Once semantic mapping feature is added, the colMapping will be updated\r\n\r\nfunction findTableFromHTML(\r\n  tableHeader,\r\n  pageHTML,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // We first get the column names of the table in the table panel, using this.state.tableHeader.\r\n  // Note: the index starts from 1 because we don't care about the originURL column (column 0).\r\n  let originCols = [];\r\n  for (let j = 1; j < tableHeader.length; ++j) {\r\n    originCols.push(tableHeader[j].value);\r\n  }\r\n  // console.log(originCols);\r\n\r\n  // We now fetch all the tables from pageHTML (the current sibling page)\r\n  let doc = new DOMParser().parseFromString(pageHTML, \"text/html\");\r\n  let wikiTablesFound = doc.getElementsByClassName(\"wikitable\");\r\n  let tablesFound = [];\r\n  for (let i = 0; i < wikiTablesFound.length; ++i) {\r\n    if (wikiTablesFound[i].tagName !== \"TH\") {\r\n      tablesFound.push(wikiTablesFound[i]);\r\n    }\r\n  }\r\n\r\n  // console.log(tablesFound);\r\n\r\n  // This is the array we will return.\r\n  let tableArray = [];\r\n\r\n  // We now loop through all the tables found on this sibling page, and see if they are unionable with the selected table\r\n  let tablePromise = [];\r\n  for (let i = 0; i < tablesFound.length; ++i) {\r\n    tablePromise.push(\r\n      findTableFromTable(\r\n        tablesFound[i],\r\n        originCols,\r\n        selectedClassAnnotation,\r\n        semanticEnabled,\r\n        unionCutOff,\r\n        pageName\r\n      )\r\n    );\r\n  }\r\n\r\n  return allPromiseReady(tablePromise).then((values) => {\r\n    for (let i = 0; i < values.length; ++i) {\r\n      tableArray.push(values[i]);\r\n    }\r\n    // we filter the tableArray here by removing those tables that do not have a high enough unionScore\r\n    // Note: In the unfiltered table array, we are using -1 to represent tables with a low unionScore\r\n    tableArray = tableArray.filter(function (x) {\r\n      return x !== -1;\r\n    });\r\n    // console.log(tableArray);\r\n    // We sort the tableArray here by unionScore\r\n    tableArray.sort((a, b) => (a.unionScore < b.unionScore ? 1 : -1));\r\n    return Promise.resolve(tableArray);\r\n  });\r\n}\r\n\r\n// This function takes in four parameters:\r\n\r\n// 1) a tableHTML\r\n// 2) originCols (denoting the columns names of the selected table)\r\n// 3) class annotation of the selected table\r\n// 4) whether semantic mapping is enabled or not\r\n\r\n// and return a table Object with properties: isOpen, unionScore, colMapping, and data\r\nfunction findTableFromTable(\r\n  tableHTML,\r\n  originCols,\r\n  selectedClassAnnotation,\r\n  semanticEnabled,\r\n  unionCutOff,\r\n  pageName\r\n) {\r\n  // Define some constants\r\n  const ontologySize = 780;\r\n  const matchCutOff = 0.999;\r\n\r\n  // We first fetch the cleaned column names of the current table\r\n  let curHeaderCells = tableHTML.rows[0].cells;\r\n  let newCols = []; // stores the cleaned column names of the this table. Let's consider using this value for display as well.\r\n  let remainCols = []; // stores an array of the indices of the columns of the current table that are not yet mapped\r\n  let searchCols = []; // stores an array of the indices of the columns from the selected table that are not yet mapped\r\n\r\n  // We potentially need to resort to semantic mapping. So let's create a promiseArray.\r\n  // This promiseArray will only contain one element\r\n  let promiseArray = [];\r\n\r\n  for (let j = 0; j < curHeaderCells.length; ++j) {\r\n    let headerName = HTMLCleanCell(curHeaderCells[j].innerText);\r\n    newCols.push(headerName);\r\n    remainCols.push(j);\r\n  }\r\n\r\n  // we want to make sure that newTable has more than half of the columns of the selectedTable\r\n  // because we require a >50% unionScore\r\n  // If it does not, we ignore this table automatically\r\n\r\n  if (newCols.length >= originCols.length * unionCutOff) {\r\n    // We use the proposed algo here.\r\n    // First we set the union score and column Mapping\r\n    let unionScore = 0;\r\n    let colMapping = [];\r\n    // We loop through the column headers in originCol, and see if they exist in newCols.\r\n    for (let k = 0; k < originCols.length; ++k) {\r\n      let curIndex = newCols.indexOf(originCols[k]);\r\n      if (curIndex !== -1) {\r\n        // This means the new table also contains column k from the selected table\r\n        // Thus we have found a mapping. We push it onto colMapping.\r\n        colMapping.push(curIndex);\r\n        unionScore += 1 / originCols.length;\r\n      } else {\r\n        colMapping.push(\"null\");\r\n      }\r\n    }\r\n    // In here we do a bit of string matching for tables with the same number of columns\r\n    // Chances are: tables from sibling pages with the same number of columns as the selected table, with structual invariability,\r\n    // is likely to be the \"same\" table as the selected on, we give it a chance for string matching\r\n    if (newCols.length === originCols.length) {\r\n      let sameStructure = true;\r\n      for (let i = 0; i < colMapping.length; ++i) {\r\n        if (colMapping[i] !== \"null\" && colMapping[i] !== i) {\r\n          sameStructure = false;\r\n          break;\r\n        }\r\n      }\r\n      if (sameStructure === true) {\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            if (\r\n              newCols[i].includes(originCols[i]) ||\r\n              originCols[i].includes(newCols[i])\r\n            ) {\r\n              colMapping[i] = i;\r\n              unionScore += 1 / originCols.length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // console.log(colMapping);\r\n      // If unionScore is 1, and newCols.length is equal to originCols.length, we want to reward it with 0.01 unionScore\r\n      // This helps us to rank the tables with the exact same column headers a bit higher\r\n      if (unionScore === 1) {\r\n        unionScore += 0.01;\r\n      }\r\n    }\r\n\r\n    // We proceed differently based on whether semantic mapping is enabled or not\r\n\r\n    // Case 1: semantic mapping is enabled\r\n\r\n    if (semanticEnabled === \"enabled\") {\r\n      // If we are not finding a perfect match, we want to do use semantic mapping here to see if it's possible to map the unmapped columns\r\n      // Note: this part is expected to take quite some time. Now it's implemented just for testing purposes\r\n      if (unionScore < 0.999) {\r\n        // We want to remove from remainCols the columns that are already mapped\r\n        // The remaining will be the columns that we can still use from the current table\r\n        remainCols = remainCols.filter(function (x) {\r\n          return colMapping.indexOf(x) < 0;\r\n        });\r\n        for (let i = 0; i < colMapping.length; ++i) {\r\n          if (colMapping[i] === \"null\") {\r\n            searchCols.push(i);\r\n          }\r\n        }\r\n        // if (newCols[1] === \"Scorer\") {\r\n        // console.log(\"We still need to find these columns from the original table: \"+searchCols);\r\n        // console.log(\"These columns are still available for use: \"+remainCols);\r\n        // console.log(\"The current column mappings are \"+colMapping);\r\n        // console.log(\"Here are the class annotations of the search columns: \")\r\n        // for (let i=0;i<searchCols.length;++i) {\r\n        //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n        // }\r\n        // }\r\n\r\n        // Now, searchCols stores the columns from the selected table that have not been mapped yet\r\n        // and remainCols stores the columns from the current table that can still be used for mapping\r\n        // Let's ask a query to find the class annotations for the remainCols\r\n        // if (remainCols.length > 0) {\r\n        promiseArray.push(findClassAnnotation(tableHTML, remainCols, pageName));\r\n        // }\r\n      }\r\n\r\n      // Because the return statement is here, it may be possible that we are pushing nothing onto the promiseArray!!!\r\n      // There is no need to worry about it.\r\n      return allPromiseReady(promiseArray).then((values) => {\r\n        // First, if we are in the perfect match case, we want to retrun straight away\r\n        if (unionScore >= 0.999) {\r\n          return Promise.resolve({\r\n            isOpen: false,\r\n            unionScore: unionScore,\r\n            colMapping: colMapping,\r\n            data: tableHTML,\r\n            title: newCols,\r\n          });\r\n        }\r\n        // Else, we want to look for semantic mapping opportunities\r\n        else {\r\n          // create a copy of values\r\n\r\n          // Note!!!! Sometimes the tableHTML only has one row, so values[0] would have a length of zero, in which case our algo breaks down\r\n          // Let's prevent it from happening\r\n          let remainClassAnnotation = values[0].slice();\r\n          if (remainClassAnnotation.length > 0) {\r\n            // let remainColsCopy = remainCols.slice();\r\n            // let remainClassAnnotationCopy = remainClassAnnotation.slice();\r\n            for (let i = 0; i < searchCols.length; ++i) {\r\n              let curSearchIndex = searchCols[i];\r\n              // console.log(curSearchIndex);\r\n              // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n              // If the class annotation for this column is empty, we skip it because there's no hope for semantic match.\r\n              // Otherwise we can work with it\r\n              if (selectedClassAnnotation[curSearchIndex].length > 0) {\r\n                // console.log(\"Current column being searched has index: \"+curSearchIndex);\r\n                // console.log(selectedClassAnnotation[curSearchIndex]);\r\n\r\n                // we loop through the remain cols and check their class annotations\r\n                for (let j = 0; j < remainCols.length; ++j) {\r\n                  // Let make sure this column does have a class annotation. Otherwise we skip it\r\n                  // console.log(remainClassAnnotation[j]);\r\n                  // Note: sometimes remainClassAnnotation[j] is undefined, which causes an error\r\n                  // if (remainClassAnnotation[j] === undefined) {\r\n                  //   console.log(\"This case is causing an error\");\r\n                  //   console.log(\"Remain cols are \"+remainCols);\r\n                  //   console.log(\"Remain class annotations are \"+remainClassAnnotation);\r\n                  //   console.log(\"Original remain cols are \"+remainColsCopy);\r\n                  //   console.log(\"original remain class annotations are \"+remainClassAnnotationCopy);\r\n                  //   console.log(\"Table HTML is \");\r\n                  //   console.log(tableHTML);\r\n                  //   console.log(values[0]);\r\n                  // }\r\n                  if (remainClassAnnotation[j].length > 0) {\r\n                    // console.log(\"Remain column index is \"+remainCols[j]);\r\n                    // console.log(\"Its class annotation is \"+remainClassAnnotation[j]);\r\n                    // Let make special cases when the any of search column class and current column class is [Number]\r\n                    // If they are both [Number], we will give it a match\r\n                    // Else it's not a match\r\n                    if (\r\n                      selectedClassAnnotation[curSearchIndex][0] === \"Number\" ||\r\n                      remainClassAnnotation[j][0] === \"Number\"\r\n                    ) {\r\n                      // This case we have a match\r\n                      if (\r\n                        selectedClassAnnotation[curSearchIndex][0] ===\r\n                        remainClassAnnotation[j][0]\r\n                      ) {\r\n                        // We need to update the colMapping and unionScore\r\n                        colMapping[curSearchIndex] = remainCols[j];\r\n                        unionScore += 1 / originCols.length;\r\n                        // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                        remainCols.splice(j, 1);\r\n                        remainClassAnnotation.splice(j, 1);\r\n                        // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                        // j to go back to the correct posiition\r\n                        --j;\r\n                        // Also we need to call break to prevent further looping: we are done with this search column\r\n                        break;\r\n                      }\r\n                      // Else there is no match. We simply ignore it.\r\n                    }\r\n                    // If neither of them is [Number], we need to use the test statistic\r\n                    else {\r\n                      // Let's first find the array intersection of selectedClassAnnotation[curSearchIndex] and remainClassAnnotation[j]\r\n                      let intersection = selectedClassAnnotation[\r\n                        curSearchIndex\r\n                      ].filter(function (x) {\r\n                        return remainClassAnnotation[j].indexOf(x) >= 0;\r\n                      });\r\n                      // console.log(\"Intersection is \"+intersection);\r\n                      // We only want to consider two column unionable if they at least have some intersections.\r\n                      if (intersection.length > 0) {\r\n                        let totalSuccess =\r\n                          selectedClassAnnotation[curSearchIndex].length;\r\n                        let numTrial = remainClassAnnotation[j].length;\r\n                        let numSuccess = intersection.length;\r\n                        let testStat = hyperCDF(\r\n                          numSuccess,\r\n                          ontologySize,\r\n                          totalSuccess,\r\n                          numTrial\r\n                        );\r\n                        // If testStat is larger than matchCutOff, we consider it a match\r\n                        if (testStat > matchCutOff) {\r\n                          // We need to update the colMapping and unionScore\r\n                          colMapping[curSearchIndex] = remainCols[j];\r\n                          unionScore += 1 / originCols.length;\r\n                          // we also need to remove this column from remainClassAnnotation and remainCols because we cannot use it anymore\r\n                          remainCols.splice(j, 1);\r\n                          remainClassAnnotation.splice(j, 1);\r\n                          // Also, since we are removing element from remainCols array and remainClassAnnotation array, we need to decrement\r\n                          // j to go back to the correct posiition\r\n                          --j;\r\n                          // Also we need to call break to prevent further looping: we are done with this search column\r\n                          break;\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          // console.log(\"Remain columns are \"+)\r\n          // console.log(\"Here is table HTML\");\r\n          // console.log(tableHTML);\r\n          // console.log(\"Here are the class annotations for columns that still need mapping\");\r\n          // for (let i=0;i<searchCols.length;++i) {\r\n          //   console.log(selectedClassAnnotation[searchCols[i]]);\r\n          // }\r\n          // console.log(\"The remain columns are \"+remainCols);\r\n          // console.log(\"Here are the class annotations for the remaining columns\");\r\n          // console.log(values);\r\n          // console.log(\"This is column mapping \"+colMapping);\r\n          // console.log(\"Union score is \"+unionScore);\r\n\r\n          // We need to loop through the searchCols\r\n\r\n          // We push on tables with unionScore > unionCutOff\r\n          if (unionScore >= unionCutOff) {\r\n            // console.log(\"This table is unionable!\");\r\n            // console.log(\"Table is \"+tableHTML);\r\n            // console.log(\"Union Score is \"+unionScore);\r\n            // console.log(\"Column mapping is \"+colMapping);\r\n            // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n            // console.log(colMapping);\r\n            return Promise.resolve({\r\n              isOpen: false,\r\n              unionScore: unionScore,\r\n              colMapping: colMapping,\r\n              data: tableHTML,\r\n              title: newCols,\r\n            });\r\n          } else {\r\n            return Promise.resolve(-1);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Case 2: semantic mapping is disabled.\r\n    // In this case we check if the unionScore is high enough directly, without going through the semantic mapping process\r\n    else {\r\n      // We push on tables with unionScore > unionCutOff\r\n      if (unionScore >= unionCutOff) {\r\n        // console.log(\"This table is unionable!\");\r\n        // console.log(\"Table is \"+tableHTML);\r\n        // console.log(\"Union Score is \"+unionScore);\r\n        // console.log(\"Column mapping is \"+colMapping);\r\n        // tableArray.push({\"isOpen\":false,\"unionScore\":unionScore,\"colMapping\":colMapping,\"data\":tablesFound[i]});\r\n        // console.log(colMapping);\r\n        return Promise.resolve({\r\n          isOpen: false,\r\n          unionScore: unionScore,\r\n          colMapping: colMapping,\r\n          data: tableHTML,\r\n          title: newCols,\r\n        });\r\n      } else {\r\n        return Promise.resolve(-1);\r\n      }\r\n    }\r\n  }\r\n  // This else clause means that this table does not even have enough number of columns.\r\n  // So we know right away it cannot be a match. So we return -1 (failure)\r\n  else {\r\n    return Promise.resolve(-1);\r\n  }\r\n}\r\n\r\n// This function takes in the HTML of a table, and returns a Promise that resolves to the class annotation for all the columns of the table\r\nfunction findClassAnnotation(tableHTML, remainCols, pageName) {\r\n  // console.log(\"Page Name is: \"+pageName);\r\n  // console.log(\"Table HTML is: \");\r\n  // console.log(tableHTML);\r\n  // console.log(remainCols);\r\n  let selectedTable = tableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // Note: this function potentially needs to be modified.\r\n  // Instead of using innerText for cell data, if its href exists, we should use its href instead\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n\r\n      // Note: We want to use the href as data for the first column (if such href exists) instead of its innerText.\r\n      if (i === 1) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = hrefArray[hrefArray.length - 1];\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            rowSpan: 1,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(\"Table data is: \");\r\n  // console.log(tempTable);\r\n\r\n  // Now tempTable contains the clean data we can use\r\n  let promiseArray = [];\r\n  // We take the minimum of (1, tempTable.length-1) number of values from each column to determine its class annotation\r\n  // Note!! This -1 here is important. It excludes the row corresponding to the column headers\r\n  let remainEntries = Math.min(1, tempTable.length - 1);\r\n\r\n  // This is a placeholder array to solve the 2D problem. It's a 1D array containing remainEntries number of -1's\r\n  // let placeHolderArray = [];\r\n  // let notFoundArray = [];\r\n  // for (let i=0;i<remainEntries;++i) {\r\n  //   placeHolderArray.push(-1);\r\n  //   notFoundArray.push(\"null\");\r\n  // }\r\n\r\n  // Let's loop through the table to ask our queries.\r\n  // If remainCols are undefined, we take every columns from the tempTable;\r\n  if (remainCols === undefined) {\r\n    remainCols = [];\r\n    for (let j = 0; j < tempTable[0].length; ++j) {\r\n      remainCols.push(j);\r\n    }\r\n  }\r\n\r\n  // console.log(\"Remain columns are: \"+remainCols);\r\n  for (let j = 0; j < remainCols.length; ++j) {\r\n    // console.log(\"We are taking this number of entries from this table: \"+remainEntries);\r\n    // Find the current column index\r\n    let curColIndex = remainCols[j];\r\n    // console.log(\"Current column index is: \"+curColIndex);\r\n\r\n    // Loop through the first three (or one) entries from this column\r\n    for (let i = 1; i <= remainEntries; ++i) {\r\n      // Here we make the query\r\n      let prefixURL =\r\n        \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n      let suffixURL =\r\n        \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n      // console.log(tempTable[i][j].data);\r\n      // console.log(regexReplace(tempTable[i][j].data));\r\n      // console.log(tempTable[i][curColIndex]);\r\n      let curEntry =\r\n        tempTable[i][curColIndex] === undefined\r\n          ? \"NONEXISTING\"\r\n          : regexReplace(tempTable[i][curColIndex].data);\r\n      // console.log(curEntry);\r\n      // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n      // console.log(!isNaN(Number(curEntry)));\r\n      // console.log(\"Replaced data is \"+curEntry);\r\n      // console.log(curEntry === \"\");\r\n\r\n      // If we found out that the current entry is a number, we do not want to send a query.\r\n      // Note: Number(\"\") will show up as a number!! This was one of the bugs that we fixed\r\n      if (!isNaN(Number(curEntry)) && curEntry !== \"\") {\r\n        promiseArray.push(Promise.resolve([\"Number\"]));\r\n      }\r\n      // Else if we find the curEntry is too long, it will likely not exist in DBPedia\r\n      else if (curEntry.length > 40) {\r\n        promiseArray.push(Promise.resolve([\"Null\"]));\r\n      }\r\n      // Else we construct the query\r\n      else {\r\n        // console.log(\"Cur Entry is \"+curEntry);\r\n        if (curEntry === undefined || curEntry === \"\") {\r\n          curEntry = \"NONEXISTING\";\r\n        }\r\n        // if (curEntry === \"Sergio_Agero\") {\r\n        //   console.log(\"We have another problem here\");\r\n        // }\r\n        // console.log(curEntry);\r\n        // console.log(tempTable[i][curColIndex].data);\r\n        // console.log(regexReplace(tempTable[i][curColIndex].data));\r\n        let queryBody =\r\n          \"SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\" +\r\n          curEntry +\r\n          \"+rdf%3Atype+%3Fo.%0D%0A++++++BIND%28STR%28%3Fo%29+AS+%3FoString+%29.%0D%0A++++++FILTER%28regex%28%3FoString%2C%22dbpedia.org%2Fontology%2F%22%2C%22i%22%29%29%0D%0A%7D%0D%0A&\";\r\n        let queryURL = prefixURL + queryBody + suffixURL;\r\n        // if (curEntry === \"Bangor_City_F%5Cu002EC%5Cu002E\") {\r\n        //   console.log(\"There is something wrong with this entry\")\r\n        //   console.log(queryURL);\r\n        // }\r\n        // console.log(\"Query is constructed!\");\r\n        // if (queryURL === \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=SELECT+%3Fo%0D%0AWHERE+%7B%0D%0A++++++dbr%3A\") {\r\n        //   console.log(\"Here is where the problem occurs\");\r\n        // }\r\n        // console.log(queryURL);\r\n        promiseArray.push(fetchJSON(queryURL));\r\n        // console.log(\"Query pushed successfully. This is queryBody: \");\r\n        // console.log(queryBody);\r\n      }\r\n    }\r\n  }\r\n  return allPromiseReady(promiseArray).then((values) => {\r\n    // console.log(values);\r\n    // for (let i=0;i<values.length;++i) {\r\n    //   console.log(values[i]);\r\n    // }\r\n    // console.log(\"Query results from Virtuoso are:\");\r\n    // console.log(values);\r\n    let classAnnotation = [];\r\n    for (let j = 0; j < remainCols.length; ++j) {\r\n      // console.log(\"Number of remain cols is \"+remainCols.length);\r\n      let curColumnClass = [];\r\n      // If we are dealing with number results, we just want to push on an array with one element \"Number\"\r\n      if (values[remainEntries * j] !== undefined) {\r\n        if (values[remainEntries * j][0] !== undefined) {\r\n          if (values[remainEntries * j][0] === \"Number\") {\r\n            classAnnotation.push([\"Number\"]);\r\n          }\r\n          // If we are dealing with invalid results, we just want to push on an empty array\r\n          else if (values[remainEntries * j][0] === \"Null\") {\r\n            classAnnotation.push([]);\r\n          }\r\n        }\r\n        // if (values[remainEntries*j][0] === -1) {\r\n        //   classAnnotation.push([\"Number\"]);\r\n        // }\r\n        // // If we are dealing with invalid results, we just want to push on an empty array\r\n        // else if (values[remainEntries*j][0] === \"null\") {\r\n        //   classAnnotation.push([]);\r\n        // }\r\n        // Else, we find its class annotation from query results\r\n        else {\r\n          for (let i = 0; i < remainEntries; ++i) {\r\n            let curCellClass = [];\r\n            // console.log(remainEntries*j+i);\r\n            let bindingArray = values[remainEntries * j + i].results.bindings;\r\n            for (let k = 0; k < bindingArray.length; ++k) {\r\n              curCellClass.push(bindingArray[k].o.value.slice(28));\r\n            }\r\n            curColumnClass = [...new Set([...curColumnClass, ...curCellClass])];\r\n          }\r\n          classAnnotation.push(curColumnClass);\r\n        }\r\n      }\r\n    }\r\n    // return classAnnotation;\r\n    // console.log(\"Current class annotation is \");\r\n    // if (classAnnotation.length === 5 && pageName === \"200809_Premier_League\") {\r\n      // console.log(classAnnotation);\r\n    // }\r\n    // console.log(classAnnotation);\r\n    return Promise.resolve(classAnnotation);\r\n  });\r\n}\r\n\r\n// This function returns a 2D array of objects representing the data for tableDataExplore.\r\n\r\n// It taks two parameters:\r\n//  1) HTML \"selectedTableHTML\" storing the HTML of a table\r\n//  2) string \"urlOrigin\", storing which page this table is from\r\n\r\n// It returns a 2D array of objects representing the data for tableDataExplore.\r\nfunction setTableFromHTML(selecteTableHTML, urlOrigin) {\r\n  let selectedTable = selecteTableHTML;\r\n  let tempTable = [];\r\n\r\n  // We first fetch the plain, unprocessed version of the table.\r\n  // This is the part where we make the modification: use links instead of cell literals\r\n\r\n  for (let i = 0; i < selectedTable.rows.length; ++i) {\r\n    let tempRow = [];\r\n    for (let j = 0; j < selectedTable.rows[i].cells.length; ++j) {\r\n      let curCellText = HTMLCleanCell(selectedTable.rows[i].cells[j].innerText);\r\n      // Note: We want to use the href as data (if such href exists) instead of its innerText.\r\n      if (i > 0) {\r\n        // We get all the links from this current cell (there may be more than one)\r\n        let anchorArray = selectedTable.rows[i].cells[j].getElementsByTagName(\r\n          \"a\"\r\n        );\r\n        // we want to use the first valid link as the search element for this cell\r\n        // Definition of being valid: its associated innerText is not empty (thus not the link of a picture)\r\n        //                            and it is not a citation (so [0] is not \"[\")\r\n        for (let k = 0; k < anchorArray.length; ++k) {\r\n          if (\r\n            anchorArray[k].innerText !== \"\" &&\r\n            anchorArray[k].innerText[0] !== \"[\"\r\n          ) {\r\n            let hrefArray = anchorArray[k].href.split(\"/\");\r\n            // console.log(\"InnerText is \"+anchorArray[k].innerText);\r\n            // console.log(\"It exists in DBPedia as \"+hrefArray[hrefArray.length-1]);\r\n            curCellText = decodeURIComponent(hrefArray[hrefArray.length - 1]);\r\n            // if (curCellText.includes(\"UEFA\")) {\r\n            // console.log(curCellText);\r\n            // }\r\n          }\r\n        }\r\n      }\r\n      let curRowSpan = selectedTable.rows[i].cells[j].rowSpan;\r\n      let curColSpan = selectedTable.rows[i].cells[j].colSpan;\r\n      // console.log(curColSpan);\r\n      tempRow.push({\r\n        data: curCellText,\r\n        origin: urlOrigin,\r\n        rowSpan: curRowSpan,\r\n        colSpan: curColSpan,\r\n      });\r\n    }\r\n    tempTable.push(tempRow);\r\n  }\r\n\r\n  // We first deal with colspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].colSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].colSpan; ++k) {\r\n          tempTable[i].splice(j + 1, 0, {\r\n            data: curCellText,\r\n            origin: urlOrigin,\r\n            rowSpan: tempTable[i][j].rowSpan,\r\n            colSpan: 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now deal with rowspans.\r\n  for (let i = 0; i < tempTable.length; ++i) {\r\n    for (let j = 0; j < tempTable[i].length; ++j) {\r\n      let curCellText = tempTable[i][j].data;\r\n      if (tempTable[i][j].rowSpan > 1) {\r\n        for (let k = 1; k < tempTable[i][j].rowSpan; ++k) {\r\n          // Note: the if condition is necessary to take care of error conditions (the original HTML table element has errors)\r\n          if (i + k < tempTable.length) {\r\n            tempTable[i + k].splice(j, 0, {\r\n              data: curCellText,\r\n              origin: urlOrigin,\r\n              rowSpan: 1,\r\n              colSpan: 1,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We now add in an additional column: the originURL of the page\r\n  tempTable[0].splice(0, 0, {\r\n    data: \"OriginURL\",\r\n    origin: urlOrigin,\r\n    rowSpan: 1,\r\n    colSpan: 1,\r\n  });\r\n  for (let i = 1; i < tempTable.length; ++i) {\r\n    tempTable[i].splice(0, 0, {\r\n      data: urlOrigin,\r\n      origin: \"null\",\r\n      rowSpan: 1,\r\n      colSpan: 1,\r\n    });\r\n  }\r\n  return tempTable; // tempTable is a 2D array of objects storing the table data. Object has two fields: data(string) and origin(string).\r\n}\r\n\r\n// This function takes in 1 parameter\r\n// 1) tableDataExplore, returned from setTableFromHTML.\r\n\r\n// And returns tableData (with no header rows) that can be unioned with the selected table.\r\n\r\nfunction setUnionData(tableDataExplore) {\r\n\r\n  // We first need to set the tableHeader, so that cells have the correct origins\r\n  let tableHeader = [];\r\n  for (let j=0;j<tableDataExplore[0].length;++j) {\r\n    tableHeader.push(\r\n      {\"value\":tableDataExplore[0][j].data\r\n      ,\"label\":tableDataExplore[0][j].data}\r\n    )\r\n  }\r\n  // We then need to handle both data and origin.\r\n  let tableData = [];\r\n  // console.log(tableDataExplore);\r\n  // This starts the loop for rows\r\n  for (let i=1;i<tableDataExplore.length;++i) {\r\n    let tempRow = [];\r\n    // This starts the loop for columns\r\n    for (let j=0;j<tableDataExplore[i].length;++j) {\r\n      // First set the data\r\n      let data = tableDataExplore[i][j].data;\r\n      // Then set the origin\r\n      let origin = [];\r\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\r\n      origin.push(originText);\r\n      tempRow.push({\"data\":data,\"origin\":origin});\r\n    }\r\n    tableData.push(tempRow);\r\n  }\r\n  return tableData;\r\n}\r\n\r\n// This function takes in four parameters and return the CDF for hypergeometric distribution, for x\r\n// N: total number of elements (780 in our case)\r\n// K: total number of successful elements (length of selected column's class annotation)\r\n// n: number of trials (length of test column's class annotation)\r\n// x: (length of intersection of selected column and test column)\r\n\r\nfunction hyperCDF(x, N, K, n) {\r\n  let count = 0;\r\n  // console.log(combinations(5,2));\r\n  let denom = combinations(N, n);\r\n  for (let i = 0; i <= x; ++i) {\r\n    count += (combinations(K, i) * combinations(N - K, n - i)) / denom;\r\n  }\r\n  return count;\r\n}\r\n\r\n// This function takes in 2 parameters:\r\n// 1) tableDataExplore\r\n// 2) selectedClassAnnotation\r\n\r\n// It returns a Promise of an object with 5 properties:\r\n// 1) keyColIndex\r\n// 2) tableHeader\r\n// 3) tableData\r\n// 4) keyColNeighbours\r\n// 5) optionsMap.\r\n\r\n// This object contains all the information we needed for the Excel-style table\r\n\r\nfunction getTableStates(tableDataExplore, selectedClassAnnotation) {\r\n  // We need to take care of keyColIndex, tableHeader, tableData, optionsMap, and keyColNeighbours\r\n\r\n  // tableDataExplore contains all the information we need to set the five states listed above\r\n  // We just need to make use of the \"data\" and \"origin\" attributes. rowSpan and colSpan have no impact here.\r\n  // Also, since we are not modifying tableDataExplore, we do not need to make a copy of it.\r\n\r\n  // First, let's deal with keyColIndex. \r\n  // We will use the first column such that it's class annotation is not [] or [\"Number\"]\r\n  // If no such column exists, we default it to the first column\r\n\r\n  let keyColIndex = -1;\r\n  for (let i=0;i<selectedClassAnnotation.length;++i) {\r\n    if (selectedClassAnnotation[i].length > 0 \r\n        && !(selectedClassAnnotation[i].length === 1 && selectedClassAnnotation[i][0] === \"Number\")) {\r\n      // Note: we have to include the plus 1 here, because selectedClassAnnotation's length is 1 smaller than the number of columns \r\n      // Since OriginURL column does not have class annotation\r\n      keyColIndex = i+1; \r\n      break;\r\n    }\r\n  }\r\n  if (keyColIndex === -1) {\r\n    keyColIndex = 0;\r\n  }\r\n  // console.log(\"Key Column Index is: \");\r\n  // console.log(keyColIndex);\r\n\r\n  // Now, let's deal with tableHeader. Note: these tableHeaders only have value and label, no range or type\r\n  let tableHeader = [];\r\n  for (let j=0;j<tableDataExplore[0].length;++j) {\r\n    tableHeader.push(\r\n      {\"value\":tableDataExplore[0][j].data\r\n      ,\"label\":tableDataExplore[0][j].data}\r\n    )\r\n  }\r\n  // console.log(\"Table header is: \");\r\n  // console.log(tableHeader);\r\n\r\n  // Now, let's deal with tableData. Wee need to handle both data and origin.\r\n  let tableData = [];\r\n  // console.log(tableDataExplore);\r\n  // This starts the loop for rows\r\n  for (let i=1;i<tableDataExplore.length;++i) {\r\n    let tempRow = [];\r\n    // This starts the loop for columns\r\n    for (let j=0;j<tableDataExplore[i].length;++j) {\r\n      // First set the data\r\n      let data = tableDataExplore[i][j].data;\r\n      // Then set the origin\r\n      let origin = [];\r\n      let originText = tableDataExplore[i][j].origin+\": \"+tableHeader[j].value+\": \"+tableDataExplore[i][j].data;\r\n      origin.push(originText);\r\n      tempRow.push({\"data\":data,\"origin\":origin});\r\n    }\r\n    tableData.push(tempRow);\r\n  }\r\n  // console.log(\"Table data is: \");\r\n  // console.log(tableData);\r\n\r\n  // Now, let's deal with keyColNeighbours and optionsMap\r\n  // Note: the following part is really similar to what we have in contextSetCell\r\n  let promiseArray = [];\r\n\r\n  // Below is the first query we will make.\r\n  // This query fetches the neighbours for tableData[0][keyColIndex], so the first cell in column with index keyColIndex\r\n  // These neighbours are either dbo or dbp, with some eliminations. In here we are using the tableCell as SUBJECT\r\n\r\n  let prefixURLOne =\r\n    \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  let suffixURLOne =\r\n    \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n  let queryBodyOne =\r\n    \"SELECT+%3Fp+%3Frange%0D%0AWHERE+%7B%0D%0A+++++++dbr%3A\" +\r\n    regexReplace(tableData[0][keyColIndex].data) +\r\n    \"+%3Fp+%3Fo.%0D%0A+++++++OPTIONAL+%7B%3Fp+rdfs%3Arange+%3Frange%7D.%0D%0A+++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A+++++++FILTER%28%0D%0A++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A++++++++++++++%29%0D%0A%7D&\";\r\n  let queryURLOne = prefixURLOne + queryBodyOne + suffixURLOne;\r\n  let otherColPromiseSubject = fetchJSON(queryURLOne);\r\n  promiseArray.push(otherColPromiseSubject);\r\n\r\n  // Below is the second query we will make.\r\n  // Difference with the previous query is that we are using tableData[0][colIndex] as OBJECT\r\n  let prefixURLTwo =\r\n    \"https://dbpedia.org/sparql?default-graph-uri=http%3A%2F%2Fdbpedia.org&query=\";\r\n  let suffixURLTwo =\r\n    \"format=application%2Fsparql-results%2Bjson&CXML_redir_for_subjs=121&CXML_redir_for_hrefs=&timeout=30000&debug=on&run=+Run+Query+\";\r\n  let queryBodyTwo =\r\n    \"SELECT+%3Fp+%0D%0AWHERE+%7B%0D%0A++++++++%3Fs+%3Fp+dbr%3A\" +\r\n    regexReplace(tableData[0][keyColIndex].data) +\r\n    \".%0D%0A++++++++BIND%28STR%28%3Fp%29+AS+%3FpString+%29.%0D%0A++++++++FILTER%28%0D%0A+++++++++++++++%21%28regex%28%3FpString%2C%22wikiPage%7Calign%7Cabstract%7Ccaption%7Cimage%7Cwidth%7Cthumbnail%7Cblank%22%2C%22i%22%29%29+%0D%0A+++++++++++++++%26%26+regex%28%3FpString%2C+%22ontology%7Cproperty%22%2C+%22i%22%29%0D%0A+++++++++++++++%29%0D%0A%7D%0D%0A&\";\r\n  let queryURLTwo = prefixURLTwo + queryBodyTwo + suffixURLTwo;\r\n  let otherColPromiseObject = fetchJSON(queryURLTwo);\r\n  promiseArray.push(otherColPromiseObject);\r\n\r\n  return allPromiseReady(promiseArray).then((values) => {\r\n    // Now we finalize the keyColNeighbours\r\n    let keyColNeighbours = [];\r\n    keyColNeighbours = updateKeyColNeighbours(\r\n      keyColNeighbours,\r\n      values[0].results.bindings,\r\n      \"subject\"\r\n    );\r\n    keyColNeighbours = updateKeyColNeighbours(\r\n      keyColNeighbours,\r\n      values[1].results.bindings,\r\n      \"object\"\r\n    );\r\n    // console.log(\"Key Column Neighbours are: \");\r\n    // console.log(keyColNeighbours);\r\n\r\n    // Now, we handle the optionsMaps\r\n    // We can just put on empty options.\r\n    let optionsMap = [];\r\n    for (let j=0;j<tableHeader.length;++j) {\r\n      optionsMap.push([]);\r\n    }\r\n    // console.log(\"Options Map are: \");\r\n    // console.log(optionsMap);\r\n\r\n    // Lastly, let's put all the information together in a single object, and return it as a Promise\r\n    return Promise.resolve(\r\n      {\r\n        \"keyColIndex\":keyColIndex,\r\n        \"tableHeader\":tableHeader,\r\n        \"tableData\":tableData,\r\n        \"keyColNeighbours\":keyColNeighbours,\r\n        \"optionsMap\":optionsMap\r\n      }\r\n    )\r\n  })\r\n}\r\n\r\n// This function renders this.props.tableData[i][j].data in a nicer way. \r\n// It changes\"_\" to \" \", and removes everything after the first occurence of (\r\n\r\n  function niceRender(str) {\r\n    let resultStr = str;\r\n    let bracketIndex = str.indexOf(\"(\");\r\n    // If ( is present in a string, we want to remove it\r\n    // We include the -1 because usually ( is preceeded by _\r\n    if (bracketIndex !== -1) {\r\n      resultStr = resultStr.slice(0, bracketIndex-1);\r\n    }\r\n    // now we turn all \"_\" into \" \"\r\n    return resultStr.replace(/_/g, \" \");\r\n  }\r\n\r\n// Testing repo change\r\n\r\n","// import { Route, Switch, Link } from \"react-router-dom\";\r\nimport React, { Component } from \"react\";\r\n// import Header from \"../components/Header\";\r\n// import Footer from \"../components/Footer\";\r\nimport MainBody from \"../components/MainBody\";\r\n\r\nclass App extends Component {\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"wrapper \">\r\n        <div className=\"font-body\">\r\n          {/* <div className=\"header\">\r\n            <Header />\r\n          </div> */}\r\n          <div>\r\n            <MainBody />\r\n          </div>\r\n          {/* <div className=\"footer\">\r\n            <Footer />\r\n          </div> */}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n\r\n\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport \"./assets/custom.css\";\r\nimport \"./assets/layout.css\";\r\n// import \"./assets/font-awesome.min.css\";\r\nimport App from \"./layouts/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}